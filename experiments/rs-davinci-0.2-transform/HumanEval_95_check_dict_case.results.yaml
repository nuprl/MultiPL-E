language: rs
name: HumanEval_95_check_dict_case
results:
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        }\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n \
    \       }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmgdzw_p9.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            is_lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            is_upper = false;\n        }\n    }\n    is_lower || is_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpg6c0eaqd.rs:21:17\n   |\n21 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpg6c0eaqd.rs:24:17\n   |\n24 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe_zwq5ys.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for (key, _) in dict {\n        if key.is_ascii_lowercase()\
    \ {\n            is_lower = true;\n        } else if key.is_ascii_uppercase()\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower ^ is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpfkvw10ff.rs:21:16\n   |\n21 |         if\
    \ key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfkvw10ff.rs:23:23\n   |\n23 |         } else if key.is_ascii_uppercase()\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        }\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n \
    \       }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmgdzw_p9.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1f2mymqi.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for key in dict.keys() {\n        if key.is_ascii_lowercase()\
    \ {\n            all_upper = false;\n        } else if key.is_ascii_uppercase()\
    \ {\n            all_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmps1_so395.rs:21:16\n   |\n21 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmps1_so395.rs:23:23\n   |\n23 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n            upper_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzmixokfe.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuxgytqef.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_count = 0;\n    let mut\
    \ upper_count = 0;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_count += 1;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            upper_count += 1;\n        } else {\n     \
    \       return false;\n        }\n    }\n    if lower_count == 0 && upper_count\
    \ == 0 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjhcck374.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lowercase = true;\n    let mut\
    \ uppercase = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lowercase = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            uppercase = false;\n        }\n    }\n    lowercase\
    \ || uppercase\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmcogqk78.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if !key.is_empty() {\n      \
    \      if key.chars().next().unwrap().is_lowercase() {\n                upper\
    \ = false;\n            } else if key.chars().next().unwrap().is_uppercase() {\n\
    \                lower = false;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    lower || upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_wziijbj.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case_keys = true;\n  \
    \  let mut upper_case_keys = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            upper_case_keys = false;\n        }\n     \
    \   if key.chars().any(|c| c.is_uppercase()) {\n            lower_case_keys =\
    \ false;\n        }\n    }\n    lower_case_keys || upper_case_keys\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv7nu08f6.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        if key.is_ascii_lowercase()\
    \ {\n            all_upper = false;\n        } else if key.is_ascii_uppercase()\
    \ {\n            all_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpb6j17qei.rs:21:16\n   |\n21 |         if\
    \ key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpb6j17qei.rs:23:23\n   |\n23 |         } else if key.is_ascii_uppercase()\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe_zwq5ys.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            is_upper = false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1k_xrqpw.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphh63836u.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            upper_case = false;\n        } else {\n   \
    \         return false;\n        }\n    }\n    if lower_case || upper_case {\n\
    \        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7jo_j9__.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower = true;\n    let mut is_upper = true;\n\
    \    for (key, _) in dict {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            is_upper = false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1bx9so08.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for key in dict.keys() {\n        if key.is_empty() {\n\
    \            return false;\n        }\n        if key.chars().all(|c| c.is_lowercase())\
    \ {\n            is_lower = true;\n        } else if key.chars().all(|c| c.is_uppercase())\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8i6lrlk8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuxgytqef.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case_keys = true;\n  \
    \  let mut upper_case_keys = true;\n    for key in dict.keys() {\n        if !key.is_empty()\
    \ {\n            if key.chars().next().unwrap().is_lowercase() {\n           \
    \     upper_case_keys = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                lower_case_keys = false;\n            } else {\n        \
    \        return false;\n            }\n        }\n    }\n    lower_case_keys ||\
    \ upper_case_keys\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmpntwl50.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower_case = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper_case = false;\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1ahmb1lk.rs:21:17\n   |\n21 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1ahmb1lk.rs:24:17\n   |\n24 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuxgytqef.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower_case = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper_case = false;\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpm4sfrdix.rs:21:17\n   |\n21 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpm4sfrdix.rs:24:17\n   |\n24 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            all_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            all_upper = false;\n        }\n    }\n    all_lower\
    \ || all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfg47zg_0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower = false;\n    let mut is_upper = false;\n\
    \    for (key, _) in dict {\n        if key.is_lowercase() {\n            is_lower\
    \ = true;\n        } else if key.is_uppercase() {\n            is_upper = true;\n\
    \        } else {\n            return false;\n        }\n    }\n    is_lower ^\
    \ is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp5ynyarzp.rs:24:16\n   |\n24 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp5ynyarzp.rs:26:23\n\
    \   |\n26 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe_zwq5ys.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if !key.is_empty() {\n\
    \            if key.chars().next().unwrap().is_lowercase() {\n               \
    \ is_upper = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                is_lower = false;\n            } else {\n               \
    \ return false;\n            }\n        }\n    }\n    is_lower || is_upper\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp4km8g9.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1f2mymqi.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        }\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n \
    \       }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmgdzw_p9.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1f2mymqi.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1f2mymqi.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for key in dict.keys() {\n        if key.is_ascii_lowercase()\
    \ {\n            is_lower = true;\n        } else if key.is_ascii_uppercase()\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower ^ is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpmaqdlpa3.rs:21:16\n   |\n21 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpmaqdlpa3.rs:23:23\n   |\n23 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for key in dict.keys() {\n        if key.is_ascii_lowercase()\
    \ {\n            all_upper = false;\n        } else if key.is_ascii_uppercase()\
    \ {\n            all_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmps1_so395.rs:21:16\n   |\n21 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmps1_so395.rs:23:23\n   |\n23 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphh63836u.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _value) in dict {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6mjhgf3t.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe_zwq5ys.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            upper_case = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        } else {\n   \
    \         return false;\n        }\n    }\n    lower_case || upper_case\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph3lqctcd.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptj3tft2r.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            all_lower = false;\n        } else {\n            all_upper =\
    \ false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxo8qcbt_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_lower = true;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_upper = true;\n        } else {\n      \
    \      return false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3u_srlzy.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuxgytqef.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if !key.is_empty() {\n\
    \            is_lower = is_lower && key.chars().all(|c| c.is_lowercase());\n \
    \           is_upper = is_upper && key.chars().all(|c| c.is_uppercase());\n  \
    \      }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5b6qdbqy.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower_case = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper_case = false;\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpm4sfrdix.rs:21:17\n   |\n21 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpm4sfrdix.rs:24:17\n   |\n24 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper = true;\n    let mut lower\
    \ = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            upper = false;\n\
    \        }\n    }\n    upper || lower\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr29nmp81.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case_keys = true;\n  \
    \  let mut upper_case_keys = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            upper_case_keys = false;\n        }\n     \
    \   if key.chars().any(|c| c.is_uppercase()) {\n            lower_case_keys =\
    \ false;\n        }\n    }\n    lower_case_keys || upper_case_keys\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv7nu08f6.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case_count = 0;\n    let\
    \ mut upper_case_count = 0;\n    for key in dict.keys() {\n        if key.chars().all(char::is_uppercase)\
    \ {\n            upper_case_count += 1;\n        } else if key.chars().all(char::is_lowercase)\
    \ {\n            lower_case_count += 1;\n        } else {\n            return\
    \ false;\n        }\n    }\n    if upper_case_count == 0 || lower_case_count ==\
    \ 0 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmk8c8bno.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyojh1wso.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower_case = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper_case = false;\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1ahmb1lk.rs:21:17\n   |\n21 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1ahmb1lk.rs:24:17\n   |\n24 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_empty()\
    \ {\n            if !key.chars().all(|c| c.is_lowercase()) {\n               \
    \ lower_case = false;\n            }\n            if !key.chars().all(|c| c.is_uppercase())\
    \ {\n                upper_case = false;\n            }\n        }\n    }\n  \
    \  lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphrqil_if.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            all_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            all_upper = false;\n        }\n    }\n    all_lower\
    \ || all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2ukj2ebf.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuxgytqef.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper = true;\n    let mut lower\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    upper || lower\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxne_trn8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for (key, _) in dict {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1wy0fj1_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for (key, _) in dict {\n        if key.is_lowercase()\
    \ {\n            is_lower = true;\n        } else if key.is_uppercase() {\n  \
    \          is_upper = true;\n        } else {\n            return false;\n   \
    \     }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpr21j3dzv.rs:21:16\n   |\n21 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpr21j3dzv.rs:23:23\n\
    \   |\n23 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        }\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n \
    \       }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmgdzw_p9.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n            upper_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzmixokfe.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower_case = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper_case = false;\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1ahmb1lk.rs:21:17\n   |\n21 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1ahmb1lk.rs:24:17\n   |\n24 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper = true;\n    let mut lower\
    \ = true;\n    for key in dict.keys() {\n        if key.to_uppercase() != *key\
    \ {\n            upper = false;\n        }\n        if key.to_lowercase() != *key\
    \ {\n            lower = false;\n        }\n    }\n    upper || lower\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2c2_4rzr.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv5ybghqf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: Implement\n    false\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgr412sw9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for (key, _) in dict {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1wy0fj1_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if !key.is_empty() {\n      \
    \      if key.chars().next().unwrap().is_lowercase() {\n                upper\
    \ = false;\n            } else if key.chars().next().unwrap().is_uppercase() {\n\
    \                lower = false;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    lower || upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_wziijbj.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower = true;\n    let mut is_upper = true;\n\
    \    for (key, _) in dict {\n        if !key.is_empty() {\n            if key.chars().next().unwrap().is_uppercase()\
    \ {\n                is_lower = false;\n            } else {\n               \
    \ is_upper = false;\n            }\n        }\n    }\n    is_lower || is_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfx15xl2n.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptj3tft2r.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for (key, _) in dict {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1wy0fj1_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            upper = false;\n\
    \        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy5g4ebmg.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe_zwq5ys.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl_g5jj2g.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyojh1wso.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_empty()\
    \ {\n            if !key.chars().all(|c| c.is_lowercase()) {\n               \
    \ lower_case = false;\n            }\n            if !key.chars().all(|c| c.is_uppercase())\
    \ {\n                upper_case = false;\n            }\n        }\n    }\n  \
    \  lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphrqil_if.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            upper_case = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        } else {\n   \
    \         return false;\n        }\n    }\n    lower_case || upper_case\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph3lqctcd.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower = true;\n    let mut is_upper = true;\n\
    \    for (key, _) in dict {\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            is_upper = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplsmhpcqp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower_case = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper_case = false;\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpm4sfrdix.rs:21:17\n   |\n21 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpm4sfrdix.rs:24:17\n   |\n24 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptj3tft2r.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower = false;\n    let mut is_upper = false;\n\
    \    for (key, _) in dict {\n        if key.is_lowercase() {\n            is_lower\
    \ = true;\n        } else if key.is_uppercase() {\n            is_upper = true;\n\
    \        } else {\n            return false;\n        }\n    }\n    is_lower ^\
    \ is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp5ynyarzp.rs:24:16\n   |\n24 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp5ynyarzp.rs:26:23\n\
    \   |\n26 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case_keys = 0;\n    let\
    \ mut upper_case_keys = 0;\n    for key in dict.keys() {\n        if key.chars().all(char::is_lowercase)\
    \ {\n            lower_case_keys += 1;\n        } else if key.chars().all(char::is_uppercase)\
    \ {\n            upper_case_keys += 1;\n        }\n    }\n    lower_case_keys\
    \ == dict.len() || upper_case_keys == dict.len()\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5kyn1p4g.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptj3tft2r.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.is_uppercase() {\n\
    \            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpuo47f5yd.rs:21:16\n   |\n21 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpuo47f5yd.rs:23:23\n\
    \   |\n23 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnqm0fw1y.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lower_case = true;\n    let mut upper_case = true;\n\
    \    for (key, _) in dict {\n        if !key.is_empty() {\n            if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n                lower_case = false;\n            }\n  \
    \          if !key.chars().all(|c| c.is_uppercase()) {\n                upper_case\
    \ = false;\n            }\n        }\n    }\n    lower_case || upper_case\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for (key, _value) in dict {\n        if key.is_empty()\
    \ {\n            return false;\n        }\n        if key.chars().all(char::is_lowercase)\
    \ {\n            is_lower = true;\n        } else if key.chars().all(char::is_uppercase)\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmecpfkot.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9536nphe.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_empty()\
    \ {\n            if !key.chars().all(|c| c.is_lowercase()) {\n               \
    \ lower_case = false;\n            }\n            if !key.chars().all(|c| c.is_uppercase())\
    \ {\n                upper_case = false;\n            }\n        }\n    }\n  \
    \  lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphrqil_if.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for key in dict.keys() {\n        if key.is_ascii_lowercase()\
    \ {\n            is_lower = true;\n        } else if key.is_ascii_uppercase()\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower ^ is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpmaqdlpa3.rs:21:16\n   |\n21 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpmaqdlpa3.rs:23:23\n   |\n23 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_upper = true;\n    let mut\
    \ is_lower = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            is_upper = false;\n\
    \        }\n    }\n    is_upper || is_lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd7cpz8gc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if !key.is_empty() {\n\
    \            if key.chars().next().unwrap().is_uppercase() {\n               \
    \ is_lower = false;\n            } else {\n                is_upper = false;\n\
    \            }\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm7mfe51h.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_count = 0;\n    let mut\
    \ upper_count = 0;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_count += 1;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            upper_count += 1;\n        } else {\n     \
    \       return false;\n        }\n    }\n    if lower_count == 0 && upper_count\
    \ == 0 {\n        return false;\n    }\n    if lower_count > 0 && upper_count\
    \ > 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper = true;\n    let mut lower\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    upper || lower\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxne_trn8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuxgytqef.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpek_aw5yh.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower_case = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper_case = false;\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpm4sfrdix.rs:21:17\n   |\n21 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpm4sfrdix.rs:24:17\n   |\n24 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnqm0fw1y.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_empty()\
    \ {\n            if key.chars().next().unwrap().is_uppercase() {\n           \
    \     lower_case = false;\n            } else {\n                upper_case =\
    \ false;\n            }\n        }\n    }\n    lower_case || upper_case\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdcdjuabk.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpktq7w_eo.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower_case = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper_case = false;\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1ahmb1lk.rs:21:17\n   |\n21 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1ahmb1lk.rs:24:17\n   |\n24 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptj3tft2r.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv5ybghqf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv5ybghqf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe_zwq5ys.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_count = 0;\n    let mut\
    \ upper_count = 0;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_count += 1;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            upper_count += 1;\n        } else {\n     \
    \       return false;\n        }\n    }\n    if lower_count == 0 && upper_count\
    \ == 0 {\n        return false;\n    }\n    if lower_count == 0 || upper_count\
    \ == 0 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lower_case = true;\n    let mut upper_case = true;\n\
    \    for (key, _) in dict {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower_case = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            upper_case = false;\n        }\n    }\n   \
    \ lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa190qc5k.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        if key.to_uppercase()\
    \ != key {\n            all_upper = false;\n        }\n        if key.to_lowercase()\
    \ != key {\n            all_lower = false;\n        }\n    }\n    all_lower ||\
    \ all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpafaozng7.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case_keys = true;\n  \
    \  let mut upper_case_keys = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case_keys = false;\n        }\n     \
    \   if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case_keys =\
    \ false;\n        }\n    }\n    lower_case_keys || upper_case_keys\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkagl9va5.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            upper_case = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        } else {\n   \
    \         return false;\n        }\n    }\n    lower_case || upper_case\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv4u4wj1t.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            all_upper = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            all_lower = false;\n        } else {\n    \
    \        return false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4o9ox8kw.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        }\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n \
    \       }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmgdzw_p9.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp68g1xr04.rs:21:17\n   |\n21 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp68g1xr04.rs:24:17\n   |\n24 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lower_case = true;\n    let mut upper_case = true;\n\
    \    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptvc801eh.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9536nphe.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptj3tft2r.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphh63836u.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            upper_case = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        } else {\n   \
    \         return false;\n        }\n    }\n    lower_case || upper_case\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph3lqctcd.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            all_upper = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            all_lower = false;\n        } else {\n    \
    \        return false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4o9ox8kw.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper = true;\n    let mut lower\
    \ = true;\n    for key in dict.keys() {\n        if !key.is_ascii_uppercase()\
    \ {\n            upper = false;\n        }\n        if !key.is_ascii_lowercase()\
    \ {\n            lower = false;\n        }\n    }\n    upper || lower\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpzzvesf4c.rs:21:17\n   |\n21 |\
    \         if !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpzzvesf4c.rs:24:17\n   |\n24 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for key in dict.keys() {\n        if key.is_empty() {\n\
    \            return false;\n        }\n        if key.chars().all(|c| c.is_lowercase())\
    \ {\n            is_lower = true;\n        } else if key.chars().all(|c| c.is_uppercase())\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8i6lrlk8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmmg_3yla.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_upper = true;\n    let mut\
    \ is_lower = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_upper || is_lower\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp2z602c1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        }\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n \
    \       }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmgdzw_p9.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            is_lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            is_upper = false;\n        }\n    }\n    is_lower || is_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpg6c0eaqd.rs:21:17\n   |\n21 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpg6c0eaqd.rs:24:17\n   |\n24 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_lower = true;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_upper = true;\n        } else {\n      \
    \      return false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3u_srlzy.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphh63836u.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if !key.is_empty() {\n\
    \            if key.chars().next().unwrap().is_lowercase() {\n               \
    \ is_upper = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                is_lower = false;\n            } else {\n               \
    \ return false;\n            }\n        }\n    }\n    is_lower || is_upper\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvtdkbeln.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for (key, _) in dict {\n        if key.is_lowercase()\
    \ {\n            is_lower = true;\n        } else if key.is_uppercase() {\n  \
    \          is_upper = true;\n        } else {\n            return false;\n   \
    \     }\n    }\n    is_lower ^ is_upper\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpq41_pi4d.rs:21:16\n   |\n21 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpq41_pi4d.rs:23:23\n\
    \   |\n23 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6h96nvgm.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuxgytqef.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case_keys = true;\n  \
    \  let mut upper_case_keys = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case_keys = false;\n        }\n     \
    \   if !key.chars().all(|c| c.is_uppercase()) {\n            upper_case_keys =\
    \ false;\n        }\n    }\n    lower_case_keys || upper_case_keys\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkagl9va5.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_empty()\
    \ {\n            if key.chars().next().unwrap().is_lowercase() {\n           \
    \     upper_case = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                lower_case = false;\n            } else {\n             \
    \   return false;\n            }\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplnv6yvmw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for (key, _) in dict {\n        if key.is_empty() {\n\
    \            return false;\n        }\n        if key.chars().all(char::is_lowercase)\
    \ {\n            is_lower = true;\n        } else if key.chars().all(char::is_uppercase)\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpey2xprga.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case_keys = true;\n  \
    \  let mut upper_case_keys = true;\n    for key in dict.keys() {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower_case_keys = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper_case_keys = false;\n        }\n    }\n    lower_case_keys\
    \ || upper_case_keys\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp8_0a7ees.rs:21:17\n   |\n21 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp8_0a7ees.rs:24:17\n   |\n24 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            all_lower = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            all_upper = false;\n        } else {\n    \
    \        return false;\n        }\n    }\n    !dict.is_empty() && (all_lower ||\
    \ all_upper)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `dict`\n   --> /tmp/tmpk1azafbs.rs:29:6\n\
    \    |\n17  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                    ---- move occurs because `dict` has type `HashMap<String,\
    \ String>`, which does not implement the `Copy` trait\n...\n20  |     for (key,\
    \ _) in dict {\n    |                     ---- `dict` moved due to this implicit\
    \ call to `.into_iter()`\n...\n29  |     !dict.is_empty() && (all_lower || all_upper)\n\
    \    |      ^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `dict`\nhelp: consider\
    \ iterating over a slice of the `HashMap<String, String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n20  |     for (key, _) in &dict {\n    |       \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphh63836u.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case_keys = true;\n  \
    \  let mut upper_case_keys = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower_case_keys = false;\n        }\n     \
    \   if key.chars().any(|c| c.is_lowercase()) {\n            upper_case_keys =\
    \ false;\n        }\n    }\n    lower_case_keys || upper_case_keys\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp542t4tlt.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for key in dict.keys() {\n        if key.is_ascii_lowercase()\
    \ {\n            is_lower = true;\n        } else if key.is_ascii_uppercase()\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower ^ is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpmaqdlpa3.rs:21:16\n   |\n21 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpmaqdlpa3.rs:23:23\n   |\n23 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv5ybghqf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_all_lower = true;\n    let\
    \ mut is_all_upper = true;\n    for key in dict.keys() {\n        if key.is_empty()\
    \ {\n            return false;\n        }\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            is_all_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            is_all_upper = false;\n        }\n    }\n \
    \   is_all_lower || is_all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwn8_an8i.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe_zwq5ys.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for (key, _) in dict {\n        if key.to_lowercase()\
    \ != key {\n            lower_case = false;\n        }\n        if key.to_uppercase()\
    \ != key {\n            upper_case = false;\n        }\n    }\n    lower_case\
    \ || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcy375z99.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        }\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n \
    \       }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmgdzw_p9.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for key in dict.keys() {\n        if key.is_empty() {\n\
    \            return false;\n        }\n        if key.chars().all(|c| c.is_lowercase())\
    \ {\n            is_lower = true;\n        } else if key.chars().all(|c| c.is_uppercase())\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8i6lrlk8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnqm0fw1y.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp68g1xr04.rs:21:17\n   |\n21 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp68g1xr04.rs:24:17\n   |\n24 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_lower = false;\n        }\n        if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_p1zc0mw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.is_empty()\
    \ {\n            if key.chars().next().unwrap().is_lowercase() {\n           \
    \     upper_case = false;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                lower_case = false;\n            } else {\n             \
    \   return false;\n            }\n        }\n    }\n    lower_case || upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplnv6yvmw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5j7bbgo4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv5ybghqf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper_case = true;\n    let\
    \ mut lower_case = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        }\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            upper_case = false;\n \
    \       }\n    }\n    upper_case || lower_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprrn52irz.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphh63836u.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lower = true;\n    let mut upper = true;\n    for\
    \ (key, _) in dict {\n        if key.chars().any(|c| c.is_uppercase()) {\n   \
    \         lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoewpj0nt.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_lower = false;\n        }\n        if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjgsvf_mh.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv5ybghqf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for (key, _) in dict {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl_g5jj2g.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpek_aw5yh.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lower_case = true;\n    let mut upper_case = true;\n\
    \    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptvc801eh.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower = dict.keys().next().unwrap().chars().next().unwrap().is_lowercase();\n\
    \    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ != is_lower {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphw101w6g.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjn7fhzzn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if !key.is_empty() {\n      \
    \      if key.chars().next().unwrap().is_lowercase() {\n                upper\
    \ = false;\n            } else if key.chars().next().unwrap().is_uppercase() {\n\
    \                lower = false;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    lower || upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_wziijbj.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3asxjft4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for key in dict.keys() {\n        if key.is_ascii_lowercase()\
    \ {\n            all_upper = false;\n        } else if key.is_ascii_uppercase()\
    \ {\n            all_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmps1_so395.rs:21:16\n   |\n21 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmps1_so395.rs:23:23\n   |\n23 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010656
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_upper = true;\n    let mut\
    \ is_lower = true;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    is_upper || is_lower\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppticnofx.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            all_lower = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            all_upper = false;\n        } else {\n    \
    \        return false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptxzi5zc6.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_lower = false;\n        }\n        if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_p1zc0mw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = false;\n    let\
    \ mut upper_case = false;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = true;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            upper_case = true;\n        } else {\n    \
    \        return false;\n        }\n    }\n    lower_case || upper_case\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqpx8e8kv.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_upper = false;\n    let mut\
    \ is_lower = false;\n    for (key, _) in dict {\n        if key.is_uppercase()\
    \ {\n            is_upper = true;\n        } else if key.is_lowercase() {\n  \
    \          is_lower = true;\n        } else {\n            return false;\n   \
    \     }\n    }\n    if is_upper && is_lower {\n        return false;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp8t71mw4b.rs:21:16\n   |\n21 |         if\
    \ key.is_uppercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `is_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp8t71mw4b.rs:23:23\n\
    \   |\n23 |         } else if key.is_lowercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for (key, _) in dict {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            lower = false;\n        }\n        if key.chars().any(|c| c.is_lowercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1wy0fj1_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    !(is_lower && is_upper)\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd_wnouyj.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_case = false;\n        }\n        if\
    \ !key.chars().all(|c| c.is_uppercase()) {\n            upper_case = false;\n\
    \        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptj3tft2r.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010656
