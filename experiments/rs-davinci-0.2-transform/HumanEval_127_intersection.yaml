name: HumanEval_127_intersection
language: rs
prompt: "/// You are given two intervals,\n/// where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed\
  \ which means that the interval (start, end)\n/// includes both start and end.\n\
  /// For each given interval, it is assumed that its start is less or equal its end.\n\
  /// Your task is to determine whether the length of intersection of these two \n\
  /// intervals is a prime number.\n/// Example, the intersection of the intervals\
  \ (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n\
  /// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise,\
  \ return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n///\
  \ [input/output] samples:\n/// >>> intersection((1, 2), (2, 3))\n/// String::from(\"\
  NO\")\n/// >>> intersection((-1, 1), (0, 4))\n/// String::from(\"NO\")\n/// >>>\
  \ intersection((-3, -1), (-5, 5))\n/// String::from(\"YES\")\nfn intersection(interval1:\
  \ (isize, isize), interval2: (isize, isize)) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ["    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    let mut start = 0;\n    let mut end = 0;\n    if start1 <= start2 {\n   \
    \     start = start2;\n    } else {\n        start = start1;\n    }\n    if end1\
    \ <= end2 {\n        end = end1;\n    } else {\n        end = end2;\n    }\n \
    \   if start > end {\n        return String::from(\"NO\");\n    }\n    let mut\
    \ is_prime = true;\n    for i in 2..(end - start + 1) {\n        if (end - start\
    \ + 1) % i == 0 {\n            is_prime = false;\n            break;\n       \
    \ }\n    }\n    if is_prime {\n        return String::from(\"YES\");\n    } else\
    \ {\n        return String::from(\"NO\");\n    }", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let start = if start1 > start2 { start1\
    \ } else { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n \
    \   if start > end {\n        return String::from(\"NO\");\n    }\n    let length\
    \ = end - start + 1;\n    if length == 1 {\n        return String::from(\"NO\"\
    );\n    }\n    let mut is_prime = true;\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            is_prime = false;\n            break;\n     \
    \   }\n    }\n    if is_prime {\n        return String::from(\"YES\");\n    }\n\
    \    String::from(\"NO\")", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = if start1 > start2 { start1 } else { start2\
    \ };\n    let end = if end1 < end2 { end1 } else { end2 };\n    if start > end\
    \ {\n        return String::from(\"NO\");\n    }\n    let length = end - start\
    \ + 1;\n    if length == 1 {\n        return String::from(\"NO\");\n    }\n  \
    \  let mut is_prime = true;\n    for i in 2..length {\n        if length % i ==\
    \ 0 {\n            is_prime = false;\n            break;\n        }\n    }\n \
    \   if is_prime {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    if start1 > end1 || start2 > end2 {\n        return String::from(\"NO\");\n\
    \    }\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n \
    \   if start > end {\n        return String::from(\"NO\");\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    if start1 > end1 || start2 > end2 {\n        return String::from(\"NO\");\n\
    \    }\n    let (start, end) = (start1.max(start2), end1.min(end2));\n    if start\
    \ > end {\n        return String::from(\"NO\");\n    }\n    if is_prime(end -\
    \ start + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    let mut start = start1;\n    let mut end = end1;\n    if start1 > start2\
    \ {\n        start = start2;\n    }\n    if end1 < end2 {\n        end = end2;\n\
    \    }\n    if start > end {\n        return String::from(\"NO\");\n    }\n  \
    \  let mut is_prime = true;\n    for i in 2..(end - start + 1) {\n        if (end\
    \ - start + 1) % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        return String::from(\"YES\");\n\
    \    }\n    String::from(\"NO\")", "    let (start1, end1) = interval1;\n    let\
    \ (start2, end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if start > end {\n        return\
    \ String::from(\"NO\");\n    }\n    let len = end - start + 1;\n    if len ==\
    \ 1 {\n        return String::from(\"NO\");\n    }\n    if len == 2 {\n      \
    \  return String::from(\"YES\");\n    }\n    for i in 2..len {\n        if len\
    \ % i == 0 {\n            return String::from(\"NO\");\n        }\n    }\n   \
    \ String::from(\"YES\")", "    let (mut start, mut end) = (0, 0);\n    if interval1.0\
    \ > interval2.0 {\n        start = interval1.0;\n    } else {\n        start =\
    \ interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n        end = interval1.1;\n\
    \    } else {\n        end = interval2.1;\n    }\n    if start > end {\n     \
    \   return String::from(\"NO\");\n    }\n    let mut count = 0;\n    for i in\
    \ start..=end {\n        count += 1;\n    }\n    if count == 2 {\n        return\
    \ String::from(\"YES\");\n    }\n    if count % 2 == 0 {\n        return String::from(\"\
    NO\");\n    }\n    for i in 2..count {\n        if count % i == 0 {\n        \
    \    return String::from(\"NO\");\n        }\n    }\n    String::from(\"YES\")",
  "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let\
    \ mut start = start1;\n    let mut end = end1;\n    if start2 > start1 {\n   \
    \     start = start2;\n    }\n    if end2 < end1 {\n        end = end2;\n    }\n\
    \    if start > end {\n        return String::from(\"NO\");\n    }\n    let mut\
    \ result = String::from(\"NO\");\n    let mut count = 0;\n    for i in start..end\
    \ + 1 {\n        count += 1;\n    }\n    if is_prime(count) {\n        result\
    \ = String::from(\"YES\");\n    }\n    result", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let start = if start1 > start2 { start1\
    \ } else { start2 };\n    let end = if end1 < end2 { end1 } else { end2 };\n \
    \   if start > end {\n        return String::from(\"NO\");\n    }\n    let len\
    \ = end - start + 1;\n    if len == 1 {\n        return String::from(\"NO\");\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..len {\n        if len %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    if start1 > end1 || start2 > end2 {\n        return String::from(\"NO\");\n\
    \    }\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n \
    \   if start > end {\n        return String::from(\"NO\");\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return String::from(\"YES\");\n    }\n    String::from(\"\
    NO\")", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    if start1 > end1 || start2 > end2 {\n        return String::from(\"NO\");\n\
    \    }\n    if start1 > end2 || start2 > end1 {\n        return String::from(\"\
    NO\");\n    }\n    let start = std::cmp::max(start1, start2);\n    let end = std::cmp::min(end1,\
    \ end2);\n    let len = end - start + 1;\n    if len == 1 {\n        return String::from(\"\
    NO\");\n    }\n    if len == 2 {\n        return String::from(\"YES\");\n    }\n\
    \    for i in 2..len {\n        if len % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")", "    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return String::from(\"NO\");\n    }\n    let mut result = String::from(\"\
    NO\");\n    let mut i = start;\n    while i <= end {\n        if is_prime(i) {\n\
    \            result = String::from(\"YES\");\n            break;\n        }\n\
    \        i += 1;\n    }\n    result", "    let (start1, end1) = interval1;\n \
    \   let (start2, end2) = interval2;\n    if start1 > end1 || start2 > end2 {\n\
    \        return String::from(\"NO\");\n    }\n    let start = if start1 > start2\
    \ { start1 } else { start2 };\n    let end = if end1 < end2 { end1 } else { end2\
    \ };\n    if start > end {\n        return String::from(\"NO\");\n    }\n    let\
    \ length = end - start + 1;\n    if length == 1 {\n        return String::from(\"\
    NO\");\n    }\n    if length == 2 {\n        return String::from(\"YES\");\n \
    \   }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ String::from(\"NO\");\n        }\n    }\n    String::from(\"YES\")", "    let\
    \ (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let start\
    \ = start1.max(start2);\n    let end = end1.min(end2);\n    if start > end {\n\
    \        return String::from(\"NO\");\n    }\n    let len = end - start + 1;\n\
    \    if len < 2 {\n        return String::from(\"NO\");\n    }\n    if len ==\
    \ 2 {\n        return String::from(\"YES\");\n    }\n    for i in 2..len {\n \
    \       if len % i == 0 {\n            return String::from(\"NO\");\n        }\n\
    \    }\n    String::from(\"YES\")", "    let (start1, end1) = interval1;\n   \
    \ let (start2, end2) = interval2;\n    let start = start1.max(start2);\n    let\
    \ end = end1.min(end2);\n    if start > end {\n        return String::from(\"\
    NO\");\n    }\n    let length = end - start + 1;\n    if length == 1 {\n     \
    \   return String::from(\"NO\");\n    }\n    let mut is_prime = true;\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return String::from(\"\
    YES\");\n    }\n    String::from(\"NO\")", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if start > end {\n        return\
    \ String::from(\"NO\");\n    }\n    if is_prime(end - start + 1) {\n        return\
    \ String::from(\"YES\");\n    }\n    String::from(\"NO\")", "    let (start1,\
    \ end1) = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return String::from(\"NO\");\n    }\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return String::from(\"NO\");\n    }\n    for i\
    \ in 2..length {\n        if length % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")", "    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (start, end) = (start1.max(start2),\
    \ end1.min(end2));\n    if start > end {\n        return String::from(\"NO\");\n\
    \    }\n    let len = end - start + 1;\n    if len == 1 {\n        return String::from(\"\
    NO\");\n    }\n    if len == 2 {\n        return String::from(\"YES\");\n    }\n\
    \    for i in 2..len {\n        if len % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")", "    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return String::from(\"NO\");\n    }\n    let length = end - start + 1;\n\
    \    if length == 1 {\n        return String::from(\"NO\");\n    }\n    for i\
    \ in 2..length {\n        if length % i == 0 {\n            return String::from(\"\
    NO\");\n        }\n    }\n    String::from(\"YES\")"]
stop_tokens:
- "\n}"
