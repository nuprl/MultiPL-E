language: rs
name: HumanEval_80_is_happy
results:
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last_char = chars.next();\n    let mut last_last_char = chars.next();\n\
    \    for c in chars {\n        if last_char == last_last_char || last_char ==\
    \ Some(c) {\n            return false;\n        }\n        last_last_char = last_char;\n\
    \        last_char = Some(c);\n    }\n    return true;\n}\n\nfn main() {\n   \
    \ let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n\
    \    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp100sye81.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut first = chars.next().unwrap();\n\
    \    let mut second = chars.next().unwrap();\n    let mut third = chars.next().unwrap();\n\
    \    for c in chars {\n        if first == second || second == third || first\
    \ == third {\n            return false;\n        }\n        first = second;\n\
    \        second = third;\n        third = c;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\"\
    )), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk3kzqa7r.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev_char = chars.next();\n    let mut prev_prev_char = chars.next();\n\
    \    for c in chars {\n        if prev_char == Some(c) || prev_prev_char == Some(c)\
    \ {\n            return false;\n        }\n        prev_prev_char = prev_char;\n\
    \        prev_char = Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa2k95ci_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut next = chars.next().unwrap();\n    let mut next_next = chars.next().unwrap();\n\
    \    while next_next != '\\0' {\n        if prev == next || next == next_next\
    \ || prev == next_next {\n            return false;\n        }\n        prev =\
    \ next;\n        next = next_next;\n        next_next = chars.next().unwrap_or('\\\
    0');\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let s = s.as_str();\n    let\
    \ len = s.len();\n    if len < 3 {\n        return false;\n    }\n    for i in\
    \ 0..len - 2 {\n        if s[i..i + 3].chars().all(|c| c == s.chars().next().unwrap())\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp08n8lczc.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|x|\
    \ x[0] != x[1] && x[1] != x[2] && x[0] != x[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut prev = s.chars().nth(0).unwrap();\n    let mut prev_prev\
    \ = s.chars().nth(1).unwrap();\n    for c in s.chars().skip(2) {\n        if c\
    \ == prev || c == prev_prev {\n            return false;\n        }\n        prev_prev\
    \ = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut curr = chars.next();\n    let mut\
    \ next = chars.next();\n    while let (Some(p), Some(c), Some(n)) = (prev, curr,\
    \ next) {\n        if p == c || c == n || p == n {\n            return false;\n\
    \        }\n        prev = curr;\n        curr = next;\n        next = chars.next();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoa6t5u9b.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ let mut prev_prev_prev = chars.next();\n    while let Some(curr) = chars.next()\
    \ {\n        if prev == prev_prev && prev == prev_prev_prev {\n            return\
    \ false;\n        }\n        prev_prev_prev = prev_prev;\n        prev_prev =\
    \ prev;\n        prev = Some(curr);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n\
    \    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4p01zrf0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if c == prev.unwrap() || c == prev_prev.unwrap() {\n\
    \            return false;\n        }\n        prev_prev = prev;\n        prev\
    \ = Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppqvune0m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut first = chars.next().unwrap();\n\
    \    let mut second = chars.next().unwrap();\n    for c in chars {\n        if\
    \ first == second || second == c || first == c {\n            return false;\n\
    \        }\n        first = second;\n        second = c;\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut next = chars.next();\n    let mut\
    \ next_next = chars.next();\n    while next_next.is_some() {\n        if prev\
    \ == next || prev == next_next || next == next_next {\n            return false;\n\
    \        }\n        prev = next;\n        next = next_next;\n        next_next\
    \ = chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjy_fj4ld.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut curr = chars.next().unwrap();\n    let mut next = chars.next().unwrap();\n\
    \    while chars.next().is_some() {\n        if prev == curr || curr == next ||\
    \ prev == next {\n            return false;\n        }\n        prev = curr;\n\
    \        curr = next;\n        next = chars.next().unwrap();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpb5xkdxsa.rs:31:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut next = chars.next();\n    let mut\
    \ next_next = chars.next();\n    while next_next.is_some() {\n        if prev\
    \ == next || next == next_next || prev == next_next {\n            return false;\n\
    \        }\n        prev = next;\n        next = next_next;\n        next_next\
    \ = chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc32brpo5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut curr = chars.next();\n    let mut\
    \ next = chars.next();\n    while next.is_some() {\n        if prev == curr ||\
    \ curr == next {\n            return false;\n        }\n        prev = curr;\n\
    \        curr = next;\n        next = chars.next();\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5o5q1lwr.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut curr = chars.next().unwrap();\n    let mut next = chars.next().unwrap();\n\
    \    while chars.next().is_some() {\n        if prev == curr || curr == next ||\
    \ prev == next {\n            return false;\n        }\n        prev = curr;\n\
    \        curr = next;\n        next = chars.next().unwrap();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpb5xkdxsa.rs:31:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011698
- exit_code: 1
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last = chars.next();\n    let mut last_last = chars.next();\n   \
    \ let mut last_last_last = chars.next();\n    while let Some(c) = last_last_last\
    \ {\n        if c == *last || c == *last_last {\n            return false;\n \
    \       }\n        last = last_last;\n        last_last = last_last_last;\n  \
    \      last_last_last = chars.next();\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n\
    \    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<char>` cannot be dereferenced\n  --> /tmp/tmpfw7d_32y.rs:23:17\n\
    \   |\n23 |         if c == *last || c == *last_last {\n   |                 ^^^^^\n\
    \nerror[E0614]: type `Option<char>` cannot be dereferenced\n  --> /tmp/tmpfw7d_32y.rs:23:31\n\
    \   |\n23 |         if c == *last || c == *last_last {\n   |                 \
    \              ^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660011697
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut next = chars.next();\n    let mut\
    \ next_next = chars.next();\n    while next_next.is_some() {\n        if prev\
    \ == next || next == next_next || prev == next_next {\n            return false;\n\
    \        }\n        prev = next;\n        next = next_next;\n        next_next\
    \ = chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc32brpo5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut first = chars.next();\n    let mut second = chars.next();\n    let\
    \ mut third = chars.next();\n    while let Some(c) = third {\n        if first\
    \ == second || second == third || first == third {\n            return false;\n\
    \        }\n        first = second;\n        second = third;\n        third =\
    \ chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfdmj5q_k.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut next = chars.next().unwrap();\n    let mut next_next = chars.next().unwrap();\n\
    \    while next_next != '\\0' {\n        if prev == next || next == next_next\
    \ || prev == next_next {\n            return false;\n        }\n        prev =\
    \ next;\n        next = next_next;\n        next_next = chars.next().unwrap_or('\\\
    0');\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|x|\
    \ x[0] != x[1] && x[1] != x[2] && x[0] != x[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut result = true;\n    let\
    \ mut chars = s.chars();\n    let mut prev = chars.next();\n    let mut curr =\
    \ chars.next();\n    let mut next = chars.next();\n    while let Some(c) = next\
    \ {\n        if prev == Some(c) || curr == Some(c) {\n            result = false;\n\
    \            break;\n        }\n        prev = curr;\n        curr = next;\n \
    \       next = chars.next();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpttn767kw.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last = chars.next();\n    let mut last_last = chars.next();\n   \
    \ for c in chars {\n        if last == last_last && last == Some(c) {\n      \
    \      return false;\n        }\n        last_last = last;\n        last = Some(c);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjjsy_iuw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ let mut prev_prev_prev = chars.next();\n    while let Some(c) = prev_prev_prev\
    \ {\n        if prev == Some(c) || prev_prev == Some(c) {\n            return\
    \ false;\n        }\n        prev = prev_prev;\n        prev_prev = prev_prev_prev;\n\
    \        prev_prev_prev = chars.next();\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu1qebav2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut next = chars.next().unwrap();\n    for c in chars {\n        if c\
    \ == prev || c == next {\n            return false;\n        }\n        prev =\
    \ next;\n        next = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut first = chars.next();\n    let mut second = chars.next();\n    let\
    \ mut third = chars.next();\n    while let Some(c) = third {\n        if first\
    \ == second || second == third || first == third {\n            return false;\n\
    \        }\n        first = second;\n        second = third;\n        third =\
    \ chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfdmj5q_k.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    for i in 0..s.len() - 2 {\n        if s.chars().nth(i) ==\
    \ s.chars().nth(i + 1)\n            || s.chars().nth(i) == s.chars().nth(i + 2)\n\
    \            || s.chars().nth(i + 1) == s.chars().nth(i + 2)\n        {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n\
    \    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut last = chars.next().unwrap();\n\
    \    let mut last_last = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == last || c == last_last {\n            return false;\n        }\n  \
    \      last_last = last;\n        last = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last = chars.next();\n    let mut last_last = chars.next();\n   \
    \ let mut last_last_last = chars.next();\n    while let Some(c) = last_last_last\
    \ {\n        if last == last_last || last == Some(c) || last_last == Some(c) {\n\
    \            return false;\n        }\n        last = last_last;\n        last_last\
    \ = last_last_last;\n        last_last_last = chars.next();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0bxrojxn.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    for i in 0..s.len() - 2 {\n        if s.chars().nth(i) ==\
    \ s.chars().nth(i + 1) || s.chars().nth(i) == s.chars().nth(i + 2)\n         \
    \   || s.chars().nth(i + 1) == s.chars().nth(i + 2)\n        {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let first = chars.next();\n    let second = chars.next();\n    let third\
    \ = chars.next();\n    if first.is_none() || second.is_none() || third.is_none()\
    \ {\n        return false;\n    }\n    let mut prev = first.unwrap();\n    let\
    \ mut prev_prev = second.unwrap();\n    let mut prev_prev_prev = third.unwrap();\n\
    \    for c in chars {\n        if c == prev || c == prev_prev || c == prev_prev_prev\
    \ {\n            return false;\n        }\n        prev_prev_prev = prev_prev;\n\
    \        prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\"\
    )), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjd59lmzw.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|x|\
    \ x[0] != x[1] && x[1] != x[2] && x[0] != x[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut first = chars.next().unwrap();\n\
    \    let mut second = chars.next().unwrap();\n    for c in chars {\n        if\
    \ first == second || second == c || first == c {\n            return false;\n\
    \        }\n        first = second;\n        second = c;\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\"\
    )), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjunsq88j.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 1
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if c == prev || c == prev_prev {\n            return\
    \ false;\n        }\n        prev_prev = prev;\n        prev = Some(c);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6aspgs86.rs:22:17\n   |\n\
    22 |         if c == prev || c == prev_prev {\n   |                 ^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6aspgs86.rs:22:30\n\
    \   |\n22 |         if c == prev || c == prev_prev {\n   |                   \
    \           ^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<char>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut a = chars.next();\n    let mut b = chars.next();\n    let mut c =\
    \ chars.next();\n    while let (Some(x), Some(y), Some(z)) = (a, b, c) {\n   \
    \     if x == y || y == z || x == z {\n            return false;\n        }\n\
    \        a = b;\n        b = c;\n        c = chars.next();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq98463ow.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last = chars.next();\n    let mut last_last = chars.next();\n   \
    \ for c in chars {\n        if last == last_last && last == Some(c) {\n      \
    \      return false;\n        }\n        last_last = last;\n        last = Some(c);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjjsy_iuw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 1
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let first = chars.next();\n    let second = chars.next();\n    let third\
    \ = chars.next();\n    if first == second || first == third || second == third\
    \ {\n        return false;\n    }\n    for (a, b, c) in s.chars().zip(s.chars().skip(1),\
    \ s.chars().skip(2)) {\n        if a == b || a == c || b == c {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpbky3as4t.rs:25:32\n    |\n25  |     for (a, b, c) in s.chars().zip(s.chars().skip(1),\
    \ s.chars().skip(2)) {\n    |                                ^^^ -----------------\
    \  ----------------- supplied 2 arguments\n    |                             \
    \   |\n    |                                expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbky3as4t.rs:25:9\n\
    \   |\n25 |     for (a, b, c) in s.chars().zip(s.chars().skip(1), s.chars().skip(2))\
    \ {\n   |         ^^^^^^^^^    ---------------------------------------------------\
    \ this expression has type `Option<(char, _)>`\n   |         |\n   |         expected\
    \ a tuple with 2 elements, found one with 3 elements\n   |\n   = note: expected\
    \ tuple `(char, _)`\n              found tuple `(_, _, _)`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut curr = chars.next();\n    let mut\
    \ next = chars.next();\n    while let (Some(p), Some(c), Some(n)) = (prev, curr,\
    \ next) {\n        if p == c || c == n || p == n {\n            return false;\n\
    \        }\n        prev = curr;\n        curr = next;\n        next = chars.next();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoa6t5u9b.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|x|\
    \ x[0] != x[1] && x[1] != x[2] && x[0] != x[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().zip(s.chars().skip(1)).zip(s.chars().skip(2)).all(|((a,\
    \ b), c)| a != b && b != c && a != c)\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut next = chars.next().unwrap();\n    for c in chars {\n        if prev\
    \ == next && next == c {\n            return false;\n        }\n        prev =\
    \ next;\n        next = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr0oirjpr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last = chars.next();\n    let mut last_last = chars.next();\n   \
    \ let mut last_last_last = chars.next();\n    for c in chars {\n        if last\
    \ == last_last && last_last == last_last_last {\n            return false;\n \
    \       }\n        last = last_last;\n        last_last = last_last_last;\n  \
    \      last_last_last = Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq9mzydvz.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if c == prev.unwrap() || c == prev_prev.unwrap() {\n\
    \            return false;\n        }\n        prev_prev = prev;\n        prev\
    \ = Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppqvune0m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut next = chars.next();\n    let mut\
    \ next_next = chars.next();\n    while let (Some(p), Some(n), Some(nn)) = (prev,\
    \ next, next_next) {\n        if p == n || n == nn || p == nn {\n            return\
    \ false;\n        }\n        prev = next;\n        next = next_next;\n       \
    \ next_next = chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp40wzlh9p.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if c == prev.unwrap() || c == prev_prev.unwrap() {\n\
    \            return false;\n        }\n        prev_prev = prev;\n        prev\
    \ = Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppqvune0m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ let mut prev_prev_prev = chars.next();\n    while let Some(c) = prev_prev_prev\
    \ {\n        if prev == Some(c) || prev_prev == Some(c) {\n            return\
    \ false;\n        }\n        prev = prev_prev;\n        prev_prev = prev_prev_prev;\n\
    \        prev_prev_prev = chars.next();\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu1qebav2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last = chars.next();\n    let mut last_last = chars.next();\n   \
    \ for c in chars {\n        if last == last_last && last == Some(c) {\n      \
    \      return false;\n        }\n        last_last = last;\n        last = Some(c);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjjsy_iuw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut curr = chars.next().unwrap();\n    let mut next = chars.next().unwrap();\n\
    \    while chars.next().is_some() {\n        if prev == curr || curr == next ||\
    \ prev == next {\n            return false;\n        }\n        prev = curr;\n\
    \        curr = next;\n        next = chars.next().unwrap();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpb5xkdxsa.rs:31:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ let mut prev_prev_prev = chars.next();\n    while let Some(c) = prev_prev_prev\
    \ {\n        if prev == Some(c) || prev_prev == Some(c) {\n            return\
    \ false;\n        }\n        prev = prev_prev;\n        prev_prev = prev_prev_prev;\n\
    \        prev_prev_prev = chars.next();\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu1qebav2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut first = chars.next();\n    let mut second = chars.next();\n    let\
    \ mut third = chars.next();\n    while let Some(c) = third {\n        if first\
    \ == second || second == third || first == third {\n            return false;\n\
    \        }\n        first = second;\n        second = third;\n        third =\
    \ chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfdmj5q_k.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut last_chars = vec![chars.next().unwrap(),\
    \ chars.next().unwrap()];\n    for c in chars {\n        if last_chars.contains(&c)\
    \ {\n            return false;\n        }\n        last_chars.push(c);\n     \
    \   last_chars.remove(0);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ let mut prev_prev_prev = chars.next();\n    while let Some(c) = prev_prev_prev\
    \ {\n        if prev == Some(c) || prev_prev == Some(c) {\n            return\
    \ false;\n        }\n        prev = prev_prev;\n        prev_prev = prev_prev_prev;\n\
    \        prev_prev_prev = chars.next();\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu1qebav2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut next = chars.next();\n    let mut\
    \ next_next = chars.next();\n    while next_next.is_some() {\n        if prev\
    \ == next || prev == next_next || next == next_next {\n            return false;\n\
    \        }\n        prev = next;\n        next = next_next;\n        next_next\
    \ = chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjy_fj4ld.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ let mut prev_prev_prev = chars.next();\n    while let Some(c) = prev_prev_prev\
    \ {\n        if prev == Some(c) || prev_prev == Some(c) {\n            return\
    \ false;\n        }\n        prev = prev_prev;\n        prev_prev = prev_prev_prev;\n\
    \        prev_prev_prev = chars.next();\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu1qebav2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: -1
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last_char = chars.next();\n    let mut last_last_char = chars.next();\n\
    \    let mut last_last_last_char = chars.next();\n    while let Some(c) = last_last_last_char\
    \ {\n        if last_char == last_last_char || last_char == last_last_last_char\
    \ || last_last_char == last_last_last_char {\n            return false;\n    \
    \    }\n        last_last_last_char = last_last_char;\n        last_last_char\
    \ = last_char;\n        last_char = Some(c);\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\"\
    )), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011703
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev_char = chars.next();\n    let mut prev_prev_char = chars.next();\n\
    \    for c in chars {\n        if prev_char == Some(c) || prev_prev_char == Some(c)\
    \ {\n            return false;\n        }\n        prev_prev_char = prev_char;\n\
    \        prev_char = Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa2k95ci_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last = chars.next();\n    let mut last_last = chars.next();\n   \
    \ for c in chars {\n        if last == last_last && last == Some(c) {\n      \
    \      return false;\n        }\n        last_last = last;\n        last = Some(c);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjjsy_iuw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut i = 0;\n    let mut j\
    \ = 3;\n    let mut result = true;\n    let mut chars = s.chars();\n    let mut\
    \ char_vec: Vec<char> = vec![];\n    while let Some(c) = chars.next() {\n    \
    \    char_vec.push(c);\n    }\n    while j <= char_vec.len() {\n        let mut\
    \ temp_vec: Vec<char> = vec![];\n        for k in i..j {\n            temp_vec.push(char_vec[k]);\n\
    \        }\n        if temp_vec[0] == temp_vec[1] || temp_vec[0] == temp_vec[2]\
    \ || temp_vec[1] == temp_vec[2] {\n            result = false;\n            break;\n\
    \        }\n        i += 1;\n        j += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\"\
    )), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwq01_5t9.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut curr = chars.next().unwrap();\n    let mut next = chars.next().unwrap();\n\
    \    while chars.next().is_some() {\n        if prev == curr || curr == next ||\
    \ prev == next {\n            return false;\n        }\n        prev = curr;\n\
    \        curr = next;\n        next = chars.next().unwrap();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpb5xkdxsa.rs:31:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut next = chars.next().unwrap();\n    let mut next_next = chars.next().unwrap();\n\
    \    while next_next != '\\0' {\n        if prev == next || next == next_next\
    \ || prev == next_next {\n            return false;\n        }\n        prev =\
    \ next;\n        next = next_next;\n        next_next = chars.next().unwrap_or('\\\
    0');\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut first = chars.next().unwrap();\n\
    \    let mut second = chars.next().unwrap();\n    let mut third = chars.next().unwrap();\n\
    \    while chars.next().is_some() {\n        if first == second || second == third\
    \ || first == third {\n            return false;\n        }\n        first = second;\n\
    \        second = third;\n        third = chars.next().unwrap();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmprsj9eh_c.rs:31:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut first = chars.next();\n    let mut second = chars.next();\n    let\
    \ mut third = chars.next();\n    while let Some(c) = third {\n        if first\
    \ == second || second == third || first == third {\n            return false;\n\
    \        }\n        first = second;\n        second = third;\n        third =\
    \ chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfdmj5q_k.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev_char = chars.next();\n    let mut next_char = chars.next();\n\
    \    let mut next_next_char = chars.next();\n    while let (Some(prev), Some(next),\
    \ Some(next_next)) = (prev_char, next_char, next_next_char) {\n        if prev\
    \ == next || next == next_next || prev == next_next {\n            return false;\n\
    \        }\n        prev_char = next_char;\n        next_char = next_next_char;\n\
    \        next_next_char = chars.next();\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy3rp_6ji.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut next = chars.next();\n    let mut\
    \ next_next = chars.next();\n    while next_next.is_some() {\n        if prev\
    \ == next || next == next_next || prev == next_next {\n            return false;\n\
    \        }\n        prev = next;\n        next = next_next;\n        next_next\
    \ = chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc32brpo5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut happy = true;\n    let\
    \ mut last_char = ' ';\n    let mut last_last_char = ' ';\n    for c in s.chars()\
    \ {\n        if last_char == c || last_last_char == c {\n            happy = false;\n\
    \            break;\n        }\n        last_last_char = last_char;\n        last_char\
    \ = c;\n    }\n    happy\n}\n\nfn main() {\n    let candidate = is_happy;\n  \
    \  assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdaxrk66g.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last_char = chars.next();\n    let mut last_last_char = chars.next();\n\
    \    for c in chars {\n        if last_char == last_last_char || last_char ==\
    \ Some(c) {\n            return false;\n        }\n        last_last_char = last_char;\n\
    \        last_char = Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjpbdspb8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut next = chars.next();\n    let mut\
    \ next_next = chars.next();\n    while next_next.is_some() {\n        if prev\
    \ == next || next == next_next || prev == next_next {\n            return false;\n\
    \        }\n        prev = next;\n        next = next_next;\n        next_next\
    \ = chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc32brpo5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut next = chars.next().unwrap();\n    for c in chars {\n        if prev\
    \ == next && next == c {\n            return false;\n        }\n        prev =\
    \ next;\n        next = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr0oirjpr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|v|\
    \ v[0] != v[1] && v[1] != v[2] && v[0] != v[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut a = chars.next();\n    let mut b = chars.next();\n    let mut c =\
    \ chars.next();\n    while let (Some(x), Some(y), Some(z)) = (a, b, c) {\n   \
    \     if x == y || y == z || x == z {\n            return false;\n        }\n\
    \        a = b;\n        b = c;\n        c = chars.next();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq98463ow.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    while i < s.len() - 2 {\n        if s.chars().nth(i)\
    \ == s.chars().nth(i + 1) || s.chars().nth(i) == s.chars().nth(i + 2)\n      \
    \      || s.chars().nth(i + 1) == s.chars().nth(i + 2)\n        {\n          \
    \  return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\"\
    )), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut happy = true;\n    let\
    \ mut i = 0;\n    while i < s.len() - 2 {\n        if s.chars().nth(i) == s.chars().nth(i\
    \ + 1) || s.chars().nth(i) == s.chars().nth(i + 2)\n            || s.chars().nth(i\
    \ + 1) == s.chars().nth(i + 2)\n        {\n            happy = false;\n      \
    \      break;\n        }\n        i += 1;\n    }\n    happy\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpe9te0vxh.rs:20:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut first = chars.next();\n    let mut second = chars.next();\n    let\
    \ mut third = chars.next();\n    while let Some(f) = first {\n        if let Some(s)\
    \ = second {\n            if let Some(t) = third {\n                if f == s\
    \ || s == t || f == t {\n                    return false;\n                }\n\
    \            }\n        }\n        first = second;\n        second = third;\n\
    \        third = chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj5xo22qf.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    while i < s.len() - 2 {\n        if s.chars().nth(i)\
    \ == s.chars().nth(i + 1) || s.chars().nth(i) == s.chars().nth(i + 2)\n      \
    \      || s.chars().nth(i + 1) == s.chars().nth(i + 2)\n        {\n          \
    \  return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\"\
    )), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last = chars.next();\n    let mut last_last = chars.next();\n   \
    \ for c in chars {\n        if last == last_last && last == Some(c) {\n      \
    \      return false;\n        }\n        last_last = last;\n        last = Some(c);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjjsy_iuw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    s.len() >= 3 && s.chars().collect::<Vec<char>>().windows(3).all(|w|\
    \ w[0] != w[1] && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut prev_prev = chars.next().unwrap();\n    for c in chars {\n      \
    \  if c == prev || c == prev_prev {\n            return false;\n        }\n  \
    \      prev_prev = prev;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: -1
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut last_char = chars.next();\n    let mut last_last_char = chars.next();\n\
    \    let mut last_last_last_char = chars.next();\n    while let Some(c) = last_last_last_char\
    \ {\n        if last_char == last_last_char || last_char == last_last_last_char\
    \ || last_last_char == last_last_last_char {\n            return false;\n    \
    \    }\n        last_last_last_char = last_last_char;\n        last_last_char\
    \ = last_char;\n        last_char = Some(c);\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\"\
    )), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011703
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let s = s.as_str();\n    if s.len()\
    \ < 3 {\n        return false;\n    }\n    for i in 0..s.len() - 2 {\n       \
    \ if s.chars().nth(i) == s.chars().nth(i + 1) || s.chars().nth(i) == s.chars().nth(i\
    \ + 2)\n            || s.chars().nth(i + 1) == s.chars().nth(i + 2)\n        {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n\
    \    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if prev == Some(c) || prev_prev == Some(c) {\n   \
    \         return false;\n        }\n        prev_prev = prev;\n        prev =\
    \ Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4wto8ntd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return\
    \ false;\n    }\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut curr = chars.next().unwrap();\n    let mut next = chars.next().unwrap();\n\
    \    while chars.next().is_some() {\n        if prev == curr || curr == next ||\
    \ prev == next {\n            return false;\n        }\n        prev = curr;\n\
    \        curr = next;\n        next = chars.next().unwrap();\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpb5xkdxsa.rs:31:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ for c in chars {\n        if c == prev.unwrap() || c == prev_prev.unwrap() {\n\
    \            return false;\n        }\n        prev_prev = prev;\n        prev\
    \ = Some(c);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppqvune0m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ let mut prev_prev_prev = chars.next();\n    while let Some(c) = prev_prev_prev\
    \ {\n        if prev == Some(c) || prev_prev == Some(c) {\n            return\
    \ false;\n        }\n        prev = prev_prev;\n        prev_prev = prev_prev_prev;\n\
    \        prev_prev_prev = chars.next();\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu1qebav2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(a)\n\
    /// false\n/// >>> is_happy(aa)\n/// false\n/// >>> is_happy(abcd)\n/// true\n\
    /// >>> is_happy(aabb)\n/// false\n/// >>> is_happy(adb)\n/// true\n/// >>> is_happy(xyy)\n\
    /// false\nfn is_happy(s: String) -> bool {\n    let mut chars = s.chars();\n\
    \    let mut prev = chars.next();\n    let mut prev_prev = chars.next();\n   \
    \ let mut prev_prev_prev = chars.next();\n    while let Some(c) = prev_prev_prev\
    \ {\n        if prev == Some(c) || prev_prev == Some(c) {\n            return\
    \ false;\n        }\n        prev = prev_prev;\n        prev_prev = prev_prev_prev;\n\
    \        prev_prev_prev = chars.next();\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu1qebav2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011698
