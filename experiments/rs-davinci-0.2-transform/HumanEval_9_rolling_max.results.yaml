language: rs
name: HumanEval_9_rolling_max
results:
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ isize::min_value();\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        if numbers[i] > max_so_far {\n            max_so_far = numbers[i];\n\
    \        }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxyg2pbld.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvslk7l9y.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = std::cmp::max(max, numbers[i]);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpue2mcepf.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp9oofkn3v.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ numbers[0];\n    result.push(current_max);\n    for number in numbers.iter().skip(1)\
    \ {\n        if number > &current_max {\n            current_max = *number;\n\
    \        }\n        result.push(current_max);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpkzy9ltm0.rs:7:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = std::cmp::max(max, numbers[i]);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpue2mcepf.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for n in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *n);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp2256kqyx.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, *n);\n   |                  \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ isize::min_value();\n    for number in numbers {\n        current_max = current_max.max(number);\n\
    \        result.push(current_max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvslk7l9y.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_so_far =\
    \ std::isize::MIN;\n    for number in numbers {\n        max_so_far = std::cmp::max(max_so_far,\
    \ number);\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvslk7l9y.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        if\
    \ *number > max {\n            max = *number;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvcx4swcs.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_so_far =\
    \ std::isize::MIN;\n    for number in numbers {\n        max_so_far = std::cmp::max(max_so_far,\
    \ number);\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = std::cmp::max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp347gb7vk.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = 0;\n    let mut result = Vec::new();\n\
    \    for number in numbers {\n        max_so_far = std::cmp::max(max_so_far, number);\n\
    \        result.push(max_so_far);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp9oofkn3v.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        if *number > max_so_far {\n            max_so_far = *number;\n  \
    \      }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxblnt931.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        if *number > max_so_far {\n            max_so_far = *number;\n  \
    \      }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxblnt931.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers {\n   \
    \     if number > max_so_far {\n            max_so_far = number;\n        }\n\
    \        result.push(max_so_far);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmptph25_kv.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = std::cmp::max(max, numbers[i]);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpue2mcepf.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        if numbers[i] > max_so_far {\n            max_so_far = numbers[i];\n\
    \        }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxyg2pbld.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for n in numbers.iter().skip(1)\
    \ {\n        if n > &max_so_far {\n            max_so_far = *n;\n        }\n \
    \       result.push(max_so_far);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpiq0o2b03.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = max.max(numbers[i]);\n        result.push(max);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpghs1i2ix.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *number);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp0qspjpcb.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, *number);\n   |             \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        if\
    \ number > &max {\n            max = *number;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmph2ie0stp.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvslk7l9y.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        if *number > max_so_far {\n            max_so_far = *number;\n  \
    \      }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxblnt931.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *number);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp0qspjpcb.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, *number);\n   |             \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for number in numbers {\n        max\
    \ = std::cmp::max(max, number);\n        rolling_max.push(max);\n    }\n    rolling_max\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = max.max(numbers[i]);\n        result.push(max);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpghs1i2ix.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for n in numbers {\n        max = max.max(n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = std::cmp::max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp347gb7vk.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *number);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp0qspjpcb.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, *number);\n   |             \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpt0z0g5uu.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for n in numbers {\n        max = max.max(n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjjm9n5jb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp9oofkn3v.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = 0;\n    let mut result = Vec::new();\n  \
    \  for number in numbers {\n        max = std::cmp::max(max, number);\n      \
    \  result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for n in numbers.iter().skip(1) {\n        if *n >\
    \ max {\n            max = *n;\n        }\n        result.push(max);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpnzah1y4n.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = std::cmp::max(max, numbers[i]);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpue2mcepf.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjjm9n5jb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = std::cmp::max(max_so_far, *number);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjw03aeyq.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for n in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *n);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp2256kqyx.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, *n);\n   |                  \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *number);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp0qspjpcb.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, *number);\n   |             \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpuxi_liqb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjjm9n5jb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjjm9n5jb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for n in numbers.iter().skip(1) {\n        if n >\
    \ &max {\n            max = *n;\n        }\n        result.push(max);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpujv2alrp.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjjm9n5jb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvslk7l9y.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        if *number > max_so_far {\n            max_so_far = *number;\n  \
    \      }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxblnt931.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvslk7l9y.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpuxi_liqb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = max.max(numbers[i]);\n        result.push(max);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpghs1i2ix.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *number);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp0qspjpcb.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, *number);\n   |             \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjjm9n5jb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = std::cmp::max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp347gb7vk.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        max\
    \ = max.max(*number);\n        result.push(max);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpotud9iah.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        if\
    \ *number > max {\n            max = *number;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvcx4swcs.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = std::cmp::max(max_so_far, *number);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjw03aeyq.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for &number in numbers.iter().skip(1)\
    \ {\n        if number > max {\n            max = number;\n        }\n       \
    \ result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp_pmid376.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for n in numbers.iter().skip(1)\
    \ {\n        max_so_far = max_so_far.max(*n);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpi5af3dvu.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        max = max.max(n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        if *number > max_so_far {\n            max_so_far = *number;\n  \
    \      }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxblnt931.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = max.max(numbers[i]);\n        result.push(max);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpghs1i2ix.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = 0;\n    let mut result = Vec::new();\n  \
    \  for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = max.max(numbers[i]);\n        result.push(max);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpghs1i2ix.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for n in numbers.iter().skip(1) {\n        if *n >\
    \ max {\n            max = *n;\n        }\n        result.push(max);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpnzah1y4n.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpuxi_liqb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpuxi_liqb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpakgcnlmh.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for n in numbers {\n        max = max.max(n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        if numbers[i] > max_so_far {\n            max_so_far = numbers[i];\n\
    \        }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxyg2pbld.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpt0z0g5uu.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        if\
    \ *number > max {\n            max = *number;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpyajy9qbd.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for n in numbers.iter().skip(1)\
    \ {\n        if *n > max {\n            max = *n;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvjcooi2u.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *number);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp0qspjpcb.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, *number);\n   |             \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for number in numbers.iter().skip(1)\
    \ {\n        if *number > max {\n            max = *number;\n        }\n     \
    \   result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpf2dzza1l.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvslk7l9y.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = 0;\n  \
    \  for number in numbers {\n        max = std::cmp::max(max, number);\n      \
    \  result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for n in numbers.iter().skip(1)\
    \ {\n        if n > &max_so_far {\n            max_so_far = *n;\n        }\n \
    \       result.push(max_so_far);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpiq0o2b03.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpt0z0g5uu.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjjm9n5jb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        if\
    \ number > &max {\n            max = *number;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpwuj0gsxf.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = std::cmp::max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp347gb7vk.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for n in numbers.iter().skip(1)\
    \ {\n        max_so_far = max_so_far.max(*n);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpi5af3dvu.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ numbers[0];\n    result.push(current_max);\n    for number in numbers.iter().skip(1)\
    \ {\n        if *number > current_max {\n            current_max = *number;\n\
    \        }\n        result.push(current_max);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjzrgrgxk.rs:7:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        if *number > max_so_far {\n            max_so_far = *number;\n  \
    \      }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxblnt931.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjjm9n5jb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = 0;\n  \
    \  for n in numbers {\n        max = std::cmp::max(max, n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpuxi_liqb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for &number in numbers.iter() {\n        max = max.max(number);\n       \
    \ result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max_so_far = numbers[0];\n    result.push(max_so_far);\n    for i\
    \ in 1..numbers.len() {\n        if numbers[i] > max_so_far {\n            max_so_far\
    \ = numbers[i];\n        }\n        result.push(max_so_far);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpwjfodudl.rs:7:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbtykpzxw.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = max.max(numbers[i]);\n        result.push(max);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpghs1i2ix.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpt0z0g5uu.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for n in numbers.iter().skip(1)\
    \ {\n        max_so_far = max(max_so_far, *n);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp2256kqyx.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, *n);\n   |                  \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        max\
    \ = std::cmp::max(max, *number);\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpmcskcn3d.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for &number in numbers.iter().skip(1) {\n        if\
    \ number > max {\n            max = number;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpsmjjpkd7.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for number in numbers.iter().skip(1)\
    \ {\n        if *number > max {\n            max = *number;\n        }\n     \
    \   result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpf2dzza1l.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = std::cmp::max(max, numbers[i]);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpue2mcepf.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ numbers[0];\n    result.push(current_max);\n    for n in numbers.iter().skip(1)\
    \ {\n        current_max = std::cmp::max(current_max, *n);\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp00iq1uyw.rs:7:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp9oofkn3v.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpuxi_liqb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpuxi_liqb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for &number in numbers.iter().skip(1)\
    \ {\n        max = max.max(number);\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpkoabrnpw.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvslk7l9y.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjjm9n5jb.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        if numbers[i] > max_so_far {\n            max_so_far = numbers[i];\n\
    \        }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxyg2pbld.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = max.max(numbers[i]);\n        result.push(max);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpghs1i2ix.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for n in numbers.iter().skip(1) {\n        if n >\
    \ &max {\n            max = *n;\n        }\n        result.push(max);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpujv2alrp.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpgnrx6zyt.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        max\
    \ = std::cmp::max(max, *number);\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpmcskcn3d.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = 0;\n    let mut result = Vec::new();\n  \
    \  for number in numbers {\n        max = std::cmp::max(max, number);\n      \
    \  result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \    for number in numbers {\n        max = max.max(number);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for number in numbers.iter().skip(1)\
    \ {\n        max_so_far = max_so_far.max(*number);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpy2iq9qfp.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        if numbers[i] > max_so_far {\n            max_so_far = numbers[i];\n\
    \        }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpxyg2pbld.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp9oofkn3v.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = max.max(numbers[i]);\n        result.push(max);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpghs1i2ix.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_value = std::isize::MIN;\n\
    \    for number in numbers {\n        max_value = std::cmp::max(max_value, number);\n\
    \        result.push(max_value);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010771
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1,\
    \ 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ Vec::new();\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        max_so_far = std::cmp::max(max_so_far, numbers[i]);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp347gb7vk.rs:6:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010770
