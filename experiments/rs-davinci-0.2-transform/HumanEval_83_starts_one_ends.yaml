name: HumanEval_83_starts_one_ends
language: rs
prompt: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) ->\
  \ isize {\n"
tests: "}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    if n == 1 {\n        return 2;\n    }\n    let mut count = 0;\n\
    \    for i in 1..n {\n        count += starts_one_ends(i);\n    }\n    count *\
    \ 9 + 2", "    let mut count = 0;\n    for i in 1..n {\n        count += 10_isize.pow(i\
    \ as u32) - 10_isize.pow((i - 1) as u32);\n    }\n    count", "    if n == 1 {\n\
    \        return 10;\n    }\n    let mut dp = vec![0; n as usize];\n    dp[0] =\
    \ 10;\n    for i in 1..n as usize {\n        dp[i] = dp[i - 1] * 9 + 10usize.pow(i\
    \ as u32) as isize;\n    }\n    dp[n as usize - 1]", "    if n == 1 {\n      \
    \  return 2;\n    }\n    let mut count = 0;\n    for i in 1..n {\n        count\
    \ += starts_one_ends(i) * starts_one_ends(n - i);\n    }\n    count", "    if\
    \ n == 1 {\n        return 1;\n    }\n\n    let mut sum = 0;\n    for i in 1..n\
    \ {\n        sum += starts_one_ends(i);\n    }\n\n    sum + 1", "    let mut count\
    \ = 0;\n    for i in 1..n {\n        count += 9 * 10isize.pow(i - 1);\n    }\n\
    \    count + 10isize.pow(n - 1)", "    if n == 1 {\n        return 10;\n    }\n\
    \n    let mut count = 0;\n    let mut start = 1;\n    let mut end = 1;\n    for\
    \ _ in 0..n - 1 {\n        start *= 10;\n        end = end * 10 + 1;\n    }\n\n\
    \    count += start;\n    count += end;\n    count += (start - 1) * 9;\n\n   \
    \ count", "    let mut count = 0;\n    for i in 1..n {\n        count += starts_one_ends(i);\n\
    \    }\n    count + 1", "    if n == 1 {\n        return 2;\n    }\n    let mut\
    \ count = 0;\n    for i in 1..n {\n        count += starts_one_ends(i);\n    }\n\
    \    count *= 9;\n    count += starts_one_ends(n - 1);\n    count", "    let mut\
    \ count = 0;\n    for i in 1..n {\n        count += 9 * 10isize.pow(i - 1);\n\
    \    }\n    count + 10isize.pow(n - 1)", "    if n == 1 {\n        return 2;\n\
    \    }\n    let mut dp = vec![0; n as usize];\n    dp[0] = 1;\n    for i in 1..n\
    \ {\n        dp[i as usize] = dp[(i - 1) as usize] * 9 + 10_isize.pow(i - 1);\n\
    \    }\n    dp[(n - 1) as usize] * 2", "    if n == 1 {\n        return 1;\n \
    \   }\n    let mut count = 0;\n    let mut i = 1;\n    while i < n {\n       \
    \ count += starts_one_ends(i) * starts_one_ends(n - i);\n        i += 1;\n   \
    \ }\n    count", "    if n == 1 {\n        return 1;\n    }\n    let mut count\
    \ = 0;\n    for i in 1..n {\n        count += starts_one_ends(i);\n    }\n   \
    \ count *= 9;\n    count += starts_one_ends(n - 1);\n    count", "    if n ==\
    \ 1 {\n        return 10;\n    }\n    let mut count = 0;\n    for i in 1..n {\n\
    \        count += 9 * starts_one_ends(i);\n    }\n    count + 9", "    if n ==\
    \ 1 {\n        return 10;\n    }\n    let mut result = 9;\n    for _ in 1..n {\n\
    \        result *= 10;\n    }\n    result", "    if n == 1 {\n        return 2;\n\
    \    }\n    let mut dp = vec![0; (n + 1) as usize];\n    dp[1] = 2;\n    for i\
    \ in 2..=n {\n        dp[i as usize] = dp[(i - 1) as usize] + dp[(i - 2) as usize];\n\
    \    }\n    dp[n as usize]", "    if n == 1 {\n        return 10;\n    }\n   \
    \ let mut count = 10;\n    let mut base = 10;\n    for _ in 1..n {\n        count\
    \ += base;\n        base *= 10;\n    }\n    count", "    if n == 1 {\n       \
    \ return 10;\n    }\n    let mut count = 0;\n    for i in 1..n {\n        count\
    \ += starts_one_ends(i) * 9 * 10isize.pow(n - i - 1);\n    }\n    count += 10isize.pow(n\
    \ - 1);\n    count", "    if n == 1 {\n        return 2;\n    }\n    let mut dp\
    \ = vec![0; n as usize];\n    dp[0] = 1;\n    dp[1] = 2;\n    for i in 2..n {\n\
    \        dp[i as usize] = dp[(i - 1) as usize] + dp[(i - 2) as usize];\n    }\n\
    \    dp[(n - 1) as usize] * 2", "    let mut count = 0;\n    let mut i = 1;\n\
    \    while i <= n {\n        count += 9 * (10_isize.pow(i - 1) - 10_isize.pow(i\
    \ - 2));\n        i += 1;\n    }\n    count"]
stop_tokens:
- "\n}"
