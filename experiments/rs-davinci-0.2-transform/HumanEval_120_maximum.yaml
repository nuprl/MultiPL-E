name: HumanEval_120_maximum
language: rs
prompt: "/// Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n/// >>>\
  \ maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
  \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
  \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be in\
  \ the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
  \ k: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ["    let mut arr = arr;\n    let mut k = k as usize;\n    let mut res\
    \ = Vec::new();\n    if arr.len() == 0 {\n        return res;\n    }\n    arr.sort();\n\
    \    let mut i = arr.len() - 1;\n    while k > 0 {\n        res.push(arr[i]);\n\
    \        i -= 1;\n        k -= 1;\n    }\n    res", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut res = Vec::new();\n    let mut i = 0;\n\
    \    while k > 0 {\n        let mut j = i;\n        while j < arr.len() {\n  \
    \          if arr[j] > arr[i] {\n                i = j;\n            }\n     \
    \       j += 1;\n        }\n        res.push(arr[i]);\n        arr.remove(i);\n\
    \        k -= 1;\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i + 1;\n        while j < arr.len() {\n            if arr[j]\
    \ > arr[i] {\n                arr.swap(i, j);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n     \
    \       break;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right\
    \ {\n        let pivot = partition(&mut arr, left, right);\n        if pivot ==\
    \ k {\n            break;\n        } else if pivot < k {\n            left = pivot\
    \ + 1;\n        } else {\n            right = pivot - 1;\n        }\n    }\n \
    \   arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut i = 0;\n    while k > 0 {\n        let mut j = i;\n        while\
    \ j < arr.len() - k + 1 {\n            if arr[j] > arr[i] {\n                arr.swap(i,\
    \ j);\n            }\n            j += 1;\n        }\n        i += 1;\n      \
    \  k -= 1;\n    }\n    arr[..i].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut res = Vec::with_capacity(k);\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        let mut j = i + 1;\n        while j < arr.len()\
    \ && arr[j] > arr[i] {\n            j += 1;\n        }\n        if j - i >= k\
    \ {\n            res.push(arr[i]);\n            k -= 1;\n            if k == 0\
    \ {\n                break;\n            }\n        }\n        i = j;\n    }\n\
    \    res", "    let mut result = vec![];\n    let mut arr = arr;\n    arr.sort();\n\
    \    for i in 0..k {\n        result.push(arr[arr.len() - 1 - i as usize]);\n\
    \    }\n    result", "    let mut arr = arr;\n    let mut k = k as usize;\n  \
    \  let mut res = Vec::new();\n    arr.sort();\n    while k > 0 {\n        res.push(arr.pop().unwrap());\n\
    \        k -= 1;\n    }\n    res", "    let mut arr = arr;\n    let mut k = k\
    \ as usize;\n    let mut i = 0;\n    while i < arr.len() {\n        let mut j\
    \ = i + 1;\n        while j < arr.len() {\n            if arr[j] > arr[i] {\n\
    \                arr.swap(i, j);\n            }\n            j += 1;\n       \
    \ }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n\
    \        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut arr = arr;\n    let mut k = k as usize;\n    let mut start = 0;\n    let\
    \ mut end = arr.len() - 1;\n    while start < end {\n        let pivot = partition(&mut\
    \ arr, start, end);\n        if pivot == k {\n            break;\n        } else\
    \ if pivot < k {\n            start = pivot + 1;\n        } else {\n         \
    \   end = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut max_idx = 0;\n    for i in 0..k {\n        max_idx = i;\n       \
    \ for j in i+1..arr.len() {\n            if arr[j] > arr[max_idx] {\n        \
    \        max_idx = j;\n            }\n        }\n        arr.swap(i, max_idx);\n\
    \    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as\
    \ usize;\n    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i\
    \ + 1;\n        while j < arr.len() {\n            if arr[j] > arr[i] {\n    \
    \            arr.swap(i, j);\n            }\n            j += 1;\n        }\n\
    \        i += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n \
    \       }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[i] < arr[j] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        if\
    \ k > 0 {\n            result.push(arr[i]);\n            k -= 1;\n        }\n\
    \        i += 1;\n    }\n    result"]
stop_tokens:
- "\n}"
