name: HumanEval_120_maximum
language: rs
prompt: "/// Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n/// >>>\
  \ maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3,\
  \ 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the array\
  \ will be in the range of [1, 1000].\n/// 2. The elements in the array will be in\
  \ the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>,\
  \ k: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ["    let mut arr = arr;\n    let mut k = k as usize;\n    let mut res\
    \ = Vec::new();\n    if arr.len() == 0 {\n        return res;\n    }\n    arr.sort();\n\
    \    let mut i = arr.len() - 1;\n    while k > 0 {\n        res.push(arr[i]);\n\
    \        i -= 1;\n        k -= 1;\n    }\n    res", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut res = Vec::new();\n    let mut i = 0;\n\
    \    while k > 0 {\n        let mut j = i;\n        while j < arr.len() {\n  \
    \          if arr[j] > arr[i] {\n                i = j;\n            }\n     \
    \       j += 1;\n        }\n        res.push(arr[i]);\n        arr.remove(i);\n\
    \        k -= 1;\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i + 1;\n        while j < arr.len() {\n            if arr[j]\
    \ > arr[i] {\n                arr.swap(i, j);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n     \
    \       break;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right\
    \ {\n        let pivot = partition(&mut arr, left, right);\n        if pivot ==\
    \ k {\n            break;\n        } else if pivot < k {\n            left = pivot\
    \ + 1;\n        } else {\n            right = pivot - 1;\n        }\n    }\n \
    \   arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut i = 0;\n    while k > 0 {\n        let mut j = i;\n        while\
    \ j < arr.len() - k + 1 {\n            if arr[j] > arr[i] {\n                arr.swap(i,\
    \ j);\n            }\n            j += 1;\n        }\n        i += 1;\n      \
    \  k -= 1;\n    }\n    arr[..i].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut res = Vec::with_capacity(k);\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        let mut j = i + 1;\n        while j < arr.len()\
    \ && arr[j] > arr[i] {\n            j += 1;\n        }\n        if j - i >= k\
    \ {\n            res.push(arr[i]);\n            k -= 1;\n            if k == 0\
    \ {\n                break;\n            }\n        }\n        i = j;\n    }\n\
    \    res", "    let mut result = vec![];\n    let mut arr = arr;\n    arr.sort();\n\
    \    for i in 0..k {\n        result.push(arr[arr.len() - 1 - i as usize]);\n\
    \    }\n    result", "    let mut arr = arr;\n    let mut k = k as usize;\n  \
    \  let mut res = Vec::new();\n    arr.sort();\n    while k > 0 {\n        res.push(arr.pop().unwrap());\n\
    \        k -= 1;\n    }\n    res", "    let mut arr = arr;\n    let mut k = k\
    \ as usize;\n    let mut i = 0;\n    while i < arr.len() {\n        let mut j\
    \ = i + 1;\n        while j < arr.len() {\n            if arr[j] > arr[i] {\n\
    \                arr.swap(i, j);\n            }\n            j += 1;\n       \
    \ }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n\
    \        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut arr = arr;\n    let mut k = k as usize;\n    let mut start = 0;\n    let\
    \ mut end = arr.len() - 1;\n    while start < end {\n        let pivot = partition(&mut\
    \ arr, start, end);\n        if pivot == k {\n            break;\n        } else\
    \ if pivot < k {\n            start = pivot + 1;\n        } else {\n         \
    \   end = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut max_idx = 0;\n    for i in 0..k {\n        max_idx = i;\n       \
    \ for j in i+1..arr.len() {\n            if arr[j] > arr[max_idx] {\n        \
    \        max_idx = j;\n            }\n        }\n        arr.swap(i, max_idx);\n\
    \    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as\
    \ usize;\n    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i\
    \ + 1;\n        while j < arr.len() {\n            if arr[j] > arr[i] {\n    \
    \            arr.swap(i, j);\n            }\n            j += 1;\n        }\n\
    \        i += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n \
    \       }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[i] < arr[j] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        if\
    \ k > 0 {\n            result.push(arr[i]);\n            k -= 1;\n        }\n\
    \        i += 1;\n    }\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut arr = arr;\n    let mut k = k as\
    \ usize;\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while\
    \ left < right {\n        let pivot = partition(&mut arr, left, right);\n    \
    \    if pivot == k {\n            break;\n        } else if pivot < k {\n    \
    \        left = pivot + 1;\n        } else {\n            right = pivot - 1;\n\
    \        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    arr.sort();\n    arr.reverse();\n    arr.truncate(k);\n\
    \    arr", "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result\
    \ = Vec::new();\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n    }\n    result",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[i] < arr[j] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        if\
    \ k > 0 {\n            result.push(arr[i]);\n            k -= 1;\n        }\n\
    \        i += 1;\n    }\n    result", "    let mut arr = arr;\n    let mut k =\
    \ k as usize;\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n   \
    \ while left < right {\n        let pivot = partition(&mut arr, left, right);\n\
    \        if pivot == k {\n            break;\n        } else if pivot < k {\n\
    \            left = pivot + 1;\n        } else {\n            right = pivot -\
    \ 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.iter().rev().take(k as usize).cloned().collect()", "    let mut arr =\
    \ arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut heap = BinaryHeap::new();\n    for i in arr {\n        heap.push(i);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    heap.into_sorted_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let mut res = Vec::new();\n\
    \    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n        res.push(arr[arr.len()\
    \ - i as usize - 1]);\n    }\n    res", "    let mut arr = arr;\n    let mut k\
    \ = k as usize;\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n \
    \   while left <= right {\n        let pivot = partition(&mut arr, left, right);\n\
    \        if pivot == k {\n            break;\n        } else if pivot < k {\n\
    \            left = pivot + 1;\n        } else {\n            right = pivot -\
    \ 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.iter().rev().take(k as usize).cloned().collect()", "    let mut arr =\
    \ arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        let mut j = i + 1;\n        while j < arr.len() {\n\
    \            if arr[j] > arr[i] {\n                arr.swap(i, j);\n         \
    \   }\n            j += 1;\n        }\n        i += 1;\n        k -= 1;\n    \
    \    if k == 0 {\n            break;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut max_heap = BinaryHeap::new();\n    for i in 0..k {\n        max_heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > max_heap.peek().unwrap() {\n            max_heap.pop();\n         \
    \   max_heap.push(arr[i as usize]);\n        }\n    }\n    let mut result = Vec::new();\n\
    \    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut result = vec![];\n    let mut arr = arr;\n    arr.sort();\n    for i in\
    \ 0..k {\n        result.push(arr[arr.len() - i as usize - 1]);\n    }\n    result",
  "    let mut arr = arr;\n    let mut res = Vec::new();\n    let mut i = 0;\n   \
    \ while i < k {\n        let max = arr.iter().max().unwrap();\n        res.push(*max);\n\
    \        arr.remove_item(max);\n        i += 1;\n    }\n    res", "    let mut\
    \ arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut result = Vec::new();\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        let mut j = i + 1;\n        while j < arr.len() {\n            if\
    \ arr[i] < arr[j] {\n                arr.swap(i, j);\n            }\n        \
    \    j += 1;\n        }\n        if k > 0 {\n            result.push(arr[i]);\n\
    \            k -= 1;\n        }\n        i += 1;\n    }\n    result", "    let\
    \ mut arr = arr;\n    let mut k = k as usize;\n    let mut l = 0;\n    let mut\
    \ r = arr.len() - 1;\n    while l < r {\n        let i = partition(&mut arr, l,\
    \ r);\n        if i == k {\n            break;\n        } else if i < k {\n  \
    \          l = i + 1;\n        } else {\n            r = i - 1;\n        }\n \
    \   }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut res = Vec::new();\n    for i in 0..k {\n        let mut max = i;\n\
    \        for j in i+1..arr.len() {\n            if arr[j] > arr[max] {\n     \
    \           max = j;\n            }\n        }\n        res.push(arr[max]);\n\
    \        arr.swap(i, max);\n    }\n    res", "    let mut arr = arr;\n    let\
    \ mut k = k as usize;\n    let mut result = Vec::new();\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        let mut j = i + 1;\n        while j < arr.len()\
    \ {\n            if arr[i] < arr[j] {\n                arr.swap(i, j);\n     \
    \       }\n            j += 1;\n        }\n        if k > 0 {\n            result.push(arr[i]);\n\
    \            k -= 1;\n        }\n        i += 1;\n    }\n    result", "    let\
    \ mut arr = arr;\n    let mut k = k as usize;\n    let mut start = 0;\n    let\
    \ mut end = arr.len() - 1;\n    while start < end {\n        let pivot = partition(&mut\
    \ arr, start, end);\n        if pivot == k {\n            break;\n        } else\
    \ if pivot < k {\n            start = pivot + 1;\n        } else {\n         \
    \   end = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr\
    \ = arr;\n    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        let mut j = i + 1;\n        while j < arr.len() {\n            if\
    \ arr[j] > arr[i] {\n                arr.swap(i, j);\n            }\n        \
    \    j += 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n\
    \            break;\n        }\n    }\n    arr[0..k].to_vec()", "    let mut arr\
    \ = arr;\n    let mut k = k as usize;\n    let mut result = Vec::with_capacity(k);\n\
    \    for i in 0..k {\n        let mut max_index = i;\n        for j in i+1..arr.len()\
    \ {\n            if arr[j] > arr[max_index] {\n                max_index = j;\n\
    \            }\n        }\n        result.push(arr[max_index]);\n        arr.swap(i,\
    \ max_index);\n    }\n    result", "    let mut arr = arr;\n    let mut k = k\
    \ as usize;\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i <\
    \ j {\n        let p = partition(&mut arr, i, j);\n        if p == k {\n     \
    \       break;\n        } else if p < k {\n            i = p + 1;\n        } else\
    \ {\n            j = p - 1;\n            k = k - (p - i);\n        }\n    }\n\
    \    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.into_iter().take(k as usize).collect()", "    let mut arr = arr;\n  \
    \  let mut k = k as usize;\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    while left < right {\n        let pivot = partition(&mut arr, left,\
    \ right);\n        if pivot == k {\n            break;\n        } else if pivot\
    \ < k {\n            left = pivot + 1;\n        } else {\n            right =\
    \ pivot - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut result = Vec::with_capacity(k);\n  \
    \  let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n   \
    \     while j < arr.len() && arr[j] > arr[i] {\n            j += 1;\n        }\n\
    \        if j - i >= k {\n            result.push(arr[i]);\n            k -= 1;\n\
    \            if k == 0 {\n                break;\n            }\n        }\n \
    \       i = j;\n    }\n    while k > 0 {\n        result.push(arr[i]);\n     \
    \   i += 1;\n        k -= 1;\n    }\n    result", "    let mut arr = arr;\n  \
    \  arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.truncate(k);\n    arr", "    let mut arr = arr;\n    arr.sort();\n  \
    \  arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let mut\
    \ arr = arr;\n    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        let mut j = i + 1;\n        while j < arr.len() {\n            if\
    \ arr[j] > arr[i] {\n                arr.swap(i, j);\n            }\n        \
    \    j += 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n\
    \            break;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr\
    \ = arr;\n    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        let mut j = i + 1;\n        while j < arr.len() {\n            if\
    \ arr[j] > arr[i] {\n                arr.swap(i, j);\n            }\n        \
    \    j += 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n\
    \            break;\n        }\n    }\n    arr[0..k].to_vec()", "    let mut result\
    \ = Vec::new();\n    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n\
    \        result.push(arr[arr.len() - 1 - i as usize]);\n    }\n    result", " \
    \   let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n \
    \   let mut right = arr.len() - 1;\n    while left <= right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < arr.len() && k > 0 {\n        let mut j = i\
    \ + 1;\n        while j < arr.len() && arr[j] > arr[i] {\n            j += 1;\n\
    \        }\n        if j == arr.len() {\n            result.push(arr[i]);\n  \
    \          arr.remove(i);\n            k -= 1;\n        } else {\n           \
    \ i += 1;\n        }\n    }\n    result", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n\
    \    while left < right {\n        let pivot = partition(&mut arr, left, right);\n\
    \        if pivot == k {\n            break;\n        } else if pivot < k {\n\
    \            left = pivot + 1;\n        } else {\n            right = pivot -\
    \ 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut res = Vec::new();\n\
    \    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n        res.push(arr[arr.len()\
    \ - 1 - i as usize]);\n    }\n    res", "    let mut arr = arr;\n    let mut k\
    \ = k as usize;\n    let mut i = 0;\n    while i < arr.len() {\n        let mut\
    \ j = i + 1;\n        while j < arr.len() {\n            if arr[j] > arr[i] {\n\
    \                arr.swap(i, j);\n            }\n            j += 1;\n       \
    \ }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n\
    \        }\n    }\n    arr[0..k].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut result = Vec::new();\n    let mut i = 0;\n    while\
    \ i < arr.len() && k > 0 {\n        let mut j = i + 1;\n        while j < arr.len()\
    \ && arr[j] > arr[i] {\n            j += 1;\n        }\n        if j < arr.len()\
    \ {\n            arr.swap(i, j);\n        }\n        result.push(arr[i]);\n  \
    \      k -= 1;\n        i += 1;\n    }\n    result", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut result = Vec::new();\n    let mut i\
    \ = 0;\n    while i < arr.len() && k > 0 {\n        let mut j = i + 1;\n     \
    \   while j < arr.len() && arr[j] > arr[i] {\n            j += 1;\n        }\n\
    \        result.push(arr[i]);\n        arr.remove(i);\n        k -= 1;\n    }\n\
    \    result", "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n  \
    \      heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize\
    \ {\n        if arr[i as usize] > heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(arr[i as usize]);\n        }\n    }\n    heap.into_sorted_vec()",
  "    let mut max_heap = BinaryHeap::new();\n    for i in 0..k {\n        max_heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > max_heap.peek().unwrap() {\n            max_heap.pop();\n         \
    \   max_heap.push(arr[i as usize]);\n        }\n    }\n    let mut result = vec![];\n\
    \    while !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()", " \
    \   let mut arr = arr;\n    let mut res = Vec::new();\n    let mut k = k as usize;\n\
    \    while k > 0 {\n        let mut max = arr[0];\n        let mut max_index =\
    \ 0;\n        for (i, &x) in arr.iter().enumerate() {\n            if x > max\
    \ {\n                max = x;\n                max_index = i;\n            }\n\
    \        }\n        res.push(max);\n        arr.remove(max_index);\n        k\
    \ -= 1;\n    }\n    res", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n     \
    \   let p = partition(&mut arr, i, j);\n        if p == k {\n            break;\n\
    \        } else if p < k {\n            i = p + 1;\n        } else {\n       \
    \     j = p - 1;\n            k = k - (p - i);\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left <= right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n\
    \    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n        result.push(*max);\n\
    \        arr.remove_item(max);\n    }\n    result", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i + 1;\n        while j < arr.len() {\n            if arr[j]\
    \ > arr[i] {\n                arr.swap(i, j);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n     \
    \       break;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut i = 0;\n    let mut j = arr.len() -\
    \ 1;\n    while i < j {\n        let pivot = partition(&mut arr, i, j);\n    \
    \    if pivot == k {\n            break;\n        } else if pivot < k {\n    \
    \        i = pivot + 1;\n        } else {\n            j = pivot - 1;\n      \
    \      k = k - (pivot - i);\n        }\n    }\n    arr[..k].to_vec()", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right\
    \ {\n        let pivot = partition(&mut arr, left, right);\n        if pivot ==\
    \ k {\n            break;\n        } else if pivot < k {\n            left = pivot\
    \ + 1;\n        } else {\n            right = pivot - 1;\n        }\n    }\n \
    \   arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.into_iter().take(k as usize).collect()", "    let mut arr = arr;\n  \
    \  let mut k = k as usize;\n    let mut result = Vec::new();\n    let mut i =\
    \ 0;\n    while i < arr.len() && k > 0 {\n        let mut j = i + 1;\n       \
    \ while j < arr.len() && arr[j] > arr[i] {\n            j += 1;\n        }\n \
    \       result.push(arr[i]);\n        arr.remove(i);\n        k -= 1;\n    }\n\
    \    result", "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut\
    \ start = 0;\n    let mut end = arr.len() - 1;\n    while start < end {\n    \
    \    let pivot = partition(&mut arr, start, end);\n        if pivot == k {\n \
    \           break;\n        } else if pivot < k {\n            start = pivot +\
    \ 1;\n        } else {\n            end = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::with_capacity(k);\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() && arr[j] > arr[i] {\n            j += 1;\n      \
    \  }\n        if j - i >= k {\n            result.push(arr[i]);\n            k\
    \ -= 1;\n            if k == 0 {\n                break;\n            }\n    \
    \    }\n        i = j;\n    }\n    result", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    arr.sort();\n    arr.reverse();\n    arr.truncate(k);\n\
    \    arr", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut arr = arr;\n    let mut k = k as\
    \ usize;\n    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i\
    \ + 1;\n        while j < arr.len() {\n            if arr[j] > arr[i] {\n    \
    \            arr.swap(i, j);\n            }\n            j += 1;\n        }\n\
    \        i += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n \
    \       }\n    }\n    arr[0..k].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n\
    \    while start < end {\n        let pivot = partition(&mut arr, start, end);\n\
    \        if pivot == k {\n            break;\n        } else if pivot < k {\n\
    \            start = pivot + 1;\n        } else {\n            end = pivot - 1;\n\
    \        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut result = Vec::new();\n    arr.sort();\n    while\
    \ k > 0 {\n        result.push(arr.pop().unwrap());\n        k -= 1;\n    }\n\
    \    result", "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut\
    \ res = Vec::new();\n    if arr.len() == k {\n        return arr;\n    }\n   \
    \ arr.sort();\n    for i in 0..k {\n        res.push(arr[arr.len() - 1 - i]);\n\
    \    }\n    res", "    let mut arr = arr;\n    let mut k = k as usize;\n    let\
    \ mut result = Vec::new();\n    arr.sort();\n    while k > 0 {\n        result.push(arr.pop().unwrap());\n\
    \        k -= 1;\n    }\n    result", "    let mut arr = arr;\n    let mut k =\
    \ k as usize;\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    while\
    \ start < end {\n        let pivot = partition(&mut arr, start, end);\n      \
    \  if pivot == k {\n            break;\n        } else if pivot < k {\n      \
    \      start = pivot + 1;\n        } else {\n            end = pivot - 1;\n  \
    \      }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut res = Vec::with_capacity(k);\n    for i in 0..k\
    \ {\n        let mut max_index = i;\n        for j in i+1..arr.len() {\n     \
    \       if arr[j] > arr[max_index] {\n                max_index = j;\n       \
    \     }\n        }\n        res.push(arr[max_index]);\n        arr.swap(i, max_index);\n\
    \    }\n    res", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut arr = arr;\n    let mut k = k as\
    \ usize;\n    let mut i = k;\n    while i < arr.len() {\n        let mut j = i;\n\
    \        while j > 0 && arr[j - 1] < arr[j] {\n            arr.swap(j - 1, j);\n\
    \            j -= 1;\n        }\n        i += 1;\n    }\n    arr.iter().take(k).cloned().collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left <= right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left <= right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::with_capacity(k);\n\
    \    let mut i = 0;\n    while k > 0 {\n        let mut max = i;\n        for\
    \ j in i + 1..arr.len() {\n            if arr[j] > arr[max] {\n              \
    \  max = j;\n            }\n        }\n        result.push(arr[max]);\n      \
    \  arr.remove(max);\n        k -= 1;\n    }\n    result", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i + 1;\n        while j < arr.len() {\n            if arr[j]\
    \ > arr[i] {\n                arr.swap(i, j);\n            }\n            j +=\
    \ 1;\n        }\n        if k == 1 {\n            break;\n        }\n        i\
    \ += 1;\n        k -= 1;\n    }\n    arr.iter().take(k).cloned().collect()", " \
    \   let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    for _ in 0..k {\n        let mut max = std::isize::MIN;\n        let mut\
    \ max_index = 0;\n        for (i, &v) in arr.iter().enumerate() {\n          \
    \  if v > max {\n                max = v;\n                max_index = i;\n  \
    \          }\n        }\n        result.push(max);\n        arr.remove(max_index);\n\
    \    }\n    result", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut arr = arr;\n    arr.sort();\n  \
    \  arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let mut\
    \ arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right\
    \ {\n        let pivot = partition(&mut arr, left, right);\n        if pivot ==\
    \ k {\n            break;\n        } else if pivot < k {\n            left = pivot\
    \ + 1;\n        } else {\n            right = pivot - 1;\n        }\n    }\n \
    \   arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[j] > arr[i] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        i\
    \ += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n        }\n\
    \    }\n    arr.iter().take(k).cloned().collect()", "    let mut result = Vec::new();\n\
    \    let mut arr = arr;\n    let mut k = k;\n    while k > 0 {\n        let mut\
    \ max = arr[0];\n        let mut max_index = 0;\n        for (i, &x) in arr.iter().enumerate()\
    \ {\n            if x > max {\n                max = x;\n                max_index\
    \ = i;\n            }\n        }\n        result.push(max);\n        arr.remove(max_index);\n\
    \        k -= 1;\n    }\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.iter().rev().take(k as usize).cloned().collect()", "    let mut result\
    \ = vec![];\n    let mut arr = arr;\n    arr.sort();\n    for i in 0..k {\n  \
    \      result.push(arr[arr.len() - 1 - i as usize]);\n    }\n    result", "  \
    \  let mut arr = arr;\n    let mut k = k as usize;\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        let mut j = i + 1;\n        while j < arr.len() {\n\
    \            if arr[j] > arr[i] {\n                arr.swap(i, j);\n         \
    \   }\n            j += 1;\n        }\n        i += 1;\n        k -= 1;\n    \
    \    if k == 0 {\n            break;\n        }\n    }\n    arr.iter().take(k).cloned().collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n\
    \    arr.sort();\n    for i in 0..k {\n        result.push(arr[(arr.len() - i\
    \ as usize - 1) as usize]);\n    }\n    result", "    let mut arr = arr;\n   \
    \ arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut start = 0;\n    let mut end = arr.len() - 1;\n    while start < end\
    \ {\n        let pivot = partition(&mut arr, start, end);\n        if pivot ==\
    \ k {\n            break;\n        } else if pivot < k {\n            start =\
    \ pivot + 1;\n        } else {\n            end = pivot - 1;\n        }\n    }\n\
    \    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut i = 0;\n    while i < arr.len() - 1 {\n        let mut j = i + 1;\n\
    \        while j < arr.len() {\n            if arr[i] < arr[j] {\n           \
    \     arr.swap(i, j);\n            }\n            j += 1;\n        }\n       \
    \ i += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n        }\n\
    \    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as\
    \ usize;\n    let mut i = 0;\n    while i < arr.len() - 1 {\n        let mut j\
    \ = i + 1;\n        while j < arr.len() {\n            if arr[i] < arr[j] {\n\
    \                arr.swap(i, j);\n            }\n            j += 1;\n       \
    \ }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n\
    \        }\n    }\n    arr[0..k].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while\
    \ i < j {\n        let p = partition(&mut arr, i, j);\n        if p == k {\n \
    \           break;\n        } else if p < k {\n            i = p + 1;\n      \
    \  } else {\n            j = p - 1;\n            k = k - (p - i);\n        }\n\
    \    }\n    arr[..k].to_vec()", "    let mut result = Vec::new();\n    let mut\
    \ arr = arr;\n    arr.sort();\n    for i in 0..k {\n        result.push(arr[arr.len()\
    \ - 1 - i as usize]);\n    }\n    result", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n\
    \    while start < end {\n        let pivot = partition(&mut arr, start, end);\n\
    \        if pivot == k {\n            break;\n        } else if pivot < k {\n\
    \            start = pivot + 1;\n        } else {\n            end = pivot - 1;\n\
    \        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut result = Vec::with_capacity(k);\n    let mut left\
    \ = 0;\n    let mut right = arr.len() - 1;\n    while left <= right {\n      \
    \  let pivot = partition(&mut arr, left, right);\n        if pivot == k {\n  \
    \          break;\n        } else if pivot < k {\n            left = pivot + 1;\n\
    \            k -= pivot + 1;\n        } else {\n            right = pivot - 1;\n\
    \        }\n    }\n    for i in 0..k {\n        result.push(arr[i]);\n    }\n\
    \    result", "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut\
    \ max_idx = 0;\n    for i in 0..k {\n        max_idx = i;\n        for j in i+1..arr.len()\
    \ {\n            if arr[j] > arr[max_idx] {\n                max_idx = j;\n  \
    \          }\n        }\n        arr.swap(i, max_idx);\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while k > 0 {\n        let mut max = i;\n        for\
    \ j in i..arr.len() {\n            if arr[j] > arr[max] {\n                max\
    \ = j;\n            }\n        }\n        result.push(arr[max]);\n        arr.remove(max);\n\
    \        k -= 1;\n    }\n    result", "    let mut arr = arr;\n    let mut k =\
    \ k as usize;\n    let mut res = Vec::new();\n    let mut i = 0;\n    while k\
    \ > 0 {\n        let mut max = i;\n        for j in i + 1..arr.len() {\n     \
    \       if arr[j] > arr[max] {\n                max = j;\n            }\n    \
    \    }\n        res.push(arr[max]);\n        arr.remove(max);\n        k -= 1;\n\
    \    }\n    res", "    let mut arr = arr;\n    let mut k = k as usize;\n    let\
    \ mut left = 0;\n    let mut right = arr.len() - 1;\n    while left <= right {\n\
    \        let pivot = partition(&mut arr, left, right);\n        if pivot == k\
    \ {\n            break;\n        } else if pivot < k {\n            left = pivot\
    \ + 1;\n        } else {\n            right = pivot - 1;\n        }\n    }\n \
    \   arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[j] > arr[i] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        i\
    \ += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n        }\n\
    \    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as\
    \ usize;\n    let mut result = Vec::new();\n    let mut i = 0;\n    while k >\
    \ 0 {\n        let mut max = i;\n        for j in i + 1..arr.len() {\n       \
    \     if arr[j] > arr[max] {\n                max = j;\n            }\n      \
    \  }\n        result.push(arr[max]);\n        arr.remove(max);\n        k -= 1;\n\
    \    }\n    result", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[j] > arr[i] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        i\
    \ += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n        }\n\
    \    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut res = Vec::new();\n\
    \    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n        res.push(*max);\n\
    \        arr.remove_item(max);\n    }\n    res", "    let mut result = Vec::new();\n\
    \    let mut max_heap = BinaryHeap::new();\n    for i in 0..k {\n        max_heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > max_heap.peek().unwrap() {\n            max_heap.pop();\n         \
    \   max_heap.push(arr[i as usize]);\n        }\n    }\n    while !max_heap.is_empty()\
    \ {\n        result.push(max_heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut heap = BinaryHeap::new();\n    for i in arr {\n   \
    \     heap.push(i);\n        if heap.len() > k as usize {\n            heap.pop();\n\
    \        }\n    }\n    heap.into_sorted_vec()", "    let mut arr = arr;\n    let\
    \ mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len() {\n       \
    \ let mut j = i + 1;\n        while j < arr.len() {\n            if arr[j] > arr[i]\
    \ {\n                arr.swap(i, j);\n            }\n            j += 1;\n   \
    \     }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n\
    \        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n     \
    \   let p = partition(&mut arr, i, j);\n        if p == k {\n            break;\n\
    \        } else if p < k {\n            i = p + 1;\n        } else {\n       \
    \     j = p - 1;\n            k = k - (p - i);\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[i] < arr[j] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        if\
    \ k > 0 {\n            result.push(arr[i]);\n            k -= 1;\n        }\n\
    \        i += 1;\n    }\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for i in arr {\n        heap.push(i);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", " \
    \   let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut i = 0;\n    let\
    \ mut j = arr.len() - 1;\n    while i < j {\n        let p = partition(&mut arr,\
    \ i, j);\n        if p == k {\n            break;\n        } else if p < k {\n\
    \            i = p + 1;\n        } else {\n            j = p - 1;\n          \
    \  k = k - (p - i + 1);\n        }\n    }\n    arr[..k].to_vec()", "    let mut\
    \ arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::with_capacity(k);\n\
    \    for i in 0..k {\n        let mut max_index = i;\n        for j in i+1..arr.len()\
    \ {\n            if arr[j] > arr[max_index] {\n                max_index = j;\n\
    \            }\n        }\n        result.push(arr[max_index]);\n        arr.swap(i,\
    \ max_index);\n    }\n    result", "    let mut heap = BinaryHeap::new();\n  \
    \  for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n          \
    \  heap.pop();\n            heap.push(arr[i as usize]);\n        }\n    }\n  \
    \  let mut result = vec![];\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n\
    \    while left < right {\n        let pivot = partition(&mut arr, left, right);\n\
    \        if pivot == k {\n            break;\n        } else if pivot < k {\n\
    \            left = pivot + 1;\n        } else {\n            right = pivot -\
    \ 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        let pivot = partition(&mut\
    \ arr, left, right);\n        if pivot == k {\n            break;\n        } else\
    \ if pivot < k {\n            left = pivot + 1;\n        } else {\n          \
    \  right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut\
    \ arr = arr;\n    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        let mut j = i + 1;\n        while j < arr.len() {\n            if\
    \ arr[j] > arr[i] {\n                arr.swap(i, j);\n            }\n        \
    \    j += 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n\
    \            break;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr\
    \ = arr;\n    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len()\
    \ {\n        let mut j = i + 1;\n        while j < arr.len() {\n            if\
    \ arr[j] > arr[i] {\n                arr.swap(i, j);\n            }\n        \
    \    j += 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n\
    \            break;\n        }\n    }\n    arr[0..k].to_vec()", "    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut res = Vec::new();\n\
    \    if arr.len() == 0 {\n        return res;\n    }\n    if arr.len() == 1 {\n\
    \        res.push(arr[0]);\n        return res;\n    }\n    let mut left = 0;\n\
    \    let mut right = arr.len() - 1;\n    while left < right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    for i in 0..k {\n \
    \       res.push(arr[i]);\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut l = 0;\n    let mut r = arr.len() - 1;\n    while l < r {\n     \
    \   let p = partition(&mut arr, l, r);\n        if p == k {\n            break;\n\
    \        } else if p < k {\n            l = p + 1;\n        } else {\n       \
    \     r = p - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr =\
    \ arr;\n    let mut k = k as usize;\n    let mut max_idx = 0;\n    let mut max_val\
    \ = std::isize::MIN;\n    for i in 0..k {\n        max_idx = i;\n        max_val\
    \ = arr[i];\n        for j in i+1..arr.len() {\n            if arr[j] > max_val\
    \ {\n                max_idx = j;\n                max_val = arr[j];\n       \
    \     }\n        }\n        arr.swap(i, max_idx);\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    arr.sort();\n    for i in (0..k).rev() {\n        result.push(arr[i]);\n\
    \    }\n    result.reverse();\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..arr.len() {\n        if heap.len() < k as usize {\n         \
    \   heap.push(arr[i]);\n        } else {\n            if arr[i] > *heap.peek().unwrap()\
    \ {\n                heap.pop();\n                heap.push(arr[i]);\n       \
    \     }\n        }\n    }\n    heap.into_sorted_vec()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    arr.sort();\n    arr.reverse();\n    arr.truncate(k);\n\
    \    arr", "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut max_heap = BinaryHeap::new();\n    for i\
    \ in 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > max_heap.peek().unwrap() {\n      \
    \      max_heap.pop();\n            max_heap.push(arr[i as usize]);\n        }\n\
    \    }\n    let mut result = vec![];\n    while let Some(x) = max_heap.pop() {\n\
    \        result.push(x);\n    }\n    result.reverse();\n    result", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut result = Vec::with_capacity(k);\n    let mut i = 0;\n    let mut\
    \ j = arr.len() - 1;\n    while i <= j {\n        if arr[i] > arr[j] {\n     \
    \       result.push(arr[i]);\n            i += 1;\n        } else {\n        \
    \    result.push(arr[j]);\n            j -= 1;\n        }\n        if result.len()\
    \ == k {\n            break;\n        }\n    }\n    result.sort();\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut result = Vec::new();\n    let mut k = k as\
    \ usize;\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        result.push(*max);\n        arr.remove_item(max);\n        k -= 1;\n\
    \    }\n    result", "    let mut max_heap = BinaryHeap::new();\n    for i in\
    \ 0..k {\n        max_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > max_heap.peek().unwrap() {\n      \
    \      max_heap.pop();\n            max_heap.push(arr[i as usize]);\n        }\n\
    \    }\n    let mut result = vec![];\n    while !max_heap.is_empty() {\n     \
    \   result.push(max_heap.pop().unwrap());\n    }\n    result.reverse();\n    result",
  "    let mut arr = arr;\n    let mut res = Vec::new();\n    for _ in 0..k {\n  \
    \      let max = arr.iter().max().unwrap();\n        res.push(*max);\n       \
    \ arr.remove_item(max);\n    }\n    res", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while\
    \ i < j {\n        let p = partition(&mut arr, i, j);\n        if p == k {\n \
    \           break;\n        } else if p < k {\n            i = p + 1;\n      \
    \  } else {\n            j = p - 1;\n            k = k - (p - i);\n        }\n\
    \    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n   \
    \ arr.into_iter().rev().take(k as usize).collect()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i + 1;\n        while j < arr.len() {\n            if arr[j]\
    \ > arr[i] {\n                arr.swap(i, j);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n     \
    \       break;\n        }\n    }\n    arr.into_iter().take(k).collect()", "  \
    \  let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    while k > 0 {\n        let mut max = i;\n        for\
    \ j in i + 1..arr.len() {\n            if arr[j] > arr[max] {\n              \
    \  max = j;\n            }\n        }\n        result.push(arr[max]);\n      \
    \  arr.remove(max);\n        k -= 1;\n    }\n    result", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut result = Vec::with_capacity(k);\n  \
    \  let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n   \
    \     while j < arr.len() && arr[j] > arr[i] {\n            j += 1;\n        }\n\
    \        if j - i >= k {\n            result.push(arr[i]);\n            k -= 1;\n\
    \            if k == 0 {\n                break;\n            }\n        }\n \
    \       i = j;\n    }\n    while k > 0 {\n        result.push(arr[i]);\n     \
    \   i += 1;\n        k -= 1;\n    }\n    result", "    let mut arr = arr;\n  \
    \  let mut k = k as usize;\n    let mut result = Vec::new();\n    while k > 0\
    \ {\n        let max = arr.iter().max().unwrap();\n        result.push(*max);\n\
    \        arr.retain(|&x| x != *max);\n        k -= 1;\n    }\n    result", " \
    \   let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left < right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut res = Vec::new();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() && arr[j] > arr[i] {\n            j += 1;\n      \
    \  }\n        if j - i > k {\n            arr.remove(i);\n        } else {\n \
    \           res.push(arr[i]);\n            i += 1;\n            k -= j - i;\n\
    \        }\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.into_iter().take(k as usize).collect()", "    let mut arr = arr;\n  \
    \  let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len() {\n  \
    \      let mut j = i + 1;\n        while j < arr.len() {\n            if arr[j]\
    \ > arr[i] {\n                arr.swap(i, j);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n     \
    \       break;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i + 1;\n        while j < arr.len() {\n            if arr[j]\
    \ > arr[i] {\n                arr.swap(i, j);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n        k -= 1;\n        if k == 0 {\n     \
    \       break;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut result = Vec::with_capacity(k);\n  \
    \  for i in 0..k {\n        let mut max_index = i;\n        for j in i+1..arr.len()\
    \ {\n            if arr[j] > arr[max_index] {\n                max_index = j;\n\
    \            }\n        }\n        result.push(arr[max_index]);\n        arr.swap(i,\
    \ max_index);\n    }\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let mut arr = arr;\n\
    \    let mut k = k as usize;\n    let mut i = 0;\n    let mut j = arr.len() -\
    \ 1;\n    while i < j {\n        let p = partition(&mut arr, i, j);\n        if\
    \ p == k {\n            break;\n        } else if p < k {\n            i = p +\
    \ 1;\n        } else {\n            j = p - 1;\n            k = k - (p - i);\n\
    \        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut\
    \ k = k as usize;\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while\
    \ i < j {\n        let pivot = partition(&mut arr, i, j);\n        if pivot ==\
    \ k {\n            break;\n        } else if pivot < k {\n            i = pivot\
    \ + 1;\n        } else {\n            j = pivot - 1;\n            k = k - (pivot\
    \ - i);\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n \
    \   let mut k = k as usize;\n    let mut left = 0;\n    let mut right = arr.len()\
    \ - 1;\n    while left < right {\n        let pivot = partition(&mut arr, left,\
    \ right);\n        if pivot == k {\n            break;\n        } else if pivot\
    \ < k {\n            left = pivot + 1;\n        } else {\n            right =\
    \ pivot - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()", "   \
    \ let mut arr = arr;\n    let mut k = k as usize;\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        let mut j = i + 1;\n        while j < arr.len() {\n\
    \            if arr[j] > arr[i] {\n                arr.swap(i, j);\n         \
    \   }\n            j += 1;\n        }\n        i += 1;\n        k -= 1;\n    \
    \    if k == 0 {\n            break;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n  \
    \  let mut right = arr.len() - 1;\n    while left <= right {\n        let pivot\
    \ = partition(&mut arr, left, right);\n        if pivot == k {\n            break;\n\
    \        } else if pivot < k {\n            left = pivot + 1;\n        } else\
    \ {\n            right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i + 1;\n \
    \       while j < arr.len() {\n            if arr[j] > arr[i] {\n            \
    \    arr.swap(i, j);\n            }\n            j += 1;\n        }\n        i\
    \ += 1;\n        k -= 1;\n        if k == 0 {\n            break;\n        }\n\
    \    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n    let mut k = k as\
    \ usize;\n    let mut result = Vec::new();\n    while k > 0 {\n        let mut\
    \ max = isize::min_value();\n        let mut max_index = 0;\n        for (i, &n)\
    \ in arr.iter().enumerate() {\n            if n > max {\n                max =\
    \ n;\n                max_index = i;\n            }\n        }\n        result.push(max);\n\
    \        arr.remove(max_index);\n        k -= 1;\n    }\n    result", "    let\
    \ mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n     \
    \   if arr[i] < arr[j] {\n            arr.swap(i, j);\n        }\n        i +=\
    \ 1;\n        j -= 1;\n    }\n    while k > 0 {\n        result.push(arr[k - 1]);\n\
    \        k -= 1;\n    }\n    result", "    let mut arr = arr;\n    let mut k =\
    \ k as usize;\n    let mut result = Vec::new();\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        let mut j = i + 1;\n        while j < arr.len() {\n\
    \            if arr[i] < arr[j] {\n                arr.swap(i, j);\n         \
    \   }\n            j += 1;\n        }\n        if k > 0 {\n            result.push(arr[i]);\n\
    \            k -= 1;\n        }\n        i += 1;\n    }\n    result", "    let\
    \ mut arr = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n    let\
    \ mut right = arr.len() - 1;\n    while left < right {\n        let pivot = partition(&mut\
    \ arr, left, right);\n        if pivot == k {\n            break;\n        } else\
    \ if pivot < k {\n            left = pivot + 1;\n        } else {\n          \
    \  right = pivot - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut\
    \ result = Vec::new();\n    let mut arr = arr;\n    for _ in 0..k {\n        let\
    \ max = arr.iter().max().unwrap();\n        result.push(*max);\n        arr.remove(arr.iter().position(|&x|\
    \ x == *max).unwrap());\n    }\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.iter().rev().take(k as usize).cloned().collect()"]
stop_tokens:
- "\n}"
