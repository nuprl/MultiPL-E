name: HumanEval_57_monotonic
language: rkt
prompt: "#lang racket\n\n;; Return #t is list elements are monotonically increasing\
  \ or decreasing.\n;; >>> (monotonic (list 1 2 4 20))\n;; #t\n;; >>> (monotonic (list\
  \ 1 20 4 10))\n;; #f\n;; >>> (monotonic (list 4 1 0 -10))\n;; #t\n(define (monotonic\
  \ l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n\
  \    (check-equal? (candidate (list 1 2 4 10)) #t)\n    (check-equal? (candidate\
  \ (list 1 2 4 20)) #t)\n    (check-equal? (candidate (list 1 20 4 10)) #f)\n   \
  \ (check-equal? (candidate (list 4 1 0 -10)) #t)\n    (check-equal? (candidate (list\
  \ 4 1 1 0)) #t)\n    (check-equal? (candidate (list 1 2 3 2 5 60)) #f)\n    (check-equal?\
  \ (candidate (list 1 2 3 4 5 60)) #t)\n    (check-equal? (candidate (list 9 9 9\
  \ 9)) #t)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(and\
    \ (positive? (sub1 (first l))) (negative? (sub1 (second l)))) #f]\n    [(and (negative?\
    \ (sub1 (first l))) (positive? (sub1 (second l)))) #f]\n    [else (monotonic (rest\
    \ l))]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(<\
    \ (first l) (second l))\n     (and (monotonic (rest l))\n          (not (member\
    \ (first l) (rest l)) #:test <))]\n    [(> (first l) (second l))\n     (and (monotonic\
    \ (rest l))\n          (not (member (first l) (rest l)) #:test >))]\n    [else\
    \ #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(and\
    \ (positive? (sub1 (first l))) (positive? (sub1 (second l))))\n     (and (monotonic\
    \ (rest l)) (positive? (sub1 (first l) (second l))))]\n    [(and (negative? (sub1\
    \ (first l))) (negative? (sub1 (second l))))\n     (and (monotonic (rest l)) (negative?\
    \ (sub1 (first l) (second l))))]\n    [else #f]))\n", "  (cond\n    [(empty? l)\
    \ #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second l)) (and (monotonic\
    \ (rest l)) (<= (first l) (second l)))]\n    [(< (first l) (second l)) (and (monotonic\
    \ (rest l)) (>= (first l) (second l)))]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second l)) (and (monotonic\
    \ (rest l)) (monotonic (rest (rest l)) #f))]\n    [(< (first l) (second l)) (and\
    \ (monotonic (rest l)) (monotonic (rest (rest l)) #f))]\n    [else #f]))\n", " \
    \ (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second\
    \ l))\n     (and (monotonic (rest l))\n          (or (empty? (rest (rest l)))\n\
    \              (> (second l) (third l))))]\n    [(< (first l) (second l))\n  \
    \   (and (monotonic (rest l))\n          (or (empty? (rest (rest l)))\n      \
    \        (< (second l) (third l))))]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second l)) (monotonic\
    \ (rest l))]\n    [(< (first l) (second l)) (monotonic (rest l))]\n    [else #f]))\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(or (= (first l)\
    \ (second l))\n         (and (< (first l) (second l))\n              (monotonic\
    \ (rest l))))\n     #t]\n    [(and (> (first l) (second l))\n          (monotonic\
    \ (rest l)))\n     #t]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n  \
    \  [(empty? (rest l)) #t]\n    [(< (first l) (second l)) (monotonic (rest l))]\n\
    \    [(> (first l) (second l)) (monotonic (rest l))]\n    [else #f]))\n", "  (cond\n\
    \    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(and (positive? (sub1 (first\
    \ l))) (positive? (sub1 (second l))))\n     (and (monotonic (rest l)) (positive?\
    \ (sub1 (first l) (second l))))]\n    [(and (negative? (sub1 (first l))) (negative?\
    \ (sub1 (second l))))\n     (and (monotonic (rest l)) (negative? (sub1 (first\
    \ l) (second l))))]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty?\
    \ (rest l)) #t]\n    [(< (first l) (second l)) (monotonic (rest l))]\n    [(>\
    \ (first l) (second l)) (monotonic (rest l))]\n    [else #f]))\n", "  (cond\n\
    \    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(and (positive? (sub1 (first\
    \ l))) (positive? (sub1 (second l))))\n     (and (monotonic (rest l)) (positive?\
    \ (sub1 (first l) (second l))))]\n    [(and (negative? (sub1 (first l))) (negative?\
    \ (sub1 (second l))))\n     (and (monotonic (rest l)) (negative? (sub1 (first\
    \ l) (second l))))]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty?\
    \ (rest l)) #t]\n    [(< (first l) (second l))\n     (and (monotonic (rest l))\n\
    \          (or (empty? (rest (rest l)))\n              (< (second l) (third l))))]\n\
    \    [(> (first l) (second l))\n     (and (monotonic (rest l))\n          (or\
    \ (empty? (rest (rest l)))\n              (> (second l) (third l))))]\n    [else\
    \ #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(>\
    \ (first l) (second l)) (and (monotonic (rest l)) (monotonic (rest (rest l)) #f))]\n\
    \    [(< (first l) (second l)) (and (monotonic (rest l)) (monotonic (rest (rest\
    \ l)) #f))]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest\
    \ l)) #t]\n    [(> (first l) (second l))\n     (and (monotonic (rest l))\n   \
    \       (every < (rest l)))]\n    [(< (first l) (second l))\n     (and (monotonic\
    \ (rest l))\n          (every > (rest l)))]\n    [else #f]))\n", "  (cond\n  \
    \  [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second l))\
    \ (monotonic (rest l))]\n    [(< (first l) (second l)) (monotonic (rest l))]\n\
    \    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n\
    \    [(> (first l) (second l)) (and (monotonic (rest l)) (positive? (first l)\
    \ (second l)))]\n    [(< (first l) (second l)) (and (monotonic (rest l)) (negative?\
    \ (first l) (second l)))]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n\
    \    [(empty? (rest l)) #t]\n    [(< (first l) (second l))\n     (and (monotonic\
    \ (rest l)) #t)]\n    [(> (first l) (second l))\n     (and (monotonic (rest l))\
    \ #t)]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest\
    \ l)) #t]\n    [(> (first l) (second l)) (monotonic-decreasing (rest l))]\n  \
    \  [(< (first l) (second l)) (monotonic-increasing (rest l))]\n    [else #f]))\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(< (first l) (second\
    \ l)) (monotonic (rest l))]\n    [(> (first l) (second l)) (monotonic (rest l))]\n\
    \    [else #f]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
