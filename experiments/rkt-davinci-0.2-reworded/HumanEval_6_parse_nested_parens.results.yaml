name: HumanEval_6_parse_nested_parens
language: rkt
results:
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_depth 0] [current_depth 0])\n           (cond [(empty? paren_group)\
    \ max_depth]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group)\n                        (if (> current_depth\
    \ max_depth)\n                            (+ current_depth 1)\n              \
    \              max_depth)\n                        (+ current_depth 1))]\n   \
    \              [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group)\n                        max_depth\n                        (-\
    \ current_depth 1))]\n                 [else (loop (rest paren_group) max_depth\
    \ current_depth)])))\n       (string-split paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4_8a4ucj.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4_8a4ucj.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4_8a4ucj.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [paren_count 0] [max_paren_count 0])\n      (cond\n        [(empty?\
    \ paren_string) max_paren_count]\n        [(char=? (first paren_string) #\\()\n\
    \         (loop (rest paren_string) (+ paren_count 1) (max paren_count max_paren_count))]\n\
    \        [(char=? (first paren_string) #\\))\n         (loop (rest paren_string)\
    \ (- paren_count 1) (max paren_count max_paren_count))]\n        [else (loop (rest\
    \ paren_string) paren_count max_paren_count)])))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4se317eb.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4se317eb.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4se317eb.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (paren_group_max_depth\
    \ paren_group))\n       (string-split paren_string)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp2b7eu_t6.rkt:10:10: paren_group_max_depth: unbound identifier\n\
    \  in: paren_group_max_depth\n  location...:\n   /tmp/tmp2b7eu_t6.rkt:10:10\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (define (parse_parens paren_string)\n    (define (parse_parens_helper\
    \ paren_string depth)\n      (cond\n        [(empty? paren_string) depth]\n  \
    \      [(char=? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ depth 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- depth 1))]\n        [else (parse_parens_helper (rest\
    \ paren_string) depth)]))\n    (parse_parens_helper paren_string 0))\n  (define\
    \ (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string) '()]\n\
    \      [(char=? (first paren_string) #\\ ) (cons (parse_parens (rest paren_string))\
    \ (parse_parens_list (rest paren_string)))]\n      [else (parse_parens_list (rest\
    \ paren_string))]))\n  (parse_parens_list paren_string))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjqopkwau.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjqopkwau.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpjqopkwau.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (define (parse_parens paren_string)\n    (cond\n      [(empty?\
    \ paren_string) 0]\n      [(equal? (first paren_string) #\\()\n       (+ 1 (parse_parens\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) #\\))\n       (-\
    \ 1 (parse_parens (rest paren_string)))]\n      [else (parse_parens (rest paren_string))]))\n\
    \  (define (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(equal? (first paren_string) #\\ )\n       (cons (parse_parens\
    \ (rest paren_string)) (parse_parens_list (rest paren_string)))]\n      [else\
    \ (parse_parens_list (rest paren_string))]))\n  (parse_parens_list paren_string))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4giv5_62.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4giv5_62.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp4giv5_62.rkt:32:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (define (parse_parens paren_string)\n    (define (parse-parens-helper\
    \ paren_string level)\n      (cond ((null? paren_string) level)\n            ((char=?\
    \ (car paren_string) #\\()\n             (parse-parens-helper (cdr paren_string)\
    \ (+ level 1)))\n            ((char=? (car paren_string) #\\))\n             (parse-parens-helper\
    \ (cdr paren_string) (- level 1)))))\n    (parse-parens-helper paren_string 0))\n\
    \  (map parse_parens (string-split paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpd8k__w_g.rkt:24:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"(()())\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpd8k__w_g.rkt:25:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"()\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpd8k__w_g.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"(()(())((())))\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (paren_depth paren_group\
    \ 0))\n       (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp15hzshkg.rkt:10:10: paren_depth: unbound identifier\n  in: paren_depth\n\
    \  location...:\n   /tmp/tmp15hzshkg.rkt:10:10\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (paren_depth paren_group\
    \ 0))\n       (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpsz95a450.rkt:10:10: paren_depth: unbound identifier\n  in: paren_depth\n\
    \  location...:\n   /tmp/tmpsz95a450.rkt:10:10\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group) (parse_nested_parens_helper paren_group\
    \ 0)) (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpdi4loe1z.rkt:9:30: parse_nested_parens_helper: unbound identifier\n\
    \  in: parse_nested_parens_helper\n  location...:\n   /tmp/tmpdi4loe1z.rkt:9:30\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (define (parse_parens paren_string)\n    (define (parse_parens_helper\
    \ paren_string level)\n      (cond\n        [(empty? paren_string) level]\n  \
    \      [(char=? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ level 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- level 1))]\n        [else (parse_parens_helper (rest\
    \ paren_string) level)]))\n    (parse_parens_helper paren_string 0))\n  (define\
    \ (parse_nested_parens_helper paren_string result)\n    (cond\n      [(empty?\
    \ paren_string) result]\n      [(char=? (first paren_string) #\\ ) (parse_nested_parens_helper\
    \ (rest paren_string) result)]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) (append result (list (parse_parens paren_string))))]))\n  (parse_nested_parens_helper\
    \ paren_string '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv9is8_j_.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv9is8_j_.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpv9is8_j_.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (paren_group_max_depth\
    \ paren_group))\n       (string-split paren_string)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpboj7mbyp.rkt:10:10: paren_group_max_depth: unbound identifier\n\
    \  in: paren_group_max_depth\n  location...:\n   /tmp/tmpboj7mbyp.rkt:10:10\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (\u03BB (paren_group)\n         (let ([paren_group (string->list\
    \ paren_group)])\n           (let loop ([paren_group paren_group] [max_level 0]\
    \ [level 0])\n             (cond\n               [(empty? paren_group) max_level]\n\
    \               [(char=? (first paren_group) #\\()\n                (loop (rest\
    \ paren_group)\n                      (max max_level (add1 level))\n         \
    \             (add1 level))]\n               [(char=? (first paren_group) #\\\
    ))\n                (loop (rest paren_group)\n                      max_level\n\
    \                      (sub1 level))]\n               [else (loop (rest paren_group)\
    \ max_level level)]))))\n       (regexp-split #rx\" \" paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [nesting_level 0] [max_nesting_level 0])\n           (cond [(empty?\
    \ paren_group) max_nesting_level]\n                 [(equal? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group) (+ nesting_level 1) max_nesting_level)]\n\
    \                 [(equal? (first paren_group) #\\))\n                  (loop\
    \ (rest paren_group) (- nesting_level 1) (max nesting_level max_nesting_level))]\n\
    \                 [else (loop (rest paren_group) nesting_level max_nesting_level)])))\n\
    \       (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnsfds9tw.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpnsfds9tw.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnsfds9tw.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group) (paren_depth paren_group)) (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpxiin3ylm.rkt:9:30: paren_depth: unbound identifier\n  in: paren_depth\n\
    \  location...:\n   /tmp/tmpxiin3ylm.rkt:9:30\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_level 0] [current_level 0])\n           (cond [(empty? paren_group)\
    \ max_level]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group) max_level (+ current_level 1))]\n          \
    \       [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\
    \ (max max_level current_level) (- current_level 1))]\n                 [else\
    \ (loop (rest paren_group) max_level current_level)])))\n       (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfwucswb5.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfwucswb5.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfwucswb5.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (define (parens-helper paren_string)\n    (cond\n      [(empty?\
    \ paren_string) 0]\n      [(eq? (first paren_string) #\\() (add1 (parens-helper\
    \ (rest paren_string)))]\n      [(eq? (first paren_string) #\\)) (sub1 (parens-helper\
    \ (rest paren_string)))]\n      [else (parens-helper (rest paren_string))]))\n\
    \  (map (lambda (x) (parens-helper x)) (string-split paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ua9ucma.rkt:22:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7ua9ucma.rkt:23:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ua9ucma.rkt:24:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group) (parse_nested_parens_helper paren_group\
    \ 0)) (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpn5eh8p34.rkt:9:30: parse_nested_parens_helper: unbound identifier\n\
    \  in: parse_nested_parens_helper\n  location...:\n   /tmp/tmpn5eh8p34.rkt:9:30\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (paren_nesting_level paren_group\
    \ 0))\n       (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmppoh6xw8_.rkt:10:10: paren_nesting_level: unbound identifier\n \
    \ in: paren_nesting_level\n  location...:\n   /tmp/tmppoh6xw8_.rkt:10:10\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpxud0jurq.rkt:10:10: parse_nested_parens_helper: unbound identifier\n\
    \  in: parse_nested_parens_helper\n  location...:\n   /tmp/tmpxud0jurq.rkt:10:10\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
    (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
    \ paren_string)\n  (map (lambda (paren_group)\n         (paren_nesting_level paren_group))\n\
    \       (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmplym7pwjh.rkt:10:10: paren_nesting_level: unbound identifier\n \
    \ in: paren_nesting_level\n  location...:\n   /tmp/tmplym7pwjh.rkt:10:10\n"
  exit_code: 1
  status: Exception
