name: HumanEval_80_is_happy
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; Your task is to check if\
  \ the string is haprkt or not.\n;; A string is haprkt if its length is at least\
  \ 3 and every 3 consecutive letters are distinct\n;; For example:\n;; >>> (is_happy\
  \ a)\n;; #f\n;; >>> (is_happy aa)\n;; #f\n;; >>> (is_happy abcd)\n;; #t\n;; >>>\
  \ (is_happy aabb)\n;; #f\n;; >>> (is_happy adb)\n;; #t\n;; >>> (is_happy xyy)\n\
  ;; #f\n(define (is_happy s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n\
  \    (check-equal? (candidate \"a\") #f)\n    (check-equal? (candidate \"aa\") #f)\n\
  \    (check-equal? (candidate \"abcd\") #t)\n    (check-equal? (candidate \"aabb\"\
  ) #f)\n    (check-equal? (candidate \"adb\") #t)\n    (check-equal? (candidate \"\
  xyy\") #f)\n    (check-equal? (candidate \"iopaxpoi\") #t)\n    (check-equal? (candidate\
  \ \"iopaxioi\") #f)\n))\n\n(test-humaneval)"
completions: ["  (if (&lt; (string-length s) 3)\n      #f\n      (let ([s (string-&gt;list\
    \ s)])\n        (cond\n          [(equal? (list-ref s 0) (list-ref s 1)) #f]\n\
    \          [(equal? (list-ref s 0) (list-ref s 2)) #f]\n          [(equal? (list-ref\
    \ s 1) (list-ref s 2)) #f]\n          [else #t]))))\n</code>\n", "  (and (not\
    \ (empty? s))\n       (not (empty? (rest s)))\n       (not (empty? (rest (rest\
    \ s))))\n       (and (not (equal? (first s) (second s)))\n            (and (not\
    \ (equal? (first s) (third s)))\n                 (and (not (equal? (second s)\
    \ (third s)))\n                      (is_happy (rest (rest (rest s)))))))))\n",
  "  (and (&gt;= (string-length s) 3)\n       (for/and ([i (in-range 0 (- (string-length\
    \ s) 2))])\n         (not (equal? (string-ref s i) (string-ref s (+ i 2)))))))\n",
  "  (cond\n    [(string=? s \"\") #f]\n    [(string=? s \"a\") #f]\n    [(string=?\
    \ s \"aa\") #f]\n    [(string=? s \"aaa\") #t]\n    [(string=? s \"aaaa\") #f]\n\
    \    [(string=? s \"aaaaa\") #t]\n    [(string=? s \"aaaaaa\") #f]\n    [(string=?\
    \ s \"aaaaaaa\") #t]\n    [(string=? s \"aaaaaaaa\") #f]\n    [(string=? s \"\
    aaaaaaaaa\") #t]\n    [(string=? s \"aaaaaaaaaa\") #f]\n    [(string=? s \"aaaaaaaaaaa\"\
    ) #t]\n    [(string=? s \"aaaaaaaaaaaa\") #f]\n    [(string=? s \"aaaaaaaaaaaaa\"\
    ) #t]\n    [(string=? s \"aaaaaaaaaaaaaa\") #f]\n    [(string=? s \"aaaaaaaaaaaaaaa\"\
    ) #t]\n    [(string=? s \"aaaaaaaaaaaaaaaa\") #f]\n    [(string=? s \"aaaaaaaaaaaaaaaaa\"\
    ) #t]\n    [(string=? s \"aaaaaaaaaaaaaaaaaa\") #f]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaa\"\
    ) #t]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaaa\") #f]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaaaa\"\
    ) #t]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaaaaa\") #f]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaaaaaa\"\
    ) #t]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaaaaaaa\") #f]\n    [(string=? s \"\
    aaaaaaaaaaaaaaaaaaaaaaaaa\") #t]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    ) #f]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaaaaaaaaaa\") #t]\n    [(string=? s\
    \ \"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\") #f]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    ) #t]\n    [(string=? s \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") #f]\n    [(string=?\
    \ s \"", "  (if (&lt; (string-length s) 3)\n      #f\n      (let ((s (string-&gt;list\
    \ s)))\n        (define (is_happy-helper s)\n          (if (null? s)\n       \
    \       #t\n              (if (equal? (car s) (cadr s))\n                  #f\n\
    \                  (is_happy-helper (cdr s)))))\n        (is_happy-helper s))))\n\
    </code>\n", "  (cond\n    [(< (string-length s) 3) #f]\n    [(equal? (string-ref\
    \ s 0) (string-ref s 1)) #f]\n    [(equal? (string-ref s 1) (string-ref s 2))\
    \ #f]\n    [else #t]))\n", "  (cond\n    [(< (string-length s) 3) #f]\n    [(equal?\
    \ (string-ref s 0) (string-ref s 1)) #f]\n    [(equal? (string-ref s 1) (string-ref\
    \ s 2)) #f]\n    [else #t]))\n", "  (cond\n    [(< (string-length s) 3) #f]\n\
    \    [(equal? (string-ref s 0) (string-ref s 1)) #f]\n    [(equal? (string-ref\
    \ s 1) (string-ref s 2)) #f]\n    [else #t]))\n", "  (cond\n    [(< (string-length\
    \ s) 3) #f]\n    [(equal? (string-ref s 0) (string-ref s 1)) #f]\n    [(equal?\
    \ (string-ref s 1) (string-ref s 2)) #f]\n    [else #t]))\n", "  (cond\n    [(<\
    \ (string-length s) 3) #f]\n    [(equal? (string-ref s 0) (string-ref s 1)) #f]\n\
    \    [(equal? (string-ref s 1) (string-ref s 2)) #f]\n    [else #t]))\n", "  (if\
    \ (&lt; (string-length s) 3)\n      #f\n      (let ([s (string-&gt;list s)])\n\
    \        (for/and ([i (in-range 0 (- (length s) 2))])\n          (not (equal?\
    \ (list-ref s i) (list-ref s (+ i 1))))))))\n", "  (cond\n    [(< (string-length\
    \ s) 3) #f]\n    [(equal? (string-ref s 0) (string-ref s 1)) #f]\n    [(equal?\
    \ (string-ref s 1) (string-ref s 2)) #f]\n    [else #t]))\n", "  (cond\n    [(<\
    \ (string-length s) 3) #f]\n    [(not (equal? (string-ref s 0) (string-ref s 1)))\n\
    \     (is_happy (substring s 1))]\n    [(not (equal? (string-ref s 0) (string-ref\
    \ s 2)))\n     (is_happy (substring s 1))]\n    [else #f]))\n", "  (if (&lt; (string-length\
    \ s) 3)\n      #f\n      (let ([s (string-&gt;list s)])\n        (let loop ([s\
    \ s])\n          (if (null? s)\n              #t\n              (if (equal? (car\
    \ s) (cadr s))\n                  #f\n                  (loop (cdr s))))))))\n\
    </code>\n", "  (cond\n    [(< (string-length s) 3) #f]\n    [(equal? (string-ref\
    \ s 0) (string-ref s 1)) #f]\n    [(equal? (string-ref s 1) (string-ref s 2))\
    \ #f]\n    [else #t]))\n", "  (cond\n    [(< (string-length s) 3) #f]\n    [(equal?\
    \ (string-ref s 0) (string-ref s 1)) #f]\n    [(equal? (string-ref s 1) (string-ref\
    \ s 2)) #f]\n    [else #t]))\n", "  (cond\n    [(< (string-length s) 3) #f]\n\
    \    [(equal? (string-ref s 0) (string-ref s 1)) #f]\n    [(equal? (string-ref\
    \ s 1) (string-ref s 2)) #f]\n    [else #t]))\n", "  (cond\n    [(< (string-length\
    \ s) 3) #f]\n    [(equal? (string-ref s 0) (string-ref s 1)) #f]\n    [(equal?\
    \ (string-ref s 1) (string-ref s 2)) #f]\n    [else #t]))\n", "  (cond\n    [(<\
    \ (string-length s) 3) #f]\n    [(and (equal? (substring s 0 1) (substring s 1\
    \ 2))\n          (equal? (substring s 1 2) (substring s 2 3))) #f]\n    [else\
    \ #t]))\n", "  (if (&lt; (string-length s) 3)\n      #f\n      (let ([s (string-&gt;list\
    \ s)])\n        (for/and ([i (in-range 0 (- (length s) 2))])\n          (not (equal?\
    \ (list-ref s i) (list-ref s (+ i 1))))))))\n</code>\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
