name: HumanEval_161_solve
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter, reverse\
  \ its case from lower to upper or vise versa, \n;; otherwise keep it as it is.\n\
  ;; If the string contains no letters, reverse the string.\n;; The function should\
  \ return the resulted string.\n;; Examples\n;; >>> (solve \"1234\")\n;; \"4321\"\
  \n;; >>> (solve \"ab\")\n;; \"AB\"\n;; >>> (solve \"#a@C\")\n;; \"#A@c\"\n(define\
  \ (solve s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
  \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
  \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"\
  #aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
  \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\"\
  )\n))\n\n(test-humaneval)"
completions: ["  (if (string-contains-char? s #\\a)\n      (string-map (lambda (c)\
    \ (if (char-alphabetic? c)\n                                  (char-downcase c)\n\
    \                                  (char-upcase c))) s)\n      (string-reverse\
    \ s)))\n", "  (if (string-contains-letter? s)\n      (string-reverse-case s)\n\
    \      (string-reverse s)))\n", "  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic?\
    \ (string-ref s 0))\n     (string-append (string (char-upcase (string-ref s 0)))\n\
    \                    (solve (substring s 1)))]\n    [(char-numeric? (string-ref\
    \ s 0))\n     (string-append (string (char-downcase (string-ref s 0)))\n     \
    \               (solve (substring s 1)))]\n    [else (string-append (string (string-ref\
    \ s 0))\n                         (solve (substring s 1)))]))\n", "  (if (string-contains-letter?\
    \ s)\n      (string-reverse-case s)\n      (string-reverse s)))\n", "  (if (string-contains-letter?\
    \ s)\n      (reverse-case s)\n      (reverse s)))\n", "  (if (string-contains?\
    \ s #\\a)\n      (string-map (lambda (c)\n                    (if (char-alphabetic?\
    \ c)\n                        (char-upcase c)\n                        (char-downcase\
    \ c)))\n                  s)\n      (string-reverse s)))\n", "  (if (empty? s)\n\
    \      \"\"\n      (if (char-alphabetic? (string-ref s 0))\n          (string-append\
    \ (string-upcase (string-ref s 0)) (solve (substring s 1)))\n          (string-append\
    \ (string-downcase (string-ref s 0)) (solve (substring s 1))))))\n", "  (if (string-contains-char?\
    \ s #\\a)\n      (string-map (lambda (c)\n                    (if (char-alphabetic?\
    \ c)\n                        (char-upcase c)\n                        (char-downcase\
    \ c)))\n                  s)\n      (string-reverse s)))\n", "  (if (string-contains-letter?\
    \ s)\n      (reverse-case s)\n      (string-reverse s)))\n", "  (if (string-contains-letter?\
    \ s)\n      (string-reverse-case s)\n      (string-reverse s)))\n", "  (if (string-empty?\
    \ s)\n      \"\"\n      (let ([c (string-ref s 0)])\n        (cond\n         [(char-alphabetic?\
    \ c)\n          (string-append (string (char-upcase c)) (solve (substring s 1)))]\n\
    \         [else\n          (string-append (string (char-downcase c)) (solve (substring\
    \ s 1)))]))))\n", "  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref\
    \ s 0))\n     (string-append (string-upcase (string-ref s 0))\n              \
    \      (solve (substring s 1)))]\n    [(char-numeric? (string-ref s 0))\n    \
    \ (string-append (string-ref s 0)\n                    (solve (substring s 1)))]\n\
    \    [else\n     (string-append (string-downcase (string-ref s 0))\n         \
    \           (solve (substring s 1)))]))\n", "  (if (string-contains? s #\\a)\n\
    \      (string-map (lambda (c)\n                    (if (char-alphabetic? c)\n\
    \                        (char-upcase c)\n                        (char-downcase\
    \ c)))\n                  s)\n      (string-reverse s)))\n", "  (if (string-contains-any?\
    \ s (string->list \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n\
    \      (string-join (map (lambda (c) (if (char-alphabetic? c) (char-upcase c)\
    \ (char-downcase c))) (string->list s)))\n      (string-reverse s)))\n", "  (cond\n\
    \    [(empty? s) '()]\n    [(char-alphabetic? (car s))\n     (cons (char-upcase\
    \ (car s)) (solve (cdr s)))]\n    [(char-numeric? (car s))\n     (cons (car s)\
    \ (solve (cdr s)))]\n    [else\n     (cons (char-downcase (car s)) (solve (cdr\
    \ s)))]))\n", "  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref\
    \ s 0))\n     (string-append\n      (string (char-upcase (string-ref s 0)))\n\
    \      (solve (substring s 1)))]\n    [(char-numeric? (string-ref s 0))\n    \
    \ (string-append\n      (string (char-downcase (string-ref s 0)))\n      (solve\
    \ (substring s 1)))]\n    [else (string-append (string (string-ref s 0)) (solve\
    \ (substring s 1)))]))\n", "  (cond\n    [(empty? s) s]\n    [(char-alphabetic?\
    \ (string-ref s 0))\n     (string-append (string (char-upcase (string-ref s 0)))\n\
    \                    (solve (substring s 1)))]\n    [(char-numeric? (string-ref\
    \ s 0))\n     (string-append (string (char-downcase (string-ref s 0)))\n     \
    \               (solve (substring s 1)))]\n    [else (string-append (string (string-ref\
    \ s 0))\n                         (solve (substring s 1)))]))\n", "  (cond\n \
    \   [(empty? s) s]\n    [(char-alphabetic? (first s))\n     (string-append (string-upcase\
    \ (first s)) (solve (rest s)))]\n    [(char-numeric? (first s))\n     (string-append\
    \ (first s) (solve (rest s)))]\n    [else\n     (string-append (string-downcase\
    \ (first s)) (solve (rest s)))]))\n", "  (if (string-contains-letter? s)\n   \
    \   (string-reverse-case s)\n      (string-reverse s)))\n", "  (cond\n    [(empty?\
    \ s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append (string-upcase\
    \ (first s)) (solve (rest s)))]\n    [(char-numeric? (first s))\n     (string-append\
    \ (first s) (solve (rest s)))]\n    [else\n     (string-append (string-downcase\
    \ (first s)) (solve (rest s)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
