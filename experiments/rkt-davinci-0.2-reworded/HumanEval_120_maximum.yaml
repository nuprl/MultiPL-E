name: HumanEval_120_maximum
language: rkt
prompt: "#lang racket\n\n;; Given a list arr of integers and a positive integer k,\
  \ return a sorted list \n;; of length k with the maximum k numbers in arr.\n;; Example\
  \ 1:\n;; >>> (maximum (list -3 -4 5) 3)\n;; (list -4 -3 5)\n;; Example 2:\n;; >>>\
  \ (maximum (list 4 -4 4) 2)\n;; (list 4 4)\n;; Example 3:\n;; >>> (maximum (list\
  \ -3 2 1 2 -1 -2 1) 1)\n;; (list 2)\n;; Note:\n;; 1. The length of the list will\
  \ be in the range of [1, 1000].\n;; 2. The elements in the list will be in the range\
  \ of [-1000, 1000].\n;; 3. 0 <= k <= len(arr)\n(define (maximum arr k)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n\
  \    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))\n    (check-equal?\
  \ (candidate (list 4 -4 4) 2) (list 4 4))\n    (check-equal? (candidate (list -3\
  \ 2 1 2 -1 -2 1) 1) (list 2))\n    (check-equal? (candidate (list 123 -123 20 0\
  \ 1 2 -3) 3) (list 2 20 123))\n    (check-equal? (candidate (list -123 20 0 1 2\
  \ -3) 4) (list 0 1 2 20))\n    (check-equal? (candidate (list 5 15 0 3 -13 -8 0)\
  \ 7) (list -13 -8 0 0 3 5 15))\n    (check-equal? (candidate (list -1 0 2 5 3 -10)\
  \ 2) (list 3 5))\n    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))\n  \
  \  (check-equal? (candidate (list 4 -4) 2) (list -4 4))\n    (check-equal? (candidate\
  \ (list -10 10) 2) (list -10 10))\n    (check-equal? (candidate (list 1 2 3 -23\
  \ 243 -400 0) 0) (list ))\n))\n\n(test-humaneval)"
completions: ["  (let loop ((arr arr)\n             (k k)\n             (max-list\
    \ (list)))\n    (if (or (null? arr)\n            (= k 0))\n        max-list\n\
    \        (let ((max (apply max arr)))\n          (loop (remove max arr)\n    \
    \            (- k 1)\n                (cons max max-list))))))\n", "  (sort arr\
    \ < (sublist arr 0 k)))\n", "  (sort (list-ref arr (sub1 k)) > (list-ref arr (sub1\
    \ k))))\n", "  (sort arr < (take k (sort arr >))))\n", "  (sort arr >))\n", " \
    \ (sort arr (lambda (x y) (&lt; x y))))\n</code>\n", "  (sort arr (lambda (x y)\
    \ (< x y))))\n", "  (sort arr >))\n", "  (sort arr (lambda (x y) (< x y))))\n",
  "  (sort arr > (take arr k)))\n", "  (sort arr (lambda (x y) (< x y))))\n", "  (sort\
    \ arr <))\n", "  (sort arr (lambda (x y) (&lt; y x))))\n</code>\n", "  (sort arr\
    \ < k))\n", "  (sort arr (lambda (a b) (> a b))))\n", "  (sort arr (lambda (a\
    \ b) (> a b))))\n", "  (sort arr (lambda (x y) (< x y))))\n", "  (sort arr (lambda\
    \ (x y) (< x y))))\n", "  (let loop ((arr arr)\n             (k k)\n         \
    \    (res '()))\n    (if (or (null? arr)\n            (= k 0))\n        (reverse\
    \ res)\n        (loop (remove (apply max arr) arr)\n              (- k 1)\n  \
    \            (cons (apply max arr) res)))))\n", "  (sort arr (lambda (x y) (<\
    \ x y))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
