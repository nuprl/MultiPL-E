name: HumanEval_6_parse_nested_parens
language: rkt
prompt: "#lang racket\n\n;; Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
  \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
  \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
  (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
  \ paren_string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
  \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
  \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n   \
  \ (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
completions: ["  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group]\
    \ [max_depth 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group)\n                        (if (> current_depth max_depth)\n\
    \                            (+ current_depth 1)\n                           \
    \ max_depth)\n                        (+ current_depth 1))]\n                \
    \ [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\n\
    \                        max_depth\n                        (- current_depth 1))]\n\
    \                 [else (loop (rest paren_group) max_depth current_depth)])))\n\
    \       (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count 0])\n\
    \      (cond\n        [(empty? paren_string) max_paren_count]\n        [(char=?\
    \ (first paren_string) #\\()\n         (loop (rest paren_string) (+ paren_count\
    \ 1) (max paren_count max_paren_count))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (loop (rest paren_string) (- paren_count 1) (max paren_count\
    \ max_paren_count))]\n        [else (loop (rest paren_string) paren_count max_paren_count)])))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (paren_group_max_depth paren_group))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (define (parse_parens_helper\
    \ paren_string depth)\n      (cond\n        [(empty? paren_string) depth]\n  \
    \      [(char=? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ depth 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- depth 1))]\n        [else (parse_parens_helper (rest\
    \ paren_string) depth)]))\n    (parse_parens_helper paren_string 0))\n  (define\
    \ (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string) '()]\n\
    \      [(char=? (first paren_string) #\\ ) (cons (parse_parens (rest paren_string))\
    \ (parse_parens_list (rest paren_string)))]\n      [else (parse_parens_list (rest\
    \ paren_string))]))\n  (parse_parens_list paren_string))\n", "  (define (parse_parens\
    \ paren_string)\n    (cond\n      [(empty? paren_string) 0]\n      [(equal? (first\
    \ paren_string) #\\()\n       (+ 1 (parse_parens (rest paren_string)))]\n    \
    \  [(equal? (first paren_string) #\\))\n       (- 1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (define (parse_parens_list\
    \ paren_string)\n    (cond\n      [(empty? paren_string) empty]\n      [(equal?\
    \ (first paren_string) #\\ )\n       (cons (parse_parens (rest paren_string))\
    \ (parse_parens_list (rest paren_string)))]\n      [else (parse_parens_list (rest\
    \ paren_string))]))\n  (parse_parens_list paren_string))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse-parens-helper paren_string level)\n      (cond\
    \ ((null? paren_string) level)\n            ((char=? (car paren_string) #\\()\n\
    \             (parse-parens-helper (cdr paren_string) (+ level 1)))\n        \
    \    ((char=? (car paren_string) #\\))\n             (parse-parens-helper (cdr\
    \ paren_string) (- level 1)))))\n    (parse-parens-helper paren_string 0))\n \
    \ (map parse_parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper\
    \ paren_group 0)) (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse_parens_helper paren_string level)\n      (cond\n        [(empty?\
    \ paren_string) level]\n        [(char=? (first paren_string) #\\() (parse_parens_helper\
    \ (rest paren_string) (+ level 1))]\n        [(char=? (first paren_string) #\\\
    )) (parse_parens_helper (rest paren_string) (- level 1))]\n        [else (parse_parens_helper\
    \ (rest paren_string) level)]))\n    (parse_parens_helper paren_string 0))\n \
    \ (define (parse_nested_parens_helper paren_string result)\n    (cond\n      [(empty?\
    \ paren_string) result]\n      [(char=? (first paren_string) #\\ ) (parse_nested_parens_helper\
    \ (rest paren_string) result)]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) (append result (list (parse_parens paren_string))))]))\n  (parse_nested_parens_helper\
    \ paren_string '()))\n", "  (map (lambda (paren_group)\n         (paren_group_max_depth\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (\u03BB (paren_group)\n\
    \         (let ([paren_group (string->list paren_group)])\n           (let loop\
    \ ([paren_group paren_group] [max_level 0] [level 0])\n             (cond\n  \
    \             [(empty? paren_group) max_level]\n               [(char=? (first\
    \ paren_group) #\\()\n                (loop (rest paren_group)\n             \
    \         (max max_level (add1 level))\n                      (add1 level))]\n\
    \               [(char=? (first paren_group) #\\))\n                (loop (rest\
    \ paren_group)\n                      max_level\n                      (sub1 level))]\n\
    \               [else (loop (rest paren_group) max_level level)]))))\n       (regexp-split\
    \ #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop\
    \ ([paren_group paren_group] [nesting_level 0] [max_nesting_level 0])\n      \
    \     (cond [(empty? paren_group) max_nesting_level]\n                 [(equal?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group) (+ nesting_level\
    \ 1) max_nesting_level)]\n                 [(equal? (first paren_group) #\\))\n\
    \                  (loop (rest paren_group) (- nesting_level 1) (max nesting_level\
    \ max_nesting_level))]\n                 [else (loop (rest paren_group) nesting_level\
    \ max_nesting_level)])))\n       (string-split paren_string)))\n", "  (map (lambda\
    \ (paren_group) (paren_depth paren_group)) (string-split paren_string)))\n", " \
    \ (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [current_level 0])\n           (cond [(empty? paren_group) max_level]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_level (+ current_level 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_level\
    \ current_level) (- current_level 1))]\n                 [else (loop (rest paren_group)\
    \ max_level current_level)])))\n       (string-split paren_string)))\n", "  (define\
    \ (parens-helper paren_string)\n    (cond\n      [(empty? paren_string) 0]\n \
    \     [(eq? (first paren_string) #\\() (add1 (parens-helper (rest paren_string)))]\n\
    \      [(eq? (first paren_string) #\\)) (sub1 (parens-helper (rest paren_string)))]\n\
    \      [else (parens-helper (rest paren_string))]))\n  (map (lambda (x) (parens-helper\
    \ x)) (string-split paren_string)))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper\
    \ paren_group 0)) (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [count 0] [max_count 0])\n      (cond\n        [(empty? paren_string) (list\
    \ max_count)]\n        [(char=? (first paren_string) #\\()\n         (loop (rest\
    \ paren_string) (+ count 1) (if (> count max_count) count max_count))]\n     \
    \   [(char=? (first paren_string) #\\))\n         (loop (rest paren_string) (-\
    \ count 1) max_count)]\n        [else (loop (rest paren_string) count max_count)])))\n\
    \  (map parse_parens (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse_parens_iter paren_string max_level level)\n\
    \      (cond ((empty? paren_string) (list max_level level))\n            ((char=?\
    \ (first paren_string) #\\() (parse_parens_iter (rest paren_string) (max max_level\
    \ (add1 level)) (add1 level)))\n            ((char=? (first paren_string) #\\\
    )) (parse_parens_iter (rest paren_string) max_level (sub1 level)))\n         \
    \   (else (parse_parens_iter (rest paren_string) max_level level))))\n    (parse_parens_iter\
    \ paren_string 0 0))\n  (define (parse_parens_iter paren_string max_levels)\n\
    \    (cond ((empty? paren_string) max_levels)\n          ((char=? (first paren_string)\
    \ #\\ ) (parse_parens_iter (rest paren_string) max_levels))\n          (else (parse_parens_iter\
    \ (rest paren_string) (append max_levels (list (first (parse_parens paren_string))))))))\n\
    \  (parse_parens_iter paren_string '()))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse_parens_iter paren_string paren_count max_paren_count)\n  \
    \    (cond\n        [(empty? paren_string) (list paren_count max_paren_count)]\n\
    \        [(equal? (first paren_string) #\\() (parse_parens_iter (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n        [(equal? (first\
    \ paren_string) #\\)) (parse_parens_iter (rest paren_string) (- paren_count 1)\
    \ (max paren_count max_paren_count))]\n        [else (parse_parens_iter (rest\
    \ paren_string) paren_count max_paren_count)]))\n    (parse_parens_iter paren_string\
    \ 0 0))\n  (define (parse_parens_iter paren_string paren_count max_paren_count)\n\
    \    (cond\n      [(empty? paren_string) (list paren_count max_paren_count)]\n\
    \      [(equal? (first paren_string) #\\() (parse_parens_iter (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n      [(equal? (first\
    \ paren_string) #\\)) (parse_parens_iter (rest paren_string) (- paren_count 1)\
    \ (max paren_count max_paren_count))]\n      [else (parse_parens_iter (rest paren_string)\
    \ paren_count max_paren_count)]))\n  (define (parse_parens_iter_2 paren_string)\n\
    \    (cond\n      [(empty? paren_string) '()]\n      [(equal? (first paren_string)\
    \ #\\ ) (cons (parse_parens (rest paren_string)) (parse_parens_iter_2 (rest paren_string)))]\n\
    \      [else (parse_parens_iter_2 (rest paren_string))]))\n  (parse_parens_iter_2\
    \ paren_string))\n", "  (map (lambda (paren_group)\n         (length (parse_nested_parens_helper\
    \ paren_group)))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let ([paren_stack '()])\n           (for ([paren (in-string paren_group)])\n\
    \             (cond\n               [(equal? paren \"(\") (push paren paren_stack)]\n\
    \               [(equal? paren \")\") (pop paren_stack)]\n               [else\
    \ (error \"Invalid character\")]))\n           (length paren_stack)))\n      \
    \ (regexp-split #rx\" \" paren_string)))\n```\n\n## Problem 2\n\n```racket\n#lang\
    \ racket\n", "  (let ([paren_list (string-&gt;list paren_string)])\n    (define\
    \ (parse_parens paren_list)\n      (cond\n        [(empty? paren_list) 0]\n  \
    \      [(equal? (first paren_list) #\\()\n         (add1 (parse_parens (rest paren_list)))]\n\
    \        [(equal? (first paren_list) #\\))\n         (parse_parens (rest paren_list))]\n\
    \        [else (parse_parens (rest paren_list))]))\n    (map parse_parens (string-&gt;list\
    \ paren_string))))\n</code>\nI am getting the following error:\n<code>parse_nested_parens:\
    \ expects argument of type &lt;string&gt;; given #&lt;procedure:parse_parens&gt;\n\
    </code>\nI am not sure what I am doing wrong.\n\n\nA:\n\nYou're calling <code>map</code>\
    \ with a procedure and a list of characters. You probably want to call it with\
    \ a procedure and a list of strings.\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count 0])\n\
    \      (cond [(empty? paren_string) (list paren_count max_paren_count)]\n    \
    \        [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ paren_count 1) max_paren_count)]\n            [(char=? (first paren_string)\
    \ #\\))\n             (loop (rest paren_string) (- paren_count 1) (max paren_count\
    \ max_paren_count))]\n            [else (loop (rest paren_string) paren_count\
    \ max_paren_count)])))\n  (define (parse_paren_groups paren_string)\n    (let\
    \ loop ([paren_string paren_string] [paren_groups '()])\n      (cond [(empty?\
    \ paren_string) (reverse paren_groups)]\n            [(char=? (first paren_string)\
    \ #\\ )\n             (loop (rest paren_string) paren_groups)]\n            [else\
    \ (loop (rest paren_string) (cons (parse_parens (first paren_string)) paren_groups))])))\n\
    \  (map second (parse_paren_groups paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse_parens_helper paren_string current_level max_level)\n\
    \      (cond\n        [(empty? paren_string) max_level]\n        [(equal? (first\
    \ paren_string) #\\()\n         (parse_parens_helper (rest paren_string) (+ current_level\
    \ 1) (max current_level max_level))]\n        [(equal? (first paren_string) #\\\
    ))\n         (parse_parens_helper (rest paren_string) (- current_level 1) (max\
    \ current_level max_level))]\n        [else (parse_parens_helper (rest paren_string)\
    \ current_level max_level)]))\n    (parse_parens_helper paren_string 0 0))\n \
    \ (define (parse_nested_parens_helper paren_string result)\n    (cond\n      [(empty?\
    \ paren_string) result]\n      [else (parse_nested_parens_helper (rest paren_string)\
    \ (append result (list (parse_parens (first paren_string)))))]))\n  (parse_nested_parens_helper\
    \ (string-split paren_string) '()))\n", "  (map (lambda (paren_group)\n      \
    \   (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group) (paren_depth paren_group))\
    \ (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n \
    \   (define (parse_parens_helper paren_string level)\n      (cond\n        [(empty?\
    \ paren_string) level]\n        [(equal? (first paren_string) #\\() (parse_parens_helper\
    \ (rest paren_string) (+ level 1))]\n        [(equal? (first paren_string) #\\\
    )) (parse_parens_helper (rest paren_string) (- level 1))]\n        [else (parse_parens_helper\
    \ (rest paren_string) level)]))\n    (parse_parens_helper paren_string 0))\n \
    \ (define (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string)\
    \ '()]\n      [(equal? (first paren_string) #\\ ) (cons (parse_parens (rest paren_string))\
    \ (parse_parens_list (rest paren_string)))]\n      [else (parse_parens_list (rest\
    \ paren_string))]))\n  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_max_nesting paren_group))\n       (paren_string_to_list\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond\n    \
    \  [(empty? paren_string) 0]\n      [(equal? (first paren_string) #\\() (add1\
    \ (parse_parens (rest paren_string)))]\n      [(equal? (first paren_string) #\\\
    )) (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond ((null? paren_string) 0)\n   \
    \       ((equal? (car paren_string) \"(\") (+ 1 (parse_parens (cdr paren_string))))\n\
    \          ((equal? (car paren_string) \")\") (- 1 (parse_parens (cdr paren_string))))\n\
    \          (else (parse_parens (cdr paren_string)))))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond\n    \
    \  [(empty? paren_string) 0]\n      [(equal? (first paren_string) #\\() (+ 1 (parse_parens\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) #\\)) (- 1 (parse_parens\
    \ (rest paren_string)))]\n      [else (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse_parens_helper paren_string level)\n      (cond\
    \ ((null? paren_string) level)\n            ((equal? (car paren_string) \"(\"\
    ) (parse_parens_helper (cdr paren_string) (+ level 1)))\n            ((equal?\
    \ (car paren_string) \")\") (parse_parens_helper (cdr paren_string) (- level 1)))))\n\
    \    (parse_parens_helper paren_string 0))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_nesting_level\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count\
    \ 0])\n      (cond [(empty? paren_string) (list paren_count max_paren_count)]\n\
    \            [(equal? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n            [(equal?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- paren_count\
    \ 1) (max paren_count max_paren_count))]\n            [else (loop (rest paren_string)\
    \ paren_count max_paren_count)])))\n  (define (parse_paren_groups paren_string)\n\
    \    (let loop ([paren_string paren_string] [paren_groups '()])\n      (cond [(empty?\
    \ paren_string) (reverse paren_groups)]\n            [(equal? (first paren_string)\
    \ #\\ )\n             (loop (rest paren_string) paren_groups)]\n            [else\
    \ (let ([paren_group (string-take paren_string (string-index paren_string #\\\
    \ ))])\n                    (loop (string-drop paren_string (string-length paren_group))\n\
    \                          (cons (parse_parens paren_group) paren_groups)))])))\n\
    \  (map second (parse_paren_groups paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (group) (parse_nested_parens_helper group 0)) (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parens-helper paren_string\
    \ count)\n      (cond ((null? paren_string) count)\n            ((equal? (car\
    \ paren_string) \"(\") (parens-helper (cdr paren_string) (+ count 1)))\n     \
    \       ((equal? (car paren_string) \")\") (parens-helper (cdr paren_string) (-\
    \ count 1)))))\n    (parens-helper paren_string 0))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse-parens-helper paren_string acc)\n      (cond\n\
    \        [(empty? paren_string) acc]\n        [(equal? (first paren_string) #\\\
    () (parse-parens-helper (rest paren_string) (+ acc 1))]\n        [(equal? (first\
    \ paren_string) #\\)) (parse-parens-helper (rest paren_string) (- acc 1))]\n \
    \       [else (parse-parens-helper (rest paren_string) acc)]))\n    (parse-parens-helper\
    \ paren_string 0))\n  (define (parse-parens-list paren_string acc)\n    (cond\n\
    \      [(empty? paren_string) (reverse acc)]\n      [(equal? (first paren_string)\
    \ #\\ ) (parse-parens-list (rest paren_string) acc)]\n      [else (parse-parens-list\
    \ (rest paren_string) (cons (parse_parens paren_string) acc))]))\n  (parse-parens-list\
    \ paren_string '()))\n", "  (map (lambda (paren_group)\n         (paren_depth\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (max-depth paren_group 0 0))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond ((empty?\
    \ paren_string) 0)\n          ((eq? (first paren_string) #\\() (+ 1 (parse_parens\
    \ (rest paren_string))))\n          ((eq? (first paren_string) #\\)) (- 1 (parse_parens\
    \ (rest paren_string))))))\n  (map parse_parens (string-split paren_string #\\\
    space)))\n", "  (define (parse_parens paren_string)\n    (cond\n      [(empty?\
    \ paren_string) 0]\n      [(equal? (first paren_string) #\\() (add1 (parse_parens\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) #\\)) (sub1 (parse_parens\
    \ (rest paren_string)))]\n      [else (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (length (regexp-match #rx\"\\(\\(+\\)\" paren_group)))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (define (paren_level paren_string)\n\
    \    (let loop ([paren_string paren_string] [level 0])\n      (cond [(empty? paren_string)\
    \ level]\n            [(eq? (first paren_string) #\\() (loop (rest paren_string)\
    \ (+ level 1))]\n            [(eq? (first paren_string) #\\)) (loop (rest paren_string)\
    \ (- level 1))]\n            [else (loop (rest paren_string) level)])))\n  (map\
    \ paren_level (regexp-split #rx\" \" paren_string)))\n", "  (list-of-lists-to-list\
    \ (map (lambda (paren_group) (parse_nested_parens_helper paren_group)) (string-&gt;list-of-lists\
    \ paren_string))))\n", "  (define (parse-parens paren-string)\n    (define (parse-parens-iter\
    \ paren-string depth max-depth)\n      (cond ((null? paren-string) max-depth)\n\
    \            ((char=? (car paren-string) #\\()\n             (parse-parens-iter\
    \ (cdr paren-string) (+ depth 1) (max depth max-depth)))\n            ((char=?\
    \ (car paren-string) #\\))\n             (parse-parens-iter (cdr paren-string)\
    \ (- depth 1) (max depth max-depth)))\n            (else (parse-parens-iter (cdr\
    \ paren-string) depth max-depth))))\n    (parse-parens-iter paren-string 0 0))\n\
    \  (map parse-parens (string-split paren-string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_nesting_level paren_group))\n   \
    \    (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (cond\n      [(empty? paren_string) 0]\n      [(string=? (first paren_string)\
    \ \"(\") (+ 1 (parse_parens (rest paren_string)))]\n      [(string=? (first paren_string)\
    \ \")\") (- 1 (parse_parens (rest paren_string)))]\n      [else (parse_parens\
    \ (rest paren_string))]))\n  (map parse_parens (string-split paren_string \" \"\
    )))\n", "  (map (lambda (paren_group)\n         (paren_group_max_depth paren_group))\n\
    \       (string-split paren_string)))\n", "  (define (parse-parens paren-string)\n\
    \    (let loop ([paren-string paren-string] [paren-count 0] [max-paren-count 0])\n\
    \      (cond\n        [(empty? paren-string) (list paren-count max-paren-count)]\n\
    \        [(char=? (first paren-string) #\\()\n         (loop (rest paren-string)\
    \ (+ paren-count 1) (max paren-count max-paren-count))]\n        [(char=? (first\
    \ paren-string) #\\))\n         (loop (rest paren-string) (- paren-count 1) (max\
    \ paren-count max-paren-count))]\n        [else (loop (rest paren-string) paren-count\
    \ max-paren-count)])))\n  (map (lambda (paren-string) (first (parse-parens paren-string)))\
    \ (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n \
    \   (let loop ([paren_string paren_string] [count 0] [max_count 0])\n      (cond\
    \ [(empty? paren_string) (list max_count)]\n            [(char=? (first paren_string)\
    \ #\\()\n             (loop (rest paren_string) (+ count 1) (if (> count max_count)\
    \ count max_count))]\n            [(char=? (first paren_string) #\\))\n      \
    \       (loop (rest paren_string) (- count 1) max_count)]\n            [else (loop\
    \ (rest paren_string) count max_count)])))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (let loop\
    \ ([paren_group paren_group] [count 0] [max_count 0])\n           (cond [(empty?\
    \ paren_group) max_count]\n                 [(char=? (first paren_group) #\\()\n\
    \                  (loop (rest paren_group) (+ count 1) max_count)]\n        \
    \         [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\
    \ (- count 1) (max max_count count))]\n                 [else (loop (rest paren_group)\
    \ count max_count)])))\n       (string-split paren_string #\\space)))\n", "  (map\
    \ (lambda (paren_group)\n         (paren_depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [max_depth 0] [curr_depth 0])\n      (cond\n        [(empty? paren_string)\
    \ (list max_depth curr_depth)]\n        [(char=? (first paren_string) #\\()\n\
    \         (loop (rest paren_string)\n               (if (> (+ curr_depth 1) max_depth)\n\
    \                   (+ curr_depth 1)\n                   max_depth)\n        \
    \       (+ curr_depth 1))]\n        [(char=? (first paren_string) #\\))\n    \
    \     (loop (rest paren_string)\n               max_depth\n               (- curr_depth\
    \ 1))]\n        [else (loop (rest paren_string) max_depth curr_depth)])))\n  (define\
    \ (parse_paren_groups paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_groups '()])\n      (cond\n        [(empty? paren_string) (reverse paren_groups)]\n\
    \        [(char=? (first paren_string) #\\ )\n         (loop (rest paren_string)\
    \ paren_groups)]\n        [else (let ([paren_group (string-take paren_string (string-index\
    \ paren_string #\\ ))])\n                (loop (string-drop paren_string (string-length\
    \ paren_group))\n                      (cons paren_group paren_groups)))])))\n\
    \  (map (lambda (paren_group) (first (parse_parens paren_group)))\n       (parse_paren_groups\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [paren_stack '()] [max_depth 0])\n      (cond [(empty? paren_string)\
    \ (values (reverse paren_stack) max_depth)]\n            [(char=? (first paren_string)\
    \ #\\()\n             (loop (rest paren_string) (cons (first paren_string) paren_stack)\
    \ (add1 max_depth))]\n            [(char=? (first paren_string) #\\))\n      \
    \       (loop (rest paren_string) (rest paren_stack) max_depth)]\n           \
    \ [else (loop (rest paren_string) paren_stack max_depth)])))\n  (let loop ([paren_string\
    \ paren_string] [paren_stack '()] [max_depth 0] [result '()])\n    (cond [(empty?\
    \ paren_string) (reverse result)]\n          [(char=? (first paren_string) #\\\
    ()\n           (loop (rest paren_string) (cons (first paren_string) paren_stack)\
    \ (add1 max_depth) result)]\n          [(char=? (first paren_string) #\\))\n \
    \          (loop (rest paren_string) (rest paren_stack) max_depth result)]\n \
    \         [(char=? (first paren_string) #\\space)\n           (let-values ([(paren_stack\
    \ max_depth) (parse_parens paren_string)])\n             (loop (rest paren_string)\
    \ paren_stack max_depth (cons max_depth result)))]\n          [else (loop (rest\
    \ paren_string) paren_stack max_depth result)])))\n", "  (map (lambda (paren_group)\
    \ (parse_nested_parens_helper paren_group 0)) (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let ((paren_stack '()))\n           (for\
    \ ([char (in-string paren_group)])\n             (cond\n               [(equal?\
    \ char #\\() (push 1 paren_stack)]\n               [(equal? char #\\)) (pop paren_stack)]))\n\
    \           (length paren_stack)))\n       (regexp-split #rx\" \" paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_count 0] [max_paren_count 0])\n      (cond [(empty? paren_string) max_paren_count]\n\
    \            [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- paren_count\
    \ 1) max_paren_count)]\n            [else (loop (rest paren_string) paren_count\
    \ max_paren_count)])))\n  (map parse_parens (string-split paren_string #\\space)))\n",
  "  (map (lambda (paren_group)\n         (paren_nesting_level paren_group))\n   \
    \    (string-split paren_string)))\n", "  (define (parse-parens-helper paren_string\
    \ current_level max_level)\n    (cond\n      [(empty? paren_string) max_level]\n\
    \      [(char=? (first paren_string) #\\() (parse-parens-helper (rest paren_string)\
    \ (+ current_level 1) (max current_level max_level))]\n      [(char=? (first paren_string)\
    \ #\\)) (parse-parens-helper (rest paren_string) (- current_level 1) (max current_level\
    \ max_level))]\n      [else (parse-parens-helper (rest paren_string) current_level\
    \ max_level)]))\n  (map (lambda (paren_group) (parse-parens-helper paren_group\
    \ 0 0)) (string-split paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n\
    \    (cond ((null? paren_string) 0)\n          ((eq? (car paren_string) #\\()\n\
    \           (+ 1 (parse_parens (cdr paren_string))))\n          ((eq? (car paren_string)\
    \ #\\))\n           (parse_parens (cdr paren_string)))\n          (else (parse_parens\
    \ (cdr paren_string)))))\n  (map parse_parens (string-split paren_string #\\space)))\n",
  "  (map (\u03BB (paren_group) (count_parens paren_group)) (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group) (parse_nested_parens_helper paren_group 0)) (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_nesting_level\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [level 0] [max_level 0])\n    \
    \       (cond [(empty? paren_group) max_level]\n                 [(char=? (first\
    \ paren_group) #\\()\n                  (loop (rest paren_group) (+ level 1) max_level)]\n\
    \                 [(char=? (first paren_group) #\\))\n                  (loop\
    \ (rest paren_group) (- level 1) (max max_level level))]\n                 [else\
    \ (loop (rest paren_group) level max_level)])))\n       (regexp-split #rx\" \"\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let ([paren_group (string-&gt;list paren_group)])\n           (let\
    \ loop ([paren_group paren_group] [level 0] [max_level 0])\n             (cond\n\
    \               [(null? paren_group) max_level]\n               [(equal? (car\
    \ paren_group) #\\()\n                (loop (cdr paren_group) (+ level 1) (max\
    \ level max_level))]\n               [(equal? (car paren_group) #\\))\n      \
    \          (loop (cdr paren_group) (- level 1) (max level max_level))]\n     \
    \          [else (loop (cdr paren_group) level max_level)]))))\n       (string-split\
    \ paren_string #\\space)))\n</code>\n", "  (map (lambda (x) (length (regexp-match\
    \ #rx\"\\(+\" x)))\n       (string-split paren_string #rx\" \")))\n", "  (map\
    \ (lambda (paren_group)\n         (parse_nested_parens_helper paren_group 0))\n\
    \       (string-split paren_string \" \")))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [max_depth 0] [current_depth 0])\n\
    \      (cond [(empty? paren_string) max_depth]\n            [(char=? (first paren_string)\
    \ #\\()\n             (loop (rest paren_string)\n                   (if (> current_depth\
    \ max_depth)\n                       (+ current_depth 1)\n                   \
    \    max_depth)\n                   (+ current_depth 1))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string)\n       \
    \            max_depth\n                   (- current_depth 1))]\n           \
    \ [else (loop (rest paren_string)\n                        max_depth\n       \
    \                 current_depth)])))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [max_depth 0] [current_depth 0])\n      (cond\n        [(empty?\
    \ paren_string) max_depth]\n        [(char=? (first paren_string) #\\()\n    \
    \     (loop (rest paren_string)\n               (if (> (+ current_depth 1) max_depth)\n\
    \                   (+ current_depth 1)\n                   max_depth)\n     \
    \          (+ current_depth 1))]\n        [(char=? (first paren_string) #\\))\n\
    \         (loop (rest paren_string)\n               max_depth\n              \
    \ (- current_depth 1))]\n        [else (loop (rest paren_string) max_depth current_depth)])))\n\
    \  (map parse_parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [max_nesting 0] [current_nesting\
    \ 0])\n           (cond [(empty? paren_group) max_nesting]\n                 [(equal?\
    \ (first paren_group) \"(\")\n                  (loop (rest paren_group)\n   \
    \                     (if (> current_nesting max_nesting)\n                  \
    \          (+ current_nesting 1)\n                            max_nesting)\n \
    \                       (+ current_nesting 1))]\n                 [(equal? (first\
    \ paren_group) \")\")\n                  (loop (rest paren_group)\n          \
    \              max_nesting\n                        (- current_nesting 1))]\n\
    \                 [else (loop (rest paren_group)\n                           \
    \  max_nesting\n                             current_nesting)])))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_nesting_level\
    \ paren_group))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (let loop ([paren_string paren_string] [depth 0] [max_depth\
    \ 0])\n      (cond [(empty? paren_string) (list max_depth)]\n            [(char=?\
    \ (first paren_string) #\\()\n             (loop (rest paren_string) (+ depth\
    \ 1) (max depth max_depth))]\n            [(char=? (first paren_string) #\\))\n\
    \             (loop (rest paren_string) (- depth 1) (max depth max_depth))]\n\
    \            [else (loop (rest paren_string) depth max_depth)])))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n \
    \        (let loop ([paren_group paren_group] [level 0] [max_level 0])\n     \
    \      (cond\n             [(empty? paren_group) max_level]\n             [(char=?\
    \ (first paren_group) #\\()\n              (loop (rest paren_group) (+ level 1)\
    \ (if (> level max_level) level max_level))]\n             [(char=? (first paren_group)\
    \ #\\))\n              (loop (rest paren_group) (- level 1) max_level)]\n    \
    \         [else (loop (rest paren_group) level max_level)])))\n       (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (paren_group_max_depth\
    \ paren_group))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (cond\n      [(empty? paren_string) 0]\n      [(equal? (first\
    \ paren_string) #\\()\n       (+ 1 (parse_parens (rest paren_string)))]\n    \
    \  [(equal? (first paren_string) #\\))\n       (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (parse_nested_parens_helper paren_group 0))\n      \
    \ (string-split paren_string \" \")))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse_parens_helper paren_string depth)\n      (cond\n        [(empty?\
    \ paren_string) depth]\n        [(equal? (first paren_string) #\\() (parse_parens_helper\
    \ (rest paren_string) (+ depth 1))]\n        [(equal? (first paren_string) #\\\
    )) (parse_parens_helper (rest paren_string) (- depth 1))]\n        [else (parse_parens_helper\
    \ (rest paren_string) depth)]))\n    (parse_parens_helper paren_string 0))\n \
    \ (define (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(equal? (first paren_string) #\\ ) (parse_parens_list (rest paren_string))]\n\
    \      [else (cons (parse_parens paren_string) (parse_parens_list (rest paren_string)))]))\n\
    \  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (let ((paren_list (string-&gt;list paren_string))\n\
    \          (paren_stack '()))\n      (for ([paren paren_list])\n        (cond\n\
    \          [(equal? paren #\\() (push paren paren_stack)]\n          [(equal?\
    \ paren #\\)) (pop paren_stack)]))\n      (length paren_stack)))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n</code>\n", "  (define (parse_parens\
    \ paren_string)\n    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count\
    \ 0])\n      (cond\n        [(empty? paren_string) (list paren_count max_paren_count)]\n\
    \        [(char=? (first paren_string) #\\()\n         (loop (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n        [(char=? (first\
    \ paren_string) #\\))\n         (loop (rest paren_string) (- paren_count 1) (max\
    \ paren_count max_paren_count))]\n        [else (loop (rest paren_string) paren_count\
    \ max_paren_count)])))\n  (map (lambda (paren_string) (first (parse_parens paren_string)))\
    \ (string-split paren_string)))\n", "  (map (lambda (paren_group)\n         (let\
    \ ((paren_stack '()))\n           (for ((paren (in-string paren_group)))\n   \
    \          (cond ((equal? paren \"(\")\n                    (set! paren_stack\
    \ (cons paren paren_stack)))\n                   ((equal? paren \")\")\n     \
    \               (set! paren_stack (cdr paren_stack)))))\n           (length paren_stack)))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\
    \ (paren_group_depth paren_group)) (string-&gt;list paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (cond ((null? paren_string) 0)\n          ((equal?\
    \ (car paren_string) \"(\") (+ 1 (parse_parens (cdr paren_string))))\n       \
    \   ((equal? (car paren_string) \")\") (- 1 (parse_parens (cdr paren_string))))\n\
    \          (else (parse_parens (cdr paren_string)))))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [level 0] [max_level 0])\n           (cond [(empty? paren_group)\
    \ max_level]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group) (+ level 1) max_level)]\n                 [(char=?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (- level\
    \ 1) (max max_level level))]\n                 [else (loop (rest paren_group)\
    \ level max_level)])))\n       (string-split paren_string #\\space)))\n```\n\n\
    ```racket\n#lang racket\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (cond\n      [(empty? paren_string) 0]\n      [(equal? (first\
    \ paren_string) #\\()\n       (add1 (parse_parens (rest paren_string)))]\n   \
    \   [(equal? (first paren_string) #\\))\n       (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (define (parse_parens\
    \ paren_string)\n    (cond\n      [(empty? paren_string) 0]\n      [(equal? (first\
    \ paren_string) #\\()\n       (add1 (parse_parens (rest paren_string)))]\n   \
    \   [(equal? (first paren_string) #\\))\n       (parse_parens (rest paren_string))]))\n\
    \  (map (lambda (paren_string) (parse_parens paren_string))\n       (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n    (define\
    \ (parse_parens_helper paren_string level)\n      (cond\n        [(empty? paren_string)\
    \ level]\n        [(equal? (first paren_string) #\\() (parse_parens_helper (rest\
    \ paren_string) (+ level 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- level 1))]\n        [else (parse_parens_helper (rest\
    \ paren_string) level)]))\n    (parse_parens_helper paren_string 0))\n  (define\
    \ (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string) '()]\n\
    \      [(equal? (first paren_string) #\\ ) (cons (parse_parens (rest paren_string))\
    \ (parse_parens_list (rest paren_string)))]\n      [else (parse_parens_list (rest\
    \ paren_string))]))\n  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [nesting_level 0] [max_nesting_level\
    \ 0])\n           (cond [(empty? paren_group) max_nesting_level]\n           \
    \      [(char=? (first paren_group) #\\()\n                  (loop (rest paren_group)\
    \ (+ nesting_level 1) max_nesting_level)]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group) (- nesting_level 1) (max nesting_level\
    \ max_nesting_level))]\n                 [else (loop (rest paren_group) nesting_level\
    \ max_nesting_level)])))\n       (string-split paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (cond ((empty? paren_string) 0)\n         \
    \ ((equal? (first paren_string) #\\()\n           (+ 1 (parse_parens (rest paren_string))))\n\
    \          ((equal? (first paren_string) #\\))\n           (parse_parens (rest\
    \ paren_string)))))\n  (parse-parens-helper paren_string))\n", "  (define (parse_parens\
    \ paren_string)\n    (let loop ([paren_string paren_string] [level 0] [max_level\
    \ 0])\n      (cond [(empty? paren_string) max_level]\n            [(char=? (first\
    \ paren_string) #\\()\n             (loop (rest paren_string) (+ level 1) (if\
    \ (> level max_level) level max_level))]\n            [(char=? (first paren_string)\
    \ #\\))\n             (loop (rest paren_string) (- level 1) max_level)]\n    \
    \        [else (loop (rest paren_string) level max_level)])))\n  (map parse_parens\
    \ (string-split paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_depth\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_max_nesting paren_group))\n       (paren_string_to_list\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_group_max_nesting\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_nesting_level paren_group))\n   \
    \    (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse_parens_helper paren_string current_level max_level)\n    \
    \  (cond\n        [(empty? paren_string) max_level]\n        [(char=? (first paren_string)\
    \ #\\()\n         (parse_parens_helper (rest paren_string) (+ current_level 1)\
    \ (max current_level max_level))]\n        [(char=? (first paren_string) #\\))\n\
    \         (parse_parens_helper (rest paren_string) (- current_level 1) (max current_level\
    \ max_level))]\n        [else (parse_parens_helper (rest paren_string) current_level\
    \ max_level)]))\n    (parse_parens_helper paren_string 0 0))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n\
    \    (cond ((null? paren_string) 0)\n          ((equal? (car paren_string) \"\
    (\") (+ 1 (parse_parens (cdr paren_string))))\n          ((equal? (car paren_string)\
    \ \")\") (- 1 (parse_parens (cdr paren_string))))\n          (else (parse_parens\
    \ (cdr paren_string)))))\n  (map parse_parens (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> current_depth max_depth)\n    \
    \                        (+ current_depth 1)\n                            max_depth)\n\
    \                        (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_depth\n                        (- current_depth 1))]\n     \
    \            [else (loop (rest paren_group) max_depth current_depth)])))\n   \
    \    (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_max_depth paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ count max)\n      (cond\n        [(empty? paren_string) (list count max)]\n\
    \        [(equal? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ count 1) (max count max))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- count 1) (max count max))]\n        [else (parse_parens_helper\
    \ (rest paren_string) count max)]))\n    (parse_parens_helper paren_string 0 0))\n\
    \  (define (parse_parens_string paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(equal? (first paren_string) #\\ ) (parse_parens_string (rest\
    \ paren_string))]\n      [else (cons (parse_parens paren_string) (parse_parens_string\
    \ (rest paren_string)))]))\n  (parse_parens_string paren_string))\n", "  (map\
    \ (lambda (paren_group)\n         (paren_group_max_depth paren_group))\n     \
    \  (paren_string_to_list paren_string)))\n", "  (map (lambda (paren_group)\n \
    \        (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_nesting_level paren_group))\n   \
    \    (string-split paren_string)))\n", "  (map (lambda (paren_group) (count_parens\
    \ paren_group 0)) (string-split paren_string)))\n", "  (let ([paren_groups (string-split\
    \ paren_string #\\space)])\n    (map (lambda (group)\n           (let ([max-level\
    \ 0]\n                 [current-level 0])\n             (for ([c (in-string group)])\n\
    \               (cond\n                 [(char=? c #\\()\n                  (set!\
    \ current-level (+ current-level 1))\n                  (when (> current-level\
    \ max-level)\n                    (set! max-level current-level))]\n         \
    \        [(char=? c #\\))\n                  (set! current-level (- current-level\
    \ 1))]))\n             max-level))\n         paren_groups)))\n", "  (map (lambda\
    \ (paren_group) (parse_nested_parens_helper paren_group 0))\n       (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n    (define\
    \ (parse_parens_helper paren_string level)\n      (cond\n        [(empty? paren_string)\
    \ level]\n        [(char=? (first paren_string) #\\() (parse_parens_helper (rest\
    \ paren_string) (+ level 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- level 1))]\n        [else (parse_parens_helper (rest\
    \ paren_string) level)]))\n    (parse_parens_helper paren_string 0))\n  (define\
    \ (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string) '()]\n\
    \      [(char=? (first paren_string) #\\space) (cons (parse_parens (rest paren_string))\
    \ (parse_parens_list (rest paren_string)))]\n      [else (parse_parens_list (rest\
    \ paren_string))]))\n  (parse_parens_list paren_string))\n", "  (define (parse-parens\
    \ paren-string)\n    (cond ((null? paren-string) 0)\n          ((equal? (car paren-string)\
    \ \"(\") (+ 1 (parse-parens (cdr paren-string))))\n          ((equal? (car paren-string)\
    \ \")\") (- 1 (parse-parens (cdr paren-string))))\n          (else (parse-parens\
    \ (cdr paren-string)))))\n  (map parse-parens (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(eq? (first paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n\
    \      [(eq? (first paren_string) #\\)) (sub1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (define\
    \ max_depth 0)\n         (define current_depth 0)\n         (for ([c (in-string\
    \ paren_group)])\n           (cond\n             [(char=? c #\\()\n          \
    \    (set! current_depth (+ current_depth 1))\n              (when (> current_depth\
    \ max_depth)\n                (set! max_depth current_depth))]\n             [(char=?\
    \ c #\\))\n              (set! current_depth (- current_depth 1))]))\n       \
    \  max_depth)\n       (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda\
    \ (paren_group)\n         (parse_nested_parens_helper paren_group 0))\n      \
    \ (string-split paren_string)))\n", "  (map (\u03BB (paren_group)\n         (let\
    \ loop ([paren_group paren_group] [max_depth 0] [current_depth 0])\n         \
    \  (cond [(empty? paren_group) max_depth]\n                 [(char=? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group)\n                        (if\
    \ (> (+ current_depth 1) max_depth)\n                            (+ current_depth\
    \ 1)\n                            max_depth)\n                        (+ current_depth\
    \ 1))]\n                 [(char=? (first paren_group) #\\))\n                \
    \  (loop (rest paren_group)\n                        max_depth\n             \
    \           (- current_depth 1))]\n                 [else (loop (rest paren_group)\
    \ max_depth current_depth)])))\n       (string-split paren_string)))\n", "  (define\
    \ (parse_nested_parens_helper paren_string current_depth max_depth)\n    (cond\n\
    \      [(empty? paren_string) (list max_depth)]\n      [(equal? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ current_depth\
    \ 1) (max max_depth current_depth))]\n      [(equal? (first paren_string) #\\\
    ))\n       (parse_nested_parens_helper (rest paren_string) (- current_depth 1)\
    \ max_depth)]\n      [else (parse_nested_parens_helper (rest paren_string) current_depth\
    \ max_depth)]))\n  (parse_nested_parens_helper (string->list paren_string) 0 0))\n",
  "  (define (parse_nested_parens_helper paren_string acc)\n    (cond\n      [(empty?\
    \ paren_string) (reverse acc)]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) (cons (max_nested_parens (first paren_string)) acc))]))\n  (parse_nested_parens_helper\
    \ (string-split paren_string) '()))\n", "  (map (lambda (paren_group)\n      \
    \   (count_nested_parens paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_depth paren_group))\n \
    \      (string-split paren_string)))\n", "  (map (\u03BB (x) (parse_nested_parens_helper\
    \ x 0)) (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse_parens_helper paren_string depth)\n      (cond\n        [(empty?\
    \ paren_string) depth]\n        [(char=? (first paren_string) #\\() (parse_parens_helper\
    \ (rest paren_string) (+ depth 1))]\n        [(char=? (first paren_string) #\\\
    )) (parse_parens_helper (rest paren_string) (- depth 1))]\n        [else (parse_parens_helper\
    \ (rest paren_string) depth)]))\n    (parse_parens_helper paren_string 0))\n \
    \ (define (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(char=? (first paren_string) #\\ ) (parse_parens_list (rest paren_string))]\n\
    \      [else (cons (parse_parens paren_string) (parse_parens_list (rest paren_string)))]))\n\
    \  (parse_parens_list paren_string))\n", "  (define (parse_parens paren_string)\n\
    \    (cond\n      [(empty? paren_string) 0]\n      [(equal? (first paren_string)\
    \ #\\() (add1 (parse_parens (rest paren_string)))]\n      [(equal? (first paren_string)\
    \ #\\)) (sub1 (parse_parens (rest paren_string)))]\n      [else (parse_parens\
    \ (rest paren_string))]))\n  (map (lambda (x) (parse_parens x)) (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n    (cond\n\
    \      [(empty? paren_string) 0]\n      [(eq? (first paren_string) #\\() (add1\
    \ (parse_parens (rest paren_string)))]\n      [(eq? (first paren_string) #\\))\
    \ (sub1 (parse_parens (rest paren_string)))]\n      [else (parse_parens (rest\
    \ paren_string))]))\n  (define (parse_parens_list paren_string)\n    (cond\n \
    \     [(empty? paren_string) empty]\n      [(eq? (first paren_string) #\\() (cons\
    \ (parse_parens paren_string) (parse_parens_list (rest paren_string)))]\n    \
    \  [(eq? (first paren_string) #\\)) (parse_parens_list (rest paren_string))]\n\
    \      [else (parse_parens_list (rest paren_string))]))\n  (parse_parens_list\
    \ paren_string))\n", "  (define (parse_parens paren_string)\n    (cond\n     \
    \ [(empty? paren_string) 0]\n      [(equal? (first paren_string) #\\()\n     \
    \  (+ 1 (parse_parens (rest paren_string)))]\n      [(equal? (first paren_string)\
    \ #\\))\n       (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper\
    \ paren_group 0)) (string-split paren_string)))\n", "  (map (lambda (paren_group)\
    \ (paren_group_depth paren_group)) (string-&gt;list paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (cond\n      [(empty? paren_string) 0]\n  \
    \    [(equal? (first paren_string) #\\() (+ 1 (parse_parens (rest paren_string)))]\n\
    \      [(equal? (first paren_string) #\\)) (- 1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n    (let\
    \ loop ([paren_string paren_string] [paren_stack '()] [max_level 0])\n      (cond\
    \ [(empty? paren_string) (list max_level paren_stack)]\n            [(char=? (first\
    \ paren_string) #\\()\n             (loop (rest paren_string) (cons (first paren_string)\
    \ paren_stack) (add1 max_level))]\n            [(char=? (first paren_string) #\\\
    ))\n             (loop (rest paren_string) (rest paren_stack) max_level)]\n  \
    \          [else (loop (rest paren_string) paren_stack max_level)])))\n  (let\
    \ loop ([paren_string paren_string] [max_levels '()])\n    (cond [(empty? paren_string)\
    \ (reverse max_levels)]\n          [else (let ([result (parse_parens paren_string)])\n\
    \                  (loop (rest (regexp-split #rx\" +\" paren_string))\n      \
    \                  (cons (first result) max_levels)))])))\n", "  (map (lambda\
    \ (paren_group)\n         (paren_nesting_level paren_group))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_nesting_level\
    \ paren_group))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (cond [(empty? paren_string) 0]\n          [(equal? (first\
    \ paren_string) #\\() (+ 1 (parse_parens (rest paren_string)))]\n          [(equal?\
    \ (first paren_string) #\\)) (- 1 (parse_parens (rest paren_string)))]))\n  (map\
    \ parse_parens (string-split paren_string #\\space)))\n", "  (define (parse_parens\
    \ paren_string)\n    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count\
    \ 0])\n      (cond [(empty? paren_string) max_paren_count]\n            [(char=?\
    \ (first paren_string) #\\()\n             (loop (rest paren_string) (+ paren_count\
    \ 1) (max paren_count max_paren_count))]\n            [(char=? (first paren_string)\
    \ #\\))\n             (loop (rest paren_string) (- paren_count 1) max_paren_count)]\n\
    \            [else (loop (rest paren_string) paren_count max_paren_count)])))\n\
    \  (map parse_parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\
    \ (paren_nesting_level paren_group)) (string-&gt;list paren_string)))\n", "  (map\
    \ (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [cur_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_level (+ cur_level 1))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group) (max max_level cur_level)\
    \ (- cur_level 1))]\n                 [else (loop (rest paren_group) max_level\
    \ cur_level)])))\n       (regexp-split #rx\" \" paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (cond\n      [(empty? paren_string) 0]\n  \
    \    [(equal? (first paren_string) #\\()\n       (+ 1 (parse_parens (rest paren_string)))]\n\
    \      [(equal? (first paren_string) #\\))\n       (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse_parens_helper paren_string max_level current_level)\n\
    \      (cond\n        [(empty? paren_string) max_level]\n        [(char=? (first\
    \ paren_string) #\\()\n         (parse_parens_helper (rest paren_string)\n   \
    \                           (if (> current_level max_level) current_level max_level)\n\
    \                              (+ current_level 1))]\n        [(char=? (first\
    \ paren_string) #\\))\n         (parse_parens_helper (rest paren_string)\n   \
    \                           (if (> current_level max_level) current_level max_level)\n\
    \                              (- current_level 1))]\n        [else (parse_parens_helper\
    \ (rest paren_string) max_level current_level)]))\n    (parse_parens_helper paren_string\
    \ 0 0))\n  (define (parse_nested_parens_helper paren_string result)\n    (cond\n\
    \      [(empty? paren_string) result]\n      [(char=? (first paren_string) #\\\
    \ )\n       (parse_nested_parens_helper (rest paren_string) result)]\n      [else\
    \ (parse_nested_parens_helper (rest paren_string)\n                          \
    \              (append result (list (parse_parens paren_string))))]))\n  (parse_nested_parens_helper\
    \ paren_string '()))\n", "  (define (parse_parens paren_string)\n    (cond\n \
    \     [(empty? paren_string) 0]\n      [(eq? (first paren_string) #\\() (add1\
    \ (parse_parens (rest paren_string)))]\n      [(eq? (first paren_string) #\\))\
    \ (sub1 (parse_parens (rest paren_string)))]\n      [else (parse_parens (rest\
    \ paren_string))]))\n  (map parse_parens (string-split paren_string #\\space)))\n",
  "  (map (lambda (paren_group) (parse_nested_parens_helper paren_group 0)) (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [paren_count 0] [max_paren_count 0])\n      (cond\n        [(empty?\
    \ paren_string) (list paren_count max_paren_count)]\n        [(char=? (first paren_string)\
    \ #\\()\n         (loop (rest paren_string) (+ paren_count 1) (max paren_count\
    \ max_paren_count))]\n        [(char=? (first paren_string) #\\))\n         (loop\
    \ (rest paren_string) (- paren_count 1) (max paren_count max_paren_count))]\n\
    \        [else (loop (rest paren_string) paren_count max_paren_count)])))\n  (for/list\
    \ ([paren_group (in-list (string-split paren_string))])\n    (let ([paren_counts\
    \ (parse_parens paren_group)])\n      (first (rest paren_counts)))))\n```\n\n\
    ### Problem 5:\n\n```racket\n#lang racket\n", "  (map (lambda (paren_group)\n\
    \         (count-parens paren_group 0))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ paren_count)\n      (cond\n        [(empty? paren_string) paren_count]\n   \
    \     [(equal? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ paren_count 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- paren_count 1))]\n        [else (parse_parens_helper\
    \ (rest paren_string) paren_count)]))\n    (parse_parens_helper paren_string 0))\n\
    \  (define (parse_parens_groups paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(equal? (first paren_string) #\\ ) (parse_parens_groups (rest\
    \ paren_string))]\n      [else (cons (parse_parens (first paren_string)) (parse_parens_groups\
    \ (rest paren_string)))]))\n  (parse_parens_groups paren_string))\n", "  (map\
    \ (lambda (paren_group)\n         (parse_nested_parens_helper paren_group 0))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (let loop ([paren_group paren_group] [level 0] [max_level 0])\n        \
    \   (cond [(empty? paren_group) max_level]\n                 [(char=? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group) (+ level 1) (if (> level max_level)\
    \ level max_level))]\n                 [(char=? (first paren_group) #\\))\n  \
    \                (loop (rest paren_group) (- level 1) max_level)]\n          \
    \       [else (loop (rest paren_group) level max_level)])))\n       (string-split\
    \ paren_string #\\space)))\n", "  (define (parse-parens-helper paren_string current_level\
    \ max_level)\n    (cond [(empty? paren_string) (list max_level)]\n          [(char=?\
    \ (first paren_string) #\\()\n           (parse-parens-helper (rest paren_string)\
    \ (+ current_level 1) (max max_level current_level))]\n          [(char=? (first\
    \ paren_string) #\\))\n           (parse-parens-helper (rest paren_string) (-\
    \ current_level 1) max_level)]\n          [(char=? (first paren_string) #\\space)\n\
    \           (append (list max_level) (parse-parens-helper (rest paren_string)\
    \ 0 0))]))\n  (parse-parens-helper paren_string 0 0))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [level 0] [max_level 0])\n    \
    \       (cond [(empty? paren_group) max_level]\n                 [(char=? (first\
    \ paren_group) #\\()\n                  (loop (rest paren_group) (+ level 1) max_level)]\n\
    \                 [(char=? (first paren_group) #\\))\n                  (loop\
    \ (rest paren_group) (- level 1) (max max_level level))]\n                 [else\
    \ (loop (rest paren_group) level max_level)])))\n       (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group)\n         (let loop ([paren_group paren_group] [depth\
    \ 0] [max-depth 0])\n           (cond [(empty? paren_group) max-depth]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ depth 1) (max max-depth depth))]\n                 [(char=?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (- depth\
    \ 1) max-depth)]\n                 [else (loop (rest paren_group) depth max-depth)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (define (parse_nested_parens_helper\
    \ paren_string max_depth)\n    (if (string-empty? paren_string)\n        (list\
    \ max_depth)\n        (if (string=? (substring paren_string 0 1) \"(\")\n    \
    \        (parse_nested_parens_helper (substring paren_string 1) (add1 max_depth))\n\
    \            (parse_nested_parens_helper (substring paren_string 1) (sub1 max_depth)))))\n\
    \  (parse_nested_parens_helper paren_string 0))\n", "  (map (lambda (paren_group)\n\
    \         (paren_depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (cond\n      [(empty? paren_string) 0]\n      [(eq? (first paren_string)\
    \ #\\()\n       (add1 (parse_parens (rest paren_string)))]\n      [(eq? (first\
    \ paren_string) #\\))\n       (parse_parens (rest paren_string))]))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n \
    \        (paren_group_max_nesting paren_group))\n       (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (paren_group_max_nesting\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group) (parse_nested_parens_helper paren_group 0)) (string-split\
    \ paren_string)))\n", "  (define (parse_nested_parens_helper paren_string paren_count\
    \ max_paren_count)\n    (cond\n      [(empty? paren_string) (list max_paren_count)]\n\
    \      [(char=? (first paren_string) #\\()\n       (parse_nested_parens_helper\
    \ (rest paren_string) (+ paren_count 1) (max paren_count max_paren_count))]\n\
    \      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- paren_count 1) (max paren_count max_paren_count))]\n\
    \      [else (parse_nested_parens_helper (rest paren_string) paren_count max_paren_count)]))\n\
    \  (parse_nested_parens_helper paren_string 0 0))\n", "  (map (lambda (paren_group)\n\
    \         (let ([paren_group (string->list paren_group)])\n           (let loop\
    \ ([paren_group paren_group] [level 0] [max_level 0])\n             (cond\n  \
    \             [(null? paren_group) max_level]\n               [(equal? (car paren_group)\
    \ #\\()\n                (loop (cdr paren_group) (+ level 1) (max level max_level))]\n\
    \               [(equal? (car paren_group) #\\))\n                (loop (cdr paren_group)\
    \ (- level 1) (max level max_level))]\n               [else (loop (cdr paren_group)\
    \ level max_level)]))))\n       (string-split paren_string #\\space)))\n", " \
    \ (define (parse_parens paren_string)\n    (cond ((empty? paren_string) 0)\n \
    \         ((equal? (first paren_string) #\\()\n           (+ 1 (parse_parens (rest\
    \ paren_string))))\n          ((equal? (first paren_string) #\\))\n          \
    \ (parse_parens (rest paren_string)))))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (paren_depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count 0])\n\
    \      (cond [(empty? paren_string) (list paren_count max_paren_count)]\n    \
    \        [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- paren_count\
    \ 1) (max paren_count max_paren_count))]\n            [else (loop (rest paren_string)\
    \ paren_count max_paren_count)])))\n  (map (lambda (paren_string) (second (parse_parens\
    \ paren_string))) (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_depth paren_group))\n \
    \      (string-split paren_string)))\n", "  (map (lambda (paren_group)\n     \
    \    (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n\
    \         (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) (if (> level max_level) level max_level))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group) (- level 1) max_level)]\n                 [else (loop (rest paren_group)\
    \ level max_level)])))\n       (string-split paren_string)))\n", "  (map (lambda\
    \ (paren_group)\n         (parse_nested_parens_helper paren_group 0))\n      \
    \ (string-split paren_string)))\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0 0))\n       (string-split paren_string #\\space)))\n", "  (define\
    \ (parse_parens paren_string)\n    (define (parse_parens_iter paren_string depth\
    \ max_depth)\n      (cond ((null? paren_string) max_depth)\n            ((char=?\
    \ (car paren_string) #\\()\n             (parse_parens_iter (cdr paren_string)\
    \ (+ depth 1) (if (> depth max_depth) depth max_depth)))\n            ((char=?\
    \ (car paren_string) #\\))\n             (parse_parens_iter (cdr paren_string)\
    \ (- depth 1) max_depth))\n            (else (parse_parens_iter (cdr paren_string)\
    \ depth max_depth))))\n    (parse_parens_iter paren_string 0 0))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n \
    \        (paren_nesting_level paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_depth paren_group 0 0))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ depth)\n      (cond\n        [(empty? paren_string) depth]\n        [(equal?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ depth\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- depth 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ depth)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_parens_list\
    \ paren_string)\n    (cond\n      [(empty? paren_string) empty]\n      [(equal?\
    \ (first paren_string) #\\ ) (parse_parens_list (rest paren_string))]\n      [else\
    \ (cons (parse_parens paren_string) (parse_parens_list (rest paren_string)))]))\n\
    \  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group)\n     \
    \    (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ level)\n      (cond\n        [(empty? paren-string) level]\n        [(char=?\
    \ (first paren-string) #\\()\n         (parse-parens-iter (rest paren-string)\
    \ (+ level 1))]\n        [(char=? (first paren-string) #\\))\n         (parse-parens-iter\
    \ (rest paren-string) (- level 1))]\n        [else (parse-parens-iter (rest paren-string)\
    \ level)]))\n    (parse-parens-iter paren-string 0))\n  (define (parse-parens-list\
    \ paren-string)\n    (cond\n      [(empty? paren-string) (list)]\n      [(char=?\
    \ (first paren-string) #\\ )\n       (cons (parse-parens (rest paren-string))\n\
    \             (parse-parens-list (rest paren-string)))]\n      [else (parse-parens-list\
    \ (rest paren-string))]))\n  (parse-parens-list paren-string))\n", "  (map (lambda\
    \ (paren_group)\n         (parse_nested_parens_helper paren_group 0))\n      \
    \ (string-split paren_string)))\n", "  (map (lambda (paren_group)\n         (let\
    \ loop ([paren_group paren_group] [level 0] [max_level 0])\n           (cond [(empty?\
    \ paren_group) max_level]\n                 [(char=? (first paren_group) #\\()\n\
    \                  (loop (rest paren_group) (+ level 1) max_level)]\n        \
    \         [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\
    \ (- level 1) (max max_level level))]\n                 [else (loop (rest paren_group)\
    \ level max_level)])))\n       (regexp-split #rx\" \" paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (define (parse_parens_iter paren_string count\
    \ max_count)\n      (cond\n        [(empty? paren_string) (values count max_count)]\n\
    \        [(char=? (first paren_string) #\\() (parse_parens_iter (rest paren_string)\
    \ (+ count 1) (max count max_count))]\n        [(char=? (first paren_string) #\\\
    )) (parse_parens_iter (rest paren_string) (- count 1) (max count max_count))]\n\
    \        [else (parse_parens_iter (rest paren_string) count max_count)]))\n  \
    \  (parse_parens_iter paren_string 0 0))\n  (define (parse_parens_iter paren_string\
    \ result)\n    (cond\n      [(empty? paren_string) result]\n      [else (parse_parens_iter\
    \ (rest paren_string) (append result (list (parse_parens (first paren_string)))))]))\n\
    \  (parse_parens_iter (string-split paren_string) '()))\n", "  (map (lambda (paren_group)\n\
    \         (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [level 0] [max_level 0])\n      (cond [(empty? paren_string) max_level]\n  \
    \          [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ level 1) (if (> max_level level) max_level level))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- level\
    \ 1) max_level)]\n            [else (loop (rest paren_string) level max_level)])))\n\
    \  (map parse_parens (string-split paren_string)))\n", "  (define (parse-parens\
    \ paren-string)\n    (let loop ([paren-string paren-string] [paren-count 0] [max-paren-count\
    \ 0])\n      (cond [(empty? paren-string) (list paren-count max-paren-count)]\n\
    \            [(char=? (first paren-string) #\\()\n             (loop (rest paren-string)\
    \ (+ paren-count 1) (max paren-count (+ paren-count 1)))]\n            [(char=?\
    \ (first paren-string) #\\))\n             (loop (rest paren-string) (- paren-count\
    \ 1) (max paren-count (- paren-count 1)))]\n            [else (loop (rest paren-string)\
    \ paren-count max-paren-count)])))\n  (let loop ([paren-string paren-string] [paren-count\
    \ 0] [max-paren-count 0] [paren-list '()])\n    (cond [(empty? paren-string) (reverse\
    \ (cons max-paren-count paren-list))]\n          [(char=? (first paren-string)\
    \ #\\ )\n           (let ([result (parse-parens (rest paren-string))])\n     \
    \        (loop (rest (rest paren-string)) (first result) (second result) (cons\
    \ (second result) paren-list)))]\n          [else (loop (rest paren-string) paren-count\
    \ max-paren-count paren-list)])))\n", "  (map (lambda (paren_group)\n        \
    \ (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string\
    \ #\\space)))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [max_level 0] [cur_level 0])\n      (cond [(empty? paren_string)\
    \ max_level]\n            [(char=? (first paren_string) #\\()\n             (loop\
    \ (rest paren_string)\n                   (max max_level (add1 cur_level))\n \
    \                  (add1 cur_level))]\n            [(char=? (first paren_string)\
    \ #\\))\n             (loop (rest paren_string)\n                   max_level\n\
    \                   (sub1 cur_level))]\n            [else (loop (rest paren_string)\
    \ max_level cur_level)])))\n  (map parse_parens (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (max-depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond\n    \
    \  [(empty? paren_string) 0]\n      [(eq? (first paren_string) #\\()\n       (add1\
    \ (parse_parens (rest paren_string)))]\n      [(eq? (first paren_string) #\\))\n\
    \       (sub1 (parse_parens (rest paren_string)))]\n      [else (parse_parens\
    \ (rest paren_string))]))\n  (map parse_parens (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ max_depth depth)\n      (cond\n        [(empty? paren_string) max_depth]\n \
    \       [(equal? (first paren_string) #\\()\n         (parse_parens_iter (rest\
    \ paren_string)\n                            (if (> (+ depth 1) max_depth)\n \
    \                               (+ depth 1)\n                                max_depth)\n\
    \                            (+ depth 1))]\n        [(equal? (first paren_string)\
    \ #\\))\n         (parse_parens_iter (rest paren_string)\n                   \
    \         max_depth\n                            (- depth 1))]\n        [else\
    \ (parse_parens_iter (rest paren_string)\n                                 max_depth\n\
    \                                 depth)]))\n    (parse_parens_iter paren_string\
    \ 0 0))\n  (define (parse_parens_iter paren_string max_depth depth)\n    (cond\n\
    \      [(empty? paren_string) (list max_depth)]\n      [(equal? (first paren_string)\
    \ #\\ )\n       (append (list max_depth)\n               (parse_parens_iter (rest\
    \ paren_string)\n                                  0\n                       \
    \           0))]\n      [else (append (list max_depth)\n                    (parse_parens_iter\
    \ (rest paren_string)\n                                       (parse_parens paren_string)\n\
    \                                       0))]))\n  (parse_parens_iter paren_string\
    \ 0 0))\n", "  (define (parse_parens paren_string)\n    (cond ((string=? paren_string\
    \ \"\") 0)\n          ((string=? paren_string \"()\") 1)\n          ((string=?\
    \ (substring paren_string 0 1) \"(\")\n           (add1 (parse_parens (substring\
    \ paren_string 1 (- (string-length paren_string) 1)))))\n          (else 0)))\n\
    \  (map parse_parens (string-split paren_string \" \")))\n", "  (map (lambda (paren_group)\n\
    \         (let ([paren_group (string-&gt;list paren_group)])\n           (let\
    \ loop ([paren_group paren_group] [max_level 0] [level 0])\n             (cond\n\
    \               [(empty? paren_group) max_level]\n               [(char=? (first\
    \ paren_group) #\\()\n                (loop (rest paren_group)\n             \
    \         (if (&gt; level max_level) level max_level)\n                      (+\
    \ level 1))]\n               [(char=? (first paren_group) #\\))\n            \
    \    (loop (rest paren_group)\n                      (if (&gt; level max_level)\
    \ level max_level)\n                      (- level 1))]\n               [else\
    \ (loop (rest paren_group) max_level level)]))))\n       (string-split paren_string)))\n\
    </code>\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group]\
    \ [nesting_level 0] [max_nesting_level 0])\n           (cond [(empty? paren_group)\
    \ max_nesting_level]\n                 [(char=? (first paren_group) #\\()\n  \
    \                (loop (rest paren_group) (+ nesting_level 1) max_nesting_level)]\n\
    \                 [(char=? (first paren_group) #\\))\n                  (loop\
    \ (rest paren_group) (- nesting_level 1) (max nesting_level max_nesting_level))]\n\
    \                 [else (loop (rest paren_group) nesting_level max_nesting_level)])))\n\
    \       (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count 0])\n\
    \      (cond [(empty? paren_string) (list paren_count max_paren_count)]\n    \
    \        [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- paren_count\
    \ 1) (max paren_count max_paren_count))]\n            [else (loop (rest paren_string)\
    \ paren_count max_paren_count)])))\n  (define (parse_paren_groups paren_string)\n\
    \    (let loop ([paren_string paren_string] [paren_groups '()])\n      (cond [(empty?\
    \ paren_string) (reverse paren_groups)]\n            [(char=? (first paren_string)\
    \ #\\ )\n             (loop (rest paren_string) paren_groups)]\n            [else\
    \ (let ([paren_group (take-while (lambda (c) (not (char=? c #\\ ))) paren_string)])\n\
    \                    (loop (drop-while (lambda (c) (not (char=? c #\\ ))) paren_string)\n\
    \                          (cons (parse_parens paren_group) paren_groups))))])))\n\
    \  (map second (parse_paren_groups paren_string)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
