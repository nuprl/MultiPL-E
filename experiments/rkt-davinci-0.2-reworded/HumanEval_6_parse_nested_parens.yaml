name: HumanEval_6_parse_nested_parens
language: rkt
prompt: "#lang racket\n\n;; Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
  \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
  \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
  (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
  \ paren_string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
  \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
  \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n   \
  \ (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
completions: ["  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group]\
    \ [max_depth 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group)\n                        (if (> current_depth max_depth)\n\
    \                            (+ current_depth 1)\n                           \
    \ max_depth)\n                        (+ current_depth 1))]\n                \
    \ [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\n\
    \                        max_depth\n                        (- current_depth 1))]\n\
    \                 [else (loop (rest paren_group) max_depth current_depth)])))\n\
    \       (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count 0])\n\
    \      (cond\n        [(empty? paren_string) max_paren_count]\n        [(char=?\
    \ (first paren_string) #\\()\n         (loop (rest paren_string) (+ paren_count\
    \ 1) (max paren_count max_paren_count))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (loop (rest paren_string) (- paren_count 1) (max paren_count\
    \ max_paren_count))]\n        [else (loop (rest paren_string) paren_count max_paren_count)])))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (paren_group_max_depth paren_group))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (define (parse_parens_helper\
    \ paren_string depth)\n      (cond\n        [(empty? paren_string) depth]\n  \
    \      [(char=? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ depth 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- depth 1))]\n        [else (parse_parens_helper (rest\
    \ paren_string) depth)]))\n    (parse_parens_helper paren_string 0))\n  (define\
    \ (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string) '()]\n\
    \      [(char=? (first paren_string) #\\ ) (cons (parse_parens (rest paren_string))\
    \ (parse_parens_list (rest paren_string)))]\n      [else (parse_parens_list (rest\
    \ paren_string))]))\n  (parse_parens_list paren_string))\n", "  (define (parse_parens\
    \ paren_string)\n    (cond\n      [(empty? paren_string) 0]\n      [(equal? (first\
    \ paren_string) #\\()\n       (+ 1 (parse_parens (rest paren_string)))]\n    \
    \  [(equal? (first paren_string) #\\))\n       (- 1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (define (parse_parens_list\
    \ paren_string)\n    (cond\n      [(empty? paren_string) empty]\n      [(equal?\
    \ (first paren_string) #\\ )\n       (cons (parse_parens (rest paren_string))\
    \ (parse_parens_list (rest paren_string)))]\n      [else (parse_parens_list (rest\
    \ paren_string))]))\n  (parse_parens_list paren_string))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse-parens-helper paren_string level)\n      (cond\
    \ ((null? paren_string) level)\n            ((char=? (car paren_string) #\\()\n\
    \             (parse-parens-helper (cdr paren_string) (+ level 1)))\n        \
    \    ((char=? (car paren_string) #\\))\n             (parse-parens-helper (cdr\
    \ paren_string) (- level 1)))))\n    (parse-parens-helper paren_string 0))\n \
    \ (map parse_parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper\
    \ paren_group 0)) (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse_parens_helper paren_string level)\n      (cond\n        [(empty?\
    \ paren_string) level]\n        [(char=? (first paren_string) #\\() (parse_parens_helper\
    \ (rest paren_string) (+ level 1))]\n        [(char=? (first paren_string) #\\\
    )) (parse_parens_helper (rest paren_string) (- level 1))]\n        [else (parse_parens_helper\
    \ (rest paren_string) level)]))\n    (parse_parens_helper paren_string 0))\n \
    \ (define (parse_nested_parens_helper paren_string result)\n    (cond\n      [(empty?\
    \ paren_string) result]\n      [(char=? (first paren_string) #\\ ) (parse_nested_parens_helper\
    \ (rest paren_string) result)]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) (append result (list (parse_parens paren_string))))]))\n  (parse_nested_parens_helper\
    \ paren_string '()))\n", "  (map (lambda (paren_group)\n         (paren_group_max_depth\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (\u03BB (paren_group)\n\
    \         (let ([paren_group (string->list paren_group)])\n           (let loop\
    \ ([paren_group paren_group] [max_level 0] [level 0])\n             (cond\n  \
    \             [(empty? paren_group) max_level]\n               [(char=? (first\
    \ paren_group) #\\()\n                (loop (rest paren_group)\n             \
    \         (max max_level (add1 level))\n                      (add1 level))]\n\
    \               [(char=? (first paren_group) #\\))\n                (loop (rest\
    \ paren_group)\n                      max_level\n                      (sub1 level))]\n\
    \               [else (loop (rest paren_group) max_level level)]))))\n       (regexp-split\
    \ #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop\
    \ ([paren_group paren_group] [nesting_level 0] [max_nesting_level 0])\n      \
    \     (cond [(empty? paren_group) max_nesting_level]\n                 [(equal?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group) (+ nesting_level\
    \ 1) max_nesting_level)]\n                 [(equal? (first paren_group) #\\))\n\
    \                  (loop (rest paren_group) (- nesting_level 1) (max nesting_level\
    \ max_nesting_level))]\n                 [else (loop (rest paren_group) nesting_level\
    \ max_nesting_level)])))\n       (string-split paren_string)))\n", "  (map (lambda\
    \ (paren_group) (paren_depth paren_group)) (string-split paren_string)))\n", " \
    \ (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [current_level 0])\n           (cond [(empty? paren_group) max_level]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_level (+ current_level 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_level\
    \ current_level) (- current_level 1))]\n                 [else (loop (rest paren_group)\
    \ max_level current_level)])))\n       (string-split paren_string)))\n", "  (define\
    \ (parens-helper paren_string)\n    (cond\n      [(empty? paren_string) 0]\n \
    \     [(eq? (first paren_string) #\\() (add1 (parens-helper (rest paren_string)))]\n\
    \      [(eq? (first paren_string) #\\)) (sub1 (parens-helper (rest paren_string)))]\n\
    \      [else (parens-helper (rest paren_string))]))\n  (map (lambda (x) (parens-helper\
    \ x)) (string-split paren_string)))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper\
    \ paren_group 0)) (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
