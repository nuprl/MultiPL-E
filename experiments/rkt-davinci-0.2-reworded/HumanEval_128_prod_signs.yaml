name: HumanEval_128_prod_signs
language: rkt
prompt: "#lang racket\n\n;; You are given a list arr of integers and you need to return\n\
  ;; sum of magnitudes of integers multiplied by product of all signs\n;; of each\
  \ number in the list, represented by 1, -1 or 0.\n;; Note: return #f for empty arr.\n\
  ;; Example:\n;; >>> (prod_signs (list 1 2 2 -4))\n;; 9\n;; >>> (prod_signs (list\
  \ 0 1))\n;; 0\n;; >>> (prod_signs (list ))\n;; #f\n(define (prod_signs arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
  \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
  \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n   \
  \ (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list 2 4\
  \ 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal?\
  \ (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0))\
  \ 0)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (let ([magnitudes (map\
    \ abs arr)])\n         (let ([prod (apply * signs)])\n           (let ([sum (apply\
    \ + magnitudes)])\n             (* prod sum)))))]))\n", "  (if (null? arr)\n \
    \     #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (< x 0) -1 1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (cond [(empty? arr) #f]\n        [else (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n                (let ([magnitudes (map abs\
    \ arr)])\n                  (let ([sign-prod (apply * signs)])\n             \
    \       (let ([mag-sum (apply + magnitudes)])\n                      (* sign-prod\
    \ mag-sum)))))]))\n", "  (if (null? arr)\n      #f\n      (let ((signs (map (lambda\
    \ (x)\n                          (if (zero? x)\n                             \
    \ 0\n                              (if (negative? x)\n                       \
    \           -1\n                                  1)))\n                     \
    \   arr)))\n        (let ((magnitudes (map abs arr)))\n          (let ((prod (apply\
    \ * signs)))\n            (apply + (map (lambda (x) (* x prod)) magnitudes)))))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (let ([magnitudes (map abs arr)])\n\
    \         (apply * signs)\n         (apply + magnitudes)))]))\n", "  (if (null?\
    \ arr)\n      #f\n      (letrec ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)]\n               [magnitudes (map abs arr)])\n        (apply\
    \ * (map * signs magnitudes)))))\n", "  (cond\n    [(empty? arr) #f]\n    [else\n\
    \     (apply * (map sign arr))\n     (apply + (map abs arr))]))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (< x 0) -1 1))) arr)])\n       (let ([magnitudes (map abs arr)])\n\
    \         (let ([prod (apply * signs)])\n           (let ([sum (apply + magnitudes)])\n\
    \             (* prod sum)))))]))\n", "  (if (null? arr)\n      #f\n      (let\
    \ ((signs (map (lambda (x)\n                          (if (zero? x)\n        \
    \                      0\n                              (if (< x 0)\n        \
    \                          -1\n                                  1)))\n      \
    \                  arr)))\n        (let ((magnitudes (map abs arr)))\n       \
    \   (let ((sign-prod (apply * signs)))\n            (let ((mag-sum (apply + magnitudes)))\n\
    \              (* sign-prod mag-sum)))))))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n       (* (product signs) (sum (map abs arr))))]))\n", "  (if (empty?\
    \ arr)\n      #f\n      (let ([signs (map (lambda (x)\n                      \
    \    (if (= x 0)\n                              0\n                          \
    \    (if (> x 0)\n                                  1\n                      \
    \            -1)))\n                        arr)])\n        (let ([magnitudes\
    \ (map abs arr)])\n          (let ([sign-prod (apply * signs)])\n            (let\
    \ ([mag-sum (apply + magnitudes)])\n              (* sign-prod mag-sum)))))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (let ([magnitudes (map abs arr)])\n\
    \         (let ([prod (apply * signs)])\n           (let ([sum (apply + magnitudes)])\n\
    \             (* prod sum)))))]))\n", "  (cond\n    [(empty? arr) #f]\n    [else\n\
    \     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \       (let ([magnitudes (map abs arr)])\n         (let ([sign-product (apply\
    \ * signs)])\n           (let ([magnitude-sum (apply + magnitudes)])\n       \
    \      (* sign-product magnitude-sum)))))]))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [else\n     (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1\
    \ 1))) arr)]\n            [magnitudes (map abs arr)])\n       (apply * signs)\n\
    \       (apply + magnitudes))]))\n", "  (cond\n    [(empty? arr) #f]\n    [else\n\
    \     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \       (* (product signs) (sum (map abs arr))))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)])\n       (* (product signs) (sum (map abs arr))))]))\n",
  "  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (negative? x) -1 1))) arr)])\n       (let ([magnitudes (map\
    \ abs arr)])\n         (let ([sign-prod (apply * signs)])\n           (let ([mag-sum\
    \ (apply + magnitudes)])\n             (* sign-prod mag-sum)))))]))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      #f\n      (letrec ([sign (lambda (x)\n               \
    \        (cond [(> x 0) 1]\n                             [(< x 0) -1]\n      \
    \                       [else 0]))]\n               [magnitude (lambda (x)\n \
    \                           (cond [(> x 0) x]\n                              \
    \    [(< x 0) (- x)]\n                                  [else 0]))])\n       \
    \ (let ([signs (map sign arr)])\n          (* (apply * signs)\n             (apply\
    \ + (map magnitude arr)))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
