name: HumanEval_96_count_up_to
language: rkt
prompt: "#lang racket\n\n;; Implement a function that takes an non-negative integer\
  \ and returns a list of the first n\n;; integers that are prime numbers and less\
  \ than n.\n;; for example:\n;; >>> (count_up_to 5)\n;; (list 2 3)\n;; >>> (count_up_to\
  \ 11)\n;; (list 2 3 5 7)\n;; >>> (count_up_to 0)\n;; (list )\n;; >>> (count_up_to\
  \ 20)\n;; (list 2 3 5 7 11 13 17 19)\n;; >>> (count_up_to 1)\n;; (list )\n;; >>>\
  \ (count_up_to 18)\n;; (list 2 3 5 7 11 13 17)\n(define (count_up_to n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_up_to))\n\
  \    (check-equal? (candidate 5) (list 2 3))\n    (check-equal? (candidate 6) (list\
  \ 2 3 5))\n    (check-equal? (candidate 7) (list 2 3 5))\n    (check-equal? (candidate\
  \ 10) (list 2 3 5 7))\n    (check-equal? (candidate 0) (list ))\n    (check-equal?\
  \ (candidate 22) (list 2 3 5 7 11 13 17 19))\n    (check-equal? (candidate 1) (list\
  \ ))\n    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))\n    (check-equal?\
  \ (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))\n    (check-equal?\
  \ (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71\
  \ 73 79 83 89 97))\n))\n\n(test-humaneval)"
completions: ["  (define (is_prime? n)\n    (define (divisible? a b)\n      (= (remainder\
    \ a b) 0))\n    (define (find-divisor n test-divisor)\n      (cond ((> (square\
    \ test-divisor) n) n)\n            ((divisible? n test-divisor) test-divisor)\n\
    \            (else (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor\
    \ n 2) n))\n  (define (count_up_to_iter n acc)\n    (cond ((= n 0) acc)\n    \
    \      ((is_prime? n) (count_up_to_iter (- n 1) (cons n acc)))\n          (else\
    \ (count_up_to_iter (- n 1) acc))))\n  (count_up_to_iter n '()))\n", "  (if (=\
    \ n 0)\n      '()\n      (if (prime? n)\n          (cons n (count_up_to (- n 1)))\n\
    \          (count_up_to (- n 1)))))\n", "  (define (is-prime? n)\n    (define\
    \ (is-divisible? a b)\n      (= (remainder a b) 0))\n    (define (iter i)\n  \
    \    (cond ((< i n) (if (is-divisible? n i) #f (iter (+ i 1))))\n            (else\
    \ #t)))\n    (iter 2))\n  (define (iter i)\n    (cond ((< i n) (if (is-prime?\
    \ i) (cons i (iter (+ i 1))) (iter (+ i 1))))\n          (else '())))\n  (iter\
    \ 2))\n", "  (define (is_prime? n)\n    (define (is_prime?-iter n i)\n      (cond\n\
    \        [(= i 1) #t]\n        [(= (modulo n i) 0) #f]\n        [else (is_prime?-iter\
    \ n (- i 1))]))\n    (is_prime?-iter n (- n 1)))\n  (define (count_up_to-iter\
    \ n i)\n    (cond\n      [(= i n) '()]\n      [(is_prime? i) (cons i (count_up_to-iter\
    \ n (+ i 1)))]\n      [else (count_up_to-iter n (+ i 1))]))\n  (count_up_to-iter\
    \ n 2))\n", "  (define (is_prime? n)\n    (define (divides? a b)\n      (= (remainder\
    \ b a) 0))\n    (define (find-divisor n test-divisor)\n      (cond ((> (square\
    \ test-divisor) n) n)\n            ((divides? test-divisor n) test-divisor)\n\
    \            (else (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor\
    \ n 2) n))\n  (define (count_up_to_iter n acc)\n    (cond ((= n 0) acc)\n    \
    \      ((is_prime? n) (count_up_to_iter (- n 1) (cons n acc)))\n          (else\
    \ (count_up_to_iter (- n 1) acc))))\n  (count_up_to_iter n '()))\n", "  (define\
    \ (is-prime? n)\n    (define (divides? a b)\n      (= (remainder b a) 0))\n  \
    \  (define (find-divisor n test-divisor)\n      (cond ((> (square test-divisor)\
    \ n) n)\n            ((divides? test-divisor n) test-divisor)\n            (else\
    \ (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor n 2) n))\n  (define\
    \ (count-up-to-iter n count)\n    (cond ((= count n) '())\n          ((is-prime?\
    \ count) (cons count (count-up-to-iter n (+ count 1))))\n          (else (count-up-to-iter\
    \ n (+ count 1)))))\n  (count-up-to-iter n 2))\n", "  (cond\n    [(= n 0) '()]\n\
    \    [(= n 1) '()]\n    [else (append (list (first (prime-numbers n))) (count_up_to\
    \ (- n 1)))]))\n", "  (define (is_prime? n)\n    (define (is_prime_helper? n i)\n\
    \      (cond ((= i n) #t)\n            ((= (modulo n i) 0) #f)\n            (else\
    \ (is_prime_helper? n (+ i 1)))))\n    (is_prime_helper? n 2))\n  (define (count_up_to_helper\
    \ n i)\n    (cond ((= i n) '())\n          ((is_prime? i) (cons i (count_up_to_helper\
    \ n (+ i 1))))\n          (else (count_up_to_helper n (+ i 1)))))\n  (count_up_to_helper\
    \ n 2))\n", "  (cond\n    [(= n 0) '()]\n    [(= n 1) '()]\n    [else (cons (count_up_to_helper\
    \ n 2) (count_up_to (- n 1)))]))\n", "  (define (is_prime? n)\n    (define (divides?\
    \ a b)\n      (= (remainder b a) 0))\n    (define (find-divisor n test-divisor)\n\
    \      (cond ((> (square test-divisor) n) n)\n            ((divides? test-divisor\
    \ n) test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n\
    \    (= (find-divisor n 2) n))\n  (define (count_up_to_iter n acc)\n    (cond\
    \ ((= n 0) acc)\n          ((is_prime? n) (count_up_to_iter (- n 1) (cons n acc)))\n\
    \          (else (count_up_to_iter (- n 1) acc))))\n  (count_up_to_iter n '()))\n",
  "  (define (is_prime? n)\n    (define (is_prime_helper? n i)\n      (if (= i 1)\n\
    \          #t\n          (if (= (modulo n i) 0)\n              #f\n          \
    \    (is_prime_helper? n (- i 1)))))\n    (is_prime_helper? n (- n 1)))\n  (define\
    \ (count_up_to_helper n i)\n    (if (= i n)\n        '()\n        (if (is_prime?\
    \ i)\n            (cons i (count_up_to_helper n (+ i 1)))\n            (count_up_to_helper\
    \ n (+ i 1)))))\n  (count_up_to_helper n 2))\n", "  (define (is_prime? n)\n  \
    \  (define (divisible? a b)\n      (= (remainder a b) 0))\n    (define (find-divisor\
    \ n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((divisible?\
    \ n test-divisor) test-divisor)\n            (else (find-divisor n (+ test-divisor\
    \ 1)))))\n    (= (find-divisor n 2) n))\n  (define (count_up_to_iter n acc)\n\
    \    (cond ((= n 0) acc)\n          ((is_prime? n) (count_up_to_iter (- n 1) (cons\
    \ n acc)))\n          (else (count_up_to_iter (- n 1) acc))))\n  (count_up_to_iter\
    \ n '()))\n", "  (cond\n    [(= n 0) '()]\n    [(= n 1) '()]\n    [(= n 2) (list\
    \ 2)]\n    [else (append (list (first (count_up_to (- n 1))))\n              \
    \    (filter (lambda (x) (not (divisible? x (first (count_up_to (- n 1))))))\n\
    \                          (count_up_to (- n 1))))]))\n", "  (define (is-prime?\
    \ n)\n    (define (is-prime-helper n i)\n      (cond ((= i n) #t)\n          \
    \  ((= (modulo n i) 0) #f)\n            (else (is-prime-helper n (+ i 1)))))\n\
    \    (is-prime-helper n 2))\n  (define (count-up-to-helper n i)\n    (cond ((=\
    \ i n) '())\n          ((is-prime? i) (cons i (count-up-to-helper n (+ i 1))))\n\
    \          (else (count-up-to-helper n (+ i 1)))))\n  (count-up-to-helper n 2))\n",
  "  (define (is_prime? n)\n    (define (is_prime_helper? n i)\n      (cond ((= i\
    \ n) #t)\n            ((= (modulo n i) 0) #f)\n            (else (is_prime_helper?\
    \ n (+ i 1)))))\n    (is_prime_helper? n 2))\n  (define (count_up_to_helper n\
    \ i)\n    (cond ((= i n) (list))\n          ((is_prime? i) (cons i (count_up_to_helper\
    \ n (+ i 1))))\n          (else (count_up_to_helper n (+ i 1)))))\n  (count_up_to_helper\
    \ n 2))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((= i\
    \ 1) #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (- i 1)))))\n\
    \    (iter (- n 1)))\n  (define (iter i)\n    (cond ((= i n) '())\n          ((is-prime?\
    \ i) (cons i (iter (+ i 1))))\n          (else (iter (+ i 1)))))\n  (iter 2))\n",
  "  (define (is_prime? n)\n    (define (loop i)\n      (if (= i n)\n          #t\n\
    \          (if (= (remainder n i) 0)\n              #f\n              (loop (+\
    \ i 1)))))\n    (loop 2))\n  (define (loop i lst)\n    (if (= i n)\n        lst\n\
    \        (if (is_prime? i)\n            (loop (+ i 1) (cons i lst))\n        \
    \    (loop (+ i 1) lst))))\n  (loop 2 (list)))\n", "  (cond\n    [(= n 0) (list)]\n\
    \    [(= n 1) (list)]\n    [else (cons 2 (count_up_to (- n 1)))]))\n", "  (define\
    \ (is_prime? n)\n    (define (divisible? a b)\n      (= (remainder a b) 0))\n\
    \    (define (find-divisor n test-divisor)\n      (cond ((> (square test-divisor)\
    \ n) n)\n            ((divisible? n test-divisor) test-divisor)\n            (else\
    \ (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor n 2) n))\n  (define\
    \ (count_up_to_iter n acc)\n    (cond ((= n 0) acc)\n          ((is_prime? n)\
    \ (count_up_to_iter (- n 1) (cons n acc)))\n          (else (count_up_to_iter\
    \ (- n 1) acc))))\n  (count_up_to_iter n '()))\n", "  (define (is_prime? n)\n\
    \    (define (divides? a b)\n      (= (remainder b a) 0))\n    (define (find-divisor\
    \ n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((divides?\
    \ test-divisor n) test-divisor)\n            (else (find-divisor n (+ test-divisor\
    \ 1)))))\n    (= (find-divisor n 2) n))\n  (define (count_up_to_iter n primes)\n\
    \    (cond ((= n 0) primes)\n          ((is_prime? n) (count_up_to_iter (- n 1)\
    \ (cons n primes)))\n          (else (count_up_to_iter (- n 1) primes))))\n  (count_up_to_iter\
    \ n '()))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
