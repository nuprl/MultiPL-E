name: HumanEval_99_closest_integer
language: rkt
results:
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([value (string->number\
    \ value)])\n    (if (positive? value)\n        (round value)\n        (round (-\
    \ value)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpncdma48_.rkt:28:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpncdma48_.rkt:29:4\nactual:\
    \     16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpncdma48_.rkt:30:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest-integer-helper\
    \ value)\n    (cond\n      [(= (remainder value 1) 0) (round value)]\n      [(>\
    \ (remainder value 1) 0) (round (+ value 0.5))]\n      [(< (remainder value 1)\
    \ 0) (round (- value 0.5))]))\n  (closest-integer-helper (string->number value)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcqobihk0.rkt:30:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcqobihk0.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcqobihk0.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpyepn5vtz.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpyepn5vtz.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpyepn5vtz.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpa6i2a48u.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpa6i2a48u.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpa6i2a48u.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([n (string->number\
    \ value)])\n    (if (negative? n)\n        (- (round (- n)) 1)\n        (round\
    \ n))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpb1ql0qto.rkt:28:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpb1ql0qto.rkt:29:4\nactual:\
    \     15.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpb1ql0qto.rkt:30:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (round value) value) (round value)]\n    [(> (round value) value) (round (-\
    \ value))]\n    [else (round (+ value))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplrv6g95e.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplrv6g95e.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplrv6g95e.rkt:29:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplrv6g95e.rkt:30:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplrv6g95e.rkt:31:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8j1fyoyc.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8j1fyoyc.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp8j1fyoyc.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (string->number value) 0)\n     (round (string->number value) -1)]\n    [else\n\
    \     (round (string->number value) 1)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppu8jmme5.rkt:28:4\n\
    \nround: arity mismatch;\n the expected number of arguments does not match the\
    \ given number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppu8jmme5.rkt:29:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppu8jmme5.rkt:30:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppu8jmme5.rkt:31:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppu8jmme5.rkt:32:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([number\
    \ (string->number value)])\n    (if (integer? number)\n        number\n      \
    \  (let ([floor (floor number)])\n          (if (and (positive? number)\n    \
    \               (< (- number floor) 0.5))\n              floor\n             \
    \ (ceiling number))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n\
    \    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpsiw4y7jd.rkt:32:4\n\
    actual:     15.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpsiw4y7jd.rkt:33:4\nactual:\
    \     -15.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpsiw4y7jd.rkt:34:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp55oplsog.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp55oplsog.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp55oplsog.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest-integer-helper\
    \ value)\n    (if (negative? value)\n        (- (round (abs value)))\n       \
    \ (round value)))\n  (closest-integer-helper (string->number value)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkm3w85cv.rkt:29:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkm3w85cv.rkt:30:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpkm3w85cv.rkt:31:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_eks4xqj.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_eks4xqj.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp_eks4xqj.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n        (- (round (abs value)))\n     \
    \   (round value))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpl7tamufx.rkt:28:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpl7tamufx.rkt:29:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpl7tamufx.rkt:30:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpy3q7m1wt.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpy3q7m1wt.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpy3q7m1wt.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n    [else (error 'closest_integer\
    \ \"unknown value\")]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n\
    \    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbjjy5bxg.rkt:28:4\n\
    \nclosest_integer: unknown value\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbjjy5bxg.rkt:29:4\n\nclosest_integer:\
    \ unknown value\n--------------------\n--------------------\nERROR\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpbjjy5bxg.rkt:31:4\n\nclosest_integer: unknown\
    \ value\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmphkz84yc9.rkt:28:4\n\
    actual:     10.0\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmphkz84yc9.rkt:29:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmphkz84yc9.rkt:30:4\nactual:     -16.0\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmphkz84yc9.rkt:31:4\nactual:     16.0\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmphkz84yc9.rkt:32:4\nactual:     0.0\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp9nreu20k.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp9nreu20k.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp9nreu20k.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest-integer-helper\
    \ value)\n    (if (integer? value)\n        value\n        (if (positive? value)\n\
    \            (closest-integer-helper (+ value 1))\n            (closest-integer-helper\
    \ (- value 1)))))\n  (closest-integer-helper (string->number value)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6q1xygiz.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6q1xygiz.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp6q1xygiz.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
    \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
    \ away from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([num (string->number\
    \ value)]\n         [int (round num)])\n    (if (= num int)\n        int\n   \
    \     (if (> num 0)\n            (if (< (- num int) 0.5)\n                int\n\
    \                (+ int 1))\n            (if (< (- int num) 0.5)\n           \
    \     int\n                (- int 1))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5p6cojz2.rkt:35:4\n\
    actual:     15.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5p6cojz2.rkt:36:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp5p6cojz2.rkt:37:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
