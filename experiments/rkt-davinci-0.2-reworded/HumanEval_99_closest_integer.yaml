name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
  \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (let ([value (string->number value)])\n    (if (positive? value)\n\
    \        (round value)\n        (round (- value)))))\n", "  (define (closest-integer-helper\
    \ value)\n    (cond\n      [(= (remainder value 1) 0) (round value)]\n      [(>\
    \ (remainder value 1) 0) (round (+ value 0.5))]\n      [(< (remainder value 1)\
    \ 0) (round (- value 0.5))]))\n  (closest-integer-helper (string->number value)))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (let ([n (string->number value)])\n    (if (negative? n)\n        (- (round\
    \ (- n)) 1)\n        (round n))))\n", "  (cond\n    [(= (round value) value) (round\
    \ value)]\n    [(> (round value) value) (round (- value))]\n    [else (round (+\
    \ value))]))\n", "  (round (string->number value)))\n", "  (cond\n    [(< (string->number\
    \ value) 0)\n     (round (string->number value) -1)]\n    [else\n     (round (string->number\
    \ value) 1)]))\n", "  (let ([number (string->number value)])\n    (if (integer?\
    \ number)\n        number\n        (let ([floor (floor number)])\n          (if\
    \ (and (positive? number)\n                   (< (- number floor) 0.5))\n    \
    \          floor\n              (ceiling number))))))\n", "  (round (string->number\
    \ value)))\n", "  (define (closest-integer-helper value)\n    (if (negative? value)\n\
    \        (- (round (abs value)))\n        (round value)))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (let\
    \ ([value (string->number value)])\n    (if (negative? value)\n        (- (round\
    \ (abs value)))\n        (round value))))\n", "  (round (string->number value)))\n",
  "  (cond\n    [(string=? value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n\
    \    [else (error 'closest_integer \"unknown value\")]))\n", "  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (define (closest-integer-helper value)\n    (if (integer? value)\n\
    \        value\n        (if (positive? value)\n            (closest-integer-helper\
    \ (+ value 1))\n            (closest-integer-helper (- value 1)))))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (let*\
    \ ([num (string->number value)]\n         [int (round num)])\n    (if (= num int)\n\
    \        int\n        (if (> num 0)\n            (if (< (- num int) 0.5)\n   \
    \             int\n                (+ int 1))\n            (if (< (- int num)\
    \ 0.5)\n                int\n                (- int 1))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
