name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
  \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (let ([value (string->number value)])\n    (if (positive? value)\n\
    \        (round value)\n        (round (- value)))))\n", "  (define (closest-integer-helper\
    \ value)\n    (cond\n      [(= (remainder value 1) 0) (round value)]\n      [(>\
    \ (remainder value 1) 0) (round (+ value 0.5))]\n      [(< (remainder value 1)\
    \ 0) (round (- value 0.5))]))\n  (closest-integer-helper (string->number value)))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (let ([n (string->number value)])\n    (if (negative? n)\n        (- (round\
    \ (- n)) 1)\n        (round n))))\n", "  (cond\n    [(= (round value) value) (round\
    \ value)]\n    [(> (round value) value) (round (- value))]\n    [else (round (+\
    \ value))]))\n", "  (round (string->number value)))\n", "  (cond\n    [(< (string->number\
    \ value) 0)\n     (round (string->number value) -1)]\n    [else\n     (round (string->number\
    \ value) 1)]))\n", "  (let ([number (string->number value)])\n    (if (integer?\
    \ number)\n        number\n        (let ([floor (floor number)])\n          (if\
    \ (and (positive? number)\n                   (< (- number floor) 0.5))\n    \
    \          floor\n              (ceiling number))))))\n", "  (round (string->number\
    \ value)))\n", "  (define (closest-integer-helper value)\n    (if (negative? value)\n\
    \        (- (round (abs value)))\n        (round value)))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (let\
    \ ([value (string->number value)])\n    (if (negative? value)\n        (- (round\
    \ (abs value)))\n        (round value))))\n", "  (round (string->number value)))\n",
  "  (cond\n    [(string=? value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n\
    \    [else (error 'closest_integer \"unknown value\")]))\n", "  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (define (closest-integer-helper value)\n    (if (integer? value)\n\
    \        value\n        (if (positive? value)\n            (closest-integer-helper\
    \ (+ value 1))\n            (closest-integer-helper (- value 1)))))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (let*\
    \ ([num (string->number value)]\n         [int (round num)])\n    (if (= num int)\n\
    \        int\n        (if (> num 0)\n            (if (< (- num int) 0.5)\n   \
    \             int\n                (+ int 1))\n            (if (< (- int num)\
    \ 0.5)\n                int\n                (- int 1))))))\n", "  (let* ([num\
    \ (string->number value)]\n         [int (inexact->exact (floor num))]\n     \
    \    [frac (exact->inexact (- num int))])\n    (if (> frac 0.5)\n        (inexact->exact\
    \ (+ int 1))\n        int)))\n", "  (let ((num (string->number value)))\n    (if\
    \ (integer? num)\n        num\n        (if (and (positive? num)\n            \
    \     (negative? (modulo num 1)))\n            (round num)\n            (round\
    \ (+ num 1))))))\n", "  (let* ((number (string->number value))\n         (integer\
    \ (round number)))\n    integer))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (cond\n    [(< (string->number value)\
    \ 0) (round (string->number value) -1)]\n    [else (round (string->number value)\
    \ 1)]))\n", "  (cond\n    [(= (remainder (string->number value) 1) 0)\n     (string->number\
    \ value)]\n    [(> (remainder (string->number value) 1) 0)\n     (add1 (floor\
    \ (string->number value)))]\n    [(< (remainder (string->number value) 1) 0)\n\
    \     (sub1 (floor (string->number value)))]))\n", "  (round (string->number value)))\n",
  "  (cond\n    [(> (string->number value) 0) (round (string->number value))]\n  \
    \  [(< (string->number value) 0) (round (string->number value))]\n    [else (round\
    \ (string->number value))]))\n", "  (let ([value (string->number value)])\n  \
    \  (if (negative? value)\n        (- (round (abs value)))\n        (round value))))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (if (string=? (substring value -1) \".\")\n      (string->number (substring\
    \ value 0 -1))\n      (string->number value)))\n", "  (round (string->number value)))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (round (string->number value)))\n", "  (define (closest_integer-helper value)\n\
    \    (if (positive? value)\n        (round value)\n        (round (- value))))\n\
    \  (closest_integer-helper (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (cond\n    [(= (floor value) (ceiling value)) (floor value)]\n\
    \    [(> (abs (- value (floor value))) (abs (- value (ceiling value)))) (ceiling\
    \ value)]\n    [else (floor value)]))\n", "  (cond [(< (string->number value)\
    \ 0)\n         (round (string->number value) -1)]\n        [else\n         (round\
    \ (string->number value) 1)]))\n", "  (round (string->number value)))\n", "  (define\
    \ (closest-integer-helper value)\n    (cond ((< value 0) (- (closest-integer-helper\
    \ (- value))))\n          ((< value 1) 0)\n          ((< value 2) 1)\n       \
    \   (else (closest-integer-helper (- value 1)))))\n  (closest-integer-helper (string->number\
    \ value)))\n", "  (if (negative? (string->number value))\n      (- (round (string->number\
    \ value)))\n      (round (string->number value))))\n", "  (round (string->number\
    \ value)))\n", "  (let ([value (string->number value)])\n    (if (negative? value)\n\
    \        (- (round value))\n        (round value))))\n", "  (define (closest_integer-helper\
    \ value)\n    (if (and (integer? value) (not (zero? value)))\n        value\n\
    \        (closest_integer-helper (round value))))\n  (closest_integer-helper (string->number\
    \ value)))\n", "  (cond\n    [(= (round value) value) (round value)]\n    [(>\
    \ (round value) value) (round value)]\n    [(< (round value) value) (round value)]))\n",
  "  (round (string->number value)))\n", "  (cond\n    [(> (string->number value)\
    \ 0)\n     (round (string->number value))]\n    [(< (string->number value) 0)\n\
    \     (round (string->number value))]\n    [else\n     (string->number value)]))\n",
  "  (round (string->number value)))\n", "  (let* ([number (string->number value)]\n\
    \         [integer (round number)])\n    integer))\n", "  (define (closest-integer-helper\
    \ value)\n    (cond ((= (remainder value 1) 0) (round value))\n          ((< (remainder\
    \ value 1) 0.5) (round (- value (remainder value 1))))\n          (else (round\
    \ (+ value (- 1 (remainder value 1)))))))\n  (closest-integer-helper (string->number\
    \ value)))\n", "  (cond\n    [(< (string->number value) 0) (- (round (string->number\
    \ value)))]\n    [else (round (string->number value))]))\n", "  (let ((num (string->number\
    \ value)))\n    (if (integer? num)\n        num\n        (if (negative? num)\n\
    \            (floor num)\n            (ceiling num)))))\n", "  (let* ([number\
    \ (string->number value)]\n         [integer (round number)])\n    integer))\n",
  "  (if (string=? (substring value -1) \".\")\n      (string->number (substring value\
    \ 0 -1))\n      (string->number value)))\n", "  (define (closest-integer-helper\
    \ value)\n    (cond\n      [(= (remainder value 1) 0) (round value)]\n      [(>\
    \ (remainder value 1) 0) (round value)]\n      [(< (remainder value 1) 0) (round\
    \ value)]))\n  (closest-integer-helper (string->number value)))\n", "  (let* ([number\
    \ (string->number value)]\n         [integer (round number)])\n    integer))\n",
  "  (cond\n    [(< (string->number value) 0)\n     (- (round (string->number value)))]\n\
    \    [else\n     (round (string->number value))]))\n", "  (round (string->number\
    \ value)))\n", "  (let* ([value (string->number value)]\n         [floor (floor\
    \ value)]\n         [ceiling (ceiling value)])\n    (if (> (- value floor) (-\
    \ ceiling value))\n        ceiling\n        floor)))\n", "  (round (string->number\
    \ value)))\n", "  (cond\n    [(< (string->number value) 0)\n     (round (string->number\
    \ value) #:direction 'away-from-zero)]\n    [else\n     (round (string->number\
    \ value) #:direction 'toward-zero)]))\n", "  (round (string->number value)))\n",
  "  (define (closest_integer-helper value)\n    (cond ((= (remainder value 1) 0)\
    \ value)\n          ((< (remainder value 1) 0.5) (closest_integer-helper (- value\
    \ 1)))\n          (else (closest_integer-helper (+ value 1)))))\n  (closest_integer-helper\
    \ (string->number value)))\n", "  (define (closest-integer-helper value)\n   \
    \ (cond\n      [(= (floor value) (ceiling value)) (floor value)]\n      [(> (abs\
    \ (- value (floor value))) (abs (- value (ceiling value)))) (ceiling value)]\n\
    \      [else (floor value)]))\n  (closest-integer-helper (string->number value)))\n",
  "  (cond\n    [(< (string->number value) 0)\n     (round (string->number value)\
    \ -1)]\n    [else\n     (round (string->number value) 1)]))\n", "  (define (closest-integer-helper\
    \ value)\n    (cond\n      [(= (remainder value 1) 0) (round value)]\n      [(>\
    \ (remainder value 1) 0) (round (+ value 0.5))]\n      [(< (remainder value 1)\
    \ 0) (round (- value 0.5))]))\n  (closest-integer-helper (string->number value)))\n",
  "  (round (string->number value)))\n", "  (define (closest-integer-helper value)\n\
    \    (if (negative? value)\n        (- (floor value))\n        (ceiling value)))\n\
    \  (closest-integer-helper (string->number value)))\n", "  (cond\n    [(= (round\
    \ value) value) (round value)]\n    [(> (round value) value) (round value)]\n\
    \    [(< (round value) value) (round value)]))\n", "  (define (round-away-from-zero\
    \ n)\n    (if (negative? n)\n        (round (- n) 0)\n        (round n 0)))\n\
    \  (round-away-from-zero (string->number value)))\n", "  (cond\n    [(= (round\
    \ value) value) (round value)]\n    [(> value 0) (round value)]\n    [(< value\
    \ 0) (round value)]))\n", "  (define (closest-integer-helper value)\n    (if (negative?\
    \ value)\n        (- (closest-integer-helper (- value)))\n        (round value)))\n\
    \  (closest-integer-helper (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (let* ([number (string->number value)]\n         [integer (round\
    \ number)])\n    integer))\n", "  (round (string->number value)))\n", "  (if (equal?\
    \ (round value) (floor value))\n      (round value)\n      (if (equal? (round\
    \ value) (ceiling value))\n          (round value)\n          (if (> (abs (- (round\
    \ value) value)) (abs (- (ceiling value) value)))\n              (ceiling value)\n\
    \              (floor value)))))\n", "  (cond\n    [(= (remainder (string->number\
    \ value) 1) 0)\n     (string->number value)]\n    [(> (remainder (string->number\
    \ value) 1) 0)\n     (add1 (floor (string->number value)))]\n    [(< (remainder\
    \ (string->number value) 1) 0)\n     (sub1 (floor (string->number value)))]))\n",
  "  (if (negative? (string->number value))\n      (- (round (string->number value)))\n\
    \      (round (string->number value))))\n", "  (define (closest-integer-helper\
    \ value)\n    (cond ((= (floor value) (ceiling value))\n           (floor value))\n\
    \          ((< (abs (- value (floor value)))\n              (abs (- value (ceiling\
    \ value))))\n           (floor value))\n          (else (ceiling value))))\n \
    \ (closest-integer-helper (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\"\
    ) 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"0.00000000\")\
    \ 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]", "  (define (closest_integer-helper\
    \ value)\n    (cond\n      [(= (remainder value 1) 0) (round value)]\n      [(>\
    \ (remainder value 1) 0) (round (+ value 0.5))]\n      [(< (remainder value 1)\
    \ 0) (round (- value 0.5))]))\n  (closest_integer-helper (string->number value)))\n",
  "  (round (string->number value)))\n", "  (cond\n    [(string=? value \"0\") 0]\n\
    \    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\") 0]\n    [(string=?\
    \ value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n    [(string=? value\
    \ \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n    [(string=? value\
    \ \"0.0000000\") 0]\n    [(string=? value \"0.00000000\") 0]\n    [(string=? value\
    \ \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\") 0]\n    [(string=?\
    \ value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\") 0]\n \
    \   [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]", "  (define (closest_integer-helper\
    \ value)\n    (cond\n      [(= (modulo value 1) 0) (string->number value)]\n \
    \     [(> (modulo value 1) 0) (string->number (number->string (ceiling value)))]\n\
    \      [(< (modulo value 1) 0) (string->number (number->string (floor value)))]))\n\
    \  (closest_integer-helper (string->number value)))\n", "  (cond\n    [(= (round\
    \ value) value) (round value)]\n    [(> (round value) value) (round value)]\n\
    \    [(< (round value) value) (round value)]))\n", "  (round (string->number value)))\n",
  "  (if (negative? (string->number value))\n      (- (round (string->number value)))\n\
    \      (round (string->number value))))\n", "  (cond\n    [(= (remainder (string->number\
    \ value) 1) 0)\n     (string->number value)]\n    [(> (remainder (string->number\
    \ value) 1) 0)\n     (add1 (floor (string->number value)))]\n    [(< (remainder\
    \ (string->number value) 1) 0)\n     (sub1 (floor (string->number value)))]))\n",
  "  (if (string=? (substring value (sub1 (string-length value)) (string-length value))\
    \ \".\")\n      (round (string->number value))\n      (string->number value)))\n",
  "  (if (string=? (substring value -1) \".\")\n      (string->number (substring value\
    \ 0 -1))\n      (string->number value)))\n", "  (round (string->number value)))\n",
  "  (define (round-away-from-zero x)\n    (if (negative? x)\n        (round (- x\
    \ 0.5))\n        (round (+ x 0.5))))\n  (round-away-from-zero (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (let* ([number (string->number value)]\n         [integer (round\
    \ number)])\n    integer))\n", "  (if (positive? (string->number value))\n   \
    \   (round (string->number value))\n      (round (string->number value) -1)))\n",
  "  (round (string->number value)))\n", "  (round (string->number value)))\n", " \
    \ (if (string=? (substring value -1) \".\")\n      (string->number (substring\
    \ value 0 -1))\n      (string->number value)))\n", "  (round (string->number value)))\n",
  "  (define (closest-integer-helper value)\n    (cond ((< value 0) (- (closest-integer-helper\
    \ (- value))))\n          ((< value 1) 0)\n          ((< value 2) 1)\n       \
    \   (else (+ (closest-integer-helper (- value 1)) 1))))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (define\
    \ (closest-integer-helper value)\n    (if (integer? value)\n        value\n  \
    \      (closest-integer-helper (round value))))\n  (closest-integer-helper (string->number\
    \ value)))\n", "  (let ([value-as-number (string->number value)])\n    (if (integer?\
    \ value-as-number)\n        value-as-number\n        (let ([rounded-down (floor\
    \ value-as-number)]\n              [rounded-up (ceiling value-as-number)])\n \
    \         (if (> (abs (- value-as-number rounded-down))\n                 (abs\
    \ (- value-as-number rounded-up)))\n              rounded-up\n              rounded-down)))))\n",
  "  (define (closest-integer-helper value)\n    (if (negative? value)\n        (-\
    \ (closest-integer-helper (- value)))\n        (if (zero? (remainder value 1))\n\
    \            value\n            (if (< value 1)\n                0\n         \
    \       (if (> value 1)\n                    (closest-integer-helper (+ value\
    \ -1))\n                    1)))))\n  (closest-integer-helper (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (cond\n    [(< (string->number value) 0) (round (string->number\
    \ value) #:direction '-) ]\n    [else (round (string->number value) #:direction\
    \ '+)]))\n", "  (if (string-contains value \".\")\n      (if (string-contains\
    \ value \"-\")\n          (string->number (substring value 0 (string-index value\
    \ \".\")))\n          (string->number (substring value 0 (string-index value \"\
    .\"))))\n      (string->number value)))\n", "  (let* ([value (string->number value)]\n\
    \         [floor (floor value)]\n         [ceiling (ceiling value)])\n    (if\
    \ (> (- value floor) (- ceiling value))\n        ceiling\n        floor)))\n",
  "  (let ([num (string->number value)])\n    (if (negative? num)\n        (- (round\
    \ (abs num)))\n        (round num))))\n", "  (round (string->number value)))\n",
  "  (round (string->number value)))\n", "  (cond\n    [(< (string->number value)\
    \ 0)\n     (round (string->number value) -1)]\n    [else\n     (round (string->number\
    \ value) 1)]))\n", "  (if (not (string? value))\n      (error \"closest_integer:\
    \ value must be a string\")\n      (let ((num (string->number value)))\n     \
    \   (if (not (number? num))\n            (error \"closest_integer: value must\
    \ be a number\")\n            (round num)))))\n", "  (define (closest-integer-helper\
    \ value)\n    (if (negative? value)\n        (- (round value))\n        (round\
    \ value)))\n  (closest-integer-helper (string->number value)))\n", "  (define\
    \ (closest_integer-helper value)\n    (if (negative? value)\n        (- (closest_integer-helper\
    \ (- value)))\n        (if (integer? value)\n            value\n            (if\
    \ (< value (add1 value))\n                value\n                (add1 value)))))\n\
    \  (closest_integer-helper (string->number value)))\n", "  (define (closest_integer-helper\
    \ value)\n    (cond\n      [(= (remainder value 1) 0) (round value)]\n      [(<\
    \ (remainder value 1) 0.5) (round value)]\n      [else (+ (round value) 1)]))\n\
    \  (closest_integer-helper (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (let ([num (string->number value)])\n    (if (negative? num)\n\
    \        (- (round (abs num)))\n        (round num))))\n", "  (round (string->number\
    \ value)))\n", "  (let ([num (string->number value)])\n    (if (negative? num)\n\
    \        (- (round (abs num)))\n        (round num))))\n", "  (if (negative? (string->number\
    \ value))\n      (- (round (string->number value)))\n      (round (string->number\
    \ value))))\n", "  (if (string-contains value \".\")\n      (if (string-contains\
    \ value \"-\")\n          (string->number (substring value 0 (string-index value\
    \ \".\")))\n          (string->number (substring value 0 (string-index value \"\
    .\"))))\n      (string->number value)))\n", "  (cond\n    [(< (string->number\
    \ value) 0) (round (string->number value) -1)]\n    [else (round (string->number\
    \ value) 1)]))\n", "  (define (closest_integer-helper value)\n    (if (negative?\
    \ value)\n        (- (round value))\n        (round value)))\n  (closest_integer-helper\
    \ (string->number value)))\n", "  (cond\n    [(> (string->number value) 0) (round\
    \ (string->number value))]\n    [(< (string->number value) 0) (round (string->number\
    \ value))]\n    [else (round (string->number value))]))\n", "  (define (round-away-from-zero\
    \ value)\n    (if (positive? value)\n        (ceiling value)\n        (floor value)))\n\
    \  (round-away-from-zero (string->number value)))\n", "  (if (negative? (string->number\
    \ value))\n      (- (round (string->number value)))\n      (round (string->number\
    \ value))))\n", "  (cond\n    [(< value 0) (round (string->number value) -1)]\n\
    \    [else (round (string->number value) 1)]))\n", "  (round (string->number value)))\n",
  "  (round (string->number value)))\n", "  (if (equal? (remainder value 1) 0)\n \
    \     (string->number value)\n      (if (equal? (remainder value 1) 0.5)\n   \
    \       (if (positive? value)\n              (string->number (number->string (+\
    \ value 0.5)))\n              (string->number (number->string (- value 0.5))))\n\
    \          (if (positive? value)\n              (string->number (number->string\
    \ (round value)))\n              (string->number (number->string (round value)))))))\n",
  "  (round (string->number value)))\n", "  (if (string=? value \"0\")\n      0\n\
    \      (let ([sign (string-ref value 0)])\n        (if (string=? sign \"-\")\n\
    \            (- (round (string->number (substring value 1))) 1)\n            (round\
    \ (string->number value))))))\n", "  (if (negative? (string->number value))\n\
    \      (- (round (string->number value)))\n      (round (string->number value))))\n",
  "  (cond\n    [(< (string->number value) 0)\n     (round (string->number value)\
    \ -1)]\n    [else\n     (round (string->number value) 1)]))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (if (string=? (substring\
    \ value -1) \".\")\n      (round (string->number value))\n      (string->number\
    \ value)))\n", "  (if (string=? (substring value -1) \".\")\n      (string->number\
    \ (substring value 0 -1))\n      (string->number value)))\n", "  (if (string=?\
    \ (substring value -1) \".\")\n      (string->number (substring value 0 -1))\n\
    \      (string->number value)))\n", "  (cond\n    [(= (round value) (floor value))\
    \ (floor value)]\n    [(= (round value) (ceiling value)) (ceiling value)]\n  \
    \  [(> (round value) value) (floor value)]\n    [(< (round value) value) (ceiling\
    \ value)]))\n", "  (cond\n    [(< (string->number value) 0)\n     (round (string->number\
    \ value) -1)]\n    [else\n     (round (string->number value) 1)]))\n", "  (round\
    \ (string->number value)))\n", "  (round (string->number value)))\n", "  (cond\n\
    \    [(string=? value \"0\") 0]\n    [(string=? value \"-0\") 0]\n    [(string=?\
    \ value \"0.0\") 0]\n    [(string=? value \"-0.0\") 0]\n    [(string=? value \"\
    0.00\") 0]\n    [(string=? value \"-0.00\") 0]\n    [(string=? value \"0.000\"\
    ) 0]\n    [(string=? value \"-0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"-0.0000\") 0]\n    [(string=? value \"0.00000\") 0]\n\
    \    [(string=? value \"-0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"-0.000000\") 0]\n    [(string=? value \"0.0000000\") 0]\n\
    \    [(string=? value \"-0.0000000\") 0]\n    [(string=? value \"0.00000000\"\
    ) 0]\n    [(string=? value \"-0.00000000\") 0]\n    [(string=? value \"0.000000000\"\
    ) 0]\n    [(string=? value \"-0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"-0.0000000000\") 0]\n    [(string=? value \"0.00000000000\"\
    ) 0]\n    [(string=? value \"-0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"-0.000000000000\") 0]\n    [(string=? value \"0.0000000000000\"\
    ) 0]\n    [(string=? value \"-0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"-0.00000000000000\") 0]\n    [(string=? value \"\
    0.000000000000000\") 0]\n    [(string=? value \"-0.000000000000000\") 0]\n   \
    \ [(string=? value \"0.0000000000000000\") 0]\n    [(string=? value \"-0.0000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000\") 0]\n    [(string=?", "  (round\
    \ (string->number value)))\n", "  (cond\n    [(< value 0) (round (string->number\
    \ value) -1)]\n    [else (round (string->number value) 1)]))\n", "  (cond\n  \
    \  [(> (string->number value) 0)\n     (round (string->number value))]\n    [(<\
    \ (string->number value) 0)\n     (round (string->number value))]\n    [else\n\
    \     (round (string->number value))]))\n", "  (cond\n    [(< (string->number\
    \ value) 0)\n     (round (string->number value) -1)]\n    [else\n     (round (string->number\
    \ value) 1)]))\n", "  (round (string->number value)))\n", "  (if (positive? (string->number\
    \ value))\n      (round (string->number value))\n      (round (- (string->number\
    \ value)))))\n", "  (round (string->number value)))\n", "  (cond\n    [(< (string->number\
    \ value) 0) (round (string->number value) -1)]\n    [else (round (string->number\
    \ value) 1)]))\n", "  (define (closest-integer-helper value)\n    (if (negative?\
    \ value)\n        (- (round value))\n        (round value)))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (cond\n    [(string=? value \"10\") 10]\n  \
    \  [(string=? value \"15.3\") 15]\n    [(string=? value \"14.5\") 15]\n    [(string=?\
    \ value \"-14.5\") -15]\n    [else \"Not a valid input\"]))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (define (round-away-from-zero\
    \ n)\n    (if (negative? n)\n        (round (- n) 0)\n        (round n 0)))\n\
    \  (round-away-from-zero (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (cond\n    [(< value\
    \ 0) (round (string->number value) -1)]\n    [else (round (string->number value)\
    \ 1)]))\n", "  (cond\n    [(> (string->number value) 0) (round (string->number\
    \ value))]\n    [(< (string->number value) 0) (round (string->number value))]\n\
    \    [else (round (string->number value))]))\n", "  (cond\n    [(< (string->number\
    \ value) 0)\n     (string->number (number->string (round (string->number value))))]\n\
    \    [else\n     (string->number (number->string (round (string->number value))))]))\n",
  "  (round (string->number value)))\n", "  (if (positive? (string->number value))\n\
    \      (round (string->number value))\n      (round (string->number value) 0)))\n",
  "  (if (string=? (substring value (add1 (string-length value)) (string-length value))\
    \ \".\")\n      (round (string->number value))\n      (string->number value)))\n",
  "  (round (string->number value)))\n", "  (define (closest-integer-helper value)\n\
    \    (if (not (string? value))\n        (error \"closest_integer: value must be\
    \ a string\")\n        (let ((num (string->number value)))\n          (if (not\
    \ (number? num))\n              (error \"closest_integer: value must be a number\"\
    )\n              (if (integer? num)\n                  num\n                 \
    \ (let ((int (round num)))\n                    (if (and (= (abs (- num int))\
    \ 0.5)\n                             (not (zero? num)))\n                    \
    \    (if (> num 0)\n                            (add1 int)\n                 \
    \           (sub1 int))\n                        int)))))))\n  (closest-integer-helper\
    \ value))\n", "  (define (closest-integer-helper value)\n    (if (negative? value)\n\
    \        (- (round value))\n        (round value)))\n  (closest-integer-helper\
    \ (string->number value)))\n", "  (cond\n    [(string=? value \"0\") 0]\n    [(string=?\
    \ value \"0.0\") 0]\n    [(string=? value \"0.00\") 0]\n    [(string=? value \"\
    0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n    [(string=? value \"0.00000\"\
    ) 0]\n    [(string=? value \"0.000000\") 0]\n    [(string=? value \"0.0000000\"\
    ) 0]\n    [(string=? value \"0.00000000\") 0]\n    [(string=? value \"0.000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000\") 0]\n    [(string=? value \"0.00000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000\") 0]\n    [(string=? value \"0.0000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000\") 0]\n    [(string=? value \"0.000000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000000\") 0]\n    [(string=? value \"\
    0.00000000000000000\") 0]\n    [(string=? value \"0.000000000000000000\") 0]\n\
    \    [(string=? value \"0.0000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.0000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000000000000\") 0]", "  (cond\n\
    \    [(= (floor value) (ceiling value)) (floor value)]\n    [(> (modulo value\
    \ 1) 0.5) (ceiling value)]\n    [else (floor value)]))\n", "  (let* ([value (string->number\
    \ value)]\n         [floor (floor value)]\n         [ceiling (ceiling value)])\n\
    \    (if (< (abs (- value floor)) (abs (- value ceiling)))\n        floor\n  \
    \      ceiling)))\n", "  (let ([value (string->number value)])\n    (if (negative?\
    \ value)\n        (- (round (abs value)))\n        (round value))))\n", "  (let\
    \ ([value (string->number value)])\n    (if (negative? value)\n        (- (round\
    \ (abs value)))\n        (round value))))\n", "  (round (string->number value)))\n",
  "  (cond\n    [(= (round (string->number value)) (string->number value))\n     (string->number\
    \ value)]\n    [(> (round (string->number value)) (string->number value))\n  \
    \   (round (string->number value))]\n    [else\n     (- (round (string->number\
    \ value)) 1)]))\n", "  (cond\n    [(= (round value) value) (round value)]\n  \
    \  [(< value 0) (- (round value))]\n    [else (round value)]))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n", "  (let* ([num (string->number value)]\n         [int (round num)])\n\
    \    (if (and (integer? num)\n             (= num int))\n        int\n       \
    \ (if (< num 0)\n            (round (add1 num))\n            (round (sub1 num))))))\n",
  "  (define (closest_integer-helper value)\n    (cond\n      [(= (floor value) (ceiling\
    \ value)) (floor value)]\n      [(> (abs (- value (floor value))) (abs (- value\
    \ (ceiling value)))) (ceiling value)]\n      [else (floor value)]))\n  (closest_integer-helper\
    \ (string->number value)))\n", "  (let ([num (string->number value)])\n    (if\
    \ (negative? num)\n        (- (round num))\n        (round num))))\n", "  (if\
    \ (string=? (substring value -1) \".\")\n      (string->number (substring value\
    \ 0 -1))\n      (string->number value)))\n", "  (if (string=? (substring value\
    \ -1) \".\")\n      (string->number (substring value 0 -1))\n      (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (round (string->number\
    \ value)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
