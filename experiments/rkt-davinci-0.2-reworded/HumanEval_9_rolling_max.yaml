name: HumanEval_9_rolling_max
language: rkt
prompt: "#lang racket\n\n;; From a given list of integers, generate a list of rolling\
  \ maximum element found until given moment\n;; in the sequence.\n;; >>> (rolling_max\
  \ (list 1 2 3 2 3 4 2))\n;; (list 1 2 3 3 3 4 4)\n(define (rolling_max numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 1 2 3 4)) (list 1 2 3 4))\n    (check-equal? (candidate (list 4 3 2 1)) (list\
  \ 4 4 4 4))\n    (check-equal? (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100))\n\
  ))\n\n(test-humaneval)"
completions: ["  (define (rolling_max_iter numbers max-so-far)\n    (cond\n      [(empty?\
    \ numbers) empty]\n      [(empty? max-so-far) (rolling_max_iter (rest numbers)\
    \ (list (first numbers)))]\n      [else\n       (cons (max (first max-so-far)\
    \ (first numbers))\n             (rolling_max_iter (rest numbers) (cons (first\
    \ numbers) max-so-far)))]))\n  (rolling_max_iter numbers empty))\n", "  (define\
    \ (rolling_max_iter numbers max-so-far)\n    (cond\n      [(empty? numbers) empty]\n\
    \      [(> (first numbers) max-so-far)\n       (cons (first numbers) (rolling_max_iter\
    \ (rest numbers) (first numbers)))]\n      [else\n       (cons max-so-far (rolling_max_iter\
    \ (rest numbers) max-so-far))]))\n  (rolling_max_iter numbers (first numbers)))\n",
  "  (define (rolling_max_iter numbers maxes)\n    (cond\n      [(empty? numbers)\
    \ (reverse maxes)]\n      [else (rolling_max_iter (rest numbers) (cons (max (first\
    \ numbers) (first maxes)) maxes))]))\n  (rolling_max_iter (rest numbers) (list\
    \ (first numbers))))\n", "  (define (rolling_max_iter numbers max-so-far)\n  \
    \  (cond\n      [(empty? numbers) '()]\n      [(> (first numbers) max-so-far)\n\
    \       (cons (first numbers) (rolling_max_iter (rest numbers) (first numbers)))]\n\
    \      [else\n       (cons max-so-far (rolling_max_iter (rest numbers) max-so-far))]))\n\
    \  (rolling_max_iter numbers (first numbers)))\n", "  (if (null? numbers)\n  \
    \    '()\n      (cons (apply max numbers)\n            (rolling_max (cdr numbers)))))\n",
  "  (define (rolling_max-iter numbers max-so-far)\n    (if (null? numbers)\n    \
    \    '()\n        (cons (max (car numbers) max-so-far)\n              (rolling_max-iter\
    \ (cdr numbers) (max (car numbers) max-so-far)))))\n  (rolling_max-iter numbers\
    \ 0))\n", "  (define (rolling_max_iter numbers max-so-far)\n    (if (null? numbers)\n\
    \        '()\n        (cons max-so-far (rolling_max_iter (cdr numbers) (max (car\
    \ numbers) max-so-far)))))\n  (rolling_max_iter numbers (car numbers)))\n", " \
    \ (define (rolling_max_iter numbers max-so-far)\n    (if (null? numbers)\n   \
    \     '()\n        (cons (max (car numbers) max-so-far)\n              (rolling_max_iter\
    \ (cdr numbers) (max (car numbers) max-so-far)))))\n  (rolling_max_iter numbers\
    \ 0))\n", "  (let loop ([numbers numbers]\n             [max-so-far -1]\n    \
    \         [result '()])\n    (cond [(empty? numbers) (reverse result)]\n     \
    \     [(> (first numbers) max-so-far)\n           (loop (rest numbers)\n     \
    \            (first numbers)\n                 (cons (first numbers) result))]\n\
    \          [else\n           (loop (rest numbers)\n                 max-so-far\n\
    \                 (cons max-so-far result))])))\n", "  (let loop ([numbers numbers]\n\
    \             [max-so-far (first numbers)]\n             [result (list max-so-far)])\n\
    \    (if (null? (rest numbers))\n        result\n        (loop (rest numbers)\n\
    \              (max max-so-far (first (rest numbers)))\n              (append\
    \ result (list (max max-so-far (first (rest numbers)))))))))\n", "  (define (rolling_max_iter\
    \ numbers max-so-far result)\n    (cond\n      [(empty? numbers) (reverse result)]\n\
    \      [(> (first numbers) max-so-far)\n       (rolling_max_iter (rest numbers)\
    \ (first numbers) (cons (first numbers) result))]\n      [else\n       (rolling_max_iter\
    \ (rest numbers) max-so-far (cons max-so-far result))]))\n  (rolling_max_iter\
    \ numbers (first numbers) (list (first numbers))))\n", "  (define (rolling_max_helper\
    \ numbers max-so-far)\n    (cond\n      [(empty? numbers) '()]\n      [(> (first\
    \ numbers) max-so-far)\n       (cons (first numbers) (rolling_max_helper (rest\
    \ numbers) (first numbers)))]\n      [else\n       (cons max-so-far (rolling_max_helper\
    \ (rest numbers) max-so-far))]))\n  (rolling_max_helper numbers (first numbers)))\n",
  "  (define (rolling_max_iter numbers max-so-far result)\n    (cond\n      [(empty?\
    \ numbers) (reverse result)]\n      [(> (first numbers) max-so-far)\n       (rolling_max_iter\
    \ (rest numbers) (first numbers) (cons (first numbers) result))]\n      [else\n\
    \       (rolling_max_iter (rest numbers) max-so-far (cons max-so-far result))]))\n\
    \  (rolling_max_iter numbers -1 '()))\n", "  (let loop ([numbers numbers]\n  \
    \           [max-so-far -1]\n             [result '()])\n    (cond [(empty? numbers)\
    \ (reverse result)]\n          [(> (first numbers) max-so-far)\n           (loop\
    \ (rest numbers)\n                 (first numbers)\n                 (cons (first\
    \ numbers) result))]\n          [else\n           (loop (rest numbers)\n     \
    \            max-so-far\n                 (cons max-so-far result))])))\n", " \
    \ (define (rolling_max_iter numbers max-so-far)\n    (cond\n      [(empty? numbers)\
    \ (list)]\n      [(> (first numbers) max-so-far)\n       (cons (first numbers)\
    \ (rolling_max_iter (rest numbers) (first numbers)))]\n      [else\n       (cons\
    \ max-so-far (rolling_max_iter (rest numbers) max-so-far))]))\n  (rolling_max_iter\
    \ numbers (first numbers)))\n", "  (define (rolling_max_iter numbers max-so-far)\n\
    \    (cond\n      [(empty? numbers) empty]\n      [(> (first numbers) max-so-far)\n\
    \       (cons (first numbers) (rolling_max_iter (rest numbers) (first numbers)))]\n\
    \      [else\n       (cons max-so-far (rolling_max_iter (rest numbers) max-so-far))]))\n\
    \  (rolling_max_iter numbers (first numbers)))\n", "  (if (null? numbers)\n  \
    \    '()\n      (cons (apply max numbers)\n            (rolling_max (cdr numbers)))))\n",
  "  (define (rolling_max-iter max-so-far numbers)\n    (cond\n      [(empty? numbers)\
    \ empty]\n      [(> (first numbers) max-so-far)\n       (cons (first numbers)\
    \ (rolling_max-iter (first numbers) (rest numbers)))]\n      [else\n       (cons\
    \ max-so-far (rolling_max-iter max-so-far (rest numbers)))]))\n  (rolling_max-iter\
    \ (first numbers) (rest numbers)))\n", "  (define (rolling_max_iter numbers max-so-far)\n\
    \    (if (null? numbers)\n        '()\n        (cons max-so-far (rolling_max_iter\
    \ (cdr numbers) (max (car numbers) max-so-far)))))\n  (rolling_max_iter numbers\
    \ (car numbers)))\n", "  (let loop ([numbers numbers]\n             [max-so-far\
    \ (first numbers)]\n             [result (list max-so-far)])\n    (if (null? (rest\
    \ numbers))\n        result\n        (loop (rest numbers)\n              (if (&gt;\
    \ (first numbers) max-so-far)\n                  (first numbers)\n           \
    \       max-so-far)\n              (cons (if (&gt; (first numbers) max-so-far)\n\
    \                        (first numbers)\n                        max-so-far)\n\
    \                    result)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
