name: HumanEval_90_next_smallest
language: rkt
prompt: "#lang racket\n\n;; You are given a list of integers.\n;; Write a function\
  \ next_smallest() that returns the 2nd smallest element of the list.\n;; Return\
  \ #f if there is no such element.\n;; >>> (next_smallest (list 1 2 3 4 5))\n;; 2\n\
  ;; >>> (next_smallest (list 5 1 4 3 2))\n;; 2\n;; >>> (next_smallest (list ))\n\
  ;; #f\n;; >>> (next_smallest (list 1 1))\n;; #f\n(define (next_smallest lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n\
  \    (check-equal? (candidate (list 1 2 3 4 5)) 2)\n    (check-equal? (candidate\
  \ (list 5 1 4 3 2)) 2)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
  \ (candidate (list 1 1)) #f)\n    (check-equal? (candidate (list 1 1 1 1 0)) 1)\n\
  \    (check-equal? (candidate (list 1 1)) #f)\n    (check-equal? (candidate (list\
  \ -35 34 12 -45)) -35)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n\
    \     (let ([min (apply min lst)])\n       (cond\n         [(= min (second lst))\
    \ (next_smallest (rest lst))]\n         [else (second lst)]))]))\n", "  (define\
    \ (next_smallest_helper lst smallest second-smallest)\n    (cond\n      [(empty?\
    \ lst) second-smallest]\n      [(< (first lst) smallest) (next_smallest_helper\
    \ (rest lst) (first lst) smallest)]\n      [(< (first lst) second-smallest) (next_smallest_helper\
    \ (rest lst) smallest (first lst))]\n      [else (next_smallest_helper (rest lst)\
    \ smallest second-smallest)]))\n  (next_smallest_helper lst (first lst) (first\
    \ lst)))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n\
    \        (if (null? (cdr sorted))\n            #f\n            (car (cdr sorted))))))\n",
  "  (cond [(null? lst) #f]\n        [(null? (cdr lst)) #f]\n        [else (second\
    \ (sort lst <))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort\
    \ lst <)])\n        (if (null? (cdr sorted))\n            #f\n            (cadr\
    \ sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n\
    \    [else\n     (let* ([sorted (sort lst <)]\n            [first (first sorted)]\n\
    \            [second (first (rest sorted))])\n       (if (= first second)\n  \
    \         #f\n           second))]))\n", "  (cond\n    [(null? lst) #f]\n    [(null?\
    \ (cdr lst)) #f]\n    [else\n     (let* ([min (apply min lst)]\n            [min-index\
    \ (index-of min lst)]\n            [lst-without-min (remove-at min-index lst)]\n\
    \            [min2 (apply min lst-without-min)]\n            [min2-index (index-of\
    \ min2 lst-without-min)]\n            [lst-without-min2 (remove-at min2-index\
    \ lst-without-min)]\n            [min3 (apply min lst-without-min2)])\n      \
    \ min3)]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n\
    \    [else\n     (let* ([sorted (sort lst <)]\n            [first (first sorted)]\n\
    \            [second (first (rest sorted))])\n       (if (= first second)\n  \
    \         #f\n           second))]))\n", "  (cond\n    [(empty? lst) #f]\n   \
    \ [(empty? (rest lst)) #f]\n    [else (let ([min (min (first lst) (second lst))])\n\
    \            (for/min ([x (in-list (rest (rest lst)))])\n              (if (<\
    \ x min) x min)))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst))\
    \ #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n         [(=\
    \ min (first lst)) (next_smallest (rest lst))]\n         [else (apply min (filter\
    \ (lambda (x) (not (= x min))) lst))]))]))\n", "  (cond\n    [(empty? lst) #f]\n\
    \    [(empty? (rest lst)) #f]\n    [else\n     (let ([smallest (min (first lst)\
    \ (second lst))])\n       (for/fold ([smallest smallest]) ([x (in-list (rest (rest\
    \ lst)))])\n         (if (< x smallest)\n             x\n             smallest)))]))\n",
  "  (cond [(empty? lst) #f]\n        [(empty? (rest lst)) #f]\n        [else (second\
    \ (sort lst))]))\n", "  (if (null? lst)\n      #f\n      (let* ([sorted (sort\
    \ lst <)]\n             [first (car sorted)]\n             [second (car (cdr sorted))])\n\
    \        (if (equal? first second)\n            #f\n            second))))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([min (apply min lst)])\n       (cond\n         [(= min (second lst)) (next_smallest\
    \ (rest lst))]\n         [else (second lst)]))]))\n", "  (if (null? lst)\n   \
    \   #f\n      (let* ([sorted (sort lst <)]\n             [min (car sorted)]\n\
    \             [second (cadr sorted)])\n        (if (equal? min second)\n     \
    \       #f\n            second))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty?\
    \ (rest lst)) #f]\n    [else\n     (let ([smallest (min (first lst) (second lst))])\n\
    \       (for/fold ([smallest smallest]) ([x (in-list (rest (rest lst)))])\n  \
    \       (let ([new-smallest (min x smallest)])\n           (if (= new-smallest\
    \ smallest)\n               smallest\n               new-smallest))))]))\n", " \
    \ (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null?\
    \ (cdr sorted))\n            #f\n            (cadr sorted)))))\n", "  (if (null?\
    \ lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr\
    \ sorted))\n            #f\n            (cadr sorted)))))\n", "  (cond\n    [(null?\
    \ lst) #f]\n    [(null? (cdr lst)) #f]\n    [else (apply min (cdr lst))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let*\
    \ ([min (min (first lst) (second lst))]\n            [max (max (first lst) (second\
    \ lst))]\n            [rest (rest (rest lst))])\n       (cond\n         [(empty?\
    \ rest) min]\n         [else\n          (let loop ([rest rest] [min min] [max\
    \ max])\n            (cond\n              [(empty? rest) min]\n              [(<\
    \ (first rest) min) (loop (rest rest) (first rest) max)]\n              [(< (first\
    \ rest) max) (loop (rest rest) min (first rest))]\n              [else (loop (rest\
    \ rest) min max)]))]))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
