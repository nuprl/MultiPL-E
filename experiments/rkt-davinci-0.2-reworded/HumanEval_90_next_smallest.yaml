name: HumanEval_90_next_smallest
language: rkt
prompt: "#lang racket\n\n;; You are given a list of integers.\n;; Write a function\
  \ next_smallest() that returns the 2nd smallest element of the list.\n;; Return\
  \ #f if there is no such element.\n;; >>> (next_smallest (list 1 2 3 4 5))\n;; 2\n\
  ;; >>> (next_smallest (list 5 1 4 3 2))\n;; 2\n;; >>> (next_smallest (list ))\n\
  ;; #f\n;; >>> (next_smallest (list 1 1))\n;; #f\n(define (next_smallest lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n\
  \    (check-equal? (candidate (list 1 2 3 4 5)) 2)\n    (check-equal? (candidate\
  \ (list 5 1 4 3 2)) 2)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
  \ (candidate (list 1 1)) #f)\n    (check-equal? (candidate (list 1 1 1 1 0)) 1)\n\
  \    (check-equal? (candidate (list 1 1)) #f)\n    (check-equal? (candidate (list\
  \ -35 34 12 -45)) -35)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n\
    \     (let ([min (apply min lst)])\n       (cond\n         [(= min (second lst))\
    \ (next_smallest (rest lst))]\n         [else (second lst)]))]))\n", "  (define\
    \ (next_smallest_helper lst smallest second-smallest)\n    (cond\n      [(empty?\
    \ lst) second-smallest]\n      [(< (first lst) smallest) (next_smallest_helper\
    \ (rest lst) (first lst) smallest)]\n      [(< (first lst) second-smallest) (next_smallest_helper\
    \ (rest lst) smallest (first lst))]\n      [else (next_smallest_helper (rest lst)\
    \ smallest second-smallest)]))\n  (next_smallest_helper lst (first lst) (first\
    \ lst)))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n\
    \        (if (null? (cdr sorted))\n            #f\n            (car (cdr sorted))))))\n",
  "  (cond [(null? lst) #f]\n        [(null? (cdr lst)) #f]\n        [else (second\
    \ (sort lst <))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort\
    \ lst <)])\n        (if (null? (cdr sorted))\n            #f\n            (cadr\
    \ sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n\
    \    [else\n     (let* ([sorted (sort lst <)]\n            [first (first sorted)]\n\
    \            [second (first (rest sorted))])\n       (if (= first second)\n  \
    \         #f\n           second))]))\n", "  (cond\n    [(null? lst) #f]\n    [(null?\
    \ (cdr lst)) #f]\n    [else\n     (let* ([min (apply min lst)]\n            [min-index\
    \ (index-of min lst)]\n            [lst-without-min (remove-at min-index lst)]\n\
    \            [min2 (apply min lst-without-min)]\n            [min2-index (index-of\
    \ min2 lst-without-min)]\n            [lst-without-min2 (remove-at min2-index\
    \ lst-without-min)]\n            [min3 (apply min lst-without-min2)])\n      \
    \ min3)]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n\
    \    [else\n     (let* ([sorted (sort lst <)]\n            [first (first sorted)]\n\
    \            [second (first (rest sorted))])\n       (if (= first second)\n  \
    \         #f\n           second))]))\n", "  (cond\n    [(empty? lst) #f]\n   \
    \ [(empty? (rest lst)) #f]\n    [else (let ([min (min (first lst) (second lst))])\n\
    \            (for/min ([x (in-list (rest (rest lst)))])\n              (if (<\
    \ x min) x min)))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst))\
    \ #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n         [(=\
    \ min (first lst)) (next_smallest (rest lst))]\n         [else (apply min (filter\
    \ (lambda (x) (not (= x min))) lst))]))]))\n", "  (cond\n    [(empty? lst) #f]\n\
    \    [(empty? (rest lst)) #f]\n    [else\n     (let ([smallest (min (first lst)\
    \ (second lst))])\n       (for/fold ([smallest smallest]) ([x (in-list (rest (rest\
    \ lst)))])\n         (if (< x smallest)\n             x\n             smallest)))]))\n",
  "  (cond [(empty? lst) #f]\n        [(empty? (rest lst)) #f]\n        [else (second\
    \ (sort lst))]))\n", "  (if (null? lst)\n      #f\n      (let* ([sorted (sort\
    \ lst <)]\n             [first (car sorted)]\n             [second (car (cdr sorted))])\n\
    \        (if (equal? first second)\n            #f\n            second))))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([min (apply min lst)])\n       (cond\n         [(= min (second lst)) (next_smallest\
    \ (rest lst))]\n         [else (second lst)]))]))\n", "  (if (null? lst)\n   \
    \   #f\n      (let* ([sorted (sort lst <)]\n             [min (car sorted)]\n\
    \             [second (cadr sorted)])\n        (if (equal? min second)\n     \
    \       #f\n            second))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty?\
    \ (rest lst)) #f]\n    [else\n     (let ([smallest (min (first lst) (second lst))])\n\
    \       (for/fold ([smallest smallest]) ([x (in-list (rest (rest lst)))])\n  \
    \       (let ([new-smallest (min x smallest)])\n           (if (= new-smallest\
    \ smallest)\n               smallest\n               new-smallest))))]))\n", " \
    \ (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null?\
    \ (cdr sorted))\n            #f\n            (cadr sorted)))))\n", "  (if (null?\
    \ lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr\
    \ sorted))\n            #f\n            (cadr sorted)))))\n", "  (cond\n    [(null?\
    \ lst) #f]\n    [(null? (cdr lst)) #f]\n    [else (apply min (cdr lst))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let*\
    \ ([min (min (first lst) (second lst))]\n            [max (max (first lst) (second\
    \ lst))]\n            [rest (rest (rest lst))])\n       (cond\n         [(empty?\
    \ rest) min]\n         [else\n          (let loop ([rest rest] [min min] [max\
    \ max])\n            (cond\n              [(empty? rest) min]\n              [(<\
    \ (first rest) min) (loop (rest rest) (first rest) max)]\n              [(< (first\
    \ rest) max) (loop (rest rest) min (first rest))]\n              [else (loop (rest\
    \ rest) min max)]))]))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest\
    \ lst)) #f]\n    [else (apply min (rest lst))]))\n", "  (cond\n    [(null? lst)\
    \ #f]\n    [(null? (cdr lst)) #f]\n    [else\n     (let* ([min (apply min lst)]\n\
    \            [lst (remove min lst)])\n       (apply min lst))]))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted\
    \ (sort lst <)]\n            [first (first sorted)]\n            [second (first\
    \ (rest sorted))])\n       (if (= first second)\n           #f\n           second))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let*\
    \ ([sorted (sort lst <)]\n            [first (first sorted)]\n            [second\
    \ (first (rest sorted))])\n       (if (= first second)\n           #f\n      \
    \     second))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst))\
    \ #f]\n    [else\n     (let ([min (min (first lst) (second lst))]\n          \
    \ [max (max (first lst) (second lst))])\n       (for/fold ([min min] [max max])\
    \ ([x (in-list (rest (rest lst)))])\n         (cond\n           [(< x min) (values\
    \ x max)]\n           [(> x max) (values min x)]\n           [else (values min\
    \ max)])))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n\
    \    [else (let ([min (apply min lst)])\n            (cond\n              [(=\
    \ min (second lst)) (next_smallest (rest lst))]\n              [else (second lst)]))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let*\
    \ ([min (apply min lst)]\n            [min-index (index-of min lst)]\n       \
    \     [lst-without-min (remove-at min-index lst)]\n            [min2 (apply min\
    \ lst-without-min)]\n            [min2-index (index-of min2 lst-without-min)]\n\
    \            [lst-without-min2 (remove-at min2-index lst-without-min)])\n    \
    \   (cond\n         [(empty? lst-without-min2) #f]\n         [else (apply min\
    \ lst-without-min2)]))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted\
    \ (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n         \
    \   (cadr sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest\
    \ lst)) #f]\n    [else\n     (let ([min (min (first lst) (second lst))]\n    \
    \       [max (max (first lst) (second lst))])\n       (for/fold ([min min] [max\
    \ max]) ([x (in-list (rest (rest lst)))])\n         (cond\n           [(< x min)\
    \ (values x max)]\n           [(< x max) (values min x)]\n           [else (values\
    \ min max)])))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort\
    \ lst <)])\n        (if (null? (cdr sorted))\n            #f\n            (cadr\
    \ sorted)))))\n", "  (cond\n    [(null? lst) #f]\n    [(null? (cdr lst)) #f]\n\
    \    [else (apply min (cdr lst))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty?\
    \ (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n\
    \         [(= min (first lst)) (next_smallest (rest lst))]\n         [else (apply\
    \ min (remove min lst))]))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted\
    \ (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n         \
    \   (cadr sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest\
    \ lst)) #f]\n    [else\n     (let ([min (min (first lst) (second lst))]\n    \
    \       [max (max (first lst) (second lst))])\n       (for/fold ([min min] [max\
    \ max]) ([x (in-list (rest (rest lst)))])\n         (cond\n           [(< x min)\
    \ (values x max)]\n           [(< x max) (values min x)]\n           [else (values\
    \ min max)])))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst))\
    \ #f]\n    [else\n     (let*\n         ([sorted (sort lst <)]\n          [smallest\
    \ (first sorted)]\n          [second-smallest (first (rest sorted))])\n      \
    \ (if (equal? smallest second-smallest)\n           #f\n           second-smallest))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([sorted (sort lst <)])\n       (if (equal? (first sorted) (second sorted))\n\
    \           #f\n           (second sorted)))]))\n", "  (if (null? lst)\n     \
    \ #f\n      (let* ([sorted (sort lst <)]\n             [first (car sorted)]\n\
    \             [second (cadr sorted)])\n        (if (equal? first second)\n   \
    \         #f\n            second))))\n", "  (cond\n    [(empty? lst) #f]\n   \
    \ [(empty? (rest lst)) #f]\n    [else\n     (let* ([min (apply min lst)]\n   \
    \         [lst (remove min lst)])\n       (apply min lst))]))\n", "  (if (empty?\
    \ lst)\n      #f\n      (let ([min (apply min lst)])\n        (if (null? (rest\
    \ lst))\n            #f\n            (let ([min2 (apply min (filter (lambda (x)\
    \ (not (= x min))) lst))])\n              (if (= min min2)\n                 \
    \ #f\n                  min2))))))\n", "  (if (null? lst)\n      #f\n      (let\
    \ ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n\
    \            (cadr sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty?\
    \ (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n\
    \         [(= min (first lst)) (next_smallest (rest lst))]\n         [else (apply\
    \ min (filter (lambda (x) (not (= x min))) lst))]))]))\n", "  (if (null? lst)\n\
    \      #f\n      (let ((sorted (sort lst <)))\n        (if (null? (cdr sorted))\n\
    \            #f\n            (cadr sorted)))))\n", "  (if (null? lst)\n      #f\n\
    \      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n      \
    \      #f\n            (cadr sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n\
    \    [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted (sort lst <)]\n\
    \            [first (first sorted)]\n            [second (first (rest sorted))])\n\
    \       (if (= first second)\n           #f\n           second))]))\n", "  (if\
    \ (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null?\
    \ (cdr sorted))\n            #f\n            (cadr sorted)))))\n", "  (cond [(empty?\
    \ lst) #f]\n        [(empty? (rest lst)) #f]\n        [else (apply min (rest lst))]))\n",
  "  (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null?\
    \ (cdr sorted))\n            #f\n            (cadr sorted)))))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(= (length lst) 1) #f]\n    [else (apply min (cdr\
    \ (sort lst <)))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort\
    \ lst <)])\n        (if (null? (cdr sorted))\n            #f\n            (cadr\
    \ sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n\
    \    [else\n     (let* ([sorted (sort lst <)]\n            [min (first sorted)]\n\
    \            [min2 (first (rest sorted))])\n       (if (equal? min min2)\n   \
    \        #f\n           min2))]))\n", "  (cond [(empty? lst) #f]\n        [(empty?\
    \ (rest lst)) #f]\n        [else (apply min (rest lst))]))\n", "  (if (null? lst)\n\
    \      #f\n      (let* ([sorted (sort lst <)]\n             [first (car sorted)]\n\
    \             [second (cadr sorted)])\n        (if (equal? first second)\n   \
    \         #f\n            second))))\n", "  (if (null? lst)\n      #f\n      (let\
    \ ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n\
    \            (cadr sorted)))))\n", "  (if (null? lst)\n      #f\n      (let ([sorted\
    \ (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n         \
    \   (car (cdr sorted))))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest\
    \ lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n    \
    \     [(= min (first lst)) (next_smallest (rest lst))]\n         [else (apply\
    \ min (filter (lambda (x) (not (= x min))) lst))]))]))\n", "  (if (null? lst)\n\
    \      #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n\
    \            #f\n            (cadr sorted)))))\n", "  (cond\n    [(empty? lst)\
    \ #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n\
    \       (cond\n         [(= min (first lst)) (next_smallest (rest lst))]\n   \
    \      [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))\n", " \
    \ (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null?\
    \ (cdr sorted))\n            #f\n            (cadr sorted)))))\n", "  (define\
    \ (next_smallest_iter lst smallest smallest_index)\n    (cond\n      [(empty?\
    \ lst) (if (= smallest_index 1) #f smallest)]\n      [(= (first lst) smallest)\
    \ (next_smallest_iter (rest lst) smallest smallest_index)]\n      [(< (first lst)\
    \ smallest) (next_smallest_iter (rest lst) (first lst) 1)]\n      [else (next_smallest_iter\
    \ (rest lst) smallest (+ smallest_index 1))]))\n  (next_smallest_iter lst (first\
    \ lst) 0))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n\
    \        (if (null? (cdr sorted))\n            #f\n            (car (cdr sorted))))))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([min (min (first lst) (second lst))]\n           [max (max (first lst) (second\
    \ lst))])\n       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n\
    \         (let ([new-min (min x min)]\n               [new-max (max x max)])\n\
    \           (cond\n             [(= new-min min) (values new-min max)]\n     \
    \        [(= new-max max) (values min new-max)]\n             [else (values new-min\
    \ new-max)]))))]))\n", "  (cond\n    [(null? lst) #f]\n    [(null? (cdr lst))\
    \ #f]\n    [else (let* ([min (apply min lst)]\n                 [min-index (index-of\
    \ min lst)]\n                 [lst-without-min (remove-at min-index lst)])\n \
    \            (apply min lst-without-min))]))\n", "  (cond\n    [(empty? lst) #f]\n\
    \    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n\
    \       (cond\n         [(= min (car lst)) (next_smallest (rest lst))]\n     \
    \    [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))\n", " \
    \ (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null?\
    \ (cdr sorted))\n            #f\n            (cadr sorted)))))\n", "  (if (null?\
    \ lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (equal? (length\
    \ sorted) 1)\n            #f\n            (second sorted)))))\n", "  (cond\n \
    \   [(null? lst) #f]\n    [(null? (cdr lst)) #f]\n    [else\n     (let ([min (apply\
    \ min lst)])\n       (cond\n         [(= min (car lst)) (next_smallest (cdr lst))]\n\
    \         [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))\n",
  "  (define (next_smallest_iter lst smallest second-smallest)\n    (cond\n      [(empty?\
    \ lst) second-smallest]\n      [(< (first lst) smallest) (next_smallest_iter (rest\
    \ lst) (first lst) smallest)]\n      [(< (first lst) second-smallest) (next_smallest_iter\
    \ (rest lst) smallest (first lst))]\n      [else (next_smallest_iter (rest lst)\
    \ smallest second-smallest)]))\n  (if (empty? lst)\n      #f\n      (next_smallest_iter\
    \ (rest lst) (first lst) (first lst))))\n", "  (if (null? lst)\n      #f\n   \
    \   (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n         \
    \   #f\n            (car (cdr sorted))))))\n", "  (cond\n    [(empty? lst) #f]\n\
    \    [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted (sort lst <)]\n\
    \            [smallest (first sorted)]\n            [second-smallest (first (rest\
    \ sorted))])\n       (if (equal? smallest second-smallest)\n           #f\n  \
    \         second-smallest))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted\
    \ (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n         \
    \   (cadr sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest\
    \ lst)) #f]\n    [else\n     (let ([min (min (first lst) (second lst))]\n    \
    \       [second-min (max (first lst) (second lst))])\n       (for ([x (rest (rest\
    \ lst))])\n         (cond\n           [(< x min)\n            (set! second-min\
    \ min)\n            (set! min x)]\n           [(and (< x second-min) (< x min))\n\
    \            (set! second-min x)]))\n       second-min)]))\n", "  (let ([min (apply\
    \ min lst)])\n    (if (null? lst)\n        #f\n        (let ([new-lst (filter\
    \ (lambda (x) (not (= x min))) lst)])\n          (if (null? new-lst)\n       \
    \       #f\n              (apply min new-lst))))))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([sorted (sort\
    \ lst <)])\n       (if (equal? (first sorted) (second sorted))\n           #f\n\
    \           (second sorted)))]))\n", "  (cond\n    [(null? lst) #f]\n    [(null?\
    \ (cdr lst)) #f]\n    [else\n     (let* ([min (apply min lst)]\n            [min-pos\
    \ (position min lst)]\n            [lst-without-min (remove min lst)])\n     \
    \  (if (null? lst-without-min)\n           #f\n           (apply min lst-without-min)))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([smallest (min (first lst) (second lst))])\n       (for/fold ([smallest smallest])\
    \ ([x (in-list (rest (rest lst)))])\n         (cond\n           [(< x smallest)\
    \ x]\n           [else smallest])))]))\n", "  (cond\n    [(empty? lst) #f]\n \
    \   [(empty? (rest lst)) #f]\n    [else (let ([min (min (first lst) (second lst))])\n\
    \            (cond\n              [(= min (first lst)) (next_smallest (rest lst))]\n\
    \              [else min]))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted\
    \ (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n         \
    \   (cadr sorted)))))\n", "  (if (null? lst)\n      #f\n      (let ((first (car\
    \ lst))\n            (rest (cdr lst)))\n        (if (null? rest)\n           \
    \ #f\n            (let ((second (car rest))\n                  (rest2 (cdr rest)))\n\
    \              (if (null? rest2)\n                  #f\n                  (let\
    \ loop ((lst rest2)\n                             (min first)\n              \
    \               (min2 second))\n                    (if (null? lst)\n        \
    \                min2\n                        (let ((x (car lst)))\n        \
    \                  (if (< x min)\n                              (loop (cdr lst)\
    \ x min)\n                              (if (< x min2)\n                     \
    \             (loop (cdr lst) min x)\n                                  (loop\
    \ (cdr lst) min min2))))))))))))\n", "  (if (null? lst)\n      #f\n      (let\
    \ ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n\
    \            (cadr sorted)))))\n", "  (define (next_smallest-helper lst min1 min2)\n\
    \    (cond\n      [(empty? lst) min2]\n      [(< (first lst) min1) (next_smallest-helper\
    \ (rest lst) (first lst) min1)]\n      [(< (first lst) min2) (next_smallest-helper\
    \ (rest lst) min1 (first lst))]\n      [else (next_smallest-helper (rest lst)\
    \ min1 min2)]))\n  (if (empty? lst)\n      #f\n      (next_smallest-helper (rest\
    \ lst) (first lst) (first lst))))\n", "  (cond [(empty? lst) #f]\n        [(empty?\
    \ (rest lst)) #f]\n        [else (apply min (rest lst))]))\n", "  (if (null? lst)\n\
    \      #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n\
    \            #f\n            (cadr sorted)))))\n", "  (if (null? lst)\n      #f\n\
    \      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n      \
    \      #f\n            (cadr sorted)))))\n", "  (define (next_smallest-helper\
    \ lst smallest second-smallest)\n    (cond [(empty? lst) second-smallest]\n  \
    \        [(= (first lst) smallest) (next_smallest-helper (rest lst) smallest second-smallest)]\n\
    \          [(< (first lst) smallest) (next_smallest-helper (rest lst) (first lst)\
    \ smallest)]\n          [else (next_smallest-helper (rest lst) smallest (first\
    \ lst))]))\n  (if (empty? lst)\n      #f\n      (next_smallest-helper (rest lst)\
    \ (first lst) (first lst))))\n", "  (if (empty? lst)\n      #f\n      (let ([min\
    \ (apply min lst)])\n        (if (empty? (remove min lst))\n            #f\n \
    \           (apply min (remove min lst))))))\n", "  (cond\n    [(null? lst) #f]\n\
    \    [(null? (cdr lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n  \
    \     (cond\n         [(null? (cdr (cdr lst))) #f]\n         [else\n         \
    \ (let ([min2 (apply min (filter (lambda (x) (not (= x min))) lst))])\n      \
    \      (if (= min min2)\n                #f\n                min2))]))]))\n",
  "  (cond [(empty? lst) #f]\n        [(= (length lst) 1) #f]\n        [else (apply\
    \ min (cdr (sort < lst)))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted\
    \ (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n         \
    \   (cadr sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest\
    \ lst)) #f]\n    [else (let ([min (min (first lst) (second lst))])\n         \
    \   (cond\n              [(= min (first lst)) (next_smallest (rest lst))]\n  \
    \            [else min]))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty?\
    \ (rest lst)) #f]\n    [else (let ([min (min (first lst) (second lst))])\n   \
    \         (cond\n              [(= min (first lst)) (next_smallest (rest lst))]\n\
    \              [else min]))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(= (length\
    \ lst) 1) #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n  \
    \       [(= min (apply max lst)) #f]\n         [else\n          (let ([lst (remove\
    \ min lst)])\n            (apply min lst))]))]))\n", "  (cond\n    [(null? lst)\
    \ #f]\n    [(null? (cdr lst)) #f]\n    [else\n     (let ([sorted (sort lst <)])\n\
    \       (if (equal? (car sorted) (cadr sorted))\n           #f\n           (cadr\
    \ sorted)))]))\n", "  (define (next_smallest-iter lst smallest second-smallest)\n\
    \    (cond\n      [(empty? lst) second-smallest]\n      [(< (first lst) smallest)\
    \ (next_smallest-iter (rest lst) (first lst) smallest)]\n      [(< (first lst)\
    \ second-smallest) (next_smallest-iter (rest lst) smallest (first lst))]\n   \
    \   [else (next_smallest-iter (rest lst) smallest second-smallest)]))\n  (if (empty?\
    \ lst)\n      #f\n      (next_smallest-iter (rest lst) (first lst) (first lst))))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(= (length lst) 1) #f]\n    [else\n     (let\
    \ ([sorted (sort lst <)])\n       (if (equal? (first sorted) (second sorted))\n\
    \           #f\n           (second sorted)))]))\n", "  (cond\n    [(empty? lst)\
    \ #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let* ([min (apply min lst)]\n\
    \            [min-index (index-of min lst)]\n            [lst-without-min (remove-at\
    \ min-index lst)]\n            [next-min (apply min lst-without-min)])\n     \
    \  next-min)]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst))\
    \ #f]\n    [else\n     (let* ([sorted (sort lst <)]\n            [first (first\
    \ sorted)]\n            [second (first (rest sorted))])\n       (if (= first second)\n\
    \           #f\n           second))]))\n", "  (if (null? lst)\n      #f\n    \
    \  (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n          \
    \  #f\n            (cadr sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n   \
    \ [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted (sort lst <)]\n   \
    \         [first (first sorted)]\n            [second (first (rest sorted))])\n\
    \       (if (equal? first second)\n           #f\n           second))]))\n", " \
    \ (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n    \
    \ (let* ([sorted (sort lst <)]\n            [first (first sorted)]\n         \
    \   [second (first (rest sorted))])\n       (if (equal? first second)\n      \
    \     #f\n           second))]))\n", "  (if (null? lst)\n      #f\n      (let\
    \ ([min (apply min lst)]\n            [min2 (apply min (filter (lambda (x) (not\
    \ (= x min))) lst))])\n        (if (= min min2)\n            #f\n            min2))))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else (next_smallest_helper\
    \ lst (first lst) (first (rest lst)))]))\n", "  (cond\n    [(empty? lst) #f]\n\
    \    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (min (first lst) (second\
    \ lst))]\n           [max (max (first lst) (second lst))])\n       (for/fold ([min\
    \ min] [max max]) ([e (in-list (rest (rest lst)))])\n         (cond\n        \
    \   [(< e min) (values e max)]\n           [(< e max) (values min e)]\n      \
    \     [else (values min max)])))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty?\
    \ (rest lst)) #f]\n    [else\n     (let* ([sorted (sort lst <)]\n            [first\
    \ (first sorted)]\n            [second (first (rest sorted))])\n       (if (equal?\
    \ first second)\n           #f\n           second))]))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (apply min\
    \ lst)])\n       (cond\n         [(= min (second lst)) (next_smallest (rest lst))]\n\
    \         [else (second lst)]))]))\n", "  (if (null? lst)\n      #f\n      (let\
    \ ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n\
    \            (car (cdr sorted))))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty?\
    \ (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n\
    \         [(= min (first lst)) (next_smallest (rest lst))]\n         [else min]))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([min (apply min lst)])\n       (cond\n         [(= min (second lst)) (next_smallest\
    \ (rest lst))]\n         [else (second lst)]))]))\n", "  (if (null? lst)\n   \
    \   #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n\
    \            #f\n            (car (cdr sorted))))))\n", "  (if (null? lst)\n \
    \     #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n\
    \            #f\n            (car (cdr sorted))))))\n", "  (if (null? lst)\n \
    \     #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n\
    \            #f\n            (cadr sorted)))))\n", "  (cond\n    [(null? lst)\
    \ #f]\n    [(null? (cdr lst)) #f]\n    [else\n     (let* ([min (apply min lst)]\n\
    \            [min-index (index-of min lst)]\n            [lst-without-min (remove-at\
    \ min-index lst)]\n            [min2 (apply min lst-without-min)]\n          \
    \  [min2-index (index-of min2 lst-without-min)]\n            [lst-without-min2\
    \ (remove-at min2-index lst-without-min)]\n            [min3 (apply min lst-without-min2)])\n\
    \       min3)]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort lst\
    \ <)])\n        (if (null? (cdr sorted))\n            #f\n            (cadr sorted)))))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([min (min (first lst) (second lst))]\n           [max (max (first lst) (second\
    \ lst))])\n       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n\
    \         (let ([new-min (min x min)]\n               [new-max (max x max)])\n\
    \           (cond\n             [(= new-min min) (values min max)]\n         \
    \    [(= new-max max) (values min max)]\n             [(= new-min new-max) (values\
    \ min max)]\n             [else (values new-min new-max)]))))]))\n", "  (if (null?\
    \ lst)\n      #f\n      (let* ([sorted (sort lst <)]\n             [first (car\
    \ sorted)]\n             [second (car (cdr sorted))])\n        (if (equal? first\
    \ second)\n            #f\n            second))))\n", "  (if (null? lst)\n   \
    \   #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n\
    \            #f\n            (cadr sorted)))))\n", "  (cond\n    [(empty? lst)\
    \ #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted (sort lst\
    \ <)]\n            [smallest (first sorted)]\n            [second-smallest (first\
    \ (rest sorted))])\n       (if (equal? smallest second-smallest)\n           #f\n\
    \           second-smallest))]))\n", "  (cond\n    [(null? lst) #f]\n    [(null?\
    \ (cdr lst)) #f]\n    [else\n     (let ([min (car lst)]\n           [min2 (cadr\
    \ lst)])\n       (for ([i (in-list (cdr lst))])\n         (cond\n           [(<\
    \ i min)\n            (set! min2 min)\n            (set! min i)]\n           [(and\
    \ (< i min2)\n                 (< i min))\n            (set! min2 i)]))\n    \
    \   min2)]))\n", "  (if (null? lst)\n      #f\n      (let* ([sorted (sort lst\
    \ <)]\n             [first (car sorted)]\n             [second (cadr sorted)])\n\
    \        (if (equal? first second)\n            #f\n            second))))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let*\
    \ ([sorted (sort lst <)]\n            [smallest (first sorted)]\n            [second-smallest\
    \ (first (rest sorted))])\n       (if (equal? smallest second-smallest)\n    \
    \       #f\n           second-smallest))]))\n", "  (cond\n    [(empty? lst) #f]\n\
    \    [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted (sort lst <)]\n\
    \            [smallest (first sorted)]\n            [next-smallest (first (rest\
    \ sorted))])\n       (if (equal? smallest next-smallest)\n           #f\n    \
    \       next-smallest))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest\
    \ lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n    \
    \     [(= min (first lst)) (next_smallest (rest lst))]\n         [else (apply\
    \ min (remove min lst))]))]))\n", "  (if (null? lst)\n      #f\n      (let* ([sorted\
    \ (sort lst <)]\n             [first (car sorted)]\n             [second (car\
    \ (cdr sorted))])\n        (if (equal? first second)\n            #f\n       \
    \     second))))\n", "  (cond\n    [(null? lst) #f]\n    [(null? (cdr lst)) #f]\n\
    \    [else (let ([min (apply min lst)])\n            (cond\n              [(null?\
    \ (cdr (cdr lst))) #f]\n              [else (apply min (filter (lambda (x) (not\
    \ (= x min))) lst))]))]))\n", "  (if (or (null? lst) (null? (cdr lst)))\n    \
    \  #f\n      (let ([min (apply min lst)]\n            [min2 (apply min (filter\
    \ (lambda (x) (not (= x min))) lst))])\n        (if (= min min2)\n           \
    \ #f\n            min2))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest\
    \ lst)) #f]\n    [else (second (sort lst))]))\n", "  (if (null? lst)\n      #f\n\
    \      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n      \
    \      #f\n            (cadr sorted)))))\n", "  (if (null? lst)\n      #f\n  \
    \    (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n        \
    \    #f\n            (cadr sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n \
    \   [(empty? (rest lst)) #f]\n    [else\n     (let ([min (min (first lst) (second\
    \ lst))]\n           [max (max (first lst) (second lst))])\n       (for/fold ([min\
    \ min] [max max]) ([x (in-list (rest (rest lst)))])\n         (cond\n        \
    \   [(< x min) (values x max)]\n           [(< x max) (values min x)]\n      \
    \     [else (values min max)])))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty?\
    \ (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n\
    \         [(= min (second lst)) (next_smallest (rest lst))]\n         [else (second\
    \ lst)]))]))\n", "  (if (null? lst)\n      #f\n      (let ([min (apply min lst)]\n\
    \            [min-count (count min lst)])\n        (if (> min-count 1)\n     \
    \       #f\n            (apply min (remove min lst))))))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (min (first\
    \ lst) (second lst))]\n           [max (max (first lst) (second lst))])\n    \
    \   (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n      \
    \   (cond\n           [(< x min) (values x max)]\n           [(< x max) (values\
    \ min x)]\n           [else (values min max)])))]))\n", "  (if (null? lst)\n \
    \     #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n\
    \            #f\n            (cadr sorted)))))\n", "  (cond\n    [(empty? lst)\
    \ #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let* ([min (apply min lst)]\n\
    \            [min-index (index-of min lst)]\n            [min-index-2 (index-of\
    \ min (remove-at min-index lst))])\n       (if (negative? min-index-2)\n     \
    \      #f\n           (list-ref lst (+ min-index-2 1))))]))\n", "  (cond\n   \
    \ [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min\
    \ (apply min lst)])\n       (cond\n         [(= min (first lst)) (next_smallest\
    \ (rest lst))]\n         [else (apply min (remove min lst))]))]))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted\
    \ (sort lst <)]\n            [first (first sorted)]\n            [second (first\
    \ (rest sorted))])\n       (if (equal? first second)\n           #f\n        \
    \   second))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst))\
    \ #f]\n    [else\n     (let ([smallest (apply min lst)])\n       (cond\n     \
    \    [(= smallest (second lst)) (next_smallest (rest lst))]\n         [else (second\
    \ lst)]))]))\n", "  (if (null? lst)\n      #f\n      (let* ([sorted (sort lst\
    \ <)]\n             [min (car sorted)]\n             [min2 (car (cdr sorted))])\n\
    \        (if (= min min2)\n            #f\n            min2))))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted-lst\
    \ (sort lst <)]\n            [min (first sorted-lst)]\n            [min2 (first\
    \ (rest sorted-lst))])\n       (if (equal? min min2)\n           #f\n        \
    \   min2))]))\n", "  (if (null? lst)\n      #f\n      (let* ([sorted (sort lst\
    \ <)]\n             [first (car sorted)]\n             [second (cadr sorted)])\n\
    \        (if (= first second)\n            #f\n            second))))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min\
    \ (apply min lst)])\n       (cond\n         [(= min (second lst)) (next_smallest\
    \ (rest lst))]\n         [else (second lst)]))]))\n", "  (cond\n    [(empty? lst)\
    \ #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n\
    \       (cond\n         [(= min (first lst)) (next_smallest (rest lst))]\n   \
    \      [else min]))]))\n", "  (if (null? lst)\n      #f\n      (let ([min (apply\
    \ min lst)]\n            [min-count (count min lst)])\n        (if (> min-count\
    \ 1)\n            #f\n            (let ([lst (remove min lst)])\n            \
    \  (if (null? lst)\n                  #f\n                  (apply min lst)))))))\n",
  "  (cond [(empty? lst) #f]\n        [(empty? (rest lst)) #f]\n        [else\n  \
    \       (let ([min (apply min lst)])\n           (cond [(= min (second lst)) (next_smallest\
    \ (rest lst))]\n                 [else (second lst)]))]))\n", "  (if (null? lst)\n\
    \      #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n\
    \            #f\n            (cadr sorted)))))\n", "  (cond [(empty? lst) #f]\n\
    \        [(empty? (rest lst)) #f]\n        [else (second (sort lst))]))\n", " \
    \ (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n    \
    \ (let ([min (apply min lst)])\n       (cond\n         [(= min (first lst)) (next_smallest\
    \ (rest lst))]\n         [else (apply min (filter (lambda (x) (not (= x min)))\
    \ lst))]))]))\n", "  (cond\n    [(null? lst) #f]\n    [(null? (cdr lst)) #f]\n\
    \    [else\n     (let* ([sorted (sort lst <)]\n            [first (car sorted)]\n\
    \            [second (car (cdr sorted))])\n       (if (equal? first second)\n\
    \           #f\n           second))]))\n", "  (cond\n    [(empty? lst) #f]\n \
    \   [(empty? (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n \
    \      (cond\n         [(= min (apply max lst)) #f]\n         [else\n        \
    \  (apply min (filter (lambda (x) (not (= x min))) lst))]))]))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min\
    \ (apply min lst)])\n       (cond\n         [(= min (second lst)) (next_smallest\
    \ (rest lst))]\n         [else (second lst)]))]))\n", "  (cond\n    [(empty? lst)\
    \ #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n\
    \       (cond\n         [(= min (first lst)) (next_smallest (rest lst))]\n   \
    \      [else (apply min (remove min lst))]))]))\n", "  (if (null? lst)\n     \
    \ #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n \
    \           #f\n            (cadr sorted)))))\n", "  (cond\n    [(empty? lst)\
    \ #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([smallest (min (first\
    \ lst) (second lst))])\n       (for/fold ([smallest smallest]) ([x (in-list (rest\
    \ (rest lst)))])\n         (if (< x smallest)\n             x\n             smallest)))]))\n",
  "  (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null?\
    \ (cdr sorted))\n            #f\n            (cadr sorted)))))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min\
    \ (min (first lst) (second lst))]\n           [max (max (first lst) (second lst))])\n\
    \       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n  \
    \       (cond\n           [(< x min) (values x max)]\n           [(< x max) (values\
    \ min x)]\n           [else (values min max)])))]))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else (second (sort lst))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([min (min (first lst) (second lst))]\n           [max (max (first lst) (second\
    \ lst))])\n       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n\
    \         (cond\n           [(< x min) (values x max)]\n           [(< x max)\
    \ (values min x)]\n           [else (values min max)])))]))\n", "  (cond\n   \
    \ [(null? lst) #f]\n    [(null? (cdr lst)) #f]\n    [else\n     (let ([sorted\
    \ (sort lst <)])\n       (if (equal? (car sorted) (cadr sorted))\n           #f\n\
    \           (cadr sorted)))]))\n", "  (cond\n    [(null? lst) #f]\n    [(null?\
    \ (cdr lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n       (cond\n\
    \         [(= min (car lst)) (next_smallest (cdr lst))]\n         [else (apply\
    \ min (filter (lambda (x) (not (= x min))) lst))]))]))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let* ([min (apply min\
    \ lst)]\n            [min-index (index-of min lst)]\n            [lst-without-min\
    \ (remove min-index lst)]\n            [min2 (apply min lst-without-min)])\n \
    \      min2)]))\n", "  (if (null? lst)\n      #f\n      (let ((min (apply min\
    \ lst))\n            (min2 #f))\n        (for ([x lst])\n          (if (and (not\
    \ (eq? x min))\n                   (or (not min2)\n                       (< x\
    \ min2)))\n              (set! min2 x)))\n        min2)))\n", "  (cond\n    [(null?\
    \ lst) #f]\n    [(null? (cdr lst)) #f]\n    [else\n     (let ([min (apply min\
    \ lst)])\n       (cond\n         [(null? (cdr (cdr lst))) #f]\n         [else\n\
    \          (let ([min2 (apply min (filter (lambda (x) (not (= x min))) lst))])\n\
    \            (cond\n              [(= min min2) #f]\n              [else min2]))]))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let*\
    \ ([sorted (sort lst <)]\n            [first (first sorted)]\n            [second\
    \ (first (rest sorted))])\n       (if (= first second)\n           #f\n      \
    \     second))]))\n", "  (let ([min (apply min lst)])\n    (if (null? lst)\n \
    \       #f\n        (let ([lst (remove min lst)])\n          (if (null? lst)\n\
    \              #f\n              (apply min lst))))))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([smallest (min\
    \ (first lst) (second lst))])\n       (for/fold ([smallest smallest]) ([x (in-list\
    \ (rest (rest lst)))])\n         (if (< x smallest) x smallest)))]))\n", "  (if\
    \ (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null?\
    \ (cdr sorted))\n            #f\n            (cadr sorted)))))\n", "  (if (null?\
    \ lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr\
    \ sorted))\n            #f\n            (cadr sorted)))))\n", "  (if (null? lst)\n\
    \      #f\n      (let* ([sorted (sort lst <)]\n             [smallest (car sorted)]\n\
    \             [second-smallest (car (cdr sorted))])\n        (if (eq? smallest\
    \ second-smallest)\n            #f\n            second-smallest))))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted\
    \ (sort lst <)]\n            [min (first sorted)]\n            [min2 (first (rest\
    \ sorted))])\n       (if (= min min2)\n           #f\n           min2))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let*\
    \ ([min (apply min lst)]\n            [min-index (index-of min lst)]\n       \
    \     [lst-without-min (remove-at min-index lst)]\n            [min2 (apply min\
    \ lst-without-min)]\n            [min2-index (index-of min2 lst-without-min)]\n\
    \            [lst-without-min2 (remove-at min2-index lst-without-min)])\n    \
    \   (if (empty? lst-without-min2)\n           #f\n           (apply min lst-without-min2)))]))\n",
  "  (if (empty? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (empty?\
    \ (rest sorted))\n            #f\n            (second sorted)))))\n", "  (let\
    \ ([sorted (sort lst <)])\n    (if (null? (cdr sorted))\n        #f\n        (cadr\
    \ sorted))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n\
    \    [else\n     (let* ([sorted (sort lst <)]\n            [first (first sorted)]\n\
    \            [second (first (rest sorted))])\n       (if (equal? first second)\n\
    \           #f\n           second))]))\n", "  (cond\n    [(empty? lst) #f]\n \
    \   [(empty? (rest lst)) #f]\n    [else\n     (let* ([sorted (sort lst <)]\n \
    \           [first (first sorted)]\n            [second (first (rest sorted))])\n\
    \       (if (= first second)\n           #f\n           second))]))\n", "  (if\
    \ (null? lst)\n      #f\n      (let ((smallest (car lst))\n            (next-smallest\
    \ (car lst)))\n        (for ([x (in-list (cdr lst))])\n          (if (< x smallest)\n\
    \              (set! smallest x)\n              (if (< x next-smallest)\n    \
    \              (set! next-smallest x))))\n        next-smallest)))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min\
    \ (min (first lst) (second lst))]\n           [max (max (first lst) (second lst))])\n\
    \       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n  \
    \       (cond\n           [(< x min) (values x max)]\n           [(< x max) (values\
    \ min x)]\n           [else (values min max)])))]))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (apply min\
    \ lst)])\n       (if (= min (first lst))\n           (next_smallest (rest lst))\n\
    \           min))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst))\
    \ #f]\n    [else (next_smallest_helper (sort lst <) (first lst) (rest lst))]))\n",
  "  (cond\n    [(null? lst) #f]\n    [(null? (cdr lst)) #f]\n    [else\n     (let*\
    \ ([min (apply min lst)]\n            [lst (remove min lst)])\n       (cond\n\
    \         [(null? lst) #f]\n         [else (apply min lst)]))]))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min\
    \ (min (first lst) (second lst))]\n           [max (max (first lst) (second lst))])\n\
    \       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n  \
    \       (cond\n           [(< x min) (values x max)]\n           [(> x max) (values\
    \ min x)]\n           [else (values min max)])))]))\n", "  (if (null? lst)\n \
    \     #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr sorted))\n\
    \            #f\n            (cadr sorted)))))\n", "  (if (null? lst)\n      #f\n\
    \      (let ([min (apply min lst)]\n            [lst (remove min lst)])\n    \
    \    (if (null? lst)\n            #f\n            (apply min lst)))))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min\
    \ (min (first lst) (second lst))]\n           [max (max (first lst) (second lst))])\n\
    \       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n  \
    \       (cond\n           [(< x min) (values x max)]\n           [(< x max) (values\
    \ min x)]\n           [else (values min max)])))]))\n", "  (if (null? lst)\n \
    \     #f\n      (let* ([min (apply min lst)]\n             [lst (remove min lst)])\n\
    \        (if (null? lst)\n            #f\n            (apply min lst)))))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([min (apply min lst)])\n       (cond\n         [(= min (first lst)) (next_smallest\
    \ (rest lst))]\n         [else min]))]))\n", "  (cond\n    [(empty? lst) #f]\n\
    \    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (min (first lst) (second\
    \ lst))]\n           [max (max (first lst) (second lst))])\n       (for/fold ([min\
    \ min] [max max]) ([x (in-list (rest (rest lst)))])\n         (let ([new-min (min\
    \ x min)]\n               [new-max (max x max)])\n           (cond\n         \
    \    [(= new-min min) (values new-min max)]\n             [(= new-max max) (values\
    \ min new-max)]\n             [else (values new-min new-max)]))))]))\n", "  (cond\
    \ [(empty? lst) #f]\n        [(empty? (rest lst)) #f]\n        [else (second (sort\
    \ lst <))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n\
    \    [else\n     (let ([min (apply min lst)])\n       (if (equal? min (first lst))\n\
    \           (next_smallest (rest lst))\n           min))]))\n", "  (if (null?\
    \ lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr\
    \ sorted))\n            #f\n            (cadr sorted)))))\n", "  (if (null? lst)\n\
    \      #f\n      (let* ([sorted (sort lst <)]\n             [first (car sorted)]\n\
    \             [second (cadr sorted)])\n        (if (equal? first second)\n   \
    \         #f\n            second))))\n", "  (cond [(empty? lst) #f]\n        [(empty?\
    \ (rest lst)) #f]\n        [else (second (sort lst))]))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else (next_smallest-helper (sort\
    \ lst <) (first lst) (rest lst))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty?\
    \ (rest lst)) #f]\n    [else\n     (let* ([sorted (sort lst <)]\n            [smallest\
    \ (first sorted)]\n            [rest (rest sorted)])\n       (cond\n         [(empty?\
    \ rest) #f]\n         [(= smallest (first rest)) (next_smallest rest)]\n     \
    \    [else (first rest)]))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted\
    \ (sort lst <)])\n        (if (null? (cdr sorted))\n            #f\n         \
    \   (cadr sorted)))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest\
    \ lst)) #f]\n    [else (let ([sorted (sort lst <)])\n            (if (equal? (first\
    \ sorted) (second sorted))\n                #f\n                (second sorted)))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([sorted (sort lst <)])\n       (if (equal? (first sorted) (second sorted))\n\
    \           #f\n           (second sorted)))]))\n", "  (cond\n    [(null? lst)\
    \ #f]\n    [(null? (cdr lst)) #f]\n    [else\n     (let* ([sorted (sort lst <)]\n\
    \            [first (car sorted)]\n            [second (cadr sorted)])\n     \
    \  (if (equal? first second)\n           #f\n           second))]))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min\
    \ (min (first lst) (second lst))]\n           [max (max (first lst) (second lst))])\n\
    \       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n  \
    \       (cond\n           [(< x min) (values x max)]\n           [(< x max) (values\
    \ min x)]\n           [else (values min max)])))]))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (min (first\
    \ lst) (second lst))]\n           [max (max (first lst) (second lst))])\n    \
    \   (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n      \
    \   (let ([new-min (min x min)]\n               [new-max (max x max)])\n     \
    \      (if (= new-min min)\n               (values new-min new-max)\n        \
    \       (values new-min max))\n           )\n         )\n       )\n     ]\n  \
    \  )\n  )\n", "  (cond\n    [(empty? lst) #f]\n    [(= (length lst) 1) #f]\n \
    \   [else\n     (let ([min (apply min lst)])\n       (cond\n         [(= min (apply\
    \ max lst)) #f]\n         [else\n          (let ([lst (remove min lst)])\n   \
    \         (apply min lst))]))]))\n", "  (define (next_smallest-iter lst smallest\
    \ second-smallest)\n    (cond\n      [(empty? lst) second-smallest]\n      [(<\
    \ (first lst) smallest) (next_smallest-iter (rest lst) (first lst) smallest)]\n\
    \      [(< (first lst) second-smallest) (next_smallest-iter (rest lst) smallest\
    \ (first lst))]\n      [else (next_smallest-iter (rest lst) smallest second-smallest)]))\n\
    \  (next_smallest-iter lst (first lst) (first lst)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
