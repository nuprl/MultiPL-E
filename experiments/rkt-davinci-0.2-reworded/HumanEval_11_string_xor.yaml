name: HumanEval_11_string_xor
language: rkt
prompt: "#lang racket\n\n;; Input are two strings a and b consisting only of 1s and\
  \ 0s.\n;; Perform binary XOR on these inputs and return result also as a string.\n\
  ;; >>> (string_xor \"010\" \"110\")\n;; \"100\"\n(define (string_xor a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n\
  \    (check-equal? (candidate \"111000\" \"101010\") \"010010\")\n    (check-equal?\
  \ (candidate \"1\" \"1\") \"0\")\n    (check-equal? (candidate \"0101\" \"0000\"\
  ) \"0101\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string\
    \ (bitwise-xor (string-&gt;number (string-ref a 0))\n                        \
    \       (string-&gt;number (string-ref b 0))))\n          (string_xor (substring\
    \ a 1) (substring b 1))]))\n</code>\n", "  (if (or (string=? a \"\") (string=?\
    \ b \"\"))\n      \"\"\n      (string-append\n       (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                            (string-&gt;number (string-ref\
    \ b 0))))\n       (string_xor (substring a 1) (substring b 1)))))\n</code>\n",
  "  (string-join (map (\u03BB (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join\n   (map\n    (lambda (x)\n      (number->string\n\
    \       (bitwise-xor (string-&gt;number (string-ref x 0))\n                  \
    \  (string-&gt;number (string-ref x 1)))))\n    (map (lambda (x) (list (string-ref\
    \ a x) (string-ref b x)))\n         (build-list (string-length a) (lambda (x)\
    \ x))))))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1))))) (map list (string-&gt;list\
    \ a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else (string_xor (rest a) (rest b))]))\n", "  (string-join (map\
    \ (lambda (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1))))) (map list (string-&gt;list a) (string-&gt;list b))) \"\"\
    ))\n", "  (define (xor-char a b)\n    (cond ((and (char=? a #\\0) (char=? b #\\\
    0)) #\\0)\n          ((and (char=? a #\\1) (char=? b #\\1)) #\\0)\n          (else\
    \ #\\1)))\n  (define (xor-string a b)\n    (if (string=? a \"\")\n        \"\"\
    \n        (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))\n\
    \                       (xor-string (substring a 1) (substring b 1)))))\n  (xor-string\
    \ a b))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1))))) (string-split (string-append\
    \ a b) \"\")) \"\"))\n", "  (string-join\n   (map (lambda (x) (number->string\
    \ (xor (string-&gt;number (string-ref x 0))\n                                \
    \         (string-&gt;number (string-ref x 1)))))\n        (map list (string-&gt;list\
    \ a) (string-&gt;list b)))\n   \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (define (xor-char a b)\n    (cond ((and (char=? a #\\0) (char=? b #\\0)) #\\\
    0)\n          ((and (char=? a #\\1) (char=? b #\\1)) #\\0)\n          (else #\\\
    1)))\n  (define (xor-string a b)\n    (cond ((string=? a \"\") \"\")\n       \
    \   ((string=? b \"\") \"\")\n          (else (string-append (string (xor-char\
    \ (string-ref a 0) (string-ref b 0)))\n                               (xor-string\
    \ (substring a 1) (substring b 1))))))\n  (xor-string a b))\n", "  (string-join\
    \ (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (map list (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\
    \ (string-append (string (bitwise-xor (string-&gt;number (string-ref a 0)) (string-&gt;number\
    \ (string-ref b 0)))) (string_xor (substring a 1) (substring b 1)))]))\n", " \
    \ (string-join\n   (map\n    (lambda (x)\n      (number->string (bitwise-xor (string->number\
    \ (string-ref x 0))\n                                   (string->number (string-ref\
    \ x 1)))))\n    (map list (string->list a) (string->list b)))\n   \"\"))\n", " \
    \ (string-join (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (zip\
    \ (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (define (xor-char a\
    \ b)\n    (if (char=? a b)\n        #\\0\n        #\\1))\n  (define (xor-string\
    \ a b)\n    (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))\n\
    \                   (xor-string (substring a 1) (substring b 1))))\n  (if (string=?\
    \ a \"\")\n      \"\"\n      (xor-string a b)))\n", "  (string-join (map (lambda\
    \ (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1))))) (string-zip a b)) \"\"))\n", "  (define (xor-char a b)\n\
    \    (if (equal? a b)\n        #\\0\n        #\\1))\n  (apply string (map xor-char\
    \ a b)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
