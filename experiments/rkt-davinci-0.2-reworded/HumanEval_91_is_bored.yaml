name: HumanEval_91_is_bored
language: rkt
prompt: "#lang racket\n\n;; You'll be given a string of words, and your task is to\
  \ count the number\n;; of boredoms. A boredom is a sentence that starts with the\
  \ word \"I\".\n;; Sentences are delimited by '.', '?' or '!'.\n;; For example:\n\
  ;; >>> (is_bored \"Hello world\")\n;; 0\n;; >>> (is_bored \"The sky is blue. The\
  \ sun is shining. I love this weather\")\n;; 1\n(define (is_bored S)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_bored))\n\
  \    (check-equal? (candidate \"Hello world\") 0)\n    (check-equal? (candidate\
  \ \"Is the sky blue?\") 0)\n    (check-equal? (candidate \"I love It !\") 1)\n \
  \   (check-equal? (candidate \"bIt\") 0)\n    (check-equal? (candidate \"I feel\
  \ good today. I will be productive. will kill It\") 2)\n    (check-equal? (candidate\
  \ \"You and I are going for a walk\") 0)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(string=? S \"\") 0]\n    [(string=? (substring S 0 2)\
    \ \"I \") (+ 1 (is_bored (substring S 2)))]\n    [else (is_bored (substring S\
    \ 1))]))\n", "  (count (lambda (x) (string=? (first (string-split x)) \"I\"))\n\
    \         (string-split S \"[.?!]\")))\n", "  (cond\n    [(string=? S \"\") 0]\n\
    \    [(string=? (substring S 0 2) \"I \") (+ 1 (is_bored (substring S 2)))]\n\
    \    [else (is_bored (substring S 1))]))\n", "  (cond\n    [(empty? S) 0]\n  \
    \  [(string=? (substring S 0 1) \"I\") (+ 1 (is_bored (substring S 1)))]\n   \
    \ [else (is_bored (substring S 1))]))\n", "  (count-if (lambda (x) (string=? (string-trim\
    \ x) \"I\"))\n            (regexp-split #rx\"\\.|\\?|!\" S)))\n", "  (cond\n \
    \   [(empty? S) 0]\n    [(string=? (substring S 0 2) \"I \") (+ 1 (is_bored (substring\
    \ S 2)))]\n    [else (is_bored (substring S 1))]))\n", "  (cond\n    [(empty?\
    \ S) 0]\n    [(string=? (substring S 0 2) \"I \") (+ 1 (is_bored (substring S\
    \ 2)))]\n    [else (is_bored (substring S 1))]))\n", "  (cond\n    [(empty? S)\
    \ 0]\n    [(string=? (substring S 0 2) \"I \") (+ 1 (is_bored (substring S 2)))]\n\
    \    [else (is_bored (substring S 1))]))\n", "  (cond\n    [(empty? S) 0]\n  \
    \  [(string=? (first S) \"I\") (+ 1 (is_bored (rest S)))]\n    [else (is_bored\
    \ (rest S))]))\n", "  (count (lambda (x) (string=? x \"I\")) (string-split S #\\\
    .)))\n", "  (count (lambda (x) (string=? (substring x 0 1) \"I\"))\n         (regexp-split\
    \ #rx\"[.?!]\" S)))\n", "  (length (filter (lambda (x) (string=? (string-take\
    \ x 1) \"I\"))\n                  (regexp-split #rx\"\\.|\\?|!\" S))))\n", " \
    \ (count (lambda (x) (string=? (substring x 0 1) \"I\"))\n         (split-string\
    \ S \"[.?!]\")))\n", "  (count-if (lambda (s) (string=? \"I\" (string-trim s)))\n\
    \            (regexp-split #rx\"\\\\.|\\\\?|!\" S)))\n", "  (cond\n    [(empty?\
    \ S) 0]\n    [(string=? (substring S 0 2) \"I \") (+ 1 (is_bored (substring S\
    \ 2)))]\n    [else (is_bored (substring S 1))]))\n", "  (count (lambda (x) (string=?\
    \ (first (string-split x)) \"I\"))\n         (string-split S \"\\\\.|\\\\?|!\"\
    )))\n", "  (cond\n    [(empty? S) 0]\n    [(string=? (substring S 0 2) \"I \"\
    ) (+ 1 (is_bored (substring S 2)))]\n    [else (is_bored (substring S 1))]))\n",
  "  (define (is_bored-helper S)\n    (cond\n      [(empty? S) 0]\n      [(string=?\
    \ (first S) \"I\") (+ 1 (is_bored-helper (rest S)))]\n      [else (is_bored-helper\
    \ (rest S))]))\n  (is_bored-helper (string-split S #\\.)))\n", "  (length (filter\
    \ (lambda (x) (string=? (string-take x 1) \"I\"))\n                  (regexp-split\
    \ #rx\"[.?!]\" S))))\n", "  (cond\n    [(empty? S) 0]\n    [(string=? (substring\
    \ S 0 2) \"I \") (+ 1 (is_bored (substring S 2)))]\n    [else (is_bored (substring\
    \ S 1))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
