name: HumanEval_78_hex_key
language: rkt
prompt: "#lang racket\n\n;; You have been tasked to write a function that receives\
  \ \n;; a hexadecimal number as a string and counts the number of hexadecimal \n\
  ;; digits that are primes (prime number, or a prime, is a natural number \n;; greater\
  \ than 1 that is not a product of two smaller natural numbers).\n;; Hexadecimal\
  \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n;; Prime numbers are\
  \ 2, 3, 5, 7, 11, 13, 17,...\n;; So you have to determine a number of the following\
  \ digits: 2, 3, 5, 7, \n;; B (=decimal 11), D (=decimal 13).\n;; Note: you may assume\
  \ the input is always correct or empty string, \n;; and symbols A,B,C,D,E,F are\
  \ always uppercase.\n;; Examples:\n;; >>> (hex_key \"AB\")\n;; 1\n;; >>> (hex_key\
  \ \"1077E\")\n;; 2\n;; >>> (hex_key \"ABED1A33\")\n;; 4\n;; >>> (hex_key \"123456789ABCDEF0\"\
  )\n;; 6\n;; >>> (hex_key \"2020\")\n;; 2\n(define (hex_key num)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n\
  \    (check-equal? (candidate \"AB\") 1)\n    (check-equal? (candidate \"1077E\"\
  ) 2)\n    (check-equal? (candidate \"ABED1A33\") 4)\n    (check-equal? (candidate\
  \ \"2020\") 2)\n    (check-equal? (candidate \"123456789ABCDEF0\") 6)\n    (check-equal?\
  \ (candidate \"112233445566778899AABBCCDDEEFF00\") 12)\n    (check-equal? (candidate\
  \ (list )) 0)\n))\n\n(test-humaneval)"
completions: ["  (define (is-prime? n)\n    (define (iter i)\n      (cond\n      \
    \  [(= i n) #t]\n        [(= (modulo n i) 0) #f]\n        [else (iter (+ i 1))]))\n\
    \    (iter 2))\n  (define (hex-to-dec n)\n    (cond\n      [(= n #\\0) 0]\n  \
    \    [(= n #\\1) 1]\n      [(= n #\\2) 2]\n      [(= n #\\3) 3]\n      [(= n #\\\
    4) 4]\n      [(= n #\\5) 5]\n      [(= n #\\6) 6]\n      [(= n #\\7) 7]\n    \
    \  [(= n #\\8) 8]\n      [(= n #\\9) 9]\n      [(= n #\\A) 10]\n      [(= n #\\\
    B) 11]\n      [(= n #\\C) 12]\n      [(= n #\\D) 13]\n      [(= n #\\E) 14]\n\
    \      [(= n #\\F) 15]))\n  (define (iter i count)\n    (cond\n      [(= i (string-length\
    \ num)) count]\n      [(is-prime? (hex-to-dec (string-ref num i))) (iter (+ i\
    \ 1) (+ count 1))]\n      [else (iter (+ i 1) count)]))\n  (iter 0 0))\n", " \
    \ (cond\n    [(empty? num) 0]\n    [(char-numeric? (string-ref num 0))\n     (hex_key\
    \ (substring num 1))]\n    [(char-alphabetic? (string-ref num 0))\n     (cond\n\
    \       [(member (string-ref num 0) '(\"A\" \"B\" \"D\"))\n        (+ 1 (hex_key\
    \ (substring num 1)))]\n       [else (hex_key (substring num 1))])]))\n", "  (define\
    \ (is-prime? n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(even?\
    \ n) #f]\n      [else\n       (define (iter i)\n         (cond\n           [(=\
    \ i n) #t]\n           [(= (modulo n i) 0) #f]\n           [else (iter (+ i 1))]))\n\
    \       (iter 3)]))\n  (define (hex-to-dec n)\n    (cond\n      [(string=? n \"\
    A\") 10]\n      [(string=? n \"B\") 11]\n      [(string=? n \"C\") 12]\n     \
    \ [(string=? n \"D\") 13]\n      [(string=? n \"E\") 14]\n      [(string=? n \"\
    F\") 15]\n      [else (string->number n)]))\n  (define (iter n i)\n    (cond\n\
    \      [(empty? n) i]\n      [(is-prime? (hex-to-dec (first n))) (iter (rest n)\
    \ (+ i 1))]\n      [else (iter (rest n) i)]))\n  (iter (string->list num) 0))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D)) (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", " \
    \ (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol\
    \ (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n</code>\nI'm not sure how to convert\
    \ the hexadecimal string to a number. I tried <code>string-&gt;number</code> and\
    \ <code>string-&gt;symbol</code> but they don't work.\nI'm not sure if I'm using\
    \ <code>substring</code> correctly.\nI'm not sure if I'm using <code>member</code>\
    \ correctly.\n\n\nA:\n\n<code>string-&gt;number</code> and <code>string-&gt;symbol</code>\
    \ are not the right tools for the job.\nThe right tool is <code>string-&gt;number</code>\
    \ with the <code>radix</code> argument:\n<code>(string-&gt;number \"A\" 16)",
  "  (cond\n    [(empty? num) 0]\n    [(char-numeric? (string-ref num 0))\n     (hex_key\
    \ (substring num 1))]\n    [(char-alphabetic? (string-ref num 0))\n     (cond\n\
    \       [(or (= (string-ref num 0) #\\A)\n            (= (string-ref num 0) #\\\
    B)\n            (= (string-ref num 0) #\\C)\n            (= (string-ref num 0)\
    \ #\\D)\n            (= (string-ref num 0) #\\E)\n            (= (string-ref num\
    \ 0) #\\F))\n        (+ 1 (hex_key (substring num 1)))]\n       [else (hex_key\
    \ (substring num 1))])]))\n", "  (define (is-prime? n)\n    (define (iter i)\n\
    \      (if (= i n)\n          #t\n          (if (= (remainder n i) 0)\n      \
    \        #f\n              (iter (+ i 1)))))\n    (iter 2))\n  (define (is-prime-hex?\
    \ n)\n    (cond\n      [(= n #\\2) #t]\n      [(= n #\\3) #t]\n      [(= n #\\\
    5) #t]\n      [(= n #\\7) #t]\n      [(= n #\\B) #t]\n      [(= n #\\D) #t]\n\
    \      [else #f]))\n  (define (iter i count)\n    (if (= i (string-length num))\n\
    \        count\n        (if (is-prime-hex? (string-ref num i))\n            (iter\
    \ (+ i 1) (+ count 1))\n            (iter (+ i 1) count))))\n  (iter 0 0))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((= i n) #t)\n     \
    \       ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter\
    \ 2))\n  (define (hex-to-decimal n)\n    (cond ((string=? n \"A\") 10)\n     \
    \     ((string=? n \"B\") 11)\n          ((string=? n \"C\") 12)\n          ((string=?\
    \ n \"D\") 13)\n          ((string=? n \"E\") 14)\n          ((string=? n \"F\"\
    ) 15)\n          (else (string->number n))))\n  (define (iter i count)\n    (cond\
    \ ((= i (string-length num)) count)\n          ((is-prime? (hex-to-decimal (string-ref\
    \ num i))) (iter (+ i 1) (+ count 1)))\n          (else (iter (+ i 1) count))))\n\
    \  (iter 0 0))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\\
    2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (cond\n    [(empty? num) 0]\n    [(hex-prime? (first num))\
    \ (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (define\
    \ (is_prime? n)\n    (cond\n      [(= n 2) #t]\n      [(= n 3) #t]\n      [(=\
    \ n 5) #t]\n      [(= n 7) #t]\n      [(= n 11) #t]\n      [(= n 13) #t]\n   \
    \   [(= n 17) #t]\n      [(= n 19) #t]\n      [(= n 23) #t]\n      [(= n 29) #t]\n\
    \      [(= n 31) #t]\n      [(= n 37) #t]\n      [(= n 41) #t]\n      [(= n 43)\
    \ #t]\n      [(= n 47) #t]\n      [(= n 53) #t]\n      [(= n 59) #t]\n      [(=\
    \ n 61) #t]\n      [(= n 67) #t]\n      [(= n 71) #t]\n      [(= n 73) #t]\n \
    \     [(= n 79) #t]\n      [(= n 83) #t]\n      [(= n 89) #t]\n      [(= n 97)\
    \ #t]\n      [(= n 101) #t]\n      [(= n 103) #t]\n      [(= n 107) #t]\n    \
    \  [(= n 109) #t]\n      [(= n 113) #t]\n      [(= n 127) #t]\n      [(= n 131)\
    \ #t]\n      [(= n 137) #t]\n      [(= n 139) #t]\n      [(= n 149) #t]\n    \
    \  [(= n 151) #t]\n      [(= n 157) #t]\n      [(= n 163) #t]\n      [(= n 167)\
    \ #t]\n      [(= n 173) #t]\n      [(= n 179) #t]\n      [(= n 181) #t]\n    \
    \  [(= n 191) #t]\n      [(= n 193) #t]\n      [(= n 197) #t]\n      [(= n 199)\
    \ #t]\n      [(= n 211) #t]\n      [(= n 223) #t]\n      [(= n 227) #t]\n    \
    \  [(= n 229)", "  (length (filter (lambda (x) (member x '(2 3 5 7 11 13))) (map\
    \ string->number (string-&gt;list num) 16))))\n</code>\n", "  (define (is-prime?\
    \ n)\n    (define (is-divisible? a b)\n      (= (remainder a b) 0))\n    (define\
    \ (iter i)\n      (cond ((= i n) #t)\n            ((is-divisible? n i) #f)\n \
    \           (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal\
    \ n)\n    (cond ((string=? n \"A\") 10)\n          ((string=? n \"B\") 11)\n \
    \         ((string=? n \"C\") 12)\n          ((string=? n \"D\") 13)\n       \
    \   ((string=? n \"E\") 14)\n          ((string=? n \"F\") 15)\n          (else\
    \ (string->number n))))\n  (define (iter n i)\n    (cond ((= i (string-length\
    \ n)) 0)\n          ((is-prime? (hex-to-decimal (string-ref n i))) (+ 1 (iter\
    \ n (+ i 1))))\n          (else (iter n (+ i 1)))))\n  (iter num 0))\n", "  (define\
    \ (hex-to-dec num)\n    (cond\n      [(string=? num \"A\") 10]\n      [(string=?\
    \ num \"B\") 11]\n      [(string=? num \"C\") 12]\n      [(string=? num \"D\"\
    ) 13]\n      [(string=? num \"E\") 14]\n      [(string=? num \"F\") 15]\n    \
    \  [else (string->number num)]))\n  (define (is-prime? num)\n    (define (iter\
    \ i)\n      (cond\n        [(= i num) #t]\n        [(= (modulo num i) 0) #f]\n\
    \        [else (iter (+ i 1))]))\n    (iter 2))\n  (define (iter num count)\n\
    \    (cond\n      [(empty? num) count]\n      [(is-prime? (hex-to-dec (first num)))\
    \ (iter (rest num) (+ count 1))]\n      [else (iter (rest num) count)]))\n  (iter\
    \ num 0))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((=\
    \ i 1) #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (- i\
    \ 1)))))\n    (iter (quotient n 2)))\n  (define (hex-to-dec n)\n    (cond ((string=?\
    \ n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\"\
    ) 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n\
    \          ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (iter num count)\n    (cond ((string=? num \"\") count)\n          ((is-prime?\
    \ (hex-to-dec (substring num 0 1))) (iter (substring num 1) (+ count 1)))\n  \
    \        (else (iter (substring num 1) count))))\n  (iter num 0))\n", "  (define\
    \ (hex-to-int c)\n    (cond\n      [(string=? c \"0\") 0]\n      [(string=? c\
    \ \"1\") 1]\n      [(string=? c \"2\") 2]\n      [(string=? c \"3\") 3]\n    \
    \  [(string=? c \"4\") 4]\n      [(string=? c \"5\") 5]\n      [(string=? c \"\
    6\") 6]\n      [(string=? c \"7\") 7]\n      [(string=? c \"8\") 8]\n      [(string=?\
    \ c \"9\") 9]\n      [(string=? c \"A\") 10]\n      [(string=? c \"B\") 11]\n\
    \      [(string=? c \"C\") 12]\n      [(string=? c \"D\") 13]\n      [(string=?\
    \ c \"E\") 14]\n      [(string=? c \"F\") 15]\n      [else 0]))\n  (define (is-prime?\
    \ n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(= n 3) #t]\n\
    \      [(= n 5) #t]\n      [(= n 7) #t]\n      [(= n 11) #t]\n      [(= n 13)\
    \ #t]\n      [else #f]))\n  (define (count-primes num)\n    (cond\n      [(empty?\
    \ num) 0]\n      [(is-prime? (hex-to-int (first num))) (+ 1 (count-primes (rest\
    \ num)))]\n      [else (count-primes (rest num))]))\n  (count-primes num))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(\"2\" \"3\" \"5\" \"\
    7\" \"B\" \"D\"))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest\
    \ num))]))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\\
    2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond\
    \ ((= i 1) #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (-\
    \ i 1)))))\n    (iter (/ n 2)))\n  (define (hex-to-dec n)\n    (cond ((string=?\
    \ n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\"\
    ) 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n\
    \          ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (iter n count)\n    (cond ((string=? n \"\") count)\n          ((is-prime? (hex-to-dec\
    \ (substring n 0 1))) (iter (substring n 1) (+ count 1)))\n          (else (iter\
    \ (substring n 1) count))))\n  (iter num 0))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
