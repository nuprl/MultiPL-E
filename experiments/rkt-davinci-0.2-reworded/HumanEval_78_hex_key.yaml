name: HumanEval_78_hex_key
language: rkt
prompt: "#lang racket\n\n;; You have been tasked to write a function that receives\
  \ \n;; a hexadecimal number as a string and counts the number of hexadecimal \n\
  ;; digits that are primes (prime number, or a prime, is a natural number \n;; greater\
  \ than 1 that is not a product of two smaller natural numbers).\n;; Hexadecimal\
  \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n;; Prime numbers are\
  \ 2, 3, 5, 7, 11, 13, 17,...\n;; So you have to determine a number of the following\
  \ digits: 2, 3, 5, 7, \n;; B (=decimal 11), D (=decimal 13).\n;; Note: you may assume\
  \ the input is always correct or empty string, \n;; and symbols A,B,C,D,E,F are\
  \ always uppercase.\n;; Examples:\n;; >>> (hex_key \"AB\")\n;; 1\n;; >>> (hex_key\
  \ \"1077E\")\n;; 2\n;; >>> (hex_key \"ABED1A33\")\n;; 4\n;; >>> (hex_key \"123456789ABCDEF0\"\
  )\n;; 6\n;; >>> (hex_key \"2020\")\n;; 2\n(define (hex_key num)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate hex_key))\n\
  \    (check-equal? (candidate \"AB\") 1)\n    (check-equal? (candidate \"1077E\"\
  ) 2)\n    (check-equal? (candidate \"ABED1A33\") 4)\n    (check-equal? (candidate\
  \ \"2020\") 2)\n    (check-equal? (candidate \"123456789ABCDEF0\") 6)\n    (check-equal?\
  \ (candidate \"112233445566778899AABBCCDDEEFF00\") 12)\n    (check-equal? (candidate\
  \ (list )) 0)\n))\n\n(test-humaneval)"
completions: ["  (define (is-prime? n)\n    (define (iter i)\n      (cond\n      \
    \  [(= i n) #t]\n        [(= (modulo n i) 0) #f]\n        [else (iter (+ i 1))]))\n\
    \    (iter 2))\n  (define (hex-to-dec n)\n    (cond\n      [(= n #\\0) 0]\n  \
    \    [(= n #\\1) 1]\n      [(= n #\\2) 2]\n      [(= n #\\3) 3]\n      [(= n #\\\
    4) 4]\n      [(= n #\\5) 5]\n      [(= n #\\6) 6]\n      [(= n #\\7) 7]\n    \
    \  [(= n #\\8) 8]\n      [(= n #\\9) 9]\n      [(= n #\\A) 10]\n      [(= n #\\\
    B) 11]\n      [(= n #\\C) 12]\n      [(= n #\\D) 13]\n      [(= n #\\E) 14]\n\
    \      [(= n #\\F) 15]))\n  (define (iter i count)\n    (cond\n      [(= i (string-length\
    \ num)) count]\n      [(is-prime? (hex-to-dec (string-ref num i))) (iter (+ i\
    \ 1) (+ count 1))]\n      [else (iter (+ i 1) count)]))\n  (iter 0 0))\n", " \
    \ (cond\n    [(empty? num) 0]\n    [(char-numeric? (string-ref num 0))\n     (hex_key\
    \ (substring num 1))]\n    [(char-alphabetic? (string-ref num 0))\n     (cond\n\
    \       [(member (string-ref num 0) '(\"A\" \"B\" \"D\"))\n        (+ 1 (hex_key\
    \ (substring num 1)))]\n       [else (hex_key (substring num 1))])]))\n", "  (define\
    \ (is-prime? n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(even?\
    \ n) #f]\n      [else\n       (define (iter i)\n         (cond\n           [(=\
    \ i n) #t]\n           [(= (modulo n i) 0) #f]\n           [else (iter (+ i 1))]))\n\
    \       (iter 3)]))\n  (define (hex-to-dec n)\n    (cond\n      [(string=? n \"\
    A\") 10]\n      [(string=? n \"B\") 11]\n      [(string=? n \"C\") 12]\n     \
    \ [(string=? n \"D\") 13]\n      [(string=? n \"E\") 14]\n      [(string=? n \"\
    F\") 15]\n      [else (string->number n)]))\n  (define (iter n i)\n    (cond\n\
    \      [(empty? n) i]\n      [(is-prime? (hex-to-dec (first n))) (iter (rest n)\
    \ (+ i 1))]\n      [else (iter (rest n) i)]))\n  (iter (string->list num) 0))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D)) (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", " \
    \ (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol\
    \ (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n</code>\nI'm not sure how to convert\
    \ the hexadecimal string to a number. I tried <code>string-&gt;number</code> and\
    \ <code>string-&gt;symbol</code> but they don't work.\nI'm not sure if I'm using\
    \ <code>substring</code> correctly.\nI'm not sure if I'm using <code>member</code>\
    \ correctly.\n\n\nA:\n\n<code>string-&gt;number</code> and <code>string-&gt;symbol</code>\
    \ are not the right tools for the job.\nThe right tool is <code>string-&gt;number</code>\
    \ with the <code>radix</code> argument:\n<code>(string-&gt;number \"A\" 16)",
  "  (cond\n    [(empty? num) 0]\n    [(char-numeric? (string-ref num 0))\n     (hex_key\
    \ (substring num 1))]\n    [(char-alphabetic? (string-ref num 0))\n     (cond\n\
    \       [(or (= (string-ref num 0) #\\A)\n            (= (string-ref num 0) #\\\
    B)\n            (= (string-ref num 0) #\\C)\n            (= (string-ref num 0)\
    \ #\\D)\n            (= (string-ref num 0) #\\E)\n            (= (string-ref num\
    \ 0) #\\F))\n        (+ 1 (hex_key (substring num 1)))]\n       [else (hex_key\
    \ (substring num 1))])]))\n", "  (define (is-prime? n)\n    (define (iter i)\n\
    \      (if (= i n)\n          #t\n          (if (= (remainder n i) 0)\n      \
    \        #f\n              (iter (+ i 1)))))\n    (iter 2))\n  (define (is-prime-hex?\
    \ n)\n    (cond\n      [(= n #\\2) #t]\n      [(= n #\\3) #t]\n      [(= n #\\\
    5) #t]\n      [(= n #\\7) #t]\n      [(= n #\\B) #t]\n      [(= n #\\D) #t]\n\
    \      [else #f]))\n  (define (iter i count)\n    (if (= i (string-length num))\n\
    \        count\n        (if (is-prime-hex? (string-ref num i))\n            (iter\
    \ (+ i 1) (+ count 1))\n            (iter (+ i 1) count))))\n  (iter 0 0))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((= i n) #t)\n     \
    \       ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter\
    \ 2))\n  (define (hex-to-decimal n)\n    (cond ((string=? n \"A\") 10)\n     \
    \     ((string=? n \"B\") 11)\n          ((string=? n \"C\") 12)\n          ((string=?\
    \ n \"D\") 13)\n          ((string=? n \"E\") 14)\n          ((string=? n \"F\"\
    ) 15)\n          (else (string->number n))))\n  (define (iter i count)\n    (cond\
    \ ((= i (string-length num)) count)\n          ((is-prime? (hex-to-decimal (string-ref\
    \ num i))) (iter (+ i 1) (+ count 1)))\n          (else (iter (+ i 1) count))))\n\
    \  (iter 0 0))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\\
    2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (cond\n    [(empty? num) 0]\n    [(hex-prime? (first num))\
    \ (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (define\
    \ (is_prime? n)\n    (cond\n      [(= n 2) #t]\n      [(= n 3) #t]\n      [(=\
    \ n 5) #t]\n      [(= n 7) #t]\n      [(= n 11) #t]\n      [(= n 13) #t]\n   \
    \   [(= n 17) #t]\n      [(= n 19) #t]\n      [(= n 23) #t]\n      [(= n 29) #t]\n\
    \      [(= n 31) #t]\n      [(= n 37) #t]\n      [(= n 41) #t]\n      [(= n 43)\
    \ #t]\n      [(= n 47) #t]\n      [(= n 53) #t]\n      [(= n 59) #t]\n      [(=\
    \ n 61) #t]\n      [(= n 67) #t]\n      [(= n 71) #t]\n      [(= n 73) #t]\n \
    \     [(= n 79) #t]\n      [(= n 83) #t]\n      [(= n 89) #t]\n      [(= n 97)\
    \ #t]\n      [(= n 101) #t]\n      [(= n 103) #t]\n      [(= n 107) #t]\n    \
    \  [(= n 109) #t]\n      [(= n 113) #t]\n      [(= n 127) #t]\n      [(= n 131)\
    \ #t]\n      [(= n 137) #t]\n      [(= n 139) #t]\n      [(= n 149) #t]\n    \
    \  [(= n 151) #t]\n      [(= n 157) #t]\n      [(= n 163) #t]\n      [(= n 167)\
    \ #t]\n      [(= n 173) #t]\n      [(= n 179) #t]\n      [(= n 181) #t]\n    \
    \  [(= n 191) #t]\n      [(= n 193) #t]\n      [(= n 197) #t]\n      [(= n 199)\
    \ #t]\n      [(= n 211) #t]\n      [(= n 223) #t]\n      [(= n 227) #t]\n    \
    \  [(= n 229)", "  (length (filter (lambda (x) (member x '(2 3 5 7 11 13))) (map\
    \ string->number (string-&gt;list num) 16))))\n</code>\n", "  (define (is-prime?\
    \ n)\n    (define (is-divisible? a b)\n      (= (remainder a b) 0))\n    (define\
    \ (iter i)\n      (cond ((= i n) #t)\n            ((is-divisible? n i) #f)\n \
    \           (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal\
    \ n)\n    (cond ((string=? n \"A\") 10)\n          ((string=? n \"B\") 11)\n \
    \         ((string=? n \"C\") 12)\n          ((string=? n \"D\") 13)\n       \
    \   ((string=? n \"E\") 14)\n          ((string=? n \"F\") 15)\n          (else\
    \ (string->number n))))\n  (define (iter n i)\n    (cond ((= i (string-length\
    \ n)) 0)\n          ((is-prime? (hex-to-decimal (string-ref n i))) (+ 1 (iter\
    \ n (+ i 1))))\n          (else (iter n (+ i 1)))))\n  (iter num 0))\n", "  (define\
    \ (hex-to-dec num)\n    (cond\n      [(string=? num \"A\") 10]\n      [(string=?\
    \ num \"B\") 11]\n      [(string=? num \"C\") 12]\n      [(string=? num \"D\"\
    ) 13]\n      [(string=? num \"E\") 14]\n      [(string=? num \"F\") 15]\n    \
    \  [else (string->number num)]))\n  (define (is-prime? num)\n    (define (iter\
    \ i)\n      (cond\n        [(= i num) #t]\n        [(= (modulo num i) 0) #f]\n\
    \        [else (iter (+ i 1))]))\n    (iter 2))\n  (define (iter num count)\n\
    \    (cond\n      [(empty? num) count]\n      [(is-prime? (hex-to-dec (first num)))\
    \ (iter (rest num) (+ count 1))]\n      [else (iter (rest num) count)]))\n  (iter\
    \ num 0))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((=\
    \ i 1) #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (- i\
    \ 1)))))\n    (iter (quotient n 2)))\n  (define (hex-to-dec n)\n    (cond ((string=?\
    \ n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\"\
    ) 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n\
    \          ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (iter num count)\n    (cond ((string=? num \"\") count)\n          ((is-prime?\
    \ (hex-to-dec (substring num 0 1))) (iter (substring num 1) (+ count 1)))\n  \
    \        (else (iter (substring num 1) count))))\n  (iter num 0))\n", "  (define\
    \ (hex-to-int c)\n    (cond\n      [(string=? c \"0\") 0]\n      [(string=? c\
    \ \"1\") 1]\n      [(string=? c \"2\") 2]\n      [(string=? c \"3\") 3]\n    \
    \  [(string=? c \"4\") 4]\n      [(string=? c \"5\") 5]\n      [(string=? c \"\
    6\") 6]\n      [(string=? c \"7\") 7]\n      [(string=? c \"8\") 8]\n      [(string=?\
    \ c \"9\") 9]\n      [(string=? c \"A\") 10]\n      [(string=? c \"B\") 11]\n\
    \      [(string=? c \"C\") 12]\n      [(string=? c \"D\") 13]\n      [(string=?\
    \ c \"E\") 14]\n      [(string=? c \"F\") 15]\n      [else 0]))\n  (define (is-prime?\
    \ n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(= n 3) #t]\n\
    \      [(= n 5) #t]\n      [(= n 7) #t]\n      [(= n 11) #t]\n      [(= n 13)\
    \ #t]\n      [else #f]))\n  (define (count-primes num)\n    (cond\n      [(empty?\
    \ num) 0]\n      [(is-prime? (hex-to-int (first num))) (+ 1 (count-primes (rest\
    \ num)))]\n      [else (count-primes (rest num))]))\n  (count-primes num))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(\"2\" \"3\" \"5\" \"\
    7\" \"B\" \"D\"))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest\
    \ num))]))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\\
    2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond\
    \ ((= i 1) #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (-\
    \ i 1)))))\n    (iter (/ n 2)))\n  (define (hex-to-dec n)\n    (cond ((string=?\
    \ n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\"\
    ) 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n\
    \          ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (iter n count)\n    (cond ((string=? n \"\") count)\n          ((is-prime? (hex-to-dec\
    \ (substring n 0 1))) (iter (substring n 1) (+ count 1)))\n          (else (iter\
    \ (substring n 1) count))))\n  (iter num 0))\n", "  (define (is-prime? n)\n  \
    \  (define (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo n i) 0)\
    \ #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex->dec\
    \ n)\n    (cond ((= n #\\0) 0)\n          ((= n #\\1) 1)\n          ((= n #\\\
    2) 2)\n          ((= n #\\3) 3)\n          ((= n #\\4) 4)\n          ((= n #\\\
    5) 5)\n          ((= n #\\6) 6)\n          ((= n #\\7) 7)\n          ((= n #\\\
    8) 8)\n          ((= n #\\9) 9)\n          ((= n #\\A) 10)\n          ((= n #\\\
    B) 11)\n          ((= n #\\C) 12)\n          ((= n #\\D) 13)\n          ((= n\
    \ #\\E) 14)\n          ((= n #\\F) 15)))\n  (define (count-primes n)\n    (define\
    \ (iter i acc)\n      (cond ((= i (string-length n)) acc)\n            ((is-prime?\
    \ (hex->dec (string-ref n i))) (iter (+ i 1) (+ acc 1)))\n            (else (iter\
    \ (+ i 1) acc))))\n    (iter 0 0))\n  (count-primes num))\n", "  (define (is-prime?\
    \ n)\n    (define (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo\
    \ n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-dec\
    \ n)\n    (cond ((string=? n \"A\") 10)\n          ((string=? n \"B\") 11)\n \
    \         ((string=? n \"C\") 12)\n          ((string=? n \"D\") 13)\n       \
    \   ((string=? n \"E\") 14)\n          ((string=? n \"F\") 15)\n          (else\
    \ (string->number n))))\n  (define (iter i acc)\n    (cond ((= i (string-length\
    \ num)) acc)\n          ((is-prime? (hex-to-dec (string-ref num i))) (iter (+\
    \ i 1) (+ acc 1)))\n          (else (iter (+ i 1) acc))))\n  (iter 0 0))\n", " \
    \ (define (is-prime? n)\n    (cond ((= n 1) #f)\n          ((= n 2) #t)\n    \
    \      ((even? n) #f)\n          (else (let loop ((i 3))\n                  (cond\
    \ ((= i n) #t)\n                        ((= (remainder n i) 0) #f)\n         \
    \               (else (loop (+ i 2))))))))\n  (define (is-prime-hex? n)\n    (cond\
    \ ((= n #\\2) #t)\n          ((= n #\\3) #t)\n          ((= n #\\5) #t)\n    \
    \      ((= n #\\7) #t)\n          ((= n #\\B) #t)\n          ((= n #\\D) #t)\n\
    \          (else #f)))\n  (define (count-primes-hex num)\n    (cond ((null? num)\
    \ 0)\n          ((is-prime-hex? (car num)) (+ 1 (count-primes-hex (cdr num))))\n\
    \          (else (count-primes-hex (cdr num)))))\n  (count-primes-hex (string->list\
    \ num)))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\\
    3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond\
    \ ((= i n) #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (+\
    \ i 1)))))\n    (iter 2))\n  (define (hex-to-dec n)\n    (cond ((string=? n \"\
    A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\") 12)\n\
    \          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n      \
    \    ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (iter i acc)\n    (cond ((= i (string-length num)) acc)\n          ((is-prime?\
    \ (hex-to-dec (string-ref num i))) (iter (+ i 1) (+ acc 1)))\n          (else\
    \ (iter (+ i 1) acc))))\n  (iter 0 0))\n", "  (cond\n    [(empty? num) 0]\n  \
    \  [(hex-prime? (first num)) (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest\
    \ num))]))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond\n \
    \       [(= i n) #t]\n        [(= (modulo n i) 0) #f]\n        [else (iter (+\
    \ i 1))]))\n    (iter 2))\n  (define (hex-to-dec n)\n    (cond\n      [(string=?\
    \ n \"A\") 10]\n      [(string=? n \"B\") 11]\n      [(string=? n \"C\") 12]\n\
    \      [(string=? n \"D\") 13]\n      [(string=? n \"E\") 14]\n      [(string=?\
    \ n \"F\") 15]\n      [else (string->number n)]))\n  (define (iter i count)\n\
    \    (cond\n      [(= i (string-length num)) count]\n      [(is-prime? (hex-to-dec\
    \ (string-ref num i))) (iter (+ i 1) (+ count 1))]\n      [else (iter (+ i 1)\
    \ count)]))\n  (iter 0 0))\n", "  (define (is-prime? n)\n    (define (iter i)\n\
    \      (cond ((= i n) #t)\n            ((= (modulo n i) 0) #f)\n            (else\
    \ (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-dec n)\n    (cond ((string=?\
    \ n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\"\
    ) 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n\
    \          ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (iter n i)\n    (cond ((= i (string-length n)) 0)\n          ((is-prime? (hex-to-dec\
    \ (string-ref n i))) (+ 1 (iter n (+ i 1))))\n          (else (iter n (+ i 1)))))\n\
    \  (iter num 0))\n", "  (define (hex-to-dec num)\n    (cond\n      [(string=?\
    \ num \"A\") 10]\n      [(string=? num \"B\") 11]\n      [(string=? num \"C\"\
    ) 12]\n      [(string=? num \"D\") 13]\n      [(string=? num \"E\") 14]\n    \
    \  [(string=? num \"F\") 15]\n      [else (string->number num)]))\n  (define (is-prime?\
    \ num)\n    (define (iter n)\n      (cond\n        [(= n 1) true]\n        [(=\
    \ (modulo num n) 0) false]\n        [else (iter (- n 1))]))\n    (iter (/ num\
    \ 2)))\n  (define (iter num count)\n    (cond\n      [(empty? num) count]\n  \
    \    [(is-prime? (hex-to-dec (first num))) (iter (rest num) (+ count 1))]\n  \
    \    [else (iter (rest num) count)]))\n  (iter num 0))\n", "  (define (is-prime?\
    \ n)\n    (define (iter i)\n      (cond\n        [(= i n) #t]\n        [(= (modulo\
    \ n i) 0) #f]\n        [else (iter (+ i 1))]))\n    (iter 2))\n  (define (hex-to-dec\
    \ n)\n    (cond\n      [(string=? n \"A\") 10]\n      [(string=? n \"B\") 11]\n\
    \      [(string=? n \"C\") 12]\n      [(string=? n \"D\") 13]\n      [(string=?\
    \ n \"E\") 14]\n      [(string=? n \"F\") 15]\n      [else (string->number n)]))\n\
    \  (define (iter n count)\n    (cond\n      [(string=? n \"\") count]\n      [(is-prime?\
    \ (hex-to-dec (string-ref n 0))) (iter (substring n 1) (+ count 1))]\n      [else\
    \ (iter (substring n 1) count)]))\n  (iter num 0))\n", "  (define (is-prime? n)\n\
    \    (define (is-divisible? a b)\n      (= (remainder a b) 0))\n    (define (smallest-divisor\
    \ n)\n      (define (find-divisor n test-divisor)\n        (cond ((> (square test-divisor)\
    \ n) n)\n              ((is-divisible? n test-divisor) test-divisor)\n       \
    \       (else (find-divisor n (+ test-divisor 1)))))\n      (find-divisor n 2))\n\
    \    (= n (smallest-divisor n)))\n  (define (hex-to-dec n)\n    (cond ((string=?\
    \ n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\"\
    ) 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n\
    \          ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (hex-to-dec-list n)\n    (map hex-to-dec (string->list n)))\n  (define (count-primes\
    \ n)\n    (cond ((null? n) 0)\n          ((is-prime? (car n)) (+ 1 (count-primes\
    \ (cdr n))))\n          (else (count-primes (cdr n)))))\n  (count-primes (hex-to-dec-list\
    \ num)))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\\
    3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (hex-to-dec num)\n    (cond\n      [(string=?\
    \ num \"A\") 10]\n      [(string=? num \"B\") 11]\n      [(string=? num \"C\"\
    ) 12]\n      [(string=? num \"D\") 13]\n      [(string=? num \"E\") 14]\n    \
    \  [(string=? num \"F\") 15]\n      [else (string->number num)]))\n  (define (is-prime?\
    \ num)\n    (define (iter i)\n      (cond\n        [(= i 1) #t]\n        [(= (modulo\
    \ num i) 0) #f]\n        [else (iter (- i 1))]))\n    (iter (/ num 2)))\n  (define\
    \ (iter num count)\n    (cond\n      [(empty? num) count]\n      [(is-prime? (hex-to-dec\
    \ (first num))) (iter (rest num) (+ count 1))]\n      [else (iter (rest num) count)]))\n\
    \  (iter num 0))\n", "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number\
    \ (string-&gt;symbol (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key\
    \ (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\nI have\
    \ a problem with the line <code>(member (string-&gt;number (string-&gt;symbol\
    \ (substring num 0 1))) '(2 3 5 7 11 13))</code>.\nI am trying to check if the\
    \ first character of the string is a prime number.\nI am using <code>string-&gt;symbol</code>\
    \ to convert the string to a symbol, and then <code>string-&gt;number</code> to\
    \ convert the symbol to a number.\nHowever, when I run the code, I get the following\
    \ error:\n<code>string-&gt;number: expects argument of type &lt;string&gt;; given\
    \ #\\A\n</code>\nI am not sure what I am doing wrong.\n\n\nA:\n\nYou're using\
    \ <code>string-&gt;symbol</code> on a string that contains a single character,\
    \ which is not what it's meant for. Instead, use <code>string-&gt;number</code>\
    \ directly on the string, and it will work as expected:\n<code>(string-&gt;number\
    \ (substring num 0 1))\n</code>\n", "  (define (hex-to-dec num)\n    (cond\n \
    \     [(string=? num \"A\") 10]\n      [(string=? num \"B\") 11]\n      [(string=?\
    \ num \"C\") 12]\n      [(string=? num \"D\") 13]\n      [(string=? num \"E\"\
    ) 14]\n      [(string=? num \"F\") 15]\n      [else (string->number num)]))\n\
    \  (define (is-prime? num)\n    (cond\n      [(= num 1) #f]\n      [(= num 2)\
    \ #t]\n      [(= num 3) #t]\n      [(= num 5) #t]\n      [(= num 7) #t]\n    \
    \  [(= num 11) #t]\n      [(= num 13) #t]\n      [else #f]))\n  (define (count-primes\
    \ num)\n    (cond\n      [(empty? num) 0]\n      [(is-prime? (hex-to-dec (first\
    \ num))) (+ 1 (count-primes (rest num)))]\n      [else (count-primes (rest num))]))\n\
    \  (count-primes num))\n", "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number\
    \ (string-&gt;symbol (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key\
    \ (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\nI am\
    \ getting the following error:\n<code>string-&gt;number: expects argument of type\
    \ &lt;string&gt;; given #\\A\n</code>\nI am not sure how to fix this.\n\n\nA:\n\
    \nYou're trying to convert a character to a number, which is not possible. You\
    \ need to convert the character to a string first, and then convert the string\
    \ to a number.\nAlso, you're using <code>substring</code> in a way that's not\
    \ correct, you need to pass the start and end indexes.\n<code>(define (hex_key\
    \ num)\n  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol\
    \ (string (substring num 0 1)))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring\
    \ num 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\n", "  (cond\n\
    \    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol (substring\
    \ num 0 1)))\n             '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num\
    \ 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+\
    \ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (cond\n \
    \   [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\\
    D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", " \
    \ (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7\
    \ #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol\
    \ (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n", "  (define (is-prime? n)\n    (define\
    \ (iter i)\n      (if (= i n)\n          #t\n          (if (= (remainder n i)\
    \ 0)\n              #f\n              (iter (+ i 1)))))\n    (iter 2))\n  (define\
    \ (hex-to-decimal n)\n    (cond ((= n #\\0) 0)\n          ((= n #\\1) 1)\n   \
    \       ((= n #\\2) 2)\n          ((= n #\\3) 3)\n          ((= n #\\4) 4)\n \
    \         ((= n #\\5) 5)\n          ((= n #\\6) 6)\n          ((= n #\\7) 7)\n\
    \          ((= n #\\8) 8)\n          ((= n #\\9) 9)\n          ((= n #\\A) 10)\n\
    \          ((= n #\\B) 11)\n          ((= n #\\C) 12)\n          ((= n #\\D) 13)\n\
    \          ((= n #\\E) 14)\n          ((= n #\\F) 15)))\n  (define (iter n count)\n\
    \    (if (empty? n)\n        count\n        (if (is-prime? (hex-to-decimal (first\
    \ n)))\n            (iter (rest n) (+ count 1))\n            (iter (rest n) count))))\n\
    \  (iter (string->list num) 0))\n", "  (define (is-prime? n)\n    (cond\n    \
    \  [(= n 1) false]\n      [(= n 2) true]\n      [(= (remainder n 2) 0) false]\n\
    \      [else\n       (define (iter i)\n         (cond\n           [(= i (sqrt\
    \ n)) true]\n           [(= (remainder n i) 0) false]\n           [else (iter\
    \ (+ i 1))]))\n       (iter 3)]))\n  (define (hex-to-dec n)\n    (cond\n     \
    \ [(string=? n \"A\") 10]\n      [(string=? n \"B\") 11]\n      [(string=? n \"\
    C\") 12]\n      [(string=? n \"D\") 13]\n      [(string=? n \"E\") 14]\n     \
    \ [(string=? n \"F\") 15]\n      [else (string->number n)]))\n  (define (iter\
    \ n i)\n    (cond\n      [(empty? n) i]\n      [(is-prime? (hex-to-dec (first\
    \ n))) (iter (rest n) (+ i 1))]\n      [else (iter (rest n) i)]))\n  (iter (string->list\
    \ num) 0))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\\
    2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (let ([hex-digits (string->list num)]\n        [primes\
    \ '(2 3 5 7 11 13)])\n    (length (filter (lambda (x) (member x primes)) hex-digits))))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol\
    \ (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n</code>\nI am getting the following\
    \ error:\n<code>application: not a procedure;\n expected a procedure that can\
    \ be applied to arguments\n  given: 2\n  arguments...: [none]\n</code>\nI am not\
    \ sure what is wrong with my code.\n\n\nA:\n\nThe problem is that <code>member</code>\
    \ returns a boolean, not a number. So your <code>cond</code> is trying to apply\
    \ the number <code>2</code> to the arguments <code>1</code> and <code>(hex_key\
    \ (substring num 1))</code>.\nYou can fix this by wrapping the <code>member</code>\
    \ call in a <code>if</code> expression:\n<code>(define (hex_key num)\n  (cond\n\
    \    [(empty? num) 0]\n    [(if (member (string-&gt;number (string-&gt;symbol\
    \ (substring num 0 1))) '(2 3 5 7 11 13))\n       (+ 1 (hex_key (substring num\
    \ 1)))\n       (hex_key (substring num 1)))]))\n</code>\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (first num) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (rest\
    \ num)))]\n    [else (hex_key (rest num))]))\n", "  (define (is-prime? n)\n  \
    \  (define (iter i)\n      (if (= i n)\n          #t\n          (if (= (remainder\
    \ n i) 0)\n              #f\n              (iter (+ i 1)))))\n    (iter 2))\n\
    \  (define (hex-to-decimal n)\n    (cond ((string=? n \"A\") 10)\n          ((string=?\
    \ n \"B\") 11)\n          ((string=? n \"C\") 12)\n          ((string=? n \"D\"\
    ) 13)\n          ((string=? n \"E\") 14)\n          ((string=? n \"F\") 15)\n\
    \          (else (string->number n))))\n  (define (iter n i)\n    (if (= i (string-length\
    \ n))\n        0\n        (if (is-prime? (hex-to-decimal (string-ref n i)))\n\
    \            (+ 1 (iter n (+ i 1)))\n            (iter n (+ i 1)))))\n  (iter\
    \ num 0))\n", "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number\
    \ (string-&gt;symbol (string-ref num 0))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key\
    \ (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\nI am\
    \ getting the following error:\n<code>&gt; (hex_key \"AB\")\n. . string-&gt;number:\
    \ expects argument of type &lt;number&gt;; given #\\A\n</code>\nI am not sure\
    \ what is wrong with the code.\n\n\nA:\n\n<code>string-&gt;number</code> expects\
    \ a string, not a character. You can use <code>string-&gt;number</code> on the\
    \ whole string, and then use <code>modulo</code> to get the last digit.\n<code>(define\
    \ (hex_key num)\n  (cond\n    [(empty? num) 0]\n    [(member (modulo (string-&gt;number\
    \ num) 16) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else\
    \ (hex_key (substring num 1))]))\n</code>\n", "  (define (is-prime? n)\n    (define\
    \ (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo n i) 0) #f)\n  \
    \          (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal n)\n\
    \    (define (iter i)\n      (cond ((= i (string-length n)) 0)\n            (else\
    \ (+ (* (expt 16 (- (string-length n) i 1))\n                       (string-&gt;number\
    \ (string (string-ref n i))))\n                    (iter (+ i 1))))))\n    (iter\
    \ 0))\n  (define (count-primes n)\n    (define (iter i)\n      (cond ((= i (string-length\
    \ n)) 0)\n            ((is-prime? (hex-to-decimal (string (string-ref n i))))\n\
    \             (+ 1 (iter (+ i 1))))\n            (else (iter (+ i 1)))))\n   \
    \ (iter 0))\n  (count-primes num))\n</code>\n", "  (cond\n    [(empty? num) 0]\n\
    \    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key\
    \ (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+\
    \ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (define (is-prime?\
    \ n)\n    (define (iter i)\n      (if (= i n)\n          #t\n          (if (=\
    \ (remainder n i) 0)\n              #f\n              (iter (+ i 1)))))\n    (iter\
    \ 2))\n  (define (hex-to-dec n)\n    (cond ((string=? n \"A\") 10)\n         \
    \ ((string=? n \"B\") 11)\n          ((string=? n \"C\") 12)\n          ((string=?\
    \ n \"D\") 13)\n          ((string=? n \"E\") 14)\n          ((string=? n \"F\"\
    ) 15)\n          (else (string->number n))))\n  (define (iter num count)\n   \
    \ (if (empty? num)\n        count\n        (if (is-prime? (hex-to-dec (first num)))\n\
    \            (iter (rest num) (+ count 1))\n            (iter (rest num) count))))\n\
    \  (iter num 0))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (if\
    \ (= i n)\n          #t\n          (if (= (remainder n i) 0)\n              #f\n\
    \              (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-dec n)\n  \
    \  (cond\n      [(string=? n \"A\") 10]\n      [(string=? n \"B\") 11]\n     \
    \ [(string=? n \"C\") 12]\n      [(string=? n \"D\") 13]\n      [(string=? n \"\
    E\") 14]\n      [(string=? n \"F\") 15]\n      [else (string->number n)]))\n \
    \ (define (iter n i)\n    (if (= i (string-length n))\n        0\n        (if\
    \ (is-prime? (hex-to-dec (string-ref n i)))\n            (+ 1 (iter n (+ i 1)))\n\
    \            (iter n (+ i 1)))))\n  (iter num 0))\n", "  (cond\n    [(empty? num)\
    \ 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key\
    \ (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+\
    \ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (define (is-prime?\
    \ n)\n    (define (is-divisible? a b)\n      (= (remainder a b) 0))\n    (define\
    \ (smallest-divisor n)\n      (find-divisor n 2))\n    (define (find-divisor n\
    \ test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((is-divisible?\
    \ n test-divisor) test-divisor)\n            (else (find-divisor n (+ test-divisor\
    \ 1)))))\n    (= n (smallest-divisor n)))\n  (define (hex-to-dec n)\n    (cond\
    \ ((= n #\\0) 0)\n          ((= n #\\1) 1)\n          ((= n #\\2) 2)\n       \
    \   ((= n #\\3) 3)\n          ((= n #\\4) 4)\n          ((= n #\\5) 5)\n     \
    \     ((= n #\\6) 6)\n          ((= n #\\7) 7)\n          ((= n #\\8) 8)\n   \
    \       ((= n #\\9) 9)\n          ((= n #\\A) 10)\n          ((= n #\\B) 11)\n\
    \          ((= n #\\C) 12)\n          ((= n #\\D) 13)\n          ((= n #\\E) 14)\n\
    \          ((= n #\\F) 15)))\n  (define (count-primes n)\n    (if (is-prime? (hex-to-dec\
    \ n))\n        1\n        0))\n  (if (string=? num \"\")\n      0\n      (apply\
    \ + (map count-primes (string->list num)))))\n", "  (define (is-prime? n)\n  \
    \  (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(even? n) #f]\n     \
    \ [else\n       (define (iter i)\n         (cond\n           [(= i n) #t]\n  \
    \         [(= (modulo n i) 0) #f]\n           [else (iter (+ i 1))]))\n      \
    \ (iter 3)]))\n  (define (hex-to-dec n)\n    (cond\n      [(string=? n \"A\")\
    \ 10]\n      [(string=? n \"B\") 11]\n      [(string=? n \"C\") 12]\n      [(string=?\
    \ n \"D\") 13]\n      [(string=? n \"E\") 14]\n      [(string=? n \"F\") 15]\n\
    \      [else (string->number n)]))\n  (define (iter i acc)\n    (cond\n      [(=\
    \ i (string-length num)) acc]\n      [(is-prime? (hex-to-dec (string-ref num i)))\
    \ (iter (+ i 1) (+ acc 1))]\n      [else (iter (+ i 1) acc)]))\n  (iter 0 0))\n",
  "  (define (hex-to-dec num)\n    (cond\n      [(string=? num \"A\") 10]\n      [(string=?\
    \ num \"B\") 11]\n      [(string=? num \"C\") 12]\n      [(string=? num \"D\"\
    ) 13]\n      [(string=? num \"E\") 14]\n      [(string=? num \"F\") 15]\n    \
    \  [else (string-&gt;number num)]))\n  (define (is-prime? num)\n    (cond\n  \
    \    [(= num 1) #f]\n      [(= num 2) #t]\n      [(= num 3) #t]\n      [(= num\
    \ 5) #t]\n      [(= num 7) #t]\n      [(= num 11) #t]\n      [(= num 13) #t]\n\
    \      [else #f]))\n  (define (hex-key-helper num)\n    (cond\n      [(empty?\
    \ num) 0]\n      [(is-prime? (hex-to-dec (first num))) (+ 1 (hex-key-helper (rest\
    \ num)))]\n      [else (hex-key-helper (rest num))]))\n  (hex-key-helper (string-&gt;list\
    \ num)))\n</code>\nI'm not sure if this is the most efficient way to do it, but\
    \ it works.\n\n\nA:\n\nI would use <code>string-&gt;number</code> to convert the\
    \ hex string to a number, and then use <code>integer-&gt;digits</code> to convert\
    \ the number to a list of digits.  Then you can use <code>filter</code> to select\
    \ the prime digits.\n<code>(define (hex-key num)\n  (define (is-prime? n)\n  \
    \  (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(= n 3) #t]\n      [(=\
    \ n 5) #t]\n      [(= n 7) #t]\n      [(= n 11) #t]\n      [(= n 13) #t]\n   \
    \   [else #f]))\n  (length (filter is-prime? (integer-&gt;digits (string-&gt",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((= i n) #t)\n     \
    \       ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter\
    \ 2))\n  (define (hex-to-decimal n)\n    (cond ((string=? n \"A\") 10)\n     \
    \     ((string=? n \"B\") 11)\n          ((string=? n \"C\") 12)\n          ((string=?\
    \ n \"D\") 13)\n          ((string=? n \"E\") 14)\n          ((string=? n \"F\"\
    ) 15)\n          (else (string->number n))))\n  (define (hex-to-decimal-list num)\n\
    \    (cond ((null? num) '())\n          (else (cons (hex-to-decimal (string-ref\
    \ num 0))\n                      (hex-to-decimal-list (substring num 1))))))\n\
    \  (define (count-primes num)\n    (cond ((null? num) 0)\n          ((is-prime?\
    \ (car num)) (+ 1 (count-primes (cdr num))))\n          (else (count-primes (cdr\
    \ num)))))\n  (count-primes (hex-to-decimal-list num)))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (string-&gt;symbol (substring num 0 1)) '(2 3 5 7 11 13))\n\
    \     (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n\
    </code>\nI have a few questions about this code:\n\nIs there a better way to write\
    \ this code?\nIs there a way to make this code more efficient?\nIs there a way\
    \ to make this code more readable?\n\nI'm new to Racket, so any help would be\
    \ appreciated.\n\n\nA:\n\nI think your code is pretty good.  I would make a few\
    \ changes:\n\nI would use <code>string-&gt;number</code> to convert the hex string\
    \ to a number, then use <code>number-&gt;string</code> to convert it back to a\
    \ string.  This will make it easier to handle numbers with leading zeros.\nI would\
    \ use <code>string-&gt;list</code> to convert the string to a list of characters.\
    \  This will make it easier to handle the base case.\nI would use <code>string-&gt;symbol</code>\
    \ to convert the character to a symbol.  This will make it easier to handle the\
    \ case where the character is a digit.\nI would use <code>symbol-&gt;string</code>\
    \ to convert the symbol back to a string.  This will make it easier to handle\
    \ the case where the character is a digit.\nI would use <code>string-&gt;number</code>\
    \ to convert the string to a number.  This will make it easier to handle the case\
    \ where the character is a digit.\nI would use <code>member</code> to check whether\
    \ the character is a prime.  This will make it easier to handle the case where\
    \ the character is a digit.\n\nHere is my version of the code:\n<code>(define\
    \ (hex-key num)\n  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number\
    \ (symbol-&gt;string (string-&gt;symbol (string-ref num 0))))\n             '(2\
    \ 3 5 7 11 13))\n     (+ 1 (hex-key (substring num", "  (cond\n    [(empty? num)\
    \ 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key\
    \ (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (define (hex-to-dec\
    \ num)\n    (cond ((string=? num \"A\") 10)\n          ((string=? num \"B\") 11)\n\
    \          ((string=? num \"C\") 12)\n          ((string=? num \"D\") 13)\n  \
    \        ((string=? num \"E\") 14)\n          ((string=? num \"F\") 15)\n    \
    \      (else (string->number num))))\n  (define (is-prime? num)\n    (cond ((=\
    \ num 1) #f)\n          ((= num 2) #t)\n          ((= num 3) #t)\n          ((=\
    \ num 5) #t)\n          ((= num 7) #t)\n          ((= num 11) #t)\n          ((=\
    \ num 13) #t)\n          (else #f)))\n  (define (count-primes num)\n    (cond\
    \ ((= num 0) 0)\n          ((is-prime? num) (+ 1 (count-primes (quotient num 16))))\n\
    \          (else (count-primes (quotient num 16)))))\n  (count-primes (string->number\
    \ (string-append \"0x\" num) 16)))\n", "  (define (is-prime n)\n    (define (is-divisible?\
    \ a b)\n      (= (remainder a b) 0))\n    (define (iter i)\n      (if (> i (sqrt\
    \ n))\n          #t\n          (if (is-divisible? n i)\n              #f\n   \
    \           (iter (+ i 1)))))\n    (if (= n 1)\n        #f\n        (iter 2)))\n\
    \  (define (hex-to-decimal n)\n    (define (hex-to-decimal-iter n i)\n      (if\
    \ (empty? n)\n          i\n          (let ([c (first n)])\n            (cond\n\
    \              [(char=? c #\\0) (hex-to-decimal-iter (rest n) (+ i (* 0 (expt\
    \ 16 i)))]\n              [(char=? c #\\1) (hex-to-decimal-iter (rest n) (+ i\
    \ (* 1 (expt 16 i)))]\n              [(char=? c #\\2) (hex-to-decimal-iter (rest\
    \ n) (+ i (* 2 (expt 16 i)))]\n              [(char=? c #\\3) (hex-to-decimal-iter\
    \ (rest n) (+ i (* 3 (expt 16 i)))]\n              [(char=? c #\\4) (hex-to-decimal-iter\
    \ (rest n) (+ i (* 4 (expt 16 i)))]\n              [(char=? c #\\5) (hex-to-decimal-iter\
    \ (rest n) (+ i (* 5 (expt 16 i)))]\n              [(char=? c #\\6) (hex-to-decimal-iter\
    \ (rest n) (+ i (* 6 (expt 16 i)))]\n              [(char=? c #\\7) (hex-to-decimal-iter\
    \ (rest n) (+ i (* 7 (expt 16 i)))]\n              [(char=? c #\\8) (hex-to-decimal-iter\
    \ (rest n) (+ i (* 8 (expt 16 i)))]\n              [(char=? c #\\9) (hex-to-decimal-iter\
    \ (rest n) (+ i (* 9 (expt 16 i)))]\n              [(char", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (string-&gt;number (substring num 0 1) 16) '(2 3 5 7 11\
    \ 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring\
    \ num 1))]))\n</code>\n", "  (define (is-prime? n)\n    (define (iter i)\n   \
    \   (cond ((= i n) #t)\n            ((= (modulo n i) 0) #f)\n            (else\
    \ (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal hex)\n    (cond\
    \ ((string=? hex \"A\") 10)\n          ((string=? hex \"B\") 11)\n          ((string=?\
    \ hex \"C\") 12)\n          ((string=? hex \"D\") 13)\n          ((string=? hex\
    \ \"E\") 14)\n          ((string=? hex \"F\") 15)\n          (else (string->number\
    \ hex))))\n  (define (iter i acc)\n    (cond ((= i (string-length num)) acc)\n\
    \          ((is-prime? (hex-to-decimal (string-ref num i))) (iter (+ i 1) (+ acc\
    \ 1)))\n          (else (iter (+ i 1) acc))))\n  (iter 0 0))\n", "  (define (hex-to-dec\
    \ num)\n    (cond ((equal? num \"A\") 10)\n          ((equal? num \"B\") 11)\n\
    \          ((equal? num \"C\") 12)\n          ((equal? num \"D\") 13)\n      \
    \    ((equal? num \"E\") 14)\n          ((equal? num \"F\") 15)\n          (else\
    \ (string->number num))))\n  (define (is-prime? num)\n    (define (iter n)\n \
    \     (cond ((= n 1) #t)\n            ((= (modulo num n) 0) #f)\n            (else\
    \ (iter (- n 1)))))\n    (iter (/ num 2)))\n  (define (iter num count)\n    (cond\
    \ ((null? num) count)\n        ((is-prime? (hex-to-dec (car num))) (iter (cdr\
    \ num) (+ count 1)))\n        (else (iter (cdr num) count))))\n  (iter (string->list\
    \ num) 0))", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\\
    3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (hex-to-dec num)\n    (cond\n      [(string=?\
    \ num \"A\") 10]\n      [(string=? num \"B\") 11]\n      [(string=? num \"C\"\
    ) 12]\n      [(string=? num \"D\") 13]\n      [(string=? num \"E\") 14]\n    \
    \  [(string=? num \"F\") 15]\n      [else (string-&gt;number num)]))\n  (define\
    \ (is-prime? num)\n    (cond\n      [(= num 1) #f]\n      [(= num 2) #t]\n   \
    \   [(= num 3) #t]\n      [(= num 5) #t]\n      [(= num 7) #t]\n      [(= num\
    \ 11) #t]\n      [(= num 13) #t]\n      [else #f]))\n  (define (count-primes num)\n\
    \    (cond\n      [(empty? num) 0]\n      [(is-prime? (hex-to-dec (first num)))\
    \ (+ 1 (count-primes (rest num)))]\n      [else (count-primes (rest num))]))\n\
    \  (count-primes num))\n</code>\nI'm not sure if this is the best way to do it,\
    \ but it works.\n\n\nA:\n\nI think you're over-complicating things.\n<code>(define\
    \ (hex-key num)\n  (define (is-prime? num)\n    (member num '(2 3 5 7 11 13)))\n\
    \  (define (count-primes num)\n    (if (empty? num)\n        0\n        (+ (if\
    \ (is-prime? (string-&gt;number (string-upcase (string (first num)))))\n     \
    \          1\n               0)\n           (count-primes (rest num)))))\n  (count-primes\
    \ num))\n</code>\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond\
    \ ((= i 1) #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (-\
    \ i 1)))))\n    (iter (/ n 2)))\n  (define (hex-to-dec n)\n    (cond ((string=?\
    \ n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\"\
    ) 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n\
    \          ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (count-primes n)\n    (cond ((string=? n \"\") 0)\n        ((is-prime? (hex-to-dec\
    \ (substring n 0 1)))\n         (+ 1 (count-primes (substring n 1))))\n      \
    \  (else (count-primes (substring n 1)))))\n  (count-primes num))\n", "  (cond\n\
    \    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol (substring\
    \ num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else\
    \ (hex_key (substring num 1))]))\n</code>\n", "  (define (hex-to-dec num)\n  \
    \  (cond\n      [(string=? num \"A\") 10]\n      [(string=? num \"B\") 11]\n \
    \     [(string=? num \"C\") 12]\n      [(string=? num \"D\") 13]\n      [(string=?\
    \ num \"E\") 14]\n      [(string=? num \"F\") 15]\n      [else (string-&gt;number\
    \ num)]))\n  (define (is-prime? num)\n    (define (is-prime-helper num div)\n\
    \      (cond\n        [(= div num) #t]\n        [(= (modulo num div) 0) #f]\n\
    \        [else (is-prime-helper num (+ div 1))]))\n    (is-prime-helper num 2))\n\
    \  (define (count-primes num)\n    (cond\n      [(empty? num) 0]\n      [(is-prime?\
    \ (hex-to-dec (first num))) (+ 1 (count-primes (rest num)))]\n      [else (count-primes\
    \ (rest num))]))\n  (count-primes num))\n</code>\n", "  (cond\n    [(empty? num)\
    \ 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key\
    \ (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (define (is-prime? n)\n\
    \    (cond ((= n 1) #f)\n          ((= n 2) #t)\n          ((= n 3) #t)\n    \
    \      ((= n 5) #t)\n          ((= n 7) #t)\n          ((= n 11) #t)\n       \
    \   ((= n 13) #t)\n          (else #f)))\n  (define (is-hex-prime? n)\n    (cond\
    \ ((= n #\\2) #t)\n          ((= n #\\3) #t)\n          ((= n #\\5) #t)\n    \
    \      ((= n #\\7) #t)\n          ((= n #\\B) #t)\n          ((= n #\\D) #t)\n\
    \          (else #f)))\n  (define (count-hex-primes num)\n    (cond ((null? num)\
    \ 0)\n          ((is-hex-prime? (car num)) (+ 1 (count-hex-primes (cdr num))))\n\
    \          (else (count-hex-primes (cdr num)))))\n  (count-hex-primes (string->list\
    \ num)))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((= i\
    \ n) #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n\
    \    (iter 2))\n  (define (hex-to-decimal c)\n    (cond ((= c #\\0) 0)\n     \
    \     ((= c #\\1) 1)\n          ((= c #\\2) 2)\n          ((= c #\\3) 3)\n   \
    \       ((= c #\\4) 4)\n          ((= c #\\5) 5)\n          ((= c #\\6) 6)\n \
    \         ((= c #\\7) 7)\n          ((= c #\\8) 8)\n          ((= c #\\9) 9)\n\
    \          ((= c #\\A) 10)\n          ((= c #\\B) 11)\n          ((= c #\\C) 12)\n\
    \          ((= c #\\D) 13)\n          ((= c #\\E) 14)\n          ((= c #\\F) 15)))\n\
    \  (define (iter i count)\n    (cond ((= i (string-length num)) count)\n     \
    \     ((is-prime? (hex-to-decimal (string-ref num i)))\n           (iter (+ i\
    \ 1) (+ count 1)))\n          (else (iter (+ i 1) count))))\n  (iter 0 0))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol\
    \ (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n</code>\nI'm getting the following\
    \ error:\n<code>application: not a procedure;\n expected a procedure that can\
    \ be applied to arguments\n  given: 2\n  arguments...: [none]\n</code>\nI'm not\
    \ sure what I'm doing wrong.\n\n\nA:\n\nThe problem is in the line:\n<code>[(member\
    \ (string-&gt;number (string-&gt;symbol (substring num 0 1))) '(2 3 5 7 11 13))\n\
    </code>\nThe <code>string-&gt;number</code> function expects a string as input,\
    \ but you're passing it a symbol.\nThe <code>string-&gt;symbol</code> function\
    \ expects a string as input, but you're passing it a number.\nThe <code>substring</code>\
    \ function expects a string as input, but you're passing it a number.\nThe <code>member</code>\
    \ function expects a list as input, but you're passing it a number.\nSo, you're\
    \ calling <code>member</code> with a number as input, and that's why you're getting\
    \ the error.\n", "  (define (is-prime? n)\n    (define (iter i)\n      (cond\n\
    \        [(= i 1) #t]\n        [(= (modulo n i) 0) #f]\n        [else (iter (-\
    \ i 1))]))\n    (iter (quotient n 2)))\n  (define (is-hex-prime? c)\n    (cond\n\
    \      [(or (= c #\\2) (= c #\\3) (= c #\\5) (= c #\\7)) #t]\n      [(or (= c\
    \ #\\B) (= c #\\D)) #t]\n      [else #f]))\n  (define (count-hex-primes s)\n \
    \   (cond\n      [(empty? s) 0]\n      [(is-hex-prime? (first s)) (+ 1 (count-hex-primes\
    \ (rest s)))]\n      [else (count-hex-primes (rest s))]))\n  (count-hex-primes\
    \ (string->list num)))\n", "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number\
    \ (string-&gt;symbol (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key\
    \ (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\nI am\
    \ getting the following error:\n<code>application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: 2\n  arguments...: [none]\n\
    </code>\nI am not sure what is wrong with my code.\n\n\nA:\n\nYou have a typo\
    \ in your code:\n<code>(member (string-&gt;number (string-&gt;symbol (substring\
    \ num 0 1))) '(2 3 5 7 11 13))\n</code>\nshould be\n<code>(member (string-&gt;number\
    \ (string-&gt;symbol (substring num 0 1))) '(2 3 5 7 11 13))\n</code>\n", "  (define\
    \ (is-prime n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(= (remainder\
    \ n 2) 0) #f]\n      [else\n       (define (iter i)\n         (cond\n        \
    \   [(= i n) #t]\n           [(= (remainder n i) 0) #f]\n           [else (iter\
    \ (+ i 1))]))\n       (iter 3)]))\n  (define (hex-to-decimal n)\n    (cond\n \
    \     [(= n \"A\") 10]\n      [(= n \"B\") 11]\n      [(= n \"C\") 12]\n     \
    \ [(= n \"D\") 13]\n      [(= n \"E\") 14]\n      [(= n \"F\") 15]\n      [else\
    \ (string->number n)]))\n  (define (iter n count)\n    (cond\n      [(empty? n)\
    \ count]\n      [(is-prime (hex-to-decimal (first n))) (iter (rest n) (+ count\
    \ 1))]\n      [else (iter (rest n) count)]))\n  (iter (string->list num) 0))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol\
    \ (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n</code>\nI'm getting an error that\
    \ says:\n<code>application: not a procedure;\n expected a procedure that can be\
    \ applied to arguments\n  given: 2\n  arguments...: [none]\n</code>\nI'm not sure\
    \ what I'm doing wrong.\n\n\nA:\n\nYou're trying to use <code>member</code> in\
    \ a wrong way. The procedure expects a list as the first argument, but you're\
    \ passing a number. Try this instead:\n<code>(define (hex_key num)\n  (cond\n\
    \    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol (substring\
    \ num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else\
    \ (hex_key (substring num 1))]))\n</code>\n", "  (length (filter (lambda (x) (member\
    \ x '(2 3 5 7 11 13)))\n                  (map string->number (string-&gt;list\
    \ num) 16))))\n</code>\n", "  (define (hex-to-dec num)\n    (cond ((equal? num\
    \ \"A\") 10)\n          ((equal? num \"B\") 11)\n          ((equal? num \"C\"\
    ) 12)\n          ((equal? num \"D\") 13)\n          ((equal? num \"E\") 14)\n\
    \          ((equal? num \"F\") 15)\n          (else (string->number num))))\n\
    \  (define (is-prime? num)\n    (define (iter i)\n      (cond ((= i 1) #t)\n \
    \           ((= (modulo num i) 0) #f)\n            (else (iter (- i 1)))))\n \
    \   (iter (/ num 2)))\n  (define (iter num count)\n    (cond ((null? num) count)\n\
    \          ((is-prime? (hex-to-dec (car num))) (iter (cdr num) (+ count 1)))\n\
    \          (else (iter (cdr num) count))))\n  (iter (string->list num) 0))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (string-ref num 0) '(#\\2 #\\3 #\\\
    5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key\
    \ (substring num 1))]))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first\
    \ num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n \
    \   [else (hex_key (rest num))]))", "  (cond\n    [(empty? num) 0]\n    [(member\
    \ (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n\
    \    [else (hex_key (rest num))]))\n", "  (define (is-prime? n)\n    (cond\n \
    \     [(= n 1) #f]\n      [(= n 2) #t]\n      [(even? n) #f]\n      [else\n  \
    \     (define (iter i)\n         (cond\n           [(= i n) #t]\n           [(=\
    \ (modulo n i) 0) #f]\n           [else (iter (+ i 1))]))\n       (iter 3)]))\n\
    \  (define (hex-to-decimal c)\n    (cond\n      [(char=? c #\\0) 0]\n      [(char=?\
    \ c #\\1) 1]\n      [(char=? c #\\2) 2]\n      [(char=? c #\\3) 3]\n      [(char=?\
    \ c #\\4) 4]\n      [(char=? c #\\5) 5]\n      [(char=? c #\\6) 6]\n      [(char=?\
    \ c #\\7) 7]\n      [(char=? c #\\8) 8]\n      [(char=? c #\\9) 9]\n      [(char=?\
    \ c #\\A) 10]\n      [(char=? c #\\B) 11]\n      [(char=? c #\\C) 12]\n      [(char=?\
    \ c #\\D) 13]\n      [(char=? c #\\E) 14]\n      [(char=? c #\\F) 15]))\n  (define\
    \ (iter i count)\n    (cond\n      [(= i (string-length num)) count]\n      [(is-prime?\
    \ (hex-to-decimal (string-ref num i))) (iter (+ i 1) (+ count 1))]\n      [else\
    \ (iter (+ i 1) count)]))\n  (iter 0 0))\n", "  (define (is-prime? n)\n    (define\
    \ (is-prime-iter? n i)\n      (cond ((= n 1) #f)\n            ((= n i) #t)\n \
    \           ((= (modulo n i) 0) #f)\n            (else (is-prime-iter? n (+ i\
    \ 1)))))\n    (is-prime-iter? n 2))\n  (define (hex-to-dec n)\n    (cond ((= n\
    \ #\\0) 0)\n          ((= n #\\1) 1)\n          ((= n #\\2) 2)\n          ((=\
    \ n #\\3) 3)\n          ((= n #\\4) 4)\n          ((= n #\\5) 5)\n          ((=\
    \ n #\\6) 6)\n          ((= n #\\7) 7)\n          ((= n #\\8) 8)\n          ((=\
    \ n #\\9) 9)\n          ((= n #\\A) 10)\n          ((= n #\\B) 11)\n         \
    \ ((= n #\\C) 12)\n          ((= n #\\D) 13)\n          ((= n #\\E) 14)\n    \
    \      ((= n #\\F) 15)))\n  (define (count-primes n)\n    (cond ((= n 0) 0)\n\
    \          ((is-prime? (hex-to-dec (string-ref n 0))) (+ 1 (count-primes (substring\
    \ n 1))))\n          (else (count-primes (substring n 1)))))\n  (count-primes\
    \ num))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\\
    3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num)\
    \ '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D)) (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (if\
    \ (= i n)\n          #t\n          (if (= (remainder n i) 0)\n              #f\n\
    \              (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-dec n)\n  \
    \  (define (iter i)\n      (if (= i (string-length n))\n          0\n        \
    \  (+ (* (string->number (substring n i (+ i 1))) (expt 16 (- (string-length n)\
    \ i)))\n             (iter (+ i 1)))))\n    (iter 0))\n  (define (dec-to-hex n)\n\
    \    (define (iter i)\n      (if (= i n)\n          \"\"\n          (string-append\
    \ (number->string (remainder i 16)) (iter (/ i 16)))))\n    (iter n))\n  (define\
    \ (hex-to-dec-list n)\n    (define (iter i)\n      (if (= i (string-length n))\n\
    \          '()\n          (cons (string->number (substring n i (+ i 1))) (iter\
    \ (+ i 1)))))\n    (iter 0))\n  (define (count-primes lst)\n    (define (iter\
    \ i)\n      (if (= i (length lst))\n          0\n          (if (is-prime? (list-ref\
    \ lst i))\n              (+ 1 (iter (+ i 1)))\n              (iter (+ i 1)))))\n\
    \    (iter 0))\n  (count-primes (hex-to-dec-list num)))\n", "  (let ([primes '(2\
    \ 3 5 7 11 13)])\n    (for/fold ([count 0]) ([digit (in-string num)])\n      (if\
    \ (member digit primes)\n          (add1 count)\n          count))))\n", "  (cond\n\
    \    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\\
    D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", " \
    \ (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7\
    \ #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (define (is-prime? n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n  \
    \    [(even? n) #f]\n      [else (for/and ([i (in-range 3 (quotient n 2) 1)])\n\
    \                 (not (= (remainder n i) 0)))]))\n  (define (hex-to-dec n)\n\
    \    (cond\n      [(string=? n \"A\") 10]\n      [(string=? n \"B\") 11]\n   \
    \   [(string=? n \"C\") 12]\n      [(string=? n \"D\") 13]\n      [(string=? n\
    \ \"E\") 14]\n      [(string=? n \"F\") 15]\n      [else (string->number n)]))\n\
    \  (define (hex-to-dec-list lst)\n    (cond\n      [(empty? lst) empty]\n    \
    \  [else (cons (hex-to-dec (car lst)) (hex-to-dec-list (cdr lst)))]))\n  (define\
    \ (count-primes lst)\n    (cond\n      [(empty? lst) 0]\n      [(is-prime? (car\
    \ lst)) (+ 1 (count-primes (cdr lst)))]\n      [else (count-primes (cdr lst))]))\n\
    \  (count-primes (hex-to-dec-list (string->list num))))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (string-&gt;number (string-&gt;symbol (substring num 0\
    \ 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key\
    \ (substring num 1))]))\n</code>\nI'm getting the following error:\n<code>application:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: 2\n  arguments...: [none]\n</code>\nI'm not sure what I'm doing wrong.\
    \ I'm new to Racket and I'm not sure how to debug this.\n\n\nA:\n\nThe problem\
    \ is that <code>member</code> returns a boolean, not a number. You need to use\
    \ <code>memq</code> instead, which returns the element if it's found, or <code>#f</code>\
    \ otherwise.\n", "  (define (is_prime n)\n    (define (is_divisible? a b)\n  \
    \    (= (remainder a b) 0))\n    (define (smallest-divisor n)\n      (define (find-divisor\
    \ n test-divisor)\n        (cond ((> (square test-divisor) n) n)\n           \
    \   ((is_divisible? n test-divisor) test-divisor)\n              (else (find-divisor\
    \ n (+ test-divisor 1)))))\n      (find-divisor n 2))\n    (= n (smallest-divisor\
    \ n)))\n  (define (hex_to_dec n)\n    (cond ((string=? n \"A\") 10)\n        \
    \  ((string=? n \"B\") 11)\n          ((string=? n \"C\") 12)\n          ((string=?\
    \ n \"D\") 13)\n          ((string=? n \"E\") 14)\n          ((string=? n \"F\"\
    ) 15)\n          (else (string->number n))))\n  (define (hex_to_dec_list n)\n\
    \    (map hex_to_dec (string->list n)))\n  (define (count_primes n)\n    (cond\
    \ ((null? n) 0)\n          ((is_prime (car n)) (+ 1 (count_primes (cdr n))))\n\
    \          (else (count_primes (cdr n)))))\n  (count_primes (hex_to_dec_list num)))\n",
  "  (let ([primes '(2 3 5 7 11 13)])\n    (for/fold ([count 0]) ([digit (in-string\
    \ num)])\n      (if (member digit primes)\n          (add1 count)\n          count))))\n",
  "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((= i n) #t)\n     \
    \       ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter\
    \ 2))\n  (define (hex-to-decimal n)\n    (cond ((equal? n \"A\") 10)\n       \
    \   ((equal? n \"B\") 11)\n          ((equal? n \"C\") 12)\n          ((equal?\
    \ n \"D\") 13)\n          ((equal? n \"E\") 14)\n          ((equal? n \"F\") 15)\n\
    \          (else (string->number n))))\n  (define (iter n count)\n    (cond ((null?\
    \ n) count)\n          ((is-prime? (hex-to-decimal (car n))) (iter (cdr n) (+\
    \ count 1)))\n          (else (iter (cdr n) count))))\n  (iter (string->list num)\
    \ 0))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\\
    3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (hex-to-dec num)\n    (cond\n      [(string=?\
    \ num \"A\") 10]\n      [(string=? num \"B\") 11]\n      [(string=? num \"C\"\
    ) 12]\n      [(string=? num \"D\") 13]\n      [(string=? num \"E\") 14]\n    \
    \  [(string=? num \"F\") 15]\n      [else (string->number num)]))\n  (define (is-prime?\
    \ n)\n    (define (iter i)\n      (cond\n        [(= i n) #t]\n        [(= (modulo\
    \ n i) 0) #f]\n        [else (iter (+ i 1))]))\n    (iter 2))\n  (define (iter\
    \ num count)\n    (cond\n      [(empty? num) count]\n      [(is-prime? (hex-to-dec\
    \ (first num))) (iter (rest num) (+ count 1))]\n      [else (iter (rest num) count)]))\n\
    \  (iter num 0))\n", "  (define (is-prime? n)\n    (define (divides? a b)\n  \
    \    (= (remainder a b) 0))\n    (define (find-divisor n test-divisor)\n     \
    \ (cond ((> (square test-divisor) n) n)\n            ((divides? n test-divisor)\
    \ test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n  \
    \  (= n (find-divisor n 2)))\n  (define (is-hex-prime? c)\n    (and (is-prime?\
    \ (string->number (string c) 16))\n         (not (char=? c #\\0))\n         (not\
    \ (char=? c #\\1))))\n  (define (count-hex-primes str)\n    (cond ((null? str)\
    \ 0)\n          ((is-hex-prime? (car str)) (+ 1 (count-hex-primes (cdr str))))\n\
    \          (else (count-hex-primes (cdr str)))))\n  (count-hex-primes (string->list\
    \ num)))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\\
    3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (cond [(empty? num) 0]\n        [(member (first num) '(#\\\
    2 #\\3 #\\5 #\\7 #\\B #\\D))\n         (+ 1 (hex_key (rest num)))]\n        [else\
    \ (hex_key (rest num))]))\n", "  (define (hex-to-dec num)\n    (cond\n      [(string=?\
    \ num \"\") 0]\n      [(string=? num \"A\") 10]\n      [(string=? num \"B\") 11]\n\
    \      [(string=? num \"C\") 12]\n      [(string=? num \"D\") 13]\n      [(string=?\
    \ num \"E\") 14]\n      [(string=? num \"F\") 15]\n      [else (string->number\
    \ num)]))\n  (define (is-prime? num)\n    (cond\n      [(= num 1) #f]\n      [(=\
    \ num 2) #t]\n      [(= num 3) #t]\n      [(= num 5) #t]\n      [(= num 7) #t]\n\
    \      [(= num 11) #t]\n      [(= num 13) #t]\n      [else #f]))\n  (define (count-primes\
    \ num)\n    (cond\n      [(= num 0) 0]\n      [(is-prime? num) (+ 1 (count-primes\
    \ (/ num 16)))]\n      [else (count-primes (/ num 16))]))\n  (count-primes (hex-to-dec\
    \ num)))\n", "  (define (is-prime? num)\n    (define (is-divisible? a b)\n   \
    \   (= (remainder a b) 0))\n    (define (find-divisor n test-divisor)\n      (cond\
    \ ((> (square test-divisor) n) n)\n            ((is-divisible? n test-divisor)\
    \ test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n  \
    \  (= (find-divisor num 2) num))\n  (define (hex-to-dec num)\n    (cond ((string=?\
    \ num \"A\") 10)\n          ((string=? num \"B\") 11)\n          ((string=? num\
    \ \"C\") 12)\n          ((string=? num \"D\") 13)\n          ((string=? num \"\
    E\") 14)\n          ((string=? num \"F\") 15)\n          (else (string->number\
    \ num))))\n  (define (hex-to-dec-list num)\n    (if (empty? num)\n        '()\n\
    \        (cons (hex-to-dec (string-ref num 0))\n              (hex-to-dec-list\
    \ (substring num 1)))))\n  (define (count-primes num)\n    (cond ((empty? num)\
    \ 0)\n          ((is-prime? (car num)) (+ 1 (count-primes (cdr num))))\n     \
    \     (else (count-primes (cdr num)))))\n  (count-primes (hex-to-dec-list num)))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (define (is-prime? n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n  \
    \    [(even? n) #f]\n      [else\n       (define (iter i)\n         (cond\n  \
    \         [(> i (/ n 2)) #t]\n           [(= (modulo n i) 0) #f]\n           [else\
    \ (iter (+ i 1))]))\n       (iter 3)]))\n  (define (hex-to-decimal n)\n    (cond\n\
    \      [(= n #\\0) 0]\n      [(= n #\\1) 1]\n      [(= n #\\2) 2]\n      [(= n\
    \ #\\3) 3]\n      [(= n #\\4) 4]\n      [(= n #\\5) 5]\n      [(= n #\\6) 6]\n\
    \      [(= n #\\7) 7]\n      [(= n #\\8) 8]\n      [(= n #\\9) 9]\n      [(= n\
    \ #\\A) 10]\n      [(= n #\\B) 11]\n      [(= n #\\C) 12]\n      [(= n #\\D) 13]\n\
    \      [(= n #\\E) 14]\n      [(= n #\\F) 15]))\n  (define (iter n count)\n  \
    \  (cond\n      [(empty? n) count]\n      [(is-prime? (hex-to-decimal (first n)))\
    \ (iter (rest n) (+ count 1))]\n      [else (iter (rest n) count)]))\n  (iter\
    \ (string->list num) 0))\n", "  (define (is-prime n)\n    (cond ((= n 1) #f)\n\
    \          ((= n 2) #t)\n          ((even? n) #f)\n          (else (let loop ((i\
    \ 3))\n                  (cond ((= i n) #t)\n                        ((divides?\
    \ i n) #f)\n                        (else (loop (+ i 2))))))))\n  (define (divides?\
    \ a b)\n    (= (remainder b a) 0))\n  (define (even? n)\n    (= (remainder n 2)\
    \ 0))\n  (define (hex-to-dec n)\n    (cond ((string=? n \"A\") 10)\n         \
    \ ((string=? n \"B\") 11)\n          ((string=? n \"C\") 12)\n          ((string=?\
    \ n \"D\") 13)\n          ((string=? n \"E\") 14)\n          ((string=? n \"F\"\
    ) 15)\n          (else (string->number n))))\n  (define (hex-to-dec-list num)\n\
    \    (map hex-to-dec (string->list num)))\n  (define (count-primes num)\n    (cond\
    \ ((null? num) 0)\n          ((is-prime (car num)) (+ 1 (count-primes (cdr num))))\n\
    \          (else (count-primes (cdr num)))))\n  (count-primes (hex-to-dec-list\
    \ num)))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\\
    3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (if\
    \ (= i n)\n          #t\n          (if (= (remainder n i) 0)\n              #f\n\
    \              (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal n)\n\
    \    (define (iter i acc)\n      (if (= i 0)\n          acc\n          (let ([c\
    \ (string-ref n i)])\n            (cond\n              [(char=? c #\\0) (iter\
    \ (- i 1) (+ (* acc 16) 0))]\n              [(char=? c #\\1) (iter (- i 1) (+\
    \ (* acc 16) 1))]\n              [(char=? c #\\2) (iter (- i 1) (+ (* acc 16)\
    \ 2))]\n              [(char=? c #\\3) (iter (- i 1) (+ (* acc 16) 3))]\n    \
    \          [(char=? c #\\4) (iter (- i 1) (+ (* acc 16) 4))]\n              [(char=?\
    \ c #\\5) (iter (- i 1) (+ (* acc 16) 5))]\n              [(char=? c #\\6) (iter\
    \ (- i 1) (+ (* acc 16) 6))]\n              [(char=? c #\\7) (iter (- i 1) (+\
    \ (* acc 16) 7))]\n              [(char=? c #\\8) (iter (- i 1) (+ (* acc 16)\
    \ 8))]\n              [(char=? c #\\9) (iter (- i 1) (+ (* acc 16) 9))]\n    \
    \          [(char=? c #\\A) (iter (- i 1) (+ (* acc 16) 10))]\n              [(char=?\
    \ c #\\B) (iter (- i 1) (+ (* acc 16) 11))]\n              [(char=? c #\\C) (iter\
    \ (- i 1) (+ (* acc 16) 12))]\n              [(char=? c #\\D) (iter (- i 1) (+\
    \ (* acc 16) 13))]\n              [(char=? c #\\E) (iter (- i 1) (+ (* acc 16)\
    \ 14))]\n              [(char=? c #\\F) (iter (- i 1) (+ (* acc 16)", "  (define\
    \ (hex-to-dec num)\n    (cond\n      [(string=? num \"A\") 10]\n      [(string=?\
    \ num \"B\") 11]\n      [(string=? num \"C\") 12]\n      [(string=? num \"D\"\
    ) 13]\n      [(string=? num \"E\") 14]\n      [(string=? num \"F\") 15]\n    \
    \  [else (string->number num)]))\n  (define (is-prime? n)\n    (cond\n      [(=\
    \ n 1) false]\n      [(= n 2) true]\n      [(even? n) false]\n      [else (for/and\
    \ ([i (in-range 3 n 2)])\n                    (not (= (modulo n i) 0)))]))\n \
    \ (define (count-primes num)\n    (for/sum ([i (in-list (string->list num))])\n\
    \      (if (is-prime? (hex-to-dec i)) 1 0)))\n  (count-primes num))\n", "  (define\
    \ (is-prime? n)\n    (define (iter i)\n      (if (= i n) #t\n          (if (=\
    \ (remainder n i) 0) #f\n              (iter (+ i 1)))))\n    (iter 2))\n  (define\
    \ (hex-to-dec n)\n    (cond ((string=? n \"A\") 10)\n          ((string=? n \"\
    B\") 11)\n          ((string=? n \"C\") 12)\n          ((string=? n \"D\") 13)\n\
    \          ((string=? n \"E\") 14)\n          ((string=? n \"F\") 15)\n      \
    \    (else (string->number n))))\n  (define (iter n i)\n    (if (= i (string-length\
    \ n)) 0\n        (if (is-prime? (hex-to-dec (string-ref n i)))\n            (+\
    \ 1 (iter n (+ i 1)))\n            (iter n (+ i 1)))))\n  (iter num 0))\n", " \
    \ (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (substring num\
    \ 0 1) 16) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else\
    \ (hex_key (substring num 1))]))\n</code>\nI am getting the following error:\n\
    <code>application: not a procedure;\n expected a procedure that can be applied\
    \ to arguments\n  given: 2\n  arguments...: [none]\n</code>\nI am not sure what\
    \ I am doing wrong.\n\n\nA:\n\nThe problem is that you're trying to add 1 to the\
    \ result of <code>hex_key</code>, but <code>hex_key</code> returns a number, not\
    \ a procedure. You need to use <code>+</code> instead:\n<code>(+ 1 (hex_key (substring\
    \ num 1)))\n</code>\n", "  (define (is-prime? n)\n    (define (iter i)\n     \
    \ (cond\n        [(= i n) #t]\n        [(= (modulo n i) 0) #f]\n        [else\
    \ (iter (+ i 1))]))\n    (iter 2))\n  (define (hex-to-decimal n)\n    (cond\n\
    \      [(string=? n \"A\") 10]\n      [(string=? n \"B\") 11]\n      [(string=?\
    \ n \"C\") 12]\n      [(string=? n \"D\") 13]\n      [(string=? n \"E\") 14]\n\
    \      [(string=? n \"F\") 15]\n      [else (string->number n)]))\n  (define (iter\
    \ n count)\n    (cond\n      [(empty? n) count]\n      [(is-prime? (hex-to-decimal\
    \ (first n))) (iter (rest n) (+ count 1))]\n      [else (iter (rest n) count)]))\n\
    \  (iter (string->list num) 0))\n", "  (define (is-prime? n)\n    (define (iter\
    \ i)\n      (cond\n        [(= i n) #t]\n        [(= (modulo n i) 0) #f]\n   \
    \     [else (iter (+ i 1))]))\n    (iter 2))\n  (define (is-hex? c)\n    (or (char-numeric?\
    \ c)\n        (and (char-alphabetic? c)\n             (char-ci=? c #\\A)\n   \
    \          (char-ci=? c #\\B)\n             (char-ci=? c #\\C)\n             (char-ci=?\
    \ c #\\D)\n             (char-ci=? c #\\E)\n             (char-ci=? c #\\F))))\n\
    \  (define (hex-to-dec c)\n    (cond\n      [(char-numeric? c) (- (char->integer\
    \ c) 48)]\n      [(char-ci=? c #\\A) 10]\n      [(char-ci=? c #\\B) 11]\n    \
    \  [(char-ci=? c #\\C) 12]\n      [(char-ci=? c #\\D) 13]\n      [(char-ci=? c\
    \ #\\E) 14]\n      [(char-ci=? c #\\F) 15]))\n  (define (iter num count)\n   \
    \ (cond\n      [(empty? num) count]\n      [(is-prime? (hex-to-dec (first num)))\
    \ (iter (rest num) (+ count 1))]\n      [else (iter (rest num) count)]))\n  (iter\
    \ num 0))\n", "  (if (string=? num \"\")\n      0\n      (if (member (string-&gt;number\
    \ (string-&gt;list num) 16) '(2 3 5 7 11 13))\n          (+ 1 (hex_key (substring\
    \ num 1)))\n          (hex_key (substring num 1)))))\n</code>\n", "  (cond\n \
    \   [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\\
    D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", " \
    \ (define (is-prime n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n  \
    \    [(= n 3) #t]\n      [(= n 5) #t]\n      [(= n 7) #t]\n      [(= n 11) #t]\n\
    \      [(= n 13) #t]\n      [else #f]))\n  (define (hex-to-dec n)\n    (cond\n\
    \      [(= n #\\0) 0]\n      [(= n #\\1) 1]\n      [(= n #\\2) 2]\n      [(= n\
    \ #\\3) 3]\n      [(= n #\\4) 4]\n      [(= n #\\5) 5]\n      [(= n #\\6) 6]\n\
    \      [(= n #\\7) 7]\n      [(= n #\\8) 8]\n      [(= n #\\9) 9]\n      [(= n\
    \ #\\A) 10]\n      [(= n #\\B) 11]\n      [(= n #\\C) 12]\n      [(= n #\\D) 13]\n\
    \      [(= n #\\E) 14]\n      [(= n #\\F) 15]))\n  (define (count-primes num)\n\
    \    (if (string-null? num)\n        0\n        (if (is-prime (hex-to-dec (string-ref\
    \ num 0)))\n            (+ 1 (count-primes (substring num 1)))\n            (count-primes\
    \ (substring num 1)))))\n  (count-primes num))\n", "  (cond\n    [(empty? num)\
    \ 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key\
    \ (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (define (is-prime? n)\n\
    \    (define (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo n i)\
    \ 0) #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal\
    \ n)\n    (cond ((= n #\\0) 0)\n          ((= n #\\1) 1)\n          ((= n #\\\
    2) 2)\n          ((= n #\\3) 3)\n          ((= n #\\4) 4)\n          ((= n #\\\
    5) 5)\n          ((= n #\\6) 6)\n          ((= n #\\7) 7)\n          ((= n #\\\
    8) 8)\n          ((= n #\\9) 9)\n          ((= n #\\A) 10)\n          ((= n #\\\
    B) 11)\n          ((= n #\\C) 12)\n          ((= n #\\D) 13)\n          ((= n\
    \ #\\E) 14)\n          ((= n #\\F) 15)))\n  (define (iter n i)\n    (cond ((=\
    \ i (string-length n)) 0)\n          ((is-prime? (hex-to-decimal (string-ref n\
    \ i))) (+ 1 (iter n (+ i 1))))\n          (else (iter n (+ i 1)))))\n  (iter num\
    \ 0))\n", "  (cond\n    [(empty? num) 0]\n    [(prime? (string->number (string-&gt;symbol\
    \ (string-ref num 0)) 16))\n     (+ 1 (hex_key (substring num 1)))]\n    [else\
    \ (hex_key (substring num 1))]))\n", "  (define (is-prime? n)\n    (cond\n   \
    \   [(= n 2) #t]\n      [(= n 3) #t]\n      [(= n 5) #t]\n      [(= n 7) #t]\n\
    \      [(= n 11) #t]\n      [(= n 13) #t]\n      [(= n 17) #t]\n      [(= n 19)\
    \ #t]\n      [(= n 23) #t]\n      [(= n 29) #t]\n      [(= n 31) #t]\n      [(=\
    \ n 37) #t]\n      [(= n 41) #t]\n      [(= n 43) #t]\n      [(= n 47) #t]\n \
    \     [(= n 53) #t]\n      [(= n 59) #t]\n      [(= n 61) #t]\n      [(= n 67)\
    \ #t]\n      [(= n 71) #t]\n      [(= n 73) #t]\n      [(= n 79) #t]\n      [(=\
    \ n 83) #t]\n      [(= n 89) #t]\n      [(= n 97) #t]\n      [(= n 101) #t]\n\
    \      [(= n 103) #t]\n      [(= n 107) #t]\n      [(= n 109) #t]\n      [(= n\
    \ 113) #t]\n      [(= n 127) #t]\n      [(= n 131) #t]\n      [(= n 137) #t]\n\
    \      [(= n 139) #t]\n      [(= n 149) #t]\n      [(= n 151) #t]\n      [(= n\
    \ 157) #t]\n      [(= n 163) #t]\n      [(= n 167) #t]\n      [(= n 173) #t]\n\
    \      [(= n 179) #t]\n      [(= n 181) #t]\n      [(= n 191) #t]\n      [(= n\
    \ 193) #t]\n      [(= n 197) #t]\n      [(= n 199) #t]\n      [(= n 211) #t]\n\
    \      [(= n 223) #t]\n      [(= n 227) #t]\n      [(= n 229)", "  (cond\n   \
    \ [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n\
    \     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (cond\n\
    \    [(empty? num) 0]\n    [(member (first num) '(\"2\" \"3\" \"5\" \"7\" \"B\"\
    \ \"D\"))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (let ([primes '(2 3 5 7 11 13)])\n    (for/fold ([count 0]) ([digit (in-string\
    \ num)])\n      (if (member digit primes)\n          (add1 count)\n          count))))\n",
  "  (define (is-prime? n)\n    (cond ((= n 1) #f)\n          ((= n 2) #t)\n     \
    \     ((= (remainder n 2) 0) #f)\n          (else\n           (let loop ((i 3))\n\
    \             (cond ((> (* i i) n) #t)\n                   ((= (remainder n i)\
    \ 0) #f)\n                   (else (loop (+ i 2))))))))\n  (define (is-hex-prime?\
    \ c)\n    (cond ((or (= c #\\2) (= c #\\3) (= c #\\5) (= c #\\7)) #t)\n      \
    \    ((or (= c #\\B) (= c #\\D)) #t)\n          (else #f)))\n  (define (count-hex-primes\
    \ str)\n    (cond ((null? str) 0)\n          ((is-hex-prime? (car str)) (+ 1 (count-hex-primes\
    \ (cdr str))))\n          (else (count-hex-primes (cdr str)))))\n  (count-hex-primes\
    \ (string->list num)))\n", "  (cond\n    [(empty? num) 0]\n    [(char-numeric?\
    \ (string-ref num 0)) (hex_key (substring num 1))]\n    [(char-alphabetic? (string-ref\
    \ num 0))\n     (cond\n       [(string=? (string-ref num 0) #\\A) (hex_key (substring\
    \ num 1))]\n       [(string=? (string-ref num 0) #\\B) (+ 1 (hex_key (substring\
    \ num 1)))]\n       [(string=? (string-ref num 0) #\\C) (hex_key (substring num\
    \ 1))]\n       [(string=? (string-ref num 0) #\\D) (+ 1 (hex_key (substring num\
    \ 1)))]\n       [(string=? (string-ref num 0) #\\E) (hex_key (substring num 1))]\n\
    \       [(string=? (string-ref num 0) #\\F) (hex_key (substring num 1))]\n   \
    \    [else (hex_key (substring num 1))])]\n    [else (hex_key (substring num 1))]))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (cond [(empty? num) 0]\n        [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\\
    B #\\D)) (+ 1 (hex_key (rest num)))]\n        [else (hex_key (rest num))]))\n",
  "  (define (hex-to-dec num)\n    (cond\n      [(string=? num \"A\") 10]\n      [(string=?\
    \ num \"B\") 11]\n      [(string=? num \"C\") 12]\n      [(string=? num \"D\"\
    ) 13]\n      [(string=? num \"E\") 14]\n      [(string=? num \"F\") 15]\n    \
    \  [else (string-&gt;number num)]))\n  (define (is-prime? num)\n    (define (iter\
    \ n)\n      (cond\n        [(= n 1) #t]\n        [(= (modulo num n) 0) #f]\n \
    \       [else (iter (- n 1))]))\n    (iter (/ num 2)))\n  (define (iter num)\n\
    \    (cond\n      [(empty? num) 0]\n      [(is-prime? (hex-to-dec (first num)))\
    \ (+ 1 (iter (rest num)))]\n      [else (iter (rest num))]))\n  (iter (string-&gt;list\
    \ num)))\n</code>\n", "  (define (hex-to-dec num)\n    (cond\n      [(string=?\
    \ num \"A\") 10]\n      [(string=? num \"B\") 11]\n      [(string=? num \"C\"\
    ) 12]\n      [(string=? num \"D\") 13]\n      [(string=? num \"E\") 14]\n    \
    \  [(string=? num \"F\") 15]\n      [else (string-&gt;number num)]))\n  (define\
    \ (is-prime? num)\n    (define (iter n)\n      (cond\n        [(= n 1) true]\n\
    \        [(= (modulo num n) 0) false]\n        [else (iter (- n 1))]))\n    (iter\
    \ (/ num 2)))\n  (define (iter num count)\n    (cond\n      [(empty? num) count]\n\
    \      [(is-prime? (hex-to-dec (first num))) (iter (rest num) (+ count 1))]\n\
    \      [else (iter (rest num) count)]))\n  (iter num 0))\n</code>\n", "  (define\
    \ (is-prime? n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(=\
    \ (remainder n 2) 0) #f]\n      [else\n       (define (iter i)\n         (cond\n\
    \           [(> i (sqrt n)) #t]\n           [(= (remainder n i) 0) #f]\n     \
    \      [else (iter (+ i 1))]))\n       (iter 3)]))\n  (define (hex-to-dec n)\n\
    \    (cond\n      [(string=? n \"A\") 10]\n      [(string=? n \"B\") 11]\n   \
    \   [(string=? n \"C\") 12]\n      [(string=? n \"D\") 13]\n      [(string=? n\
    \ \"E\") 14]\n      [(string=? n \"F\") 15]\n      [else (string->number n)]))\n\
    \  (define (iter n count)\n    (cond\n      [(empty? n) count]\n      [(is-prime?\
    \ (hex-to-dec (first n))) (iter (rest n) (+ count 1))]\n      [else (iter (rest\
    \ n) count)]))\n  (iter (string->list num) 0))\n", "  (define (is-prime? n)\n\
    \    (define (divides? a b)\n      (= (remainder a b) 0))\n    (define (find-divisor\
    \ n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((divides?\
    \ n test-divisor) test-divisor)\n            (else (find-divisor n (+ test-divisor\
    \ 1)))))\n    (= n (find-divisor n 2)))\n  (define (hex-to-decimal n)\n    (cond\
    \ ((string=? n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=?\
    \ n \"C\") 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\"\
    ) 14)\n          ((string=? n \"F\") 15)\n          (else (string->number n))))\n\
    \  (define (count-primes n)\n    (cond ((string=? n \"\") 0)\n          ((is-prime?\
    \ (hex-to-decimal (string-ref n 0))) (+ 1 (count-primes (substring n 1))))\n \
    \         (else (count-primes (substring n 1)))))\n  (count-primes num))\n", " \
    \ (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7\
    \ #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n",
  "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((= i n) #t)\n     \
    \       ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter\
    \ 2))\n  (define (hex-to-decimal n)\n    (cond ((equal? n \"A\") 10)\n       \
    \   ((equal? n \"B\") 11)\n          ((equal? n \"C\") 12)\n          ((equal?\
    \ n \"D\") 13)\n          ((equal? n \"E\") 14)\n          ((equal? n \"F\") 15)\n\
    \          (else (string->number n))))\n  (define (iter i count)\n    (cond ((=\
    \ i (string-length num)) count)\n          ((is-prime? (hex-to-decimal (string-ref\
    \ num i)))\n           (iter (+ i 1) (+ count 1)))\n          (else (iter (+ i\
    \ 1) count))))\n  (iter 0 0))\n", "  (define (is-prime? n)\n    (cond ((= n 1)\
    \ #f)\n          ((= n 2) #t)\n          ((even? n) #f)\n          (else (for/and\
    \ ([i (in-range 3 (quotient n 2) 2)])\n                 (not (= (remainder n i)\
    \ 0))))))\n  (define (is-hex-prime? c)\n    (cond ((or (= c #\\2) (= c #\\3) (=\
    \ c #\\5) (= c #\\7)) #t)\n          ((or (= c #\\B) (= c #\\D)) #t)\n       \
    \   (else #f)))\n  (define (hex-to-dec c)\n    (cond ((or (= c #\\0) (= c #\\\
    1) (= c #\\2) (= c #\\3) (= c #\\4) (= c #\\5) (= c #\\6) (= c #\\7) (= c #\\\
    8) (= c #\\9)) (- c #\\0))\n          ((or (= c #\\A) (= c #\\B) (= c #\\C) (=\
    \ c #\\D) (= c #\\E) (= c #\\F)) (+ (- c #\\A) 10))))\n  (define (dec-to-hex n)\n\
    \    (cond ((or (= n 0) (= n 1) (= n 2) (= n 3) (= n 4) (= n 5) (= n 6) (= n 7)\
    \ (= n 8) (= n 9)) (+ n #\\0))\n          ((or (= n 10) (= n 11) (= n 12) (= n\
    \ 13) (= n 14) (= n 15)) (+ n #\\A -10))))\n  (define (hex-to-dec-str s)\n   \
    \ (string-&gt;number (string-&gt;list s) (\u03BB (c) (hex-to-dec c))))\n  (define\
    \ (dec-to-hex-str n)\n    (number-&gt;string n (\u03BB (n) (dec-to-hex n))))\n\
    \  (define (hex-to-dec-str-list s)\n    (map (\u03BB (c) (hex-to-dec c)) (string-&gt;list\
    \ s)))", "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((= i n)\
    \ #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n\
    \    (iter 2))\n  (define (hex-to-dec n)\n    (cond ((string=? n \"A\") 10)\n\
    \          ((string=? n \"B\") 11)\n          ((string=? n \"C\") 12)\n      \
    \    ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n          ((string=?\
    \ n \"F\") 15)\n          (else (string->number n))))\n  (define (iter n i)\n\
    \    (cond ((= i (string-length n)) 0)\n          ((is-prime? (hex-to-dec (string-ref\
    \ n i))) (+ 1 (iter n (+ i 1))))\n          (else (iter n (+ i 1)))))\n  (iter\
    \ num 0))\n", "  (define (is-prime? n)\n    (define (is-divisible? a b)\n    \
    \  (= (remainder a b) 0))\n    (define (iter i)\n      (cond ((= i n) #t)\n  \
    \          ((is-divisible? n i) #f)\n            (else (iter (+ i 1)))))\n   \
    \ (iter 2))\n  (define (is-hex-prime? n)\n    (cond ((= n #\\2) #t)\n        \
    \  ((= n #\\3) #t)\n          ((= n #\\5) #t)\n          ((= n #\\7) #t)\n   \
    \       ((= n #\\B) #t)\n          ((= n #\\D) #t)\n          (else #f)))\n  (define\
    \ (iter i acc)\n    (cond ((= i (string-length num)) acc)\n          ((is-hex-prime?\
    \ (string-ref num i)) (iter (+ i 1) (+ acc 1)))\n          (else (iter (+ i 1)\
    \ acc))))\n  (iter 0 0))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first\
    \ num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n \
    \   [else (hex_key (rest num))]))\n", "  (cond\n    [(empty? num) 0]\n    [(member\
    \ (string-&gt;number (string-&gt;symbol (string-ref num 0))) '(2 3 5 7 11 13))\n\
    \     (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n\
    </code>\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\\
    3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (is-prime n)\n    (define (iter i)\n      (cond\n\
    \        [(= i n) #t]\n        [(= (modulo n i) 0) #f]\n        [else (iter (+\
    \ i 1))]))\n    (iter 2))\n  (define (hex-to-dec n)\n    (cond\n      [(= n #\\\
    0) 0]\n      [(= n #\\1) 1]\n      [(= n #\\2) 2]\n      [(= n #\\3) 3]\n    \
    \  [(= n #\\4) 4]\n      [(= n #\\5) 5]\n      [(= n #\\6) 6]\n      [(= n #\\\
    7) 7]\n      [(= n #\\8) 8]\n      [(= n #\\9) 9]\n      [(= n #\\A) 10]\n   \
    \   [(= n #\\B) 11]\n      [(= n #\\C) 12]\n      [(= n #\\D) 13]\n      [(= n\
    \ #\\E) 14]\n      [(= n #\\F) 15]))\n  (define (iter n count)\n    (cond\n  \
    \    [(empty? n) count]\n      [(is-prime (hex-to-dec (first n))) (iter (rest\
    \ n) (+ count 1))]\n      [else (iter (rest n) count)]))\n  (iter (string->list\
    \ num) 0))\n", "  (cond\n    [(empty? num) 0]\n    [(prime? (string->number (substring\
    \ num 0 1) 16))\n     (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring\
    \ num 1))]))\n", "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number\
    \ (string-&gt;symbol (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key\
    \ (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\nI am\
    \ getting the following error:\n<code>application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: 2\n  arguments...: [none]\n\
    </code>\nI am not sure what is wrong with my code. I am using DrRacket.\n\n\n\
    A:\n\nYou're using <code>member</code> incorrectly. It's a procedure that takes\
    \ two arguments, the first being the element to search for, and the second being\
    \ the list to search in. You're passing it a list as the first argument, and a\
    \ number as the second.\nYou probably want to use <code>member/ci</code> instead,\
    \ which is like <code>member</code> but does a case-insensitive comparison.\n",
  "  (define (is-prime? n)\n    (define (iter i)\n      (cond ((= i n) #t)\n     \
    \       ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter\
    \ 2))\n  (define (hex-to-dec n)\n    (cond ((string=? n \"A\") 10)\n         \
    \ ((string=? n \"B\") 11)\n          ((string=? n \"C\") 12)\n          ((string=?\
    \ n \"D\") 13)\n          ((string=? n \"E\") 14)\n          ((string=? n \"F\"\
    ) 15)\n          (else (string->number n))))\n  (define (iter n i)\n    (cond\
    \ ((= i (string-length n)) 0)\n          ((is-prime? (hex-to-dec (string-ref n\
    \ i))) (+ 1 (iter n (+ i 1))))\n          (else (iter n (+ i 1)))))\n  (iter num\
    \ 0))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (if (= i n)\n\
    \          #t\n          (if (= (remainder n i) 0)\n              #f\n       \
    \       (iter (+ i 1)))))\n    (iter 2))\n  (define (is-hex-prime? n)\n    (if\
    \ (is-prime? (string->number (string n) 16))\n        #t\n        #f))\n  (define\
    \ (iter i)\n    (if (= i (string-length num))\n        0\n        (if (is-hex-prime?\
    \ (string-ref num i))\n            (+ 1 (iter (+ i 1)))\n            (iter (+\
    \ i 1)))))\n  (iter 0))\n", "  (define (is-prime? n)\n    (define (iter i)\n \
    \     (cond ((= i n) #t)\n            ((= (modulo n i) 0) #f)\n            (else\
    \ (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-dec n)\n    (cond ((= n\
    \ #\\0) 0)\n          ((= n #\\1) 1)\n          ((= n #\\2) 2)\n          ((=\
    \ n #\\3) 3)\n          ((= n #\\4) 4)\n          ((= n #\\5) 5)\n          ((=\
    \ n #\\6) 6)\n          ((= n #\\7) 7)\n          ((= n #\\8) 8)\n          ((=\
    \ n #\\9) 9)\n          ((= n #\\A) 10)\n          ((= n #\\B) 11)\n         \
    \ ((= n #\\C) 12)\n          ((= n #\\D) 13)\n          ((= n #\\E) 14)\n    \
    \      ((= n #\\F) 15)))\n  (define (iter n i)\n    (cond ((= i (string-length\
    \ n)) 0)\n          ((is-prime? (hex-to-dec (string-ref n i))) (+ 1 (iter n (+\
    \ i 1))))\n          (else (iter n (+ i 1)))))\n  (iter num 0))\n", "  (define\
    \ (is-prime? n)\n    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(even?\
    \ n) #f]\n      [else\n       (define (iter i)\n         (cond\n           [(=\
    \ i n) #t]\n           [(= (modulo n i) 0) #f]\n           [else (iter (+ i 1))]))\n\
    \       (iter 3)]))\n  (define (hex-to-dec n)\n    (cond\n      [(= n #\\0) 0]\n\
    \      [(= n #\\1) 1]\n      [(= n #\\2) 2]\n      [(= n #\\3) 3]\n      [(= n\
    \ #\\4) 4]\n      [(= n #\\5) 5]\n      [(= n #\\6) 6]\n      [(= n #\\7) 7]\n\
    \      [(= n #\\8) 8]\n      [(= n #\\9) 9]\n      [(= n #\\A) 10]\n      [(=\
    \ n #\\B) 11]\n      [(= n #\\C) 12]\n      [(= n #\\D) 13]\n      [(= n #\\E)\
    \ 14]\n      [(= n #\\F) 15]))\n  (define (iter n i)\n    (cond\n      [(= i (string-length\
    \ n)) 0]\n      [(is-prime? (hex-to-dec (string-ref n i))) (+ 1 (iter n (+ i 1)))]\n\
    \      [else (iter n (+ i 1))]))\n  (iter num 0))\n", "  (cond\n    [(string=?\
    \ num \"\") 0]\n    [(string=? num \"2\") 1]\n    [(string=? num \"3\") 1]\n \
    \   [(string=? num \"5\") 1]\n    [(string=? num \"7\") 1]\n    [(string=? num\
    \ \"B\") 1]\n    [(string=? num \"D\") 1]\n    [else (+ (hex_key (substring num\
    \ 0 1)) (hex_key (substring num 1 (string-length num))))]))\n", "  (define (is-prime?\
    \ n)\n    (cond ((= n 1) #f)\n          ((= n 2) #t)\n          ((even? n) #f)\n\
    \          (else (let loop ((i 3))\n                  (cond ((= i n) #t)\n   \
    \                     ((= (remainder n i) 0) #f)\n                        (else\
    \ (loop (+ i 2))))))))\n  (define (is-hex? c)\n    (or (char-numeric? c)\n   \
    \     (and (char-upper-case? c)\n             (or (char=? c #\\A)\n          \
    \       (char=? c #\\B)\n                 (char=? c #\\C)\n                 (char=?\
    \ c #\\D)\n                 (char=? c #\\E)\n                 (char=? c #\\F)))))\n\
    \  (define (hex-to-dec c)\n    (cond ((char-numeric? c) (char->integer c))\n \
    \         ((char=? c #\\A) 10)\n          ((char=? c #\\B) 11)\n          ((char=?\
    \ c #\\C) 12)\n          ((char=? c #\\D) 13)\n          ((char=? c #\\E) 14)\n\
    \          ((char=? c #\\F) 15)))\n  (define (count-primes str)\n    (if (string-null?\
    \ str)\n        0\n        (let ((c (string-ref str 0)))\n          (if (and (is-hex?\
    \ c)\n                   (is-prime? (hex-to-dec c)))\n              (+ 1 (count-primes\
    \ (string-drop str 1)))\n              (count-primes (string-drop str 1))))))\n\
    \  (count-primes num))\n", "  (define (is-prime? n)\n    (define (iter i)\n  \
    \    (cond ((= i n) #t)\n            ((= (modulo n i) 0) #f)\n            (else\
    \ (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-dec n)\n    (cond ((string=?\
    \ n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\"\
    ) 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n\
    \          ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (iter n i)\n    (cond ((string=? n \"\") i)\n          ((is-prime? (hex-to-dec\
    \ (substring n 0 1))) (iter (substring n 1) (+ i 1)))\n          (else (iter (substring\
    \ n 1) i))))\n  (iter num 0))\n", "  (let ([hex-digits (string->list num)]\n \
    \       [primes '(2 3 5 7 11 13)])\n    (for/fold ([count 0]) ([digit hex-digits])\n\
    \      (if (member digit primes)\n          (+ count 1)\n          count))))\n",
  "  (let ([primes '(2 3 5 7 11 13)])\n    (for/fold ([count 0]) ([i (in-string num)])\n\
    \      (if (member i primes)\n          (add1 count)\n          count))))\n",
  "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol\
    \ (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n</code>\nI'm getting the following\
    \ error:\n<code>string-&gt;number: expects argument of type &lt;string&gt;; given\
    \ #\\2\n</code>\nI'm not sure what I'm doing wrong.\n\n\nA:\n\nYou're trying to\
    \ convert a character to a number, but <code>string-&gt;number</code> only works\
    \ with strings. You can use <code>char-&gt;integer</code> instead:\n<code>(define\
    \ (hex_key num)\n  (cond\n    [(empty? num) 0]\n    [(member (char-&gt;integer\
    \ (string-ref num 0)) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n</code>\n", "  (define (is-prime? n)\n\
    \    (define (iter i)\n      (cond\n        [(> i (/ n 2)) #t]\n        [(= (modulo\
    \ n i) 0) #f]\n        [else (iter (+ i 1))]))\n    (iter 2))\n  (define (is-hex-prime?\
    \ c)\n    (cond\n      [(or (= c #\\2) (= c #\\3) (= c #\\5) (= c #\\7)) #t]\n\
    \      [(or (= c #\\B) (= c #\\D)) #t]\n      [else #f]))\n  (define (iter s acc)\n\
    \    (cond\n      [(empty? s) acc]\n      [(is-hex-prime? (first s)) (iter (rest\
    \ s) (+ acc 1))]\n      [else (iter (rest s) acc)]))\n  (iter (string->list num)\
    \ 0))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num) '(#\\2 #\\\
    3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else (hex_key\
    \ (rest num))]))\n", "  (define (is-prime? n)\n    (cond\n      [(= n 1) #f]\n\
    \      [(= n 2) #t]\n      [(even? n) #f]\n      [else\n       (define (iter i)\n\
    \         (cond\n           [(> i (sqrt n)) #t]\n           [(= (modulo n i) 0)\
    \ #f]\n           [else (iter (+ i 1))]))\n       (iter 3)]))\n  (define (hex-to-dec\
    \ n)\n    (cond\n      [(string=? n \"A\") 10]\n      [(string=? n \"B\") 11]\n\
    \      [(string=? n \"C\") 12]\n      [(string=? n \"D\") 13]\n      [(string=?\
    \ n \"E\") 14]\n      [(string=? n \"F\") 15]\n      [else (string->number n)]))\n\
    \  (define (iter i count)\n    (cond\n      [(= i (string-length num)) count]\n\
    \      [(is-prime? (hex-to-dec (string-ref num i))) (iter (+ i 1) (+ count 1))]\n\
    \      [else (iter (+ i 1) count)]))\n  (iter 0 0))", "  (cond\n    [(empty? num)\
    \ 0]\n    [(member (string-&gt;number (string-&gt;symbol (substring num 0 1)))\
    \ '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key\
    \ (substring num 1))]))\n", "  (define (is-prime? n)\n    (define (iter i)\n \
    \     (cond\n        [(= i n) #t]\n        [(= (modulo n i) 0) #f]\n        [else\
    \ (iter (+ i 1))]))\n    (iter 2))\n  (define (hex-to-decimal n)\n    (cond\n\
    \      [(string=? n \"A\") 10]\n      [(string=? n \"B\") 11]\n      [(string=?\
    \ n \"C\") 12]\n      [(string=? n \"D\") 13]\n      [(string=? n \"E\") 14]\n\
    \      [(string=? n \"F\") 15]\n      [else (string->number n)]))\n  (define (iter\
    \ num count)\n    (cond\n      [(empty? num) count]\n      [(is-prime? (hex-to-decimal\
    \ (first num))) (iter (rest num) (+ count 1))]\n      [else (iter (rest num) count)]))\n\
    \  (iter (string->list num) 0))\n", "  (cond\n    [(empty? num) 0]\n    [(member\
    \ (string-&gt;number (string-&gt;symbol (substring num 0 1))) '(2 3 5 7 11 13))\n\
    \     (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n\
    </code>\nI'm getting this error:\n<code>application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: 2\n  arguments...: [none]\n\
    </code>\nI'm not sure what's wrong with my code.\n\n\nA:\n\nThe problem is that\
    \ <code>member</code> is a procedure that takes two arguments, the first one being\
    \ the element to search for, and the second one being the list where to search.\
    \ You're passing only one argument, and that's why you're getting the error.\n\
    Also, <code>string-&gt;number</code> is not the right procedure to use here, because\
    \ it expects a string containing a number in decimal format, but you're passing\
    \ a symbol. Use <code>string-&gt;symbol</code> instead.\n<code>(define (hex_key\
    \ num)\n  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;symbol (substring\
    \ num 0 1)) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else\
    \ (hex_key (substring num 1))]))\n</code>\n", "  (define (is-prime? n)\n    (cond\
    \ ((= n 1) #f)\n          ((= n 2) #t)\n          ((even? n) #f)\n          (else\
    \ (let loop ((i 3))\n                  (cond ((= i n) #t)\n                  \
    \      ((= (remainder n i) 0) #f)\n                        (else (loop (+ i 2))))))))\n\
    \  (define (hex-to-decimal c)\n    (cond ((char=? c #\\0) 0)\n          ((char=?\
    \ c #\\1) 1)\n          ((char=? c #\\2) 2)\n          ((char=? c #\\3) 3)\n \
    \         ((char=? c #\\4) 4)\n          ((char=? c #\\5) 5)\n          ((char=?\
    \ c #\\6) 6)\n          ((char=? c #\\7) 7)\n          ((char=? c #\\8) 8)\n \
    \         ((char=? c #\\9) 9)\n          ((char=? c #\\A) 10)\n          ((char=?\
    \ c #\\B) 11)\n          ((char=? c #\\C) 12)\n          ((char=? c #\\D) 13)\n\
    \          ((char=? c #\\E) 14)\n          ((char=? c #\\F) 15)))\n  (define (count-primes\
    \ num)\n    (if (string-null? num)\n        0\n        (if (is-prime? (hex-to-decimal\
    \ (string-ref num 0)))\n            (+ 1 (count-primes (substring num 1)))\n \
    \           (count-primes (substring num 1)))))\n  (count-primes num))\n", " \
    \ (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol\
    \ (string-ref num 0))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n\
    \    [else (hex_key (substring num 1))]))\n</code>\nI'm getting the following\
    \ error:\n<code>&gt; (hex_key \"AB\")\n. . string-&gt;number: expects argument\
    \ of type &lt;string&gt;; given #\\A\n</code>\nI'm not sure why I'm getting this\
    \ error. I'm converting the string to a symbol and then to a number.\n\n\nA:\n\
    \nThe problem is that <code>string-&gt;symbol</code> returns a symbol, not a string.\n\
    You can use <code>string-&gt;number</code> directly on the string, and it will\
    \ convert it to a number.\n<code>(define (hex_key num)\n  (cond\n    [(empty?\
    \ num) 0]\n    [(member (string-&gt;number (string-ref num 0)) '(2 3 5 7 11 13))\n\
    \     (+ 1 (hex_key (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n\
    </code>\n", "  (define (is-prime? n)\n    (define (is-divisible? a b)\n      (=\
    \ (remainder a b) 0))\n    (define (next-prime n)\n      (if (is-divisible? n\
    \ 2)\n          (+ n 1)\n          (+ n 2)))\n    (define (find-divisor n test-divisor)\n\
    \      (cond ((> (square test-divisor) n) n)\n            ((is-divisible? n test-divisor)\
    \ n)\n            (else (find-divisor n (next-prime test-divisor)))))\n    (=\
    \ n (find-divisor n 2)))\n  (define (hex-to-decimal n)\n    (define (hex-to-decimal-iter\
    \ n acc)\n      (if (empty? n)\n          acc\n          (hex-to-decimal-iter\
    \ (rest n) (+ (* 16 acc) (char->integer (first n))))))\n    (hex-to-decimal-iter\
    \ n 0))\n  (define (hex-to-decimal-list n)\n    (define (hex-to-decimal-list-iter\
    \ n acc)\n      (if (empty? n)\n          acc\n          (hex-to-decimal-list-iter\
    \ (rest n) (cons (hex-to-decimal (first n)) acc))))\n    (hex-to-decimal-list-iter\
    \ n '()))\n  (define (count-primes n)\n    (define (count-primes-iter n acc)\n\
    \      (if (empty? n)\n          acc\n          (if (is-prime? (first n))\n  \
    \            (count-primes-iter (rest n) (+ 1 acc))\n              (count-primes-iter\
    \ (rest n) acc))))\n    (count-primes-iter n 0))\n  (count-primes (hex-to-decimal-list\
    \ (string->list num))))\n", "  (define (is-prime? n)\n    (cond ((= n 1) #f)\n\
    \          ((= n 2) #t)\n          ((even? n) #f)\n          (else\n         \
    \  (let loop ((i 3))\n             (cond ((= i n) #t)\n                   ((=\
    \ (remainder n i) 0) #f)\n                   (else (loop (+ i 2))))))))\n  (define\
    \ (hex-to-dec n)\n    (cond ((= n #\\0) 0)\n          ((= n #\\1) 1)\n       \
    \   ((= n #\\2) 2)\n          ((= n #\\3) 3)\n          ((= n #\\4) 4)\n     \
    \     ((= n #\\5) 5)\n          ((= n #\\6) 6)\n          ((= n #\\7) 7)\n   \
    \       ((= n #\\8) 8)\n          ((= n #\\9) 9)\n          ((= n #\\A) 10)\n\
    \          ((= n #\\B) 11)\n          ((= n #\\C) 12)\n          ((= n #\\D) 13)\n\
    \          ((= n #\\E) 14)\n          ((= n #\\F) 15)))\n  (define (count-primes\
    \ n)\n    (cond ((null? n) 0)\n          ((is-prime? (hex-to-dec (car n)))\n \
    \          (+ 1 (count-primes (cdr n))))\n          (else (count-primes (cdr n)))))\n\
    \  (count-primes (string->list num)))\n", "  (cond\n    [(empty? num) 0]\n   \
    \ [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest\
    \ num)))]\n    [else (hex_key (rest num))]))\n", "  (cond\n    [(empty? num) 0]\n\
    \    [(member (first num) '(\"2\" \"3\" \"5\" \"7\" \"B\" \"D\"))\n     (+ 1 (hex_key\
    \ (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (define (is-prime? n)\n\
    \    (define (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo n i)\
    \ 0) #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal\
    \ n)\n    (cond ((string=? n \"A\") 10)\n          ((string=? n \"B\") 11)\n \
    \         ((string=? n \"C\") 12)\n          ((string=? n \"D\") 13)\n       \
    \   ((string=? n \"E\") 14)\n          ((string=? n \"F\") 15)\n          (else\
    \ (string->number n))))\n  (define (hex-to-decimal-string n)\n    (cond ((string=?\
    \ n \"A\") \"10\")\n          ((string=? n \"B\") \"11\")\n          ((string=?\
    \ n \"C\") \"12\")\n          ((string=? n \"D\") \"13\")\n          ((string=?\
    \ n \"E\") \"14\")\n          ((string=? n \"F\") \"15\")\n          (else n)))\n\
    \  (define (iter n count)\n    (cond ((= (string-length n) 0) count)\n       \
    \   ((is-prime? (hex-to-decimal (string-ref n 0))) (iter (substring n 1) (+ count\
    \ 1)))\n          (else (iter (substring n 1) count))))\n  (iter (string-join\
    \ (map hex-to-decimal-string (string->list num))) 0))\n", "  (define (is-prime?\
    \ n)\n    (define (is-divisible? a b)\n      (= (remainder a b) 0))\n    (define\
    \ (find-divisor n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n\
    \            ((is-divisible? n test-divisor) test-divisor)\n            (else\
    \ (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor n 2) n))\n  (define\
    \ (is-prime-hex? n)\n    (cond ((= n #\\2) #t)\n          ((= n #\\3) #t)\n  \
    \        ((= n #\\5) #t)\n          ((= n #\\7) #t)\n          ((= n #\\B) #t)\n\
    \          ((= n #\\D) #t)\n          (else #f)))\n  (define (count-prime-hex-digits\
    \ num)\n    (if (null? num)\n        0\n        (+ (if (is-prime-hex? (car num))\
    \ 1 0)\n           (count-prime-hex-digits (cdr num)))))\n  (count-prime-hex-digits\
    \ (string->list num)))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first\
    \ num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n \
    \   [else (hex_key (rest num))]))\n", "  (cond\n    [(empty? num) 0]\n    [(member\
    \ (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n\
    \    [else (hex_key (rest num))]))\n", "  (define (is-prime? n)\n    (define (iter\
    \ i)\n      (cond\n        [(= i n) #t]\n        [(= (modulo n i) 0) #f]\n   \
    \     [else (iter (+ i 1))]))\n    (iter 2))\n  (define (is-hex-prime? c)\n  \
    \  (cond\n      [(or (= c #\\2) (= c #\\3) (= c #\\5) (= c #\\7) (= c #\\B) (=\
    \ c #\\D)) #t]\n      [else #f]))\n  (define (count-hex-primes str)\n    (cond\n\
    \      [(empty? str) 0]\n      [(is-hex-prime? (first str)) (+ 1 (count-hex-primes\
    \ (rest str)))]\n      [else (count-hex-primes (rest str))]))\n  (count-hex-primes\
    \ num))\n", "  (define (is-prime? n)\n    (cond\n      [(= n 1) #f]\n      [(=\
    \ n 2) #t]\n      [(= n 3) #t]\n      [(= n 5) #t]\n      [(= n 7) #t]\n     \
    \ [(= n 11) #t]\n      [(= n 13) #t]\n      [else #f]))\n  (define (hex-to-dec\
    \ n)\n    (cond\n      [(= n #\\0) 0]\n      [(= n #\\1) 1]\n      [(= n #\\2)\
    \ 2]\n      [(= n #\\3) 3]\n      [(= n #\\4) 4]\n      [(= n #\\5) 5]\n     \
    \ [(= n #\\6) 6]\n      [(= n #\\7) 7]\n      [(= n #\\8) 8]\n      [(= n #\\\
    9) 9]\n      [(= n #\\A) 10]\n      [(= n #\\B) 11]\n      [(= n #\\C) 12]\n \
    \     [(= n #\\D) 13]\n      [(= n #\\E) 14]\n      [(= n #\\F) 15]))\n  (define\
    \ (count-primes num)\n    (if (null? num)\n        0\n        (if (is-prime? (hex-to-dec\
    \ (string-ref num 0)))\n            (+ 1 (count-primes (substring num 1)))\n \
    \           (count-primes (substring num 1)))))\n  (count-primes num))\n", " \
    \ (define (hex-to-dec num)\n    (cond\n      [(string=? num \"A\") 10]\n     \
    \ [(string=? num \"B\") 11]\n      [(string=? num \"C\") 12]\n      [(string=?\
    \ num \"D\") 13]\n      [(string=? num \"E\") 14]\n      [(string=? num \"F\"\
    ) 15]\n      [else (string->number num)]))\n  (define (dec-to-hex num)\n    (cond\n\
    \      [(= num 10) \"A\"]\n      [(= num 11) \"B\"]\n      [(= num 12) \"C\"]\n\
    \      [(= num 13) \"D\"]\n      [(= num 14) \"E\"]\n      [(= num 15) \"F\"]\n\
    \      [else (number->string num)]))\n  (define (is-prime? num)\n    (define (is-prime-helper\
    \ num div)\n      (cond\n        [(= div 1) #t]\n        [(= (modulo num div)\
    \ 0) #f]\n        [else (is-prime-helper num (- div 1))]))\n    (is-prime-helper\
    \ num (/ num 2)))\n  (define (hex-to-dec-list num)\n    (cond\n      [(empty?\
    \ num) empty]\n      [else (cons (hex-to-dec (string-ref num 0)) (hex-to-dec-list\
    \ (substring num 1)))]))\n  (define (dec-to-hex-list num)\n    (cond\n      [(empty?\
    \ num) empty]\n      [else (cons (dec-to-hex (car num)) (dec-to-hex-list (cdr\
    \ num)))]))\n  (define (count-primes num)\n    (cond\n      [(empty? num) 0]\n\
    \      [(is-prime? (car num)) (+ 1 (count-primes (cdr num)))]\n      [else (count-primes\
    \ (cdr num))]))\n  (count-primes (hex-to-dec-list num)))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+\
    \ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (cond\n \
    \   [(empty? num) 0]\n    [(member (string-&gt;number (string-&gt;symbol (string-ref\
    \ num 0))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num 1)))]\n    [else\
    \ (hex_key (substring num 1))]))\n</code>\nI am getting the following error:\n\
    <code>string-&gt;number: expects argument of type &lt;string&gt;; given #\\2\n\
    </code>\nI am not sure what is wrong with my code.\n\n\nA:\n\nThe problem is that\
    \ <code>string-&gt;symbol</code> returns a symbol, not a string.  You need to\
    \ use <code>symbol-&gt;string</code> to convert it to a string before you can\
    \ use <code>string-&gt;number</code>.\n", "  (cond\n    [(empty? num) 0]\n   \
    \ [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest\
    \ num)))]\n    [else (hex_key (rest num))]))\n", "  (define (is-prime? n)\n  \
    \  (define (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo n i) 0)\
    \ #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal\
    \ n)\n    (cond ((= n #\\0) 0)\n          ((= n #\\1) 1)\n          ((= n #\\\
    2) 2)\n          ((= n #\\3) 3)\n          ((= n #\\4) 4)\n          ((= n #\\\
    5) 5)\n          ((= n #\\6) 6)\n          ((= n #\\7) 7)\n          ((= n #\\\
    8) 8)\n          ((= n #\\9) 9)\n          ((= n #\\A) 10)\n          ((= n #\\\
    B) 11)\n          ((= n #\\C) 12)\n          ((= n #\\D) 13)\n          ((= n\
    \ #\\E) 14)\n          ((= n #\\F) 15)))\n  (define (iter i count)\n    (cond\
    \ ((= i (string-length num)) count)\n          ((is-prime? (hex-to-decimal (string-ref\
    \ num i)))\n           (iter (+ i 1) (+ count 1)))\n          (else (iter (+ i\
    \ 1) count))))\n  (iter 0 0))\n", "  (define (is-prime? n)\n    (define (iter\
    \ i)\n      (if (= i n) #t\n          (if (= (remainder n i) 0) #f\n         \
    \     (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-dec n)\n    (cond ((string=?\
    \ n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=? n \"C\"\
    ) 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\") 14)\n\
    \          ((string=? n \"F\") 15)\n          (else (string->number n))))\n  (define\
    \ (iter i count)\n    (if (= i (string-length num)) count\n        (if (is-prime?\
    \ (hex-to-dec (string-ref num i)))\n            (iter (+ i 1) (+ count 1))\n \
    \           (iter (+ i 1) count))))\n  (iter 0 0))\n", "  (define (is-prime? n)\n\
    \    (define (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo n i)\
    \ 0) #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal\
    \ n)\n    (cond ((string=? n \"A\") 10)\n          ((string=? n \"B\") 11)\n \
    \         ((string=? n \"C\") 12)\n          ((string=? n \"D\") 13)\n       \
    \   ((string=? n \"E\") 14)\n          ((string=? n \"F\") 15)\n          (else\
    \ (string->number n))))\n  (define (count-primes lst)\n    (cond ((null? lst)\
    \ 0)\n          ((is-prime? (car lst)) (+ 1 (count-primes (cdr lst))))\n     \
    \     (else (count-primes (cdr lst)))))\n  (count-primes (map hex-to-decimal (string-&gt;list\
    \ num))))\n</code>\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num)\
    \ '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else\
    \ (hex_key (rest num))]))\n", "  (define (is-prime? n)\n    (cond ((= n 1) #f)\n\
    \          ((= n 2) #t)\n          ((even? n) #f)\n          (else (is-prime-rec\
    \ n 3))))\n  (define (is-prime-rec n i)\n    (cond ((= i n) #t)\n          ((=\
    \ (remainder n i) 0) #f)\n          (else (is-prime-rec n (+ i 2)))))\n  (define\
    \ (hex-to-dec n)\n    (cond ((= n #\\0) 0)\n          ((= n #\\1) 1)\n       \
    \   ((= n #\\2) 2)\n          ((= n #\\3) 3)\n          ((= n #\\4) 4)\n     \
    \     ((= n #\\5) 5)\n          ((= n #\\6) 6)\n          ((= n #\\7) 7)\n   \
    \       ((= n #\\8) 8)\n          ((= n #\\9) 9)\n          ((= n #\\A) 10)\n\
    \          ((= n #\\B) 11)\n          ((= n #\\C) 12)\n          ((= n #\\D) 13)\n\
    \          ((= n #\\E) 14)\n          ((= n #\\F) 15)))\n  (define (count-primes\
    \ n)\n    (cond ((null? n) 0)\n          ((is-prime? (hex-to-dec (car n))) (+\
    \ 1 (count-primes (cdr n))))\n          (else (count-primes (cdr n)))))\n  (count-primes\
    \ (string->list num)))\n", "  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number\
    \ (string-&gt;symbol (substring num 0 1))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key\
    \ (substring num 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\nI am\
    \ getting the following error:\n<code>hex_key.rkt:14:0: string-&gt;number: expects\
    \ argument of type &lt;string&gt;; given #\\2\n</code>\nI am not sure what I am\
    \ doing wrong. Can someone please help me?\n\n\nA:\n\nThe problem is that <code>string-&gt;number</code>\
    \ expects a string, but you're passing it a character. You need to convert the\
    \ character to a string first, and then to a number.\n<code>(define (hex_key num)\n\
    \  (cond\n    [(empty? num) 0]\n    [(member (string-&gt;number (string (string-&gt;symbol\
    \ (substring num 0 1)))) '(2 3 5 7 11 13))\n     (+ 1 (hex_key (substring num\
    \ 1)))]\n    [else (hex_key (substring num 1))]))\n</code>\n", "  (define (hex-to-dec\
    \ num)\n    (cond\n      [(string=? num \"A\") 10]\n      [(string=? num \"B\"\
    ) 11]\n      [(string=? num \"C\") 12]\n      [(string=? num \"D\") 13]\n    \
    \  [(string=? num \"E\") 14]\n      [(string=? num \"F\") 15]\n      [else (string->number\
    \ num)]))\n  (define (is-prime? num)\n    (define (is-prime-helper num divisor)\n\
    \      (cond\n        [(= num 1) #f]\n        [(= num 2) #t]\n        [(= num\
    \ divisor) #t]\n        [(= (modulo num divisor) 0) #f]\n        [else (is-prime-helper\
    \ num (+ divisor 1))]))\n    (is-prime-helper num 2))\n  (define (hex-key-helper\
    \ num)\n    (cond\n      [(empty? num) 0]\n      [(is-prime? (hex-to-dec (first\
    \ num))) (+ 1 (hex-key-helper (rest num)))]\n      [else (hex-key-helper (rest\
    \ num))]))\n  (hex-key-helper (string->list num)))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(hex-prime? (first num)) (+ 1 (hex_key (rest num)))]\n    [else\
    \ (hex_key (rest num))]))\n", "  (define (is_prime? n)\n    (cond ((= n 1) #f)\n\
    \          ((= n 2) #t)\n          ((even? n) #f)\n          (else (let loop ((i\
    \ 3))\n                  (cond ((= i n) #t)\n                        ((= (remainder\
    \ n i) 0) #f)\n                        (else (loop (+ i 2))))))))\n  (define (is_hex_prime?\
    \ n)\n    (cond ((= n #\\2) #t)\n          ((= n #\\3) #t)\n          ((= n #\\\
    5) #t)\n          ((= n #\\7) #t)\n          ((= n #\\B) #t)\n          ((= n\
    \ #\\D) #t)\n          (else #f)))\n  (define (count-hex-primes n)\n    (cond\
    \ ((null? n) 0)\n          ((is_hex_prime? (car n)) (+ 1 (count-hex-primes (cdr\
    \ n))))\n          (else (count-hex-primes (cdr n)))))\n  (count-hex-primes (string->list\
    \ num)))\n", "  (define (is-prime? n)\n    (define (iter i)\n      (if (> (* i\
    \ i) n)\n          #t\n          (if (= (modulo n i) 0)\n              #f\n  \
    \            (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-dec n)\n    (cond\
    \ ((string=? n \"A\") 10)\n          ((string=? n \"B\") 11)\n          ((string=?\
    \ n \"C\") 12)\n          ((string=? n \"D\") 13)\n          ((string=? n \"E\"\
    ) 14)\n          ((string=? n \"F\") 15)\n          (else (string->number n))))\n\
    \  (define (iter n acc)\n    (if (string-empty? n)\n        acc\n        (if (is-prime?\
    \ (hex-to-dec (string-ref n 0)))\n            (iter (substring n 1) (+ acc 1))\n\
    \            (iter (substring n 1) acc))))\n  (iter num 0))\n", "  (cond\n   \
    \ [(string=? num \"\") 0]\n    [(string=? num \"0\") 0]\n    [(string=? num \"\
    1\") 0]\n    [(string=? num \"2\") 1]\n    [(string=? num \"3\") 1]\n    [(string=?\
    \ num \"4\") 0]\n    [(string=? num \"5\") 1]\n    [(string=? num \"6\") 0]\n\
    \    [(string=? num \"7\") 1]\n    [(string=? num \"8\") 0]\n    [(string=? num\
    \ \"9\") 0]\n    [(string=? num \"A\") 0]\n    [(string=? num \"B\") 1]\n    [(string=?\
    \ num \"C\") 0]\n    [(string=? num \"D\") 1]\n    [(string=? num \"E\") 0]\n\
    \    [(string=? num \"F\") 0]\n    [else (hex_key (string-append (substring num\
    \ 0 1) \"\"))]))\n", "  (cond\n    [(empty? num) 0]\n    [(member (first num)\
    \ '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+ 1 (hex_key (rest num)))]\n    [else\
    \ (hex_key (rest num))]))\n", "  (define (is-prime? n)\n    (define (iter i)\n\
    \      (cond\n        [(= i n) #t]\n        [(= (modulo n i) 0) #f]\n        [else\
    \ (iter (+ i 1))]))\n    (iter 2))\n  (define (hex-to-dec n)\n    (cond\n    \
    \  [(string=? n \"A\") 10]\n      [(string=? n \"B\") 11]\n      [(string=? n\
    \ \"C\") 12]\n      [(string=? n \"D\") 13]\n      [(string=? n \"E\") 14]\n \
    \     [(string=? n \"F\") 15]\n      [else (string->number n)]))\n  (define (iter\
    \ i count)\n    (cond\n      [(= i (string-length num)) count]\n      [(is-prime?\
    \ (hex-to-dec (string-ref num i))) (iter (+ i 1) (+ count 1))]\n      [else (iter\
    \ (+ i 1) count)]))\n  (iter 0 0))", "  (define (hex_to_dec num)\n    (cond\n\
    \      [(string=? num \"A\") 10]\n      [(string=? num \"B\") 11]\n      [(string=?\
    \ num \"C\") 12]\n      [(string=? num \"D\") 13]\n      [(string=? num \"E\"\
    ) 14]\n      [(string=? num \"F\") 15]\n      [else (string->number num)]))\n\
    \  (define (is_prime? num)\n    (define (iter i)\n      (cond\n        [(= i num)\
    \ #t]\n        [(= (modulo num i) 0) #f]\n        [else (iter (+ i 1))]))\n  \
    \  (iter 2))\n  (define (iter num count)\n    (cond\n      [(empty? num) count]\n\
    \      [(is_prime? (hex_to_dec (first num))) (iter (rest num) (+ count 1))]\n\
    \      [else (iter (rest num) count)]))\n  (iter num 0))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D)) (+ 1 (hex_key\
    \ (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (cond\n    [(empty?\
    \ num) 0]\n    [(member (first num) '(#\\2 #\\3 #\\5 #\\7 #\\B #\\D))\n     (+\
    \ 1 (hex_key (rest num)))]\n    [else (hex_key (rest num))]))\n", "  (define (is-prime?\
    \ n)\n    (define (iter i)\n      (cond ((= i n) #t)\n            ((= (modulo\
    \ n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n  (define (hex-to-decimal\
    \ n)\n    (cond ((string=? n \"A\") 10)\n          ((string=? n \"B\") 11)\n \
    \         ((string=? n \"C\") 12)\n          ((string=? n \"D\") 13)\n       \
    \   ((string=? n \"E\") 14)\n          ((string=? n \"F\") 15)\n          (else\
    \ (string->number n))))\n  (define (iter n count)\n    (cond ((string=? n \"\"\
    ) count)\n          ((is-prime? (hex-to-decimal (string-ref n 0)))\n         \
    \  (iter (substring n 1) (+ count 1)))\n          (else (iter (substring n 1)\
    \ count))))\n  (iter num 0))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
