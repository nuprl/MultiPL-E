name: HumanEval_49_modp
language: rkt
prompt: "#lang racket\n\n;; Return 2^n modulo p (be aware of numerics).\n;; >>> (modp\
  \ 3 5)\n;; 3\n;; >>> (modp 1101 101)\n;; 2\n;; >>> (modp 0 101)\n;; 1\n;; >>> (modp\
  \ 3 11)\n;; 8\n;; >>> (modp 100 101)\n;; 1\n(define (modp n p)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n\
  \    (check-equal? (candidate 3 5) 3)\n    (check-equal? (candidate 1101 101) 2)\n\
  \    (check-equal? (candidate 0 101) 1)\n    (check-equal? (candidate 3 11) 8)\n\
  \    (check-equal? (candidate 100 101) 1)\n    (check-equal? (candidate 30 5) 4)\n\
  \    (check-equal? (candidate 31 5) 3)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 0)\n      1\n      (if (even? n)\n          (modulo (expt\
    \ 2 (/ n 2)) p)\n          (modulo (* (expt 2 (/ (- n 1) 2)) n) p))))\n", "  (if\
    \ (zero? n)\n      1\n      (if (even? n)\n          (modulo (expt 2 (quotient\
    \ n 2)) p)\n          (modulo (* 2 (modp (sub1 n) p)) p))))\n", "  (define (modp-iter\
    \ n p result)\n    (if (= n 0)\n        result\n        (modp-iter (quotient n\
    \ 2) p\n                   (if (odd? n)\n                       (* result result\
    \ p)\n                       (* result result)))))\n  (modp-iter n p 1))\n", " \
    \ (if (= n 0)\n      1\n      (let ([x (modp (quotient n 2) p)])\n        (if\
    \ (even? n)\n            (modulo (* x x) p)\n            (modulo (* x x x) p)))))\n",
  "  (if (zero? n)\n      1\n      (if (even? n)\n          (modulo (modp (/ n 2)\
    \ p) (modulo (* 2 p) p))\n          (modulo (modp (- n 1) p) (modulo (* 2 p) p)))))\n",
  "  (cond\n    [(= n 0) 1]\n    [(even? n) (modulo (square (modp (/ n 2) p)) p)]\n\
    \    [else (modulo (* (modp (- n 1) p) 2) p)]))\n", "  (cond\n    [(= n 0) 1]\n\
    \    [(= n 1) n]\n    [(odd? n) (modulo (* (modp (- n 1) p) 2) p)]\n    [else\
    \ (modulo (modp (/ n 2) p) p)]))\n", "  (define (modp-iter n p acc)\n    (cond\n\
    \      [(= n 0) acc]\n      [(= (remainder n 2) 0) (modp-iter (/ n 2) p (* acc\
    \ acc p))]\n      [else (modp-iter (- n 1) p (* acc acc p))]))\n  (modp-iter n\
    \ p 1))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n          (modulo (*\
    \ (modp (/ n 2) p) (modp (/ n 2) p)) p)\n          (modulo (* (modp (- n 1) p)\
    \ 2) p))))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n          (modulo\
    \ (* (modp (/ n 2) p) (modp (/ n 2) p)) p)\n          (modulo (* (modp (/ n 2)\
    \ p) (modp (/ n 2) p) 2) p))))\n", "  (if (= n 0)\n      1\n      (let ([n2 (modulo\
    \ (* n 2) p)])\n        (if (= n2 0)\n            p\n            n2))))\n", " \
    \ (cond\n    [(= n 0) 1]\n    [(= (remainder n 2) 0) (modulo (* (modp (/ n 2)\
    \ p) (modp (/ n 2) p)) p)]\n    [else (modulo (* (modp (/ n 2) p) (modp (/ n 2)\
    \ p) 2) p)]))\n", "  (if (= n 0)\n      1\n      (* (modp (- n 1) p) 2)\n    \
    \  )\n  )\n", "  (if (= n 0)\n      1\n      (if (even? n)\n          (modulo\
    \ (expt 2 (/ n 2)) p)\n          (modulo (* (expt 2 (/ (- n 1) 2)) 2) p))))\n",
  "  (cond\n    [(= n 0) 1]\n    [(even? n) (modulo (square (modp (/ n 2) p)) p)]\n\
    \    [else (modulo (* (modp (- n 1) p) 2) p)]))\n", "  (cond\n    [(= n 0) 1]\n\
    \    [(= n 1) n]\n    [(= (remainder n 2) 0) (modulo (square (modp (/ n 2) p))\
    \ p)]\n    [else (modulo (* n (modp (- n 1) p)) p)]))\n", "  (cond\n    [(= n\
    \ 0) 1]\n    [(= n 1) 1]\n    [(= n 2) 2]\n    [(= n 3) 3]\n    [(= n 4) 4]\n\
    \    [(= n 5) 5]\n    [(= n 6) 6]\n    [(= n 7) 7]\n    [(= n 8) 8]\n    [(= n\
    \ 9) 9]\n    [(= n 10) 10]\n    [(= n 11) 11]\n    [(= n 12) 12]\n    [(= n 13)\
    \ 13]\n    [(= n 14) 14]\n    [(= n 15) 15]\n    [(= n 16) 16]\n    [(= n 17)\
    \ 17]\n    [(= n 18) 18]\n    [(= n 19) 19]\n    [(= n 20) 20]\n    [(= n 21)\
    \ 21]\n    [(= n 22) 22]\n    [(= n 23) 23]\n    [(= n 24) 24]\n    [(= n 25)\
    \ 25]\n    [(= n 26) 26]\n    [(= n 27) 27]\n    [(= n 28) 28]\n    [(= n 29)\
    \ 29]\n    [(= n 30) 30]\n    [(= n 31) 31]\n    [(= n 32) 32]\n    [(= n 33)\
    \ 33]\n    [(= n 34) 34]\n    [(= n 35) 35]\n    [(= n 36) 36]\n    [(= n 37)\
    \ 37]\n    [(= n 38) 38]\n    [(= n 39) 39]\n    [(= n 40) 40]\n    [(= n 41)\
    \ 41]\n    [(= n 42) 42]\n    [(= n 43) 43]\n    [(= n 44) 44]\n    [(= n 45)\
    \ 45]\n    [(= n 46) 46]\n    [(= n 47) 47]\n    [(= n 48) 48]\n    [(= n 49)\
    \ 49]\n    [(= n 50) 50]\n    [(= n 51) 51]\n    [(= n 52) 52]\n    [(= n 53)\
    \ 53]\n    [(= n 54) 54]\n    [(= n 55) 55]\n    [(=", "  (if (= n 0)\n      1\n\
    \      (if (even? n)\n          (modulo (* (modp (/ n 2) p) (modp (/ n 2) p))\
    \ p)\n          (modulo (* (modp (/ n 2) p) (modp (/ n 2) p) 2) p))))\n", "  (if\
    \ (zero? n)\n      1\n      (if (even? n)\n          (modulo (modp (/ n 2) p)\
    \ (expt 2 (modulo n 2) p))\n          (modulo (* (modp (/ n 2) p) (expt 2 (modulo\
    \ n 2) p)) p))))\n", "  (if (= n 0)\n      1\n      (let ([m (modulo (* 2 (modp\
    \ (- n 1) p)) p)])\n        (if (= m 0)\n            p\n            m))))\n```\n\
    \n## Problem 2\n\n```racket\n#lang racket\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
