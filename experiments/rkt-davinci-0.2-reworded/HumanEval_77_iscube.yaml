name: HumanEval_77_iscube
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes an integer a and returns #t\
  \ \n;; if this ingeger is a cube of some integer number.\n;; Note: you may assume\
  \ the input is always valid.\n;; Examples:\n;; >>> (iscube 1)\n;; #t\n;; >>> (iscube\
  \ 2)\n;; #f\n;; >>> (iscube -1)\n;; #t\n;; >>> (iscube 64)\n;; #t\n;; >>> (iscube\
  \ 0)\n;; #t\n;; >>> (iscube 180)\n;; #f\n(define (iscube a)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate iscube))\n\
  \    (check-equal? (candidate 1) #t)\n    (check-equal? (candidate 2) #f)\n    (check-equal?\
  \ (candidate -1) #t)\n    (check-equal? (candidate 64) #t)\n    (check-equal? (candidate\
  \ 180) #f)\n    (check-equal? (candidate 1000) #t)\n    (check-equal? (candidate\
  \ 0) #t)\n    (check-equal? (candidate 1729) #f)\n))\n\n(test-humaneval)"
completions: ["  (define (iscube-iter a n)\n    (cond ((= a (* n n n)) #t)\n     \
    \     ((&gt; a (* n n n)) (iscube-iter a (+ n 1)))\n          (else #f)))\n  (iscube-iter\
    \ a 1))\n</code>\n", "  (define (iscube-iter a n)\n    (cond ((= a (* n n n))\
    \ #t)\n          ((&gt; a (* n n n)) (iscube-iter a (+ n 1)))\n          (else\
    \ #f)))\n  (iscube-iter a 1))\n</code>\nI'm not sure if this is the best way to\
    \ do this, but it works.\n\n\nA:\n\nI think you're over-complicating things. You\
    \ can solve this problem with a single function, without using any auxiliary procedure:\n\
    <code>(define (iscube a)\n  (let loop ((n 1))\n    (cond ((= a (* n n n)) #t)\n\
    \          ((&gt; a (* n n n)) (loop (+ n 1)))\n          (else #f))))\n</code>\n",
  "  (and (not (= a 0))\n       (exact-integer-sqrt (abs a))\n       (= (exact-integer-sqrt\
    \ (abs a))\n          (exact-integer-sqrt (abs a)))))\n", "  (cond\n    [(= a\
    \ 0) #t]\n    [(< a 0) (iscube (- a))]\n    [else (let loop ([i 1])\n        \
    \     (cond\n               [(= a (* i i i)) #t]\n               [(> a (* i i\
    \ i)) (loop (+ i 1))]\n               [else #f]))]))\n", "  (cond\n    [(= a 0)\
    \ #t]\n    [(= a 1) #t]\n    [(= a (- 0 a)) #t]\n    [(= a (- 1 a)) #t]\n    [else\
    \ (exact-integer-sqrt a)]))\n", "  (define (iscube-iter a n)\n    (cond ((= a\
    \ (* n n n)) #t)\n          ((&gt; a (* n n n)) (iscube-iter a (+ n 1)))\n   \
    \       (else #f)))\n  (iscube-iter a 1))\n</code>\n", "  (if (zero? a)\n    \
    \  #t\n      (if (negative? a)\n          (iscube (- a))\n          (let loop\
    \ ((i 1))\n            (if (= (expt i 3) a)\n                #t\n            \
    \    (if (&lt; (expt i 3) a)\n                    (loop (+ i 1))\n           \
    \         #f))))))\n</code>\n", "  (if (= a 0)\n      #t\n      (if (= a 1)\n\
    \          #t\n          (if (= a -1)\n              #t\n              (if (=\
    \ (expt (round (sqrt a)) 3) a)\n                  #t\n                  #f)))))\n",
  "  (if (zero? a)\n      #t\n      (if (negative? a)\n          (iscube (- a))\n\
    \          (let ((i 1))\n            (let loop ((i i))\n              (if (= a\
    \ (* i i i))\n                  #t\n                  (if (< i a)\n          \
    \            (loop (+ i 1))\n                      #f)))))))\n", "  (if (= a 0)\n\
    \      #t\n      (if (and (integer? (sqrt a)) (= (sqrt a) (sqrt (sqrt a))))\n\
    \          #t\n          #f)))\n", "  (define (iscube-iter a n)\n    (cond ((=\
    \ a (* n n n)) #t)\n          ((&gt; a (* n n n)) (iscube-iter a (+ n 1)))\n \
    \         (else #f)))\n  (iscube-iter a 1))\n</code>\nI'm not sure if this is\
    \ the best way to do it, but it works.\n\n\nA:\n\nI would do it like this:\n<code>(define\
    \ (iscube a)\n  (let loop ((n 1))\n    (cond ((= a (* n n n)) #t)\n          ((&gt;\
    \ a (* n n n)) (loop (+ n 1)))\n          (else #f))))\n</code>\n", "  (if (=\
    \ a 0)\n      #t\n      (if (= a 1)\n          #t\n          (if (= a -1)\n  \
    \            #t\n              (if (= (expt (round (sqrt a)) 3) a)\n         \
    \         #t\n                  #f)))))\n", "  (cond\n    [(= a 0) #t]\n    [(<\
    \ a 0) (iscube (- a))]\n    [else (let loop ([i 1])\n             (cond\n    \
    \           [(= (* i i i) a) #t]\n               [(> (* i i i) a) #f]\n      \
    \         [else (loop (+ i 1))]))]))\n", "  (if (zero? a)\n      #t\n      (if\
    \ (negative? a)\n          (iscube (- a))\n          (let loop ((i 1))\n     \
    \       (if (= (expt i 3) a)\n                #t\n                (if (&lt; (expt\
    \ i 3) a)\n                    (loop (+ i 1))\n                    #f))))))\n\
    </code>\n", "  (if (= (expt (round (sqrt a)) 3) a)\n      #t\n      #f))\n", " \
    \ (if (= (expt (round (sqrt a)) 3) a)\n      #t\n      #f))\n", "  (define (iscube-iter\
    \ a n)\n    (cond ((= a (* n n n)) #t)\n          ((&gt; a (* n n n)) (iscube-iter\
    \ a (+ n 1)))\n          (else #f)))\n  (iscube-iter a 1))\n</code>\n", "  (if\
    \ (= a 0)\n      #t\n      (if (= a 1)\n          #t\n          (if (= a -1)\n\
    \              #t\n              (if (= a (expt (round (expt a (/ 1 3))) 3))\n\
    \                  #t\n                  #f)))))\n", "  (if (= (expt (round (sqrt\
    \ a)) 3) a)\n      #t\n      #f))\n", "  (define (iscube-iter a n)\n    (cond\
    \ ((= a (* n n n)) #t)\n          ((> a (* n n n)) (iscube-iter a (+ n 1)))\n\
    \          (else #f)))\n  (iscube-iter a 1))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
