name: HumanEval_160_do_algebra
language: rkt
prompt: "#lang racket\n\n;; Given two lists operator, and operand. The first list\
  \ has basic algebra operations, and \n;; the second list is a list of integers.\
  \ Use the two given lists to build the algebric \n;; expression and return the evaluation\
  \ of this expression.\n;; The basic algebra operations:\n;; Addition ( + ) \n;;\
  \ Subtraction ( - ) \n;; Multiplication ( * ) \n;; Floor division ( // ) \n;; Exponentiation\
  \ ( ** ) \n;; Example:\n;; operator['+', '*', '-']\n;; list = [2, 3, 4, 5]\n;; result\
  \ = 2 + 3 * 4 - 5\n;; => result = 9\n;; Note:\n;; The length of operator list is\
  \ equal to the length of operand list minus one.\n;; Operand is a list of of non-negative\
  \ integers.\n;; Operator list has at least one operator, and operand list has at\
  \ least two operands.\n(define (do_algebra operator operand)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate do_algebra))\n\
  \    (check-equal? (candidate (list \"**\" \"*\" \"+\") (list 2 3 4 5)) 37)\n  \
  \  (check-equal? (candidate (list \"+\" \"*\" \"-\") (list 2 3 4 5)) 9)\n    (check-equal?\
  \ (candidate (list \"//\" \"*\") (list 7 3 4)) 8)\n))\n\n(test-humaneval)"
completions: ["  (let loop ([operator (reverse operator)]\n             [operand (reverse\
    \ operand)])\n    (if (null? operator)\n        (car operand)\n        (let* ([op\
    \ (car operator)]\n               [op1 (car operand)]\n               [op2 (cadr\
    \ operand)])\n          (cond [(equal? op '+) (+ op1 op2)]\n                [(equal?\
    \ op '-) (- op1 op2)]\n                [(equal? op '*) (* op1 op2)]\n        \
    \        [(equal? op '//) (quotient op1 op2)]\n                [(equal? op '**)\
    \ (expt op1 op2)])))))\n", "  (define (do_algebra_helper operator operand result)\n\
    \    (if (null? operator)\n        result\n        (do_algebra_helper (cdr operator)\
    \ (cdr operand)\n                           (cond\n                          \
    \   ((equal? (car operator) '+) (+ result (car operand)))\n                  \
    \           ((equal? (car operator) '-) (- result (car operand)))\n          \
    \                   ((equal? (car operator) '*) (* result (car operand)))\n  \
    \                           ((equal? (car operator) '//) (quotient result (car\
    \ operand)))\n                             ((equal? (car operator) '**) (expt\
    \ result (car operand)))))))\n  (do_algebra_helper operator operand (car operand)))\n",
  "  (let loop ([operator operator] [operand operand] [result (car operand)])\n  \
    \  (cond [(null? operator) result]\n          [else (loop (cdr operator) (cdr\
    \ operand)\n                      (match (car operator)\n                    \
    \    ['+ (+ result (car operand))]\n                        ['* (* result (car\
    \ operand))]\n                        ['- (- result (car operand))]\n        \
    \                ['// (quotient result (car operand))]\n                     \
    \   ['** (expt result (car operand))]))])))\n", "  (define (do_algebra_helper\
    \ operator operand result)\n    (cond\n      [(empty? operator) (first operand)]\n\
    \      [(empty? operand) result]\n      [else\n       (do_algebra_helper (rest\
    \ operator) (rest operand)\n                          (cond\n                \
    \            [(equal? (first operator) '+) (+ result (first operand))]\n     \
    \                       [(equal? (first operator) '-) (- result (first operand))]\n\
    \                            [(equal? (first operator) '*) (* result (first operand))]\n\
    \                            [(equal? (first operator) '//) (quotient result (first\
    \ operand))]\n                            [(equal? (first operator) '**) (expt\
    \ result (first operand))]))]))\n  (do_algebra_helper operator operand 0))\n",
  "  (let loop ((operator operator)\n             (operand operand)\n            \
    \ (result (car operand)))\n    (if (null? operator)\n        result\n        (loop\
    \ (cdr operator)\n              (cdr operand)\n              (match (car operator)\n\
    \                     ['+ (+ result (car operand))]\n                     ['*\
    \ (* result (car operand))]\n                     ['- (- result (car operand))]\n\
    \                     ['// (quotient result (car operand))]\n                \
    \     ['** (expt result (car operand))])))))\n", "  (define (do_algebra_helper\
    \ operator operand result)\n    (if (null? operator)\n        result\n       \
    \ (do_algebra_helper (cdr operator) (cdr operand)\n                          \
    \ (cond [(equal? (car operator) '+)\n                                  (+ result\
    \ (car operand))]\n                                 [(equal? (car operator) '-)\n\
    \                                  (- result (car operand))]\n               \
    \                  [(equal? (car operator) '*)\n                             \
    \     (* result (car operand))]\n                                 [(equal? (car\
    \ operator) '//)\n                                  (quotient result (car operand))]\n\
    \                                 [(equal? (car operator) '**)\n             \
    \                     (expt result (car operand))]))))\n  (do_algebra_helper operator\
    \ operand (car operand)))\n", "  (let loop ([operator (reverse operator)]\n  \
    \           [operand (reverse operand)])\n    (cond [(null? operator) (car operand)]\n\
    \          [(null? (cdr operand)) (car operand)]\n          [else (loop (cdr operator)\n\
    \                      (cons (case (car operator)\n                          \
    \    [('+ ) (+ (car operand) (cadr operand))]\n                              [('-\
    \ ) (- (car operand) (cadr operand))]\n                              [('* ) (*\
    \ (car operand) (cadr operand))]\n                              [('// ) (quotient\
    \ (car operand) (cadr operand))]\n                              [('** ) (expt\
    \ (car operand) (cadr operand))])\n                            (cddr operand)))])))\n",
  "  (let loop ((operator operator)\n             (operand operand)\n            \
    \ (result (car operand)))\n    (if (null? operator)\n        result\n        (loop\
    \ (cdr operator)\n              (cdr operand)\n              (case (car operator)\n\
    \                ((+ - * // **)\n                 (apply (car operator) result\
    \ (car operand)))\n                (else\n                 (error \"Invalid operator\"\
    )))))))\n", "  (define (do_algebra_iter operator operand result)\n    (if (null?\
    \ operator)\n        result\n        (do_algebra_iter (cdr operator) (cdr operand)\n\
    \                         (cond\n                           ((string=? (car operator)\
    \ \"+\") (+ result (car operand)))\n                           ((string=? (car\
    \ operator) \"-\") (- result (car operand)))\n                           ((string=?\
    \ (car operator) \"*\") (* result (car operand)))\n                          \
    \ ((string=? (car operator) \"//\") (quotient result (car operand)))\n       \
    \                    ((string=? (car operator) \"**\") (expt result (car operand)))))))\n\
    \  (do_algebra_iter operator operand (car operand)))\n", "  (define (helper opers\
    \ operands)\n    (if (null? opers)\n        (car operands)\n        (helper (cdr\
    \ opers) (cons (eval (list (car opers) (car operands) (car (cdr operands)))) (cdr\
    \ (cdr operands))))))\n  (helper operator operand))\n", "  (let loop ([operator\
    \ operator] [operand operand] [result (car operand)])\n    (if (null? operator)\n\
    \        result\n        (loop (cdr operator) (cdr operand)\n              (cond\n\
    \                [(equal? (car operator) '+) (+ result (car operand))]\n     \
    \           [(equal? (car operator) '-) (- result (car operand))]\n          \
    \      [(equal? (car operator) '*) (* result (car operand))]\n               \
    \ [(equal? (car operator) '//) (quotient result (car operand))]\n            \
    \    [(equal? (car operator) '**) (expt result (car operand))])))))\n", "  (define\
    \ (do_algebra_iter operator operand result)\n    (if (null? operator)\n      \
    \  result\n        (do_algebra_iter (cdr operator) (cdr operand)\n           \
    \              (match (car operator)\n                                [(\"+\"\
    ) (+ result (car operand))]\n                                [(\"-\") (- result\
    \ (car operand))]\n                                [(\"*\") (* result (car operand))]\n\
    \                                [(\"//\") (quotient result (car operand))]\n\
    \                                [(\"**\") (expt result (car operand))]))))\n\
    \  (do_algebra_iter operator operand (car operand)))\n", "  (define (do_op op1\
    \ op2 op)\n    (cond ((eq? op '+) (+ op1 op2))\n          ((eq? op '-) (- op1\
    \ op2))\n          ((eq? op '*) (* op1 op2))\n          ((eq? op '//) (quotient\
    \ op1 op2))\n          ((eq? op '**) (expt op1 op2))))\n  (define (do_op_list\
    \ ops ops_list)\n    (if (null? ops_list)\n        (car ops)\n        (do_op_list\
    \ (do_op (car ops) (car ops_list) (car operator)) (cdr ops_list))))\n  (do_op_list\
    \ (car operand) (cdr operand)))\n", "  (let loop ([operator operator] [operand\
    \ operand] [result (car operand)])\n    (if (null? operator)\n        result\n\
    \        (loop (cdr operator) (cdr operand)\n              (cond\n           \
    \     [(equal? (car operator) '+) (+ result (car operand))]\n                [(equal?\
    \ (car operator) '-) (- result (car operand))]\n                [(equal? (car\
    \ operator) '*) (* result (car operand))]\n                [(equal? (car operator)\
    \ '//) (quotient result (car operand))]\n                [(equal? (car operator)\
    \ '**) (expt result (car operand))])))))\n", "  (define (do_algebra-helper operator\
    \ operand result)\n    (cond\n      [(empty? operator) result]\n      [else (do_algebra-helper\
    \ (rest operator) (rest operand)\n                               (cond\n     \
    \                            [(equal? (first operator) '+) (+ result (first operand))]\n\
    \                                 [(equal? (first operator) '-) (- result (first\
    \ operand))]\n                                 [(equal? (first operator) '*) (*\
    \ result (first operand))]\n                                 [(equal? (first operator)\
    \ '//) (quotient result (first operand))]\n                                 [(equal?\
    \ (first operator) '**) (expt result (first operand))]))]))\n  (do_algebra-helper\
    \ operator operand (first operand)))\n", "  (define (do_algebra_iter oprnd oprtr)\n\
    \    (cond\n      [(empty? oprtr) (first oprnd)]\n      [else (do_algebra_iter\
    \ (cons (eval (list (first oprtr) (first oprnd) (second oprnd))) (rest (rest oprnd)))\
    \ (rest oprtr))]))\n  (do_algebra_iter operand operator))\n", "  (let ([op (car\
    \ operator)]\n        [op1 (car operand)]\n        [op2 (cadr operand)])\n   \
    \ (cond [(equal? op '+) (+ op1 op2)]\n          [(equal? op '-) (- op1 op2)]\n\
    \          [(equal? op '*) (* op1 op2)]\n          [(equal? op '//) (quotient\
    \ op1 op2)]\n          [(equal? op '**) (expt op1 op2)])))\n", "  (define (helper\
    \ operator operand result)\n    (if (null? operator)\n        result\n       \
    \ (helper (cdr operator) (cdr operand)\n                (cond\n              \
    \    ((string=? (car operator) \"+\") (+ result (car operand)))\n            \
    \      ((string=? (car operator) \"-\") (- result (car operand)))\n          \
    \        ((string=? (car operator) \"*\") (* result (car operand)))\n        \
    \          ((string=? (car operator) \"//\") (quotient result (car operand)))\n\
    \                  ((string=? (car operator) \"**\") (expt result (car operand)))))))\n\
    \  (helper operator operand (car operand)))\n", "  (let loop ([operator operator]\
    \ [operand operand] [result (car operand)])\n    (if (null? operator)\n      \
    \  result\n        (loop (cdr operator) (cdr operand)\n              (cond\n \
    \               [(equal? (car operator) '+)\n                 (+ result (car operand))]\n\
    \                [(equal? (car operator) '-)\n                 (- result (car\
    \ operand))]\n                [(equal? (car operator) '*)\n                 (*\
    \ result (car operand))]\n                [(equal? (car operator) '//)\n     \
    \            (quotient result (car operand))]\n                [(equal? (car operator)\
    \ '**)\n                 (expt result (car operand))])))))\n", "  (let* ([op (car\
    \ operator)]\n         [op1 (car operand)]\n         [op2 (cadr operand)])\n \
    \   (cond\n      [(equal? op '+) (+ op1 op2)]\n      [(equal? op '-) (- op1 op2)]\n\
    \      [(equal? op '*) (* op1 op2)]\n      [(equal? op '//) (quotient op1 op2)]\n\
    \      [(equal? op '**) (expt op1 op2)])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
