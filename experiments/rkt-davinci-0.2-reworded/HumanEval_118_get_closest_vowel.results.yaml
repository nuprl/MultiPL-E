name: HumanEval_118_get_closest_vowel
language: rkt
results:
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (is-consonant? c)\n\
    \    (not (is-vowel? c)))\n  (define (get-closest-vowel-helper word)\n    (if\
    \ (empty? word)\n        \"\"\n        (if (is-vowel? (first word))\n        \
    \    (if (is-consonant? (second word))\n                (string (first word))\n\
    \                (get-closest-vowel-helper (rest word)))\n            (get-closest-vowel-helper\
    \ (rest word)))))\n  (get-closest-vowel-helper (reverse word)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:41:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:42:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:43:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:44:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:45:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:46:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:47:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:48:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:49:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:50:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:51:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9bv26n6.rkt:52:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is-consonant? c)\n    (not (is-vowel? c)))\n  (define (get-closest-vowel-from-right\
    \ word)\n    (let loop ([word (string-reverse word)]\n               [prev-c #\\\
    ])\n               [prev-vowel #\\])\n      (if (string-empty? word)\n       \
    \   (string-reverse (string prev-vowel))\n          (let ([c (string-ref word\
    \ 0)])\n            (if (and (is-consonant? prev-c)\n                     (is-vowel?\
    \ c))\n                (loop (substring word 1) c c)\n                (loop (substring\
    \ word 1) c prev-vowel))))))\n  (get-closest-vowel-from-right word))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpb31ou8lm.rkt:24:26: read-syntax: missing `]` to close preceding\
    \ `[`, found instead `)`\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (get-closest-vowel-iter\
    \ word closest-vowel)\n    (cond\n      [(empty? word) closest-vowel]\n      [(member\
    \ (first word) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n       (get-closest-vowel-iter\
    \ (rest word) (first word))]\n      [else (get-closest-vowel-iter (rest word)\
    \ closest-vowel)]))\n  (get-closest-vowel-iter (reverse word) \"\"))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:38:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:39:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:40:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:41:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp74k_jl87.rkt:42:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (get-closest-vowel-iter\
    \ word i)\n    (cond\n      [(= i (string-length word)) \"\"]\n      [(and (char-vowel?\
    \ (string-ref word i)) (char-consonant? (string-ref word (- i 1)))) (string-ref\
    \ word i)]\n      [else (get-closest-vowel-iter word (+ i 1))]))\n  (get-closest-vowel-iter\
    \ word 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpbtgmnig8.rkt:21:13: char-vowel?: unbound identifier\n  in: char-vowel?\n\
    \  location...:\n   /tmp/tmpbtgmnig8.rkt:21:13\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (is-consonant? c)\n\
    \    (not (is-vowel? c)))\n  (define (get-closest-vowel-helper word)\n    (if\
    \ (or (null? word)\n            (null? (cdr word)))\n        \"\"\n        (if\
    \ (and (is-consonant? (car word))\n                 (is-vowel? (cadr word)))\n\
    \            (string (cadr word))\n            (get-closest-vowel-helper (cdr\
    \ word)))))\n  (get-closest-vowel-helper (string-&gt;list word)))\n</code>\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmphka9f1h7.rkt:34:28: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 35\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=?\
    \ c #\\u)))\n  (define (is-consonant? c)\n    (not (is-vowel? c)))\n  (define\
    \ (get-closest-vowel-helper word)\n    (cond [(empty? word) empty]\n         \
    \ [(is-vowel? (first word)) (first word)]\n          [(is-consonant? (first word))\
    \ (get-closest-vowel-helper (rest word))]))\n  (get-closest-vowel-helper (reverse\
    \ word)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:38:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:39:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:40:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:41:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:42:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:43:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfmcbf1sk.rkt:44:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is-consonant? c)\n    (not (is-vowel? c)))\n  (define (find-closest-vowel word)\n\
    \    (cond\n      [(empty? word) empty]\n      [(is-vowel? (first word)) (first\
    \ word)]\n      [(is-consonant? (first word)) (find-closest-vowel (rest word))]))\n\
    \  (find-closest-vowel (reverse word)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:38:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:39:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:40:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:41:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:42:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:43:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:44:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp45hwa8g5.rkt:45:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is-consonant? c)\n    (not (is-vowel? c)))\n  (define (find-closest-vowel word)\n\
    \    (let loop ([word (string-reverse word)]\n               [prev-is-consonant?\
    \ #f]\n               [prev-is-vowel? #f])\n      (cond [(empty? word) \"\"]\n\
    \            [(is-vowel? (first word))\n             (if prev-is-consonant?\n\
    \                 (string (first word))\n                 (loop (rest word) #f\
    \ #t))]\n            [(is-consonant? (first word))\n             (if prev-is-vowel?\n\
    \                 (string (first word))\n                 (loop (rest word) #t\
    \ #f))])))\n  (find-closest-vowel word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpvd6h27wf.rkt:23:22: string-reverse: unbound identifier\n  in: string-reverse\n\
    \  location...:\n   /tmp/tmpvd6h27wf.rkt:23:22\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (is-consonant? c)\n\
    \    (not (is-vowel? c)))\n  (define (find-closest-vowel word)\n    (if (or (empty?\
    \ word)\n            (empty? (rest word)))\n        \"\"\n        (if (and (is-consonant?\
    \ (first word))\n                 (is-vowel? (second word)))\n            (string\
    \ (second word))\n            (find-closest-vowel (rest word)))))\n  (find-closest-vowel\
    \ (reverse (string->list word))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnn_4i9tx.rkt:43:4\n\
    actual:     \"a\"\nexpected:   \"\"\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnn_4i9tx.rkt:44:4\nactual:\
    \     \"e\"\nexpected:   \"\"\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpnn_4i9tx.rkt:45:4\nactual:     \"\
    a\"\nexpected:   \"\"\n--------------------\n--------------------\nFAILURE\nname:\
    \       check-equal?\nlocation:   /tmp/tmpnn_4i9tx.rkt:48:4\nactual:     \"a\"\
    \nexpected:   \"\"\n--------------------\n--------------------\nFAILURE\nname:\
    \       check-equal?\nlocation:   /tmp/tmpnn_4i9tx.rkt:50:4\nactual:     \"i\"\
    \nexpected:   \"\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (let ([vowels (regexp-match*\
    \ #rx\"[aeiou]\" word)])\n    (if (empty? vowels)\n        \"\"\n        (let\
    \ ([consonants (regexp-match* #rx\"[^aeiou]\" word)])\n          (if (empty? consonants)\n\
    \              \"\"\n              (let ([last-consonant (last consonants)])\n\
    \                (let ([last-vowel (last vowels)])\n                  (if (&gt;\
    \ (string-length last-vowel) (string-length last-consonant))\n               \
    \       \"\"\n                      (string-ref last-vowel 0)))))))))\n</code>\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp89qm3sx3.rkt:17:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 29\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is-consonant? c)\n    (not (is-vowel? c)))\n  (define (find-closest-vowel word)\n\
    \    (if (or (null? word) (null? (cdr word)))\n        \"\"\n        (if (and\
    \ (is-consonant? (car word)) (is-vowel? (cadr word)))\n            (string (cadr\
    \ word))\n            (find-closest-vowel (cdr word)))))\n  (find-closest-vowel\
    \ word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:35:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:36:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:37:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:38:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:39:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:40:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:41:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:42:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:43:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:44:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:45:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0p5n7qt.rkt:46:4\n\
    \ncdr: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (is-consonant? c)\n\
    \    (not (is-vowel? c)))\n  (define (get-closest-vowel-from-right word)\n   \
    \ (if (or (null? word) (null? (cdr word)))\n        \"\"\n        (if (and (is-consonant?\
    \ (car word)) (is-vowel? (cadr word)))\n            (string (cadr word))\n   \
    \         (get-closest-vowel-from-right (cdr word)))))\n  (get-closest-vowel-from-right\
    \ (reverse (string->list word))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpvuoh_fzr.rkt:41:4\n\
    actual:     \"a\"\nexpected:   \"\"\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpvuoh_fzr.rkt:42:4\nactual:\
    \     \"e\"\nexpected:   \"\"\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpvuoh_fzr.rkt:43:4\nactual:     \"\
    a\"\nexpected:   \"\"\n--------------------\n--------------------\nFAILURE\nname:\
    \       check-equal?\nlocation:   /tmp/tmpvuoh_fzr.rkt:46:4\nactual:     \"a\"\
    \nexpected:   \"\"\n--------------------\n--------------------\nFAILURE\nname:\
    \       check-equal?\nlocation:   /tmp/tmpvuoh_fzr.rkt:48:4\nactual:     \"i\"\
    \nexpected:   \"\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (is-consonant? c)\n\
    \    (not (is-vowel? c)))\n  (define (find-closest-vowel word)\n    (if (or (null?\
    \ word) (null? (cdr word)))\n        \"\"\n        (if (and (is-consonant? (car\
    \ word))\n                 (is-vowel? (cadr word)))\n            (string (cadr\
    \ word))\n            (find-closest-vowel (cdr word)))))\n  (find-closest-vowel\
    \ (string-reverse word)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpw10_ef6z.rkt:33:23: string-reverse: unbound identifier\n  in: string-reverse\n\
    \  location...:\n   /tmp/tmpw10_ef6z.rkt:33:23\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is-consonant? c)\n    (not (is-vowel? c)))\n  (define (get-closest-vowel-helper\
    \ word)\n    (cond\n      [(empty? word) empty]\n      [(is-vowel? (first word))\
    \ (first word)]\n      [(is-consonant? (first word)) (get-closest-vowel-helper\
    \ (rest word))]))\n  (get-closest-vowel-helper (reverse word)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:38:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:39:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:40:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:41:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:42:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:43:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:44:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwhrmcd6.rkt:45:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is-consonant? c)\n    (not (is-vowel? c)))\n  (define (get-closest-vowel-helper\
    \ word)\n    (cond\n      [(empty? word) empty]\n      [(is-vowel? (first word))\
    \ (first word)]\n      [(is-consonant? (first word)) (get-closest-vowel-helper\
    \ (rest word))]))\n  (get-closest-vowel-helper (reverse word)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:38:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:39:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:40:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:41:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:42:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:43:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:44:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4126ck14.rkt:45:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is-consonant? c)\n    (not (is-vowel? c)))\n  (define (find-closest-vowel word)\n\
    \    (cond ((null? word) \"\")\n          ((and (is-vowel? (car word))\n     \
    \           (is-consonant? (cadr word)))\n           (car word))\n          (else\
    \ (find-closest-vowel (cdr word)))))\n  (find-closest-vowel word))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:40:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:41:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:42:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:43:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:44:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:45:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe8f0x2pi.rkt:46:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is_vowel? ch)\n\
    \    (member ch '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is_consonant? ch)\n    (not (is_vowel? ch)))\n  (define (find-closest-vowel\
    \ word)\n    (cond\n      [(empty? word) empty]\n      [(and (is_vowel? (first\
    \ word)) (is_consonant? (second word))) (first word)]\n      [else (find-closest-vowel\
    \ (rest word))]))\n  (find-closest-vowel word))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph5qaexp_.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph5qaexp_.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph5qaexp_.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph5qaexp_.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph5qaexp_.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph5qaexp_.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph5qaexp_.rkt:40:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph5qaexp_.rkt:41:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph5qaexp_.rkt:42:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph5qaexp_.rkt:43:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph5qaexp_.rkt:44:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is_vowel? c)\n\
    \    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is_consonant? c)\n    (not (is_vowel? c)))\n  (define (get-closest-vowel-helper\
    \ word)\n    (cond\n      [(empty? word) empty]\n      [(is_vowel? (first word))\
    \ (first word)]\n      [(is_consonant? (first word)) (get-closest-vowel-helper\
    \ (rest word))]))\n  (get-closest-vowel-helper (reverse word)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:38:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:39:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:40:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:41:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:42:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:43:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:44:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb5fizvi4.rkt:45:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define (is-vowel? c)\n\
    \    (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is-consonant? c)\n    (not (is-vowel? c)))\n  (define (find-closest-vowel word)\n\
    \    (cond\n      [(empty? word) empty]\n      [(is-vowel? (first word)) (first\
    \ word)]\n      [(is-consonant? (first word)) (find-closest-vowel (rest word))]))\n\
    \  (define (find-closest-consonant word)\n    (cond\n      [(empty? word) empty]\n\
    \      [(is-consonant? (first word)) (first word)]\n      [(is-vowel? (first word))\
    \ (find-closest-consonant (rest word))]))\n  (cond\n    [(empty? word) empty]\n\
    \    [(is-vowel? (first word)) empty]\n    [(is-consonant? (first word))\n   \
    \  (cond\n       [(empty? (rest word)) empty]\n       [(is-vowel? (second word))\
    \ (second word)]\n       [(is-consonant? (second word))\n        (cond\n     \
    \     [(empty? (rest (rest word))) empty]\n          [(is-vowel? (third word))\
    \ (third word)]\n          [(is-consonant? (third word))\n           (cond\n \
    \            [(empty? (rest (rest (rest word)))) empty]\n             [(is-vowel?\
    \ (fourth word)) (fourth word)]\n             [(is-consonant? (fourth word))\n\
    \              (cond\n                [(empty? (rest (rest (rest (rest word)))))\
    \ empty]\n                [(is-vowel? (fifth word)) (fifth word)]\n          \
    \      [(is-consonant? (fifth word))\n                 (cond\n               \
    \    [(empty? (rest (rest (rest (rest (rest word)))))) empty]\n              \
    \     [(is-vowel? (sixth word)) (sixth word)]\n                   [(is-consonant?\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpwpa1fhlk.rkt:55:20: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 56\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; >>> (get_closest_vowel \"yogurt\")\n;; \"u\"\n;; >>> (get_closest_vowel \"\
    FULL\")\n;; \"U\"\n;; >>> (get_closest_vowel \"quick\")\n;; \"\"\n;; >>> (get_closest_vowel\
    \ \"ab\")\n;; \"\"\n(define (get_closest_vowel word)\n  (define vowels '(#\\a\
    \ #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define (is-vowel? c)\n  \
    \  (member c vowels))\n  (define (is-consonant? c)\n    (not (is-vowel? c)))\n\
    \  (define (is-consonant-vowel-consonant? word)\n    (and (is-consonant? (string-ref\
    \ word 0))\n         (is-vowel? (string-ref word 1))\n         (is-consonant?\
    \ (string-ref word 2))))\n  (define (is-consonant-vowel? word)\n    (and (is-consonant?\
    \ (string-ref word 0))\n         (is-vowel? (string-ref word 1))))\n  (define\
    \ (is-vowel-consonant? word)\n    (and (is-vowel? (string-ref word 0))\n     \
    \    (is-consonant? (string-ref word 1))))\n  (define (is-consonant-vowel-consonant-vowel?\
    \ word)\n    (and (is-consonant? (string-ref word 0))\n         (is-vowel? (string-ref\
    \ word 1))\n         (is-consonant? (string-ref word 2))\n         (is-vowel?\
    \ (string-ref word 3))))\n  (define (is-consonant-vowel-consonant-vowel-consonant?\
    \ word)\n    (and (is-consonant? (string-ref word 0))\n         (is-vowel? (string-ref\
    \ word 1))\n         (is-consonant? (string-ref word 2))\n         (is-vowel?\
    \ (string-ref word 3))\n         (is-consonant? (string-ref word 4))))\n  (cond\n\
    \    [(is-consonant-vowel-consonant? word) (string-ref word 1)]\n    [(is-vowel-consonant?\
    \ word) (string-ref word 0)]\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpqqrchh6r.rkt:44:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 47\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: Exception
