name: HumanEval_147_get_max_triples
language: rkt
prompt: "#lang racket\n\n;; You are given a positive integer n. You have to create\
  \ an integer list a of length n.\n;; For each i (1 \u2264 i \u2264 n), the value\
  \ of a[i] = i * i - i + 1.\n;; Return the number of triples (a[i], a[j], a[k]) of\
  \ a where i < j < k, \n;; and a[i] + a[j] + a[k] is a multiple of 3.\n;; Example\
  \ :\n;; >>> (get_max_triples 5)\n;; 1\n;; Explanation: \n;; a = [1, 3, 7, 13, 21]\n\
  ;; The only valid triple is (1, 7, 13).\n(define (get_max_triples n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_max_triples))\n\
  \    (check-equal? (candidate 5) 1)\n    (check-equal? (candidate 6) 4)\n    (check-equal?\
  \ (candidate 10) 36)\n    (check-equal? (candidate 100) 53361)\n))\n\n(test-humaneval)"
completions: ["  (define (triples lst)\n    (cond [(empty? lst) 0]\n          [(and\
    \ (empty? (rest lst)) (empty? (rest (rest lst)))) 0]\n          [(and (empty?\
    \ (rest (rest lst))) (zero? (modulo (+ (first lst) (second lst) (third lst)) 3)))\
    \ 1]\n          [(zero? (modulo (+ (first lst) (second lst) (third lst)) 3)) (+\
    \ 1 (triples (rest lst)))]\n          [else (triples (rest lst))]))\n  (triples\
    \ (build-list n (lambda (x) (+ (* x x) (- x 1))))))\n", "  (define (helper a i)\n\
    \    (if (= i n)\n        0\n        (let ((a-i (+ (* i i) (- i))))\n        \
    \  (define (helper2 a j)\n            (if (= j n)\n                0\n       \
    \         (let ((a-j (+ (* j j) (- j))))\n                  (define (helper3 a\
    \ k)\n                    (if (= k n)\n                        0\n           \
    \             (let ((a-k (+ (* k k) (- k))))\n                          (if (and\
    \ (< i j) (< j k) (= (modulo (+ a-i a-j a-k) 3) 0))\n                        \
    \      (+ 1 (helper3 a (+ k 1)))\n                              (helper3 a (+\
    \ k 1))))))\n                  (+ (helper3 a (+ j 1)) (helper2 a (+ j 1))))))\n\
    \          (+ (helper2 a (+ i 1)) (helper a (+ i 1))))))\n  (helper '() 1))\n",
  "  (let ([a (for/list ([i (in-range 1 (+ n 1))])\n                     (- (* i i)\
    \ i 1))])\n    (for/sum ([i (in-range 1 (- n 2))]\n              [j (in-range\
    \ (+ i 1) (- n 1))]\n              [k (in-range (+ j 1) n)])\n      (if (zero?\
    \ (modulo (+ (list-ref a i)\n                            (list-ref a j)\n    \
    \                        (list-ref a k))\n                       3))\n       \
    \   1\n          0))))\n", "  (let loop ([i 1] [j 2] [k 3] [count 0])\n    (cond\
    \ [(>= i n) count]\n          [(>= j n) (loop (+ i 1) (+ i 2) (+ i 3) count)]\n\
    \          [(>= k n) (loop i (+ j 1) (+ j 2) count)]\n          [else (loop i\
    \ j (+ k 1) (if (and (zero? (modulo (+ (expt i 2) (- i 1)) 3))\n             \
    \                              (zero? (modulo (+ (expt j 2) (- j 1)) 3))\n   \
    \                                        (zero? (modulo (+ (expt k 2) (- k 1))\
    \ 3)))\n                                      (+ count 1)\n                  \
    \                    count))])))\n", "  (define (get-triples lst)\n    (cond [(empty?\
    \ lst) 0]\n          [(empty? (rest lst)) 0]\n          [(empty? (rest (rest lst)))\
    \ 0]\n          [else (+ (get-triples (rest lst))\n                   (get-triples\
    \ (rest (rest lst)))\n                   (get-triples (rest (rest (rest lst))))\n\
    \                   (if (zero? (modulo (+ (first lst) (second lst) (third lst))\
    \ 3)) 1 0))]))\n  (get-triples (build-list n (lambda (x) (+ (* x x) (- x 1))))))\n",
  "  (define (helper n a)\n    (if (= n 0)\n        a\n        (helper (- n 1) (cons\
    \ (+ (* n n) (- n 1)) a))))\n  (define (sum-triples a)\n    (define (helper a\
    \ i j k)\n      (if (= j k)\n          0\n          (if (= (modulo (+ (list-ref\
    \ a i) (list-ref a j) (list-ref a k)) 3) 0)\n              (+ 1 (helper a i (+\
    \ j 1) (+ k 1)))\n              (helper a i (+ j 1) (+ k 1)))))\n    (define (helper2\
    \ a i)\n      (if (= i (- (length a) 2))\n          0\n          (+ (helper a\
    \ i (+ i 1) (+ i 2)) (helper2 a (+ i 1)))))\n    (helper2 a 0))\n  (sum-triples\
    \ (helper n '())))\n", "  (define (sum-of-triple lst)\n    (cond [(empty? lst)\
    \ 0]\n          [(= (length lst) 3) (+ (car lst) (cadr lst) (caddr lst))]\n  \
    \        [else (sum-of-triple (cdr lst))]))\n  (define (get-triples lst)\n   \
    \ (cond [(empty? lst) 0]\n          [(= (length lst) 3) (if (= (modulo (sum-of-triple\
    \ lst) 3) 0) 1 0)]\n          [else (+ (get-triples (cdr lst)) (get-triples (cddr\
    \ lst)))]))\n  (get-triples (build-list n (lambda (x) (+ (* x x) (- x 1))))))\n",
  "  (define (sum-of-triple a b c)\n    (+ a b c))\n  (define (is-multiple-of-3? n)\n\
    \    (= (remainder n 3) 0))\n  (define (is-valid-triple? a b c)\n    (and (< a\
    \ b c)\n         (is-multiple-of-3? (sum-of-triple a b c))))\n  (define (get-triples\
    \ lst)\n    (for/list ([a lst]\n               [b (in-list lst (\u03BB (x) (<\
    \ x a)))]\n               [c (in-list lst (\u03BB (x) (< x b)))]\n           \
    \    #:when (is-valid-triple? a b c))\n      (list a b c)))\n  (length (get-triples\
    \ (build-list n (\u03BB (x) (+ (* x x) x -1)))))\n)\n", "  (define (get-triples\
    \ lst)\n    (define (get-triples-aux lst acc)\n      (if (null? lst)\n       \
    \   acc\n          (get-triples-aux (cdr lst) (cons (list (car lst) (cadr lst)\
    \ (caddr lst)) acc))))\n    (get-triples-aux lst '()))\n  (define (is-multiple-of-3?\
    \ n)\n    (= (modulo n 3) 0))\n  (define (sum-triple lst)\n    (apply + lst))\n\
    \  (define (filter-triples lst)\n    (filter (lambda (lst) (is-multiple-of-3?\
    \ (sum-triple lst))) lst))\n  (length (filter-triples (get-triples (build-list\
    \ n (lambda (i) (+ (* i i) (- i 1))))))))\n", "  (define (get-a-i i)\n    (+ (*\
    \ i i) (- i 1)))\n  (define (get-triples a)\n    (define (get-triples-helper a\
    \ i j k)\n      (cond\n        [(= i (- n 2)) 0]\n        [(= j (- n 1)) (get-triples-helper\
    \ a (+ i 1) (+ i 2) (+ i 3))]\n        [(= k n) (get-triples-helper a i (+ j 1)\
    \ (+ j 2))]\n        [else (if (and (< i j) (< j k) (= (modulo (+ (list-ref a\
    \ i) (list-ref a j) (list-ref a k)) 3) 0))\n                 (+ 1 (get-triples-helper\
    \ a i j (+ k 1)))\n                 (get-triples-helper a i j (+ k 1)))]))\n \
    \   (get-triples-helper a 0 1 2))\n  (get-triples (build-list n get-a-i)))\n",
  "  (define (get-a-i i)\n    (+ (* i i) (- i) 1))\n  (define (get-triples i j k)\n\
    \    (define (get-sum a b c)\n      (+ a b c))\n    (if (and (< i j) (< j k))\n\
    \        (if (zero? (modulo (get-sum (get-a-i i) (get-a-i j) (get-a-i k)) 3))\n\
    \            1\n            0)\n        0))\n  (define (get-triples-sum i j k)\n\
    \    (if (< i j)\n        (if (< j k)\n            (get-triples i j k)\n     \
    \       (get-triples-sum i j (+ k 1)))\n        (get-triples-sum i (+ j 1) (+\
    \ k 1))))\n  (get-triples-sum 1 1 1))\n", "  (define (helper i acc)\n    (if (=\
    \ i n)\n        acc\n        (helper (+ i 1) (+ acc (get-triples i)))))\n  (helper\
    \ 1 0))\n", "  (define (get-triples lst)\n    (define (get-triples-helper lst\
    \ acc)\n      (if (null? lst)\n          acc\n          (get-triples-helper (cdr\
    \ lst) (cons (list (car lst) (cadr lst) (caddr lst)) acc))))\n    (get-triples-helper\
    \ lst '()))\n  (define (is-multiple-of-3? n)\n    (= (modulo n 3) 0))\n  (define\
    \ (sum-of-triple lst)\n    (apply + lst))\n  (define (is-valid-triple? lst)\n\
    \    (and (< (car lst) (cadr lst))\n         (< (cadr lst) (caddr lst))\n    \
    \     (is-multiple-of-3? (sum-of-triple lst))))\n  (define (get-valid-triples\
    \ lst)\n    (filter is-valid-triple? lst))\n  (define (get-a n)\n    (for/list\
    \ ([i (in-range 1 (+ n 1))])\n      (- (* i i) i 1)))\n  (define (get-triples-of-a\
    \ n)\n    (get-triples (get-a n)))\n  (length (get-valid-triples (get-triples-of-a\
    \ n))))\n", "  (define (helper i a)\n    (if (= i n)\n        (count-triples a)\n\
    \        (helper (+ i 1) (append a (list (- (* i i) i 1))))))\n  (helper 1 '()))\n",
  "  (let ([a (for/list ([i (in-range 1 (+ n 1))])\n                     (* i (- i\
    \ 1) 1))])\n    (for/sum ([i (in-range 0 (- n 2))]\n              [j (in-range\
    \ (+ i 1) (- n 1))]\n              [k (in-range (+ j 1) n)])\n      (if (and (zero?\
    \ (modulo (+ (list-ref a i)\n                                 (list-ref a j)\n\
    \                                 (list-ref a k))\n                        3))\n\
    \               (< i j k))\n          1\n          0))))\n", "  (define (get-triples\
    \ lst)\n    (cond [(null? lst) 0]\n          [(null? (cdr lst)) 0]\n         \
    \ [(null? (cddr lst)) 0]\n          [else (+ (if (zero? (modulo (+ (car lst) (cadr\
    \ lst) (caddr lst)) 3)) 1 0)\n                  (get-triples (cdr lst)))]))\n\
    \  (get-triples (for/list ([i (in-range 1 (+ 1 n))])\n                 (- (* i\
    \ i) i 1))))\n", "  (let ([a (build-list n (\u03BB (i) (+ (* i i) (- i 1))))])\n\
    \    (for/fold ([count 0]) ([i (in-range (add1 n))] [j (in-range (add1 n))] [k\
    \ (in-range (add1 n))])\n      (if (and (< i j) (< j k) (zero? (modulo (+ (list-ref\
    \ a i) (list-ref a j) (list-ref a k)) 3)))\n          (add1 count)\n         \
    \ count))))\n", "  (define (triples lst)\n    (define (helper lst acc)\n     \
    \ (if (null? lst)\n          acc\n          (helper (cdr lst) (cons (list (car\
    \ lst) (cadr lst) (caddr lst)) acc))))\n    (helper lst '()))\n  (define (is_multiple_of_3?\
    \ n)\n    (= (modulo n 3) 0))\n  (define (is_valid? triple)\n    (and (not (null?\
    \ triple))\n         (is_multiple_of_3? (+ (car triple) (cadr triple) (caddr triple)))))\n\
    \  (define (is_valid_triple? triple)\n    (and (not (null? triple))\n        \
    \ (is_valid? (car triple))\n         (is_valid? (cadr triple))\n         (is_valid?\
    \ (caddr triple))))\n  (define (is_valid_triples? triples)\n    (and (not (null?\
    \ triples))\n         (is_valid_triple? (car triples))\n         (is_valid_triples?\
    \ (cdr triples))))\n  (define (count_valid_triples triples)\n    (if (null? triples)\n\
    \        0\n        (+ 1 (count_valid_triples (cdr triples)))))\n  (define (get_max_triples_helper\
    \ n)\n    (define (helper n acc)\n      (if (= n 0)\n          acc\n         \
    \ (helper (- n 1) (cons (+ 1 (* n (- n 1))) acc))))\n    (helper n '()))\n  (count_valid_triples\
    \ (triples (get_max_triples_helper n))))\n", "  (define (get-triples a)\n    (for/fold\
    \ ([count 0]) ([i (in-range (add1 (quotient n 2)))])\n      (for/fold ([count\
    \ count]) ([j (in-range (add1 i) n)])\n        (for/fold ([count count]) ([k (in-range\
    \ (add1 j) n)])\n          (if (and (zero? (modulo (+ (list-ref a i) (list-ref\
    \ a j) (list-ref a k)) 3))\n                   (not (zero? (+ (list-ref a i) (list-ref\
    \ a j) (list-ref a k)))))\n              (add1 count)\n              count)))))\n\
    \  (get-triples (for/list ([i (in-range n)])\n                 (+ (* i i) (- i\
    \ 1)))))\n", "  (define (get-triples lst)\n    (cond\n      [(empty? lst) empty]\n\
    \      [(empty? (rest lst)) empty]\n      [(empty? (rest (rest lst))) empty]\n\
    \      [else (cons (list (first lst) (second lst) (third lst))\n             \
    \     (get-triples (rest lst)))]))\n  (define (is-triple? lst)\n    (define (sum-triple\
    \ lst)\n      (cond\n        [(empty? lst) 0]\n        [else (+ (first lst) (sum-triple\
    \ (rest lst)))]))\n    (define (is-multiple-of-3? n)\n      (= (modulo n 3) 0))\n\
    \    (is-multiple-of-3? (sum-triple lst)))\n  (define (filter-triples lst)\n \
    \   (cond\n      [(empty? lst) empty]\n      [(is-triple? (first lst)) (cons (first\
    \ lst) (filter-triples (rest lst)))]\n      [else (filter-triples (rest lst))]))\n\
    \  (define (count-triples lst)\n    (cond\n      [(empty? lst) 0]\n      [else\
    \ (+ 1 (count-triples (rest lst)))]))\n  (count-triples (filter-triples (get-triples\
    \ (build-list n (lambda (x) (+ (* x x) (- x 1))))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
