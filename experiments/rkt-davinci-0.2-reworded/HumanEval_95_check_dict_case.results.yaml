name: HumanEval_95_check_dict_case
language: rkt
results:
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict)) (hash-ref dict (hash-key dict))))\n     (check_dict_case\
    \ (hash-remove dict (hash-key dict)))]\n    [else #f]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpyz6rkib8.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmpyz6rkib8.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (if (empty? dict)\n      #f\n      (let\
    \ ([keys (hash-keys dict)])\n        (if (andmap string? keys)\n            (let\
    \ ([first-key (first keys)])\n              (andmap (lambda (key)\n          \
    \              (if (string-ci=? first-key key)\n                            #t\n\
    \                            #f))\n                      keys))\n            #f))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n\
    \    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"\
    ))) #t)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .\
    \  \"banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal? (candidate #hash((\"\
    p\" .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"\
    Houston\"))) #f)\n    (check-equal? (candidate #hash((\"STATE\" .  \"NC\") (\"\
    ZIP\" .  \"12345\"))) #t)\n    (check-equal? (candidate #hash((\"fruit\" .  \"\
    Orange\") (\"taste\" .  \"Sweet\"))) #t)\n    (check-equal? (candidate #hash())\
    \ #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_gi7kuop.rkt:35:4\n\
    actual:     #f\nexpected:   #t\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp_gi7kuop.rkt:39:4\nactual:     #f\n\
    expected:   #t\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp_gi7kuop.rkt:40:4\nactual:     #f\nexpected:\
    \   #t\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_gi7kuop.rkt:41:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: '()\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict)) (hash-ref dict (hash-key dict))))\n     (check_dict_case\
    \ (hash-remove dict (hash-key dict)))]\n    [else #f]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9mptvxd6.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmp9mptvxd6.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict)) (hash-ref dict (hash-key dict))))\n     (check_dict_case\
    \ (hash-remove dict (hash-key dict)))]\n    [else #f]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp_ztucu49.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmp_ztucu49.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict))\n                       (string-upcase (hash-ref dict\
    \ (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key dict)))]\n\
    \    [(and (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict))\n                       (string-downcase (hash-ref dict\
    \ (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key dict)))]\n\
    \    [else #f]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate check_dict_case))\n    (check-equal? (candidate #hash((\"p\" .\
    \  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal? (candidate #hash((\"\
    p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"\
    ))) #f)\n    (check-equal? (candidate #hash((\"Name\" .  \"John\") (\"Age\" .\
    \  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal? (candidate #hash((\"\
    STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal? (candidate\
    \ #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n    (check-equal?\
    \ (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpf03xo18w.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmpf03xo18w.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict)) (hash-ref dict (hash-key dict))))\n     (check_dict_case\
    \ (hash-remove dict (hash-key dict)))]\n    [else #f]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp00xqkfsk.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmp00xqkfsk.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict)) (hash-ref dict (hash-key dict))))\n     (check_dict_case\
    \ (hash-remove dict (hash-key dict)))]\n    [else #f]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpd7u2mgxu.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmpd7u2mgxu.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (if (hash-empty? dict)\n      #f\n  \
    \    (let ([keys (hash-keys dict)])\n        (if (andmap string? keys)\n     \
    \       (let ([first-key (car keys)])\n              (andmap (lambda (key)\n \
    \                       (if (string-ci=? first-key key)\n                    \
    \        #t\n                            #f))\n                      keys))\n\
    \            #f))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate check_dict_case))\n    (check-equal? (candidate #hash((\"p\" .\
    \  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal? (candidate #hash((\"\
    p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"\
    ))) #f)\n    (check-equal? (candidate #hash((\"Name\" .  \"John\") (\"Age\" .\
    \  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal? (candidate #hash((\"\
    STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal? (candidate\
    \ #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n    (check-equal?\
    \ (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpiutltyaz.rkt:35:4\n\
    actual:     #f\nexpected:   #t\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpiutltyaz.rkt:39:4\nactual:     #f\n\
    expected:   #t\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpiutltyaz.rkt:40:4\nactual:     #f\nexpected:\
    \   #t\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (if (hash-empty? dict)\n      #f\n  \
    \    (let ([keys (hash-keys dict)])\n        (if (andmap string? keys)\n     \
    \       (let ([first-key (car keys)])\n              (andmap (lambda (key)\n \
    \                       (if (string-ci=? first-key key)\n                    \
    \        #t\n                            #f))\n                      keys))\n\
    \            #f))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate check_dict_case))\n    (check-equal? (candidate #hash((\"p\" .\
    \  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal? (candidate #hash((\"\
    p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"\
    ))) #f)\n    (check-equal? (candidate #hash((\"Name\" .  \"John\") (\"Age\" .\
    \  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal? (candidate #hash((\"\
    STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal? (candidate\
    \ #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n    (check-equal?\
    \ (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4trur1vx.rkt:35:4\n\
    actual:     #f\nexpected:   #t\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp4trur1vx.rkt:39:4\nactual:     #f\n\
    expected:   #t\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp4trur1vx.rkt:40:4\nactual:     #f\nexpected:\
    \   #t\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (define (check-keys dict)\n    (cond\
    \ ((empty? dict) #t)\n          ((and (string? (key dict)) (string-ci=? (key dict)\
    \ (key dict))) (check-keys (rest dict)))\n          (else #f)))\n  (check-keys\
    \ dict))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ check_dict_case))\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\"\
    ) (\"b\" .  \"banana\"))) #t)\n    (check-equal? (candidate #hash((\"p\" .  \"\
    pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"\
    ))) #f)\n    (check-equal? (candidate #hash((\"Name\" .  \"John\") (\"Age\" .\
    \  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal? (candidate #hash((\"\
    STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal? (candidate\
    \ #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n    (check-equal?\
    \ (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpq48j7tcp.rkt:20:26: key: unbound identifier\n  in: key\n  location...:\n\
    \   /tmp/tmpq48j7tcp.rkt:20:26\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict)) (hash-ref dict (hash-key dict))))\n     (check_dict_case\
    \ (hash-remove dict (hash-key dict)))]\n    [else #f]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpp9fudlad.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmpp9fudlad.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (define (check-key key)\n    (string-ci=?\
    \ (string-upcase key) key))\n  (define (check-keys keys)\n    (cond [(empty? keys)\
    \ #t]\n          [(check-key (first keys)) (check-keys (rest keys))]\n       \
    \   [else #f]))\n  (check-keys (hash-keys dict)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqiap2kpi.rkt:32:4\n\
    actual:     #t\nexpected:   #f\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpqiap2kpi.rkt:33:4\n\nstring-upcase:\
    \ contract violation\n  expected: string?\n  given: 5\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqiap2kpi.rkt:34:4\n\
    actual:     #t\nexpected:   #f\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpqiap2kpi.rkt:37:4\nactual:     #t\n\
    expected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict))\n                       (string-upcase (hash-ref dict\
    \ (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key dict)))]\n\
    \    [(and (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict))\n                       (string-downcase (hash-ref dict\
    \ (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key dict)))]\n\
    \    [else #f]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate check_dict_case))\n    (check-equal? (candidate #hash((\"p\" .\
    \  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal? (candidate #hash((\"\
    p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"\
    ))) #f)\n    (check-equal? (candidate #hash((\"Name\" .  \"John\") (\"Age\" .\
    \  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal? (candidate #hash((\"\
    STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal? (candidate\
    \ #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n    (check-equal?\
    \ (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp99qycmz0.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmp99qycmz0.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (define (check-key key)\n    (cond\n\
    \      [(string? key)\n       (string-ci=? key (string-downcase key))]\n     \
    \ [(symbol? key)\n       (string-ci=? (symbol->string key) (string-downcase (symbol->string\
    \ key)))]\n      [else\n       #f]))\n  (define (check-keys keys)\n    (cond\n\
    \      [(empty? keys)\n       #t]\n      [(check-key (first keys))\n       (check-keys\
    \ (rest keys))]\n      [else\n       #f]))\n  (check-keys (hash-keys dict)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n\
    \    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"\
    ))) #t)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .\
    \  \"banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal? (candidate #hash((\"\
    p\" .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"\
    Houston\"))) #f)\n    (check-equal? (candidate #hash((\"STATE\" .  \"NC\") (\"\
    ZIP\" .  \"12345\"))) #t)\n    (check-equal? (candidate #hash((\"fruit\" .  \"\
    Orange\") (\"taste\" .  \"Sweet\"))) #t)\n    (check-equal? (candidate #hash())\
    \ #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp9533h6ve.rkt:42:4\n\
    actual:     #t\nexpected:   #f\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp9533h6ve.rkt:44:4\nactual:     #t\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp9533h6ve.rkt:47:4\nactual:     #t\nexpected:\
    \   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (define (check-key key)\n    (and (string?\
    \ key)\n         (or (string-ci=? key (string-downcase key))\n             (string-ci=?\
    \ key (string-upcase key)))))\n  (define (check-keys dict)\n    (cond ((hash-empty?\
    \ dict) #t)\n          ((check-key (hash-key dict))\n           (check-keys (hash-rest\
    \ dict)))\n          (else #f)))\n  (check-keys dict))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp0j7ahyd9.rkt:24:23: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmp0j7ahyd9.rkt:24:23\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (if (hash-empty? dict)\n      #f\n  \
    \    (let ([keys (hash-keys dict)])\n        (if (andmap string? keys)\n     \
    \       (let ([lower (map string-downcase keys)]\n                  [upper (map\
    \ string-upcase keys)])\n              (if (equal? keys lower)\n             \
    \     #t\n                  (if (equal? keys upper)\n                      #t\n\
    \                      #f)))\n            #f))))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict))\n                       (string-upcase (hash-ref dict\
    \ (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key dict)))]\n\
    \    [(and (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict))\n                       (string-downcase (hash-ref dict\
    \ (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key dict)))]\n\
    \    [else #f]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate check_dict_case))\n    (check-equal? (candidate #hash((\"p\" .\
    \  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal? (candidate #hash((\"\
    p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"\
    ))) #f)\n    (check-equal? (candidate #hash((\"Name\" .  \"John\") (\"Age\" .\
    \  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal? (candidate #hash((\"\
    STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal? (candidate\
    \ #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n    (check-equal?\
    \ (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfzwdj1hl.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmpfzwdj1hl.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(andmap\
    \ string? (hash-keys dict)) #t]\n    [(andmap string-upcase? (hash-keys dict))\
    \ #t]\n    [else #f]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate check_dict_case))\n    (check-equal? (candidate #hash((\"\
    p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal? (candidate\
    \ #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\")))\
    \ #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5 .  \"banana\"\
    ) (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"Name\" . \
    \ \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmphind4s_p.rkt:21:13: string-upcase?: unbound identifier\n  in: string-upcase?\n\
    \  location...:\n   /tmp/tmphind4s_p.rkt:21:13\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict)) (hash-ref dict (hash-key dict))))\n     (check_dict_case\
    \ (hash-remove dict (hash-key dict)))]\n    [else #f]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"\
    banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (5\
    \ .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal? (candidate #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal?\
    \ (candidate #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n\
    \    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpx87ry5h7.rkt:20:35: hash-key: unbound identifier\n  in: hash-key\n\
    \  location...:\n   /tmp/tmpx87ry5h7.rkt:20:35\n"
  exit_code: 1
  status: Exception
- program: "#lang racket\n\n;; Given a hash, return #t if all keys are strings in\
    \ lower \n;; case or all keys are strings in upper case, else return #f.\n;; The\
    \ function should return #f is the given hash is empty.\n;; Examples:\n;; >>>\
    \ (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
    ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
    \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\")\
    \ (8 .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
    Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;;\
    \ >>> (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n\
    ;; #t\n(define (check_dict_case dict)\n  (define (is-upper? str)\n    (and (string?\
    \ str)\n         (not (string-contains str #\\a))\n         (not (string-contains\
    \ str #\\b))\n         (not (string-contains str #\\c))\n         (not (string-contains\
    \ str #\\d))\n         (not (string-contains str #\\e))\n         (not (string-contains\
    \ str #\\f))\n         (not (string-contains str #\\g))\n         (not (string-contains\
    \ str #\\h))\n         (not (string-contains str #\\i))\n         (not (string-contains\
    \ str #\\j))\n         (not (string-contains str #\\k))\n         (not (string-contains\
    \ str #\\l))\n         (not (string-contains str #\\m))\n         (not (string-contains\
    \ str #\\n))\n         (not (string-contains str #\\o))\n         (not (string-contains\
    \ str #\\p))\n         (not (string-contains str #\\q))\n         (not (string-contains\
    \ str #\\r))\n         (not (string-contains str #\\s))\n         (not (string-contains\
    \ str #\\t))\n         (not (string-contains str #\\u))\n         (not (string-contains\
    \ str #\\v))\n         (not (string-contains str #\\w))\n         (not (string-contains\
    \ str #\\x))\n         (not (string-contains str #\\y))\n         (not (string-contains\
    \ str #\\z))))\n  (define (is-lower? str)\n    (and (string? str)\n         (not\
    \ (string-contains str #\\A))\n         (not (string-contains str #\\B))\n   \
    \      (not (string-contains str #\\C))\n         (not (string-contains str #\\\
    D))\n         (not (string-contains str #\\E))\n         (not (string-contains\
    \ str #\\F))\n         (not (string-contains str #\\G))\n         (not (string-contains\
    \ str\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ check_dict_case))\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\"\
    ) (\"b\" .  \"banana\"))) #t)\n    (check-equal? (candidate #hash((\"p\" .  \"\
    pineapple\") (\"A\" .  \"banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal?\
    \ (candidate #hash((\"p\" .  \"pineapple\") (5 .  \"banana\") (\"a\" .  \"apple\"\
    ))) #f)\n    (check-equal? (candidate #hash((\"Name\" .  \"John\") (\"Age\" .\
    \  \"36\") (\"City\" .  \"Houston\"))) #f)\n    (check-equal? (candidate #hash((\"\
    STATE\" .  \"NC\") (\"ZIP\" .  \"12345\"))) #t)\n    (check-equal? (candidate\
    \ #hash((\"fruit\" .  \"Orange\") (\"taste\" .  \"Sweet\"))) #t)\n    (check-equal?\
    \ (candidate #hash()) #f)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpjb41aklb.rkt:55:14: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 56\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: Exception
