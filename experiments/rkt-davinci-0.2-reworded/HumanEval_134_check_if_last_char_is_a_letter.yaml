name: HumanEval_134_check_if_last_char_is_a_letter
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns #t if the last character\n\
  ;; of a given string is an alphabetical character and is not\n;; a part of a word,\
  \ and #f otherwise.\n;; Note: \"word\" is a group of characters separated by space.\n\
  ;; Examples:\n;; >>> (check_if_last_char_is_a_letter \"apple pie\")\n;; #f\n;; >>>\
  \ (check_if_last_char_is_a_letter \"apple pi e\")\n;; #t\n;; >>> (check_if_last_char_is_a_letter\
  \ \"apple pi e \")\n;; #f\n;; >>> (check_if_last_char_is_a_letter \"\")\n;; #f\n\
  (define (check_if_last_char_is_a_letter txt)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n\
  \    (check-equal? (candidate \"apple\") #f)\n    (check-equal? (candidate \"apple\
  \ pi e\") #t)\n    (check-equal? (candidate \"eeeee\") #f)\n    (check-equal? (candidate\
  \ \"A\") #t)\n    (check-equal? (candidate \"Pumpkin pie \") #f)\n    (check-equal?\
  \ (candidate \"Pumpkin pie 1\") #f)\n    (check-equal? (candidate \"\") #f)\n  \
  \  (check-equal? (candidate \"eeeee e \") #f)\n    (check-equal? (candidate \"apple\
  \ pie\") #f)\n    (check-equal? (candidate \"apple pi e \") #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n\
    \     (if (char-whitespace? (second-last-char txt))\n         #t\n         #f)]\n\
    \    [else #f]))\n", "  (define (is_letter? c)\n    (and (char-alphabetic? c)\
    \ (not (char-whitespace? c))))\n  (and (not (string-null? txt))\n       (is_letter?\
    \ (string-ref txt (- (string-length txt) 1)))))\n", "  (if (string=? txt \"\"\
    )\n      #f\n      (if (string-contains txt #\\ )\n          (check_if_last_char_is_a_letter\
    \ (string-drop-right txt 1))\n          (if (char-alphabetic? (string-ref txt\
    \ (- (string-length txt) 1)))\n              #t\n              #f))))\n", "  (cond\n\
    \    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (cond\n\
    \       [(empty? (rest txt)) #t]\n       [(char-alphabetic? (last-char (rest txt)))\
    \ #f]\n       [else #t])]\n    [else #f]))\n", "  (cond\n    [(empty? txt) #f]\n\
    \    [(and (char-alphabetic? (last txt))\n          (not (char-alphabetic? (last\
    \ (butlast txt))))) #t]\n    [else #f]))\n", "  (if (string=? \"\" txt)\n    \
    \  #f\n      (let ([last-char (string-ref txt (- (string-length txt) 1))])\n \
    \       (and (char-alphabetic? last-char)\n             (not (char-whitespace?\
    \ last-char))))))\n", "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic?\
    \ (last-char txt))\n     (if (char-whitespace? (second-last-char txt))\n     \
    \    #t\n         #f)]\n    [else #f]))\n", "  (cond\n    [(empty? txt) #f]\n\
    \    [(char-alphabetic? (last-char txt))\n     (if (char-whitespace? (second-last-char\
    \ txt))\n         #t\n         #f)]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ txt) #f]\n    [(char-alphabetic? (last-char txt)) (and (char-alphabetic? (last-char\
    \ txt)) (not (char-whitespace? (second-last-char txt))))]\n    [else #f]))\n",
  "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (and\
    \ (not (char-alphabetic? (last-char (butlast txt))))\n          (not (char-whitespace?\
    \ (last-char (butlast txt)))))\n     ]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (cond\n       [(empty?\
    \ (string-drop-right txt 1)) #t]\n       [(char-alphabetic? (last-char (string-drop-right\
    \ txt 1))) #f]\n       [else #t])]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (and (not (char-alphabetic?\
    \ (last-char (substring txt 0 (- (string-length txt) 1)))))\n          (not (char-whitespace?\
    \ (last-char (substring txt 0 (- (string-length txt) 1))))))]\n    [else #f]))\n",
  "  (cond\n    [(empty? txt) #f]\n    [(and (char-alphabetic? (last-char txt))\n\
    \          (not (char-alphabetic? (last-char (butlast txt))))) #t]\n    [else\
    \ #f]))\n", "  (cond\n    [(empty? txt) #f]\n    [(and (char-alphabetic? (last-char\
    \ txt))\n          (not (char-alphabetic? (last-char (butlast txt))))) #t]\n \
    \   [else #f]))\n", "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic? (last-char\
    \ txt))\n     (if (char-whitespace? (second-last-char txt))\n         #t\n   \
    \      #f)]\n    [else #f]))\n", "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic?\
    \ (last-char txt))\n     (and (not (char-alphabetic? (last-char (substring txt\
    \ 0 (- (string-length txt) 1)))))\n          (not (char-whitespace? (last-char\
    \ (substring txt 0 (- (string-length txt) 1))))))]\n    [else #f]))\n", "  (cond\n\
    \    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (and (not\
    \ (char-alphabetic? (last-char (substring txt 0 (- (string-length txt) 1)))))\n\
    \          (not (char-whitespace? (last-char (substring txt 0 (- (string-length\
    \ txt) 1))))))]\n    [else #f]))\n", "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic?\
    \ (last-char txt))\n     (cond\n       [(empty? (rest txt)) #t]\n       [(char-alphabetic?\
    \ (last-char (rest txt))) #f]\n       [else #t])]\n    [else #f]))\n", "  (cond\n\
    \    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (if (char-alphabetic?\
    \ (last-char (substring txt 0 (- (string-length txt) 1))))\n         #f\n    \
    \     #t)]\n    [else #f]))\n", "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic?\
    \ (last-char txt))\n     (cond\n       [(empty? (rest txt)) #t]\n       [(char-alphabetic?\
    \ (last-char (rest txt))) #f]\n       [else #t])]\n    [else #f]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
