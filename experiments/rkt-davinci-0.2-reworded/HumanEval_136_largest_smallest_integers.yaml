name: HumanEval_136_largest_smallest_integers
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns a list (a, b), where 'a'\
  \ is\n;; the largest of negative integers, and 'b' is the smallest\n;; of positive\
  \ integers in a list.\n;; If there is no negative or positive integers, return them\
  \ as #f.\n;; Examples:\n;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))\n\
  ;; (list #f 1)\n;; >>> (largest_smallest_integers (list ))\n;; (list #f #f)\n;;\
  \ >>> (largest_smallest_integers (list 0))\n;; (list #f #f)\n(define (largest_smallest_integers\
  \ lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n\
  \    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))\n    (check-equal?\
  \ (candidate (list 2 4 1 3 5 7 0)) (list #f 1))\n    (check-equal? (candidate (list\
  \ 1 3 2 4 5 6 -2)) (list -2 1))\n    (check-equal? (candidate (list 4 5 3 6 2 7\
  \ -7)) (list -7 2))\n    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list\
  \ -9 2))\n    (check-equal? (candidate (list )) (list #f #f))\n    (check-equal?\
  \ (candidate (list 0)) (list #f #f))\n    (check-equal? (candidate (list -1 -3 -5\
  \ -6)) (list -1 #f))\n    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1\
  \ #f))\n    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))\n    (check-equal?\
  \ (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))\n))\n\n(test-humaneval)"
completions: ["  (define (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n\
    \      [(and (negative? (first lst))\n            (or (not (negative? (second\
    \ lst)))\n                (empty? (rest lst))))\n       (first lst)]\n      [else\
    \ (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (positive? (first lst))\n            (or\
    \ (not (positive? (second lst)))\n                (empty? (rest lst))))\n    \
    \   (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (cond\n    [(empty? lst) (list #f #f)]\n\
    \    [(and (positive? (first lst)) (negative? (first lst))) (list #f #f)]\n  \
    \  [(positive? (first lst)) (list (largest_smallest_integers (rest lst)) (first\
    \ lst))]\n    [(negative? (first lst)) (list (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n    [else (list #f #f)]))\n", "  (define (largest_negative lst)\n\
    \    (cond\n      [(null? lst) #f]\n      [(< (car lst) 0) (max (car lst) (largest_negative\
    \ (cdr lst)))]\n      [else (largest_negative (cdr lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(> (car lst) 0) (min (car lst)\
    \ (smallest_positive (cdr lst)))]\n      [else (smallest_positive (cdr lst))]))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (negative? (first lst)) (or (not largest) (&gt; (first lst) largest)))\n\
    \       (largest_smallest_integers_helper (rest lst) (first lst) smallest)]\n\
    \      [(and (positive? (first lst)) (or (not smallest) (&lt; (first lst) smallest)))\n\
    \       (largest_smallest_integers_helper (rest lst) largest (first lst))]\n \
    \     [else (largest_smallest_integers_helper (rest lst) largest smallest)]))\n\
    \  (largest_smallest_integers_helper lst #f #f))\n", "  (cond\n    [(empty? lst)\
    \ (list #f #f)]\n    [(and (positive? (first lst)) (negative? (first lst))) (list\
    \ #f #f)]\n    [(positive? (first lst)) (list (first lst) (first lst))]\n    [(negative?\
    \ (first lst)) (list (first lst) (first lst))]\n    [else (list #f #f)]))\n",
  "  (define (largest_negative_integer lst)\n    (cond ((null? lst) #f)\n        \
    \  ((and (integer? (car lst)) (< (car lst) 0))\n           (max (car lst) (largest_negative_integer\
    \ (cdr lst))))\n          (else (largest_negative_integer (cdr lst)))))\n  (define\
    \ (smallest_positive_integer lst)\n    (cond ((null? lst) #f)\n          ((and\
    \ (integer? (car lst)) (> (car lst) 0))\n           (min (car lst) (smallest_positive_integer\
    \ (cdr lst))))\n          (else (smallest_positive_integer (cdr lst)))))\n  (list\
    \ (largest_negative_integer lst) (smallest_positive_integer lst)))\n", "  (define\
    \ (largest_smallest_integers_iter lst largest smallest)\n    (cond\n      [(null?\
    \ lst) (list largest smallest)]\n      [(and (positive? (car lst)) (or (not (positive?\
    \ smallest)) (< (car lst) smallest)))\n       (largest_smallest_integers_iter\
    \ (cdr lst) largest (car lst))]\n      [(and (negative? (car lst)) (or (not (negative?\
    \ largest)) (> (car lst) largest)))\n       (largest_smallest_integers_iter (cdr\
    \ lst) (car lst) smallest)]\n      [else (largest_smallest_integers_iter (cdr\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n",
  "  (define (largest_negative lst)\n    (cond ((null? lst) #f)\n          ((and (integer?\
    \ (car lst)) (< (car lst) 0))\n           (max (car lst) (largest_negative (cdr\
    \ lst))))\n          (else (largest_negative (cdr lst)))))\n  (define (smallest_positive\
    \ lst)\n    (cond ((null? lst) #f)\n          ((and (integer? (car lst)) (> (car\
    \ lst) 0))\n           (min (car lst) (smallest_positive (cdr lst))))\n      \
    \    (else (smallest_positive (cdr lst)))))\n  (list (largest_negative lst) (smallest_positive\
    \ lst)))\n", "  (let ([negs (filter (lambda (x) (negative? x)) lst)]\n       \
    \ [pos (filter (lambda (x) (positive? x)) lst)])\n    (if (empty? negs)\n    \
    \    (list #f (min pos))\n        (list (max negs) (if (empty? pos) #f (min pos))))))\n",
  "  (define (largest_negative lst)\n    (cond ((null? lst) #f)\n          ((and (negative?\
    \ (car lst)) (not (null? (cdr lst))))\n           (if (negative? (car (cdr lst)))\n\
    \               (largest_negative (cdr lst))\n               (car lst)))\n   \
    \       ((negative? (car lst)) (car lst))\n          (else (largest_negative (cdr\
    \ lst)))))\n  (define (smallest_positive lst)\n    (cond ((null? lst) #f)\n  \
    \        ((and (positive? (car lst)) (not (null? (cdr lst))))\n           (if\
    \ (positive? (car (cdr lst)))\n               (smallest_positive (cdr lst))\n\
    \               (car lst)))\n          ((positive? (car lst)) (car lst))\n   \
    \       (else (smallest_positive (cdr lst)))))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (cond\n    [(empty? lst) (list #f #f)]\n  \
    \  [(and (negative? (first lst)) (positive? (first lst))) (list #f #f)]\n    [(negative?\
    \ (first lst)) (list (first lst) (largest_smallest_integers (rest lst)))]\n  \
    \  [(positive? (first lst)) (list (largest_smallest_integers (rest lst)) (first\
    \ lst))]\n    [else (list #f #f)]))\n", "  (define (largest_smallest_integers_helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not smallest) (&lt; (first lst) smallest)))\n\
    \       (largest_smallest_integers_helper (rest lst) largest (first lst))]\n \
    \     [(and (negative? (first lst)) (or (not largest) (&gt; (first lst) largest)))\n\
    \       (largest_smallest_integers_helper (rest lst) (first lst) smallest)]\n\
    \      [else (largest_smallest_integers_helper (rest lst) largest smallest)]))\n\
    \  (largest_smallest_integers_helper lst #f #f))\n</code>\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [(and (negative? (car lst)) (not\
    \ (negative? (cadr lst)))) (car lst)]\n      [else (largest_negative (cdr lst))]))\n\
    \  (define (smallest_positive lst)\n    (cond\n      [(null? lst) #f]\n      [(and\
    \ (positive? (car lst)) (not (positive? (cadr lst)))) (car lst)]\n      [else\
    \ (smallest_positive (cdr lst))]))\n  (list (largest_negative lst) (smallest_positive\
    \ lst)))\n", "  (define (largest_negative lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(and (negative? (first lst))\n            (or (not (negative? (second\
    \ lst)))\n                (empty? (rest lst))))\n       (first lst)]\n      [else\
    \ (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (positive? (first lst))\n            (or\
    \ (not (positive? (second lst)))\n                (empty? (rest lst))))\n    \
    \   (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_negative lst)\n    (cond\
    \ ((null? lst) #f)\n          ((and (negative? (car lst))\n                (or\
    \ (not (negative? (cadr lst)))\n                    (and (negative? (cadr lst))\n\
    \                         (> (car lst) (cadr lst)))))\n           (car lst))\n\
    \          (else (largest_negative (cdr lst)))))\n  (define (smallest_positive\
    \ lst)\n    (cond ((null? lst) #f)\n          ((and (positive? (car lst))\n  \
    \              (or (not (positive? (cadr lst)))\n                    (and (positive?\
    \ (cadr lst))\n                         (< (car lst) (cadr lst)))))\n        \
    \   (car lst))\n          (else (smallest_positive (cdr lst)))))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (cond\n    [(empty? lst) (list #f #f)]\n\
    \    [(and (positive? (first lst)) (negative? (first lst))) (list #f #f)]\n  \
    \  [(positive? (first lst)) (cons (first lst) (largest_smallest_integers (rest\
    \ lst)))]\n    [(negative? (first lst)) (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n    [else (largest_smallest_integers (rest lst))]))\n", "  (define\
    \ (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative?\
    \ (first lst)) (not (negative? (first (rest lst))))) (first lst)]\n      [else\
    \ (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (positive? (first lst)) (not (positive?\
    \ (first (rest lst))))) (first lst)]\n      [else (smallest_positive (rest lst))]))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(> (first lst) 0) (largest_negative\
    \ (rest lst))]\n      [(< (first lst) 0) (max (first lst) (largest_negative (rest\
    \ lst)))]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(< (first lst) 0) (smallest_positive\
    \ (rest lst))]\n      [(> (first lst) 0) (min (first lst) (smallest_positive (rest\
    \ lst)))]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (largest_negative lst)\n    (cond\
    \ ((null? lst) #f)\n          ((and (negative? (car lst))\n                (or\
    \ (not (negative? (cadr lst)))\n                    (negative? (car lst))\n  \
    \                  (not (negative? (cadr lst)))))\n           (car lst))\n   \
    \       (else (largest_negative (cdr lst)))))\n  (define (smallest_positive lst)\n\
    \    (cond ((null? lst) #f)\n          ((and (positive? (car lst))\n         \
    \       (or (not (positive? (cadr lst)))\n                    (positive? (car\
    \ lst))\n                    (not (positive? (cadr lst)))))\n           (car lst))\n\
    \          (else (smallest_positive (cdr lst)))))\n  (list (largest_negative lst)\
    \ (smallest_positive lst)))\n", "  (define (largest_negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst))\n            (or\
    \ (not (negative? (second lst)))\n                (and (negative? (second lst))\n\
    \                     (> (first lst) (second lst)))))\n       (first lst)]\n \
    \     [else (largest_negative (rest lst))]))\n  (define (smallest_positive lst)\n\
    \    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n   \
    \         (or (not (positive? (second lst)))\n                (and (positive?\
    \ (second lst))\n                     (< (first lst) (second lst)))))\n      \
    \ (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
