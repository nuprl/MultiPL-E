name: HumanEval_20_find_closest_elements
language: rkt
prompt: "#lang racket\n\n;; From a supplied list of numbers (of length at least two)\
  \ select and return two that are the closest to each\n;; other and return them in\
  \ order (smaller number, larger number).\n;; >>> (find_closest_elements (list 1.0\
  \ 2.0 3.0 4.0 5.0 2.2))\n;; (list 2.0 2.2)\n;; >>> (find_closest_elements (list\
  \ 1.0 2.0 3.0 4.0 5.0 2.0))\n;; (list 2.0 2.0)\n(define (find_closest_elements numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_closest_elements))\n\
  \    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))\n\
  \    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))\n    (check-equal?\
  \ (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))\n    (check-equal?\
  \ (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))\n    (check-equal?\
  \ (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))\n))\n\n(test-humaneval)"
completions: ["  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers\
    \ (cdr numbers)))])\n    (list (apply min (filter (lambda (x) (= (abs (- x (apply\
    \ min numbers))) min-diff)) numbers))\n          (apply max (filter (lambda (x)\
    \ (= (abs (- x (apply min numbers))) min-diff)) numbers)))))\n", "  (cond\n  \
    \  [(empty? numbers) empty]\n    [(empty? (rest numbers)) empty]\n    [else\n\
    \     (let* ([closest-pair (list (first numbers) (first (rest numbers)))]\n  \
    \          [closest-distance (abs (- (first numbers) (first (rest numbers))))])\n\
    \       (for ([n (in-list (rest (rest numbers)))])\n         (let* ([distance\
    \ (abs (- (first numbers) n))])\n           (if (< distance closest-distance)\n\
    \               (begin\n                 (set! closest-pair (list (first numbers)\
    \ n))\n                 (set! closest-distance distance))))\n         (set! numbers\
    \ (rest numbers))))\n     (sort closest-pair <)]))\n", "  (let loop ((numbers\
    \ numbers) (closest-pair (list (car numbers) (cadr numbers))))\n    (if (null?\
    \ (cddr numbers))\n        closest-pair\n        (let ((current-pair (list (car\
    \ numbers) (cadr numbers))))\n          (if (< (abs (- (car current-pair) (cadr\
    \ current-pair)))\n                 (abs (- (car closest-pair) (cadr closest-pair))))\n\
    \              (loop (cdr numbers) current-pair)\n              (loop (cdr numbers)\
    \ closest-pair))))))\n", "  (let ((closest-pair (list (car numbers) (cadr numbers))))\n\
    \    (for ((i (in-range (length numbers)))\n          (j (in-range (add1 i) (length\
    \ numbers))))\n      (let ((pair (list (list-ref numbers i) (list-ref numbers\
    \ j))))\n        (when (< (abs (- (car pair) (cadr pair)))\n                 (abs\
    \ (- (car closest-pair) (cadr closest-pair))))\n          (set! closest-pair pair))))\n\
    \    closest-pair))\n", "  (define (find_closest_elements_helper numbers closest-pair)\n\
    \    (if (null? (cdr numbers))\n        closest-pair\n        (let* ([first (car\
    \ numbers)]\n               [second (cadr numbers)]\n               [diff (abs\
    \ (- first second))]\n               [closest-diff (abs (- (car closest-pair)\
    \ (cadr closest-pair)))])\n          (if (< diff closest-diff)\n             \
    \ (find_closest_elements_helper (cdr numbers) (list first second))\n         \
    \     (find_closest_elements_helper (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let ([diff (abs (- (car numbers) (cadr numbers)))])\n          (if (<\
    \ diff (abs (- (car closest-pair) (cadr closest-pair))))\n              (find_closest_elements_helper\
    \ (cdr numbers) (list (car numbers) (cadr numbers)))\n              (find_closest_elements_helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest_pair)\n    (cond\n      [(empty? numbers) closest_pair]\n  \
    \    [(empty? (rest numbers)) closest_pair]\n      [else\n       (let* ([current_pair\
    \ (list (first numbers) (second numbers))]\n              [current_diff (abs (-\
    \ (first current_pair) (second current_pair)))]\n              [closest_diff (abs\
    \ (- (first closest_pair) (second closest_pair)))]\n              [new_closest_pair\
    \ (if (< current_diff closest_diff) current_pair closest_pair)])\n         (find_closest_elements_helper\
    \ (rest (rest numbers)) new_closest_pair))]))\n  (find_closest_elements_helper\
    \ numbers (list (first numbers) (second numbers))))\n", "  (let* ([min-diff (apply\
    \ min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))]\n         [min-index\
    \ (list-index min-diff (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n\
    \    (list (list-ref numbers min-index) (list-ref numbers (add1 min-index)))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([current-pair (list (car numbers)\
    \ (cadr numbers))]\n               [current-diff (abs (- (car current-pair) (cadr\
    \ current-pair)))]\n               [closest-diff (abs (- (car closest-pair) (cadr\
    \ closest-pair)))])\n          (if (< current-diff closest-diff)\n           \
    \   (find_closest_elements_helper (cdr numbers) current-pair)\n              (find_closest_elements_helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-so-far)\n    (if (null? (cdr numbers))\n        closest-so-far\n\
    \        (let* ([current-pair (list (car numbers) (cadr numbers))]\n         \
    \      [current-diff (abs (- (car current-pair) (cadr current-pair)))]\n     \
    \          [closest-diff (abs (- (car closest-so-far) (cadr closest-so-far)))])\n\
    \          (if (< current-diff closest-diff)\n              (find_closest_elements_helper\
    \ (cdr numbers) current-pair)\n              (find_closest_elements_helper (cdr\
    \ numbers) closest-so-far)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements_iter numbers\
    \ closest-pair)\n    (cond\n      [(empty? numbers) closest-pair]\n      [(empty?\
    \ (rest numbers)) closest-pair]\n      [else\n       (let* ([first (first numbers)]\n\
    \              [second (first (rest numbers))]\n              [diff (abs (- first\
    \ second))]\n              [closest-diff (abs (- (first closest-pair) (second\
    \ closest-pair)))])\n         (if (< diff closest-diff)\n             (find_closest_elements_iter\
    \ (rest numbers) (list first second))\n             (find_closest_elements_iter\
    \ (rest numbers) closest-pair)))]))\n  (find_closest_elements_iter numbers (list\
    \ (first numbers) (second numbers))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([next-pair (list (car numbers) (cadr numbers))]\n            \
    \   [next-diff (abs (- (car next-pair) (cadr next-pair)))]\n               [current-diff\
    \ (abs (- (car closest-pair) (cadr closest-pair)))]\n               [new-closest-pair\
    \ (if (< next-diff current-diff) next-pair closest-pair)])\n          (find_closest_elements_helper\
    \ (cdr numbers) new-closest-pair))))\n  (if (< (length numbers) 2)\n      (error\
    \ \"find_closest_elements: list must have at least two elements\")\n      (find_closest_elements_helper\
    \ numbers (list (car numbers) (cadr numbers)))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-diff (abs\
    \ (- (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements_helper (cdr numbers) (list first second))\n\
    \              (find_closest_elements_helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements_helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (define (closest-pair lst)\n    (define (closest-pair-helper lst min-pair)\n\
    \      (if (null? lst)\n          min-pair\n          (let* ([x (car lst)]\n \
    \                [y (cadr lst)]\n                 [diff (abs (- x y))]\n     \
    \            [min-diff (abs (- (car min-pair) (cadr min-pair)))])\n          \
    \  (if (< diff min-diff)\n                (closest-pair-helper (cdr lst) (list\
    \ x y))\n                (closest-pair-helper (cdr lst) min-pair)))))\n    (closest-pair-helper\
    \ (sort lst <) (list (car lst) (cadr lst))))\n  (closest-pair numbers))\n", " \
    \ (define (find_closest_elements-helper numbers closest-pair)\n    (if (null?\
    \ (cdr numbers))\n        closest-pair\n        (let ((current-pair (list (car\
    \ numbers) (cadr numbers))))\n          (if (< (abs (- (car current-pair) (cadr\
    \ current-pair)))\n                 (abs (- (car closest-pair) (cadr closest-pair))))\n\
    \              (find_closest_elements-helper (cdr numbers) current-pair)\n   \
    \           (find_closest_elements-helper (cdr numbers) closest-pair)))))\n  (find_closest_elements-helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let* ([numbers (sort numbers\
    \ <)]\n         [min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers\
    \ (rest numbers)))]\n         [closest-pair (filter (lambda (x y) (= (abs (- x\
    \ y)) min-diff)) numbers (rest numbers))])\n    closest-pair))\n", "  (define\
    \ (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr numbers))\n\
    \        closest-pair\n        (let* ([first (car numbers)]\n               [second\
    \ (cadr numbers)]\n               [diff (abs (- first second))]\n            \
    \   [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n       \
    \   (if (< diff closest-diff)\n              (find_closest_elements_helper (cdr\
    \ numbers) (list first second))\n              (find_closest_elements_helper (cdr\
    \ numbers) closest-pair)))))\n  (find_closest_elements_helper numbers (list (car\
    \ numbers) (cadr numbers))))\n", "  (define (find_closest_elements_iter numbers\
    \ closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n       \
    \ (let* ([current-pair (list (car numbers) (cadr numbers))]\n               [current-distance\
    \ (abs (- (car current-pair) (cadr current-pair)))]\n               [closest-distance\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< current-distance\
    \ closest-distance)\n              (find_closest_elements_iter (cdr numbers) current-pair)\n\
    \              (find_closest_elements_iter (cdr numbers) closest-pair)))))\n \
    \ (find_closest_elements_iter numbers (list (car numbers) (cadr numbers))))\n",
  "  (cond\n    [(empty? numbers) empty]\n    [(empty? (rest numbers)) empty]\n  \
    \  [else\n     (let* ([numbers (sort numbers <)]\n            [min-diff (apply\
    \ min (map (lambda (x y) (- y x)) numbers (rest numbers)))]\n            [min-index\
    \ (apply min (map (lambda (x y) (if (= (- y x) min-diff) x empty)) numbers (rest\
    \ numbers)))])\n       (list (list-ref numbers min-index) (list-ref numbers (+\
    \ min-index 1))))]))\n", "  (define (find_closest_elements_helper numbers closest_pair)\n\
    \    (if (null? (cdr numbers))\n        closest_pair\n        (let* ([first_number\
    \ (car numbers)]\n               [second_number (cadr numbers)]\n            \
    \   [difference (abs (- first_number second_number))]\n               [closest_difference\
    \ (abs (- (car closest_pair) (cadr closest_pair)))]\n               [new_closest_pair\
    \ (if (< difference closest_difference)\n                                    \
    \ (list first_number second_number)\n                                     closest_pair)])\n\
    \          (find_closest_elements_helper (cdr numbers) new_closest_pair))))\n\
    \  (find_closest_elements_helper numbers (list (car numbers) (cadr numbers))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
