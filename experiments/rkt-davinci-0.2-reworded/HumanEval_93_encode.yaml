name: HumanEval_93_encode
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a message, and encodes in\
  \ such a \n;; way that it swaps case of all letters, replaces all vowels in \n;;\
  \ the message with the letter that appears 2 places ahead of that \n;; vowel in\
  \ the english alphabet. \n;; Assume only letters. \n;; Examples:\n;; >>> (encode\
  \ \"test\")\n;; \"TGST\"\n;; >>> (encode \"This is a message\")\n;; \"tHKS KS C\
  \ MGSSCGG\"\n(define (encode message)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n\
  \    (check-equal? (candidate \"TEST\") \"tgst\")\n    (check-equal? (candidate\
  \ \"Mudasir\") \"mWDCSKR\")\n    (check-equal? (candidate \"YES\") \"ygs\")\n  \
  \  (check-equal? (candidate \"This is a message\") \"tHKS KS C MGSSCGG\")\n    (check-equal?\
  \ (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\")\n))\n\
  \n(test-humaneval)"
completions: ["  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n\
    \       (define (is-vowel? c)\n         (or (char=? c #\\a)\n             (char=?\
    \ c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n      \
    \       (char=? c #\\u)))\n       (define (next-char c)\n         (if (char=?\
    \ c #\\z)\n             #\\a\n             (char+ c 1)))\n       (define (next-next-char\
    \ c)\n         (if (char=? c #\\y)\n             #\\a\n             (next-char\
    \ (next-char c))))\n       (if (is-vowel? c)\n           (next-next-char c)\n\
    \           (next-char c))]\n      [else c]))\n  (define (encode-string s)\n \
    \   (if (string-empty? s)\n        \"\"\n        (string-append (encode-char (string-ref\
    \ s 0))\n                       (encode-string (substring s 1)))))\n  (encode-string\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else c]))\n\
    \  (define (encode-word word)\n    (if (empty? word)\n        empty\n        (cons\
    \ (encode-char (car word))\n              (encode-word (cdr word)))))\n  (define\
    \ (encode-message message)\n    (if (empty? message)\n        empty\n        (cons\
    \ (swap-case (car message))\n              (encode-message (cdr message)))))\n\
    \  (encode-message (encode-word message)))\n", "  (define (swap-case c)\n    (if\
    \ (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (encode-char c)\n    (cond ((char=? c #\\a) #\\c)\n          ((char=?\
    \ c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n          ((char=? c #\\o)\
    \ #\\q)\n          ((char=? c #\\u) #\\w)\n          ((char=? c #\\A) #\\C)\n\
    \          ((char=? c #\\E) #\\G)\n          ((char=? c #\\I) #\\K)\n        \
    \  ((char=? c #\\O) #\\Q)\n          ((char=? c #\\U) #\\W)\n          (else c)))\n\
    \  (string-map (lambda (c) (encode-char (swap-case c))) message))\n", "  (string-map\n\
    \   (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n        (let ([c (char-upcase\
    \ c)])\n          (cond\n            [(member c '(#\\A #\\E #\\I #\\O #\\U))\n\
    \             (char-upcase (vector-ref (string->vector \"CDFGHJKLMNPQRSTVWXYZABCDE\"\
    ) (- (char->integer c) (char->integer #\\A))))]\n            [else\n         \
    \    (char-upcase (vector-ref (string->vector \"DEFGHIJKLMNOPQRSTUVWXYZABC\")\
    \ (- (char->integer c) (char->integer #\\A))))]))]\n       [else\n        c]))\n\
    \   message))\n", "  (string-upcase message))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (let* ([c (char-upcase c)]\n \
    \             [c (if (char-vowel? c)\n                     (char-next (char-next\
    \ c))\n                     c)])\n         (if (char-lower-case? c)\n        \
    \     (char-upcase c)\n             c))]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n     \
    \   (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=?\
    \ c #\\u))\n        (swap-case (char-upcase c))\n        (swap-case c)))\n  (define\
    \ (encode-string s)\n    (if (string-empty? s)\n        \"\"\n        (string-append\
    \ (encode-char (string-ref s 0))\n                       (encode-string (substring\
    \ s 1)))))\n  (encode-string message))\n", "  (define (swap-case c)\n    (cond\
    \ ((char-upper-case? c) (char-downcase c))\n          ((char-lower-case? c) (char-upcase\
    \ c))\n          (else c)))\n  (define (encode-char c)\n    (cond ((char=? c #\\\
    a) #\\c)\n          ((char=? c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n\
    \          ((char=? c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n        \
    \  ((char=? c #\\A) #\\C)\n          ((char=? c #\\E) #\\G)\n          ((char=?\
    \ c #\\I) #\\K)\n          ((char=? c #\\O) #\\Q)\n          ((char=? c #\\U)\
    \ #\\W)\n          (else c)))\n  (define (encode-string str)\n    (string-map\
    \ encode-char str))\n  (define (swap-case-string str)\n    (string-map swap-case\
    \ str))\n  (encode-string (swap-case-string message)))\n", "  (string-upcase message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-lower-case? c) (char-upcase\
    \ c)]\n      [(char-upper-case? c) (char-downcase c)]\n      [else c]))\n  (define\
    \ (encode-vowel c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c\
    \ #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n  \
    \    [(char=? c #\\u) #\\w]\n      [else c]))\n  (define (encode-letter c)\n \
    \   (cond\n      [(or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=?\
    \ c #\\o) (char=? c #\\u))\n       (encode-vowel c)]\n      [else (encode-char\
    \ c)]))\n  (define (encode-message message)\n    (if (empty? message)\n      \
    \  empty\n        (cons (encode-letter (first message))\n              (encode-message\
    \ (rest message)))))\n  (encode-message message))\n", "  (define (swap-case c)\n\
    \    (if (char-upcase? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (encode-char c)\n    (if (vowel? c)\n        (encode-vowel c)\n   \
    \     (swap-case c)))\n  (define (encode-vowel c)\n    (define (next-vowel c)\n\
    \      (if (vowel? c)\n          (next-vowel (next-char c))\n          c))\n \
    \   (define (next-char c)\n      (integer->char (+ (char->integer c) 1)))\n  \
    \  (next-vowel (next-char c)))\n  (define (vowel? c)\n    (member c '(#\\a #\\\
    e #\\i #\\o #\\u)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\\
    u))\n        (list-ref '(#\\c #\\f #\\j #\\o #\\t) (position c '(#\\a #\\e #\\\
    i #\\o #\\u)))\n        c))\n  (define (encode-message message)\n    (if (empty?\
    \ message)\n        empty\n        (cons (encode-char (swap-case (first message)))\n\
    \              (encode-message (rest message)))))\n  (list->string (encode-message\
    \ (string->list message))))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (let ((vowels (string-&gt;list \"aeiou\"))\n              (alphabet\
    \ (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\")))\n          (if (member c\
    \ vowels)\n              (list-ref alphabet (+ (list-index c vowels 2) 2))\n \
    \             c))\n        c))\n  (string-join\n   (map (lambda (c) (encode-char\
    \ (swap-case c)))\n        (string-&gt;list message))\n   \"\"))\n</code>\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n        c))\n\
    \  (string-map encode-char (string-map swap-case message)))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel? c)\n \
    \        (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=?\
    \ c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n    \
    \   (define (swap-case c)\n         (if (char-lower-case? c)\n             (char-upcase\
    \ c)\n             (char-downcase c)))\n       (define (next-char c)\n       \
    \  (if (char=? c #\\z)\n             #\\a\n             (char+ c 1)))\n      \
    \ (define (next-next-char c)\n         (if (char=? c #\\y)\n             #\\a\n\
    \             (next-char (next-char c))))\n       (if (is-vowel? c)\n        \
    \   (next-next-char c)\n           (swap-case c))]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (define (encode-char c)\n    (cond ((char=?\
    \ c #\\a) #\\c)\n          ((char=? c #\\e) #\\g)\n          ((char=? c #\\i)\
    \ #\\k)\n          ((char=? c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n\
    \          ((char=? c #\\A) #\\C)\n          ((char=? c #\\E) #\\G)\n        \
    \  ((char=? c #\\I) #\\K)\n          ((char=? c #\\O) #\\Q)\n          ((char=?\
    \ c #\\U) #\\W)\n          (else c)))\n  (define (encode-string s)\n    (if (string-empty?\
    \ s)\n        \"\"\n        (string-append (encode-char (string-ref s 0))\n  \
    \                     (encode-string (substring s 1)))))\n  (encode-string (string-map\
    \ swap-case message)))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\\
    c #\\f #\\j #\\o #\\t) (position c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n\
    \  (map (lambda (c) (encode-char (swap-case c))) (string->list message)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
