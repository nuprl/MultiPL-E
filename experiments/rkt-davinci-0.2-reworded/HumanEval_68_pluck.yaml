name: HumanEval_68_pluck
language: rkt
prompt: "#lang racket\n\n;; \"Given a list representing a branch of a tree that has\
  \ non-negative integer nodes\n;; your task is to pluck one of the nodes and return\
  \ it.\n;; The plucked node should be the node with the smallest even value.\n;;\
  \ If multiple nodes with the same smallest even value are found return the node\
  \ that has smallest index.\n;; The plucked node should be returned in a list, [\
  \ smalest_value, its index ],\n;; If there are no even values or the given list\
  \ is empty, return [].\n;; >>> (pluck (list 4 2 3))\n;; (list 2 1)\n;; >>> (pluck\
  \ (list 1 2 3))\n;; (list 2 1)\n;; >>> (pluck (list ))\n;; (list )\n;; >>> (pluck\
  \ (list 5 0 3 0 4 2))\n;; (list 0 1)\n;; Constraints:\n;; * 1 <= nodes.length <=\
  \ 10000\n;; * 0 <= node.value\n(define (pluck arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n\
  \    (check-equal? (candidate (list 4 2 3)) (list 2 1))\n    (check-equal? (candidate\
  \ (list 1 2 3)) (list 2 1))\n    (check-equal? (candidate (list )) (list ))\n  \
  \  (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))\n    (check-equal? (candidate\
  \ (list 1 2 3 0 5 3)) (list 0 3))\n    (check-equal? (candidate (list 5 4 8 4 8))\
  \ (list 4 1))\n    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))\n    (check-equal?\
  \ (candidate (list 7 9 7 1)) (list ))\n))\n\n(test-humaneval)"
completions: ["  (let ([evens (filter even? arr)])\n    (if (empty? evens)\n     \
    \   (list)\n        (let ([min-even (apply min evens)])\n          (list min-even\
    \ (index-of min-even arr))))))\n", "  (cond [(empty? arr) (list)]\n        [(even?\
    \ (first arr)) (list (first arr) 1)]\n        [else (cons (first arr) (pluck (rest\
    \ arr)))]))\n", "  (cond [(empty? arr) (list)]\n        [(even? (first arr)) (list\
    \ (first arr) 0)]\n        [else (list (first arr) 1)]))\n", "  (cond\n    [(empty?\
    \ arr) (list)]\n    [(even? (first arr)) (list (first arr) 0)]\n    [else (pluck\
    \ (rest arr))]))\n", "  (cond\n    [(empty? arr) (list)]\n    [(even? (first arr))\
    \ (list (first arr) 0)]\n    [else (pluck (rest arr))]))\n", "  (cond [(empty?\
    \ arr) (list)]\n        [(even? (first arr))\n         (let ([smallest-even (first\
    \ arr)])\n           (for ([i (in-range (length arr))])\n             (when (and\
    \ (even? (list-ref arr i))\n                        (< (list-ref arr i) smallest-even))\n\
    \               (set! smallest-even (list-ref arr i))))\n           (list smallest-even\
    \ (for/first ([i (in-range (length arr))])\n                                 \
    \         (when (= (list-ref arr i) smallest-even)\n                         \
    \                   i)))]\n        [else (pluck (rest arr))]))\n", "  (cond [(empty?\
    \ arr) (list)]\n        [(even? (first arr)) (list (first arr) 0)]\n        [else\
    \ (pluck (rest arr))]))\n", "  (cond [(empty? arr) empty]\n        [(even? (first\
    \ arr)) (list (first arr) 0)]\n        [else (pluck (rest arr))]))\n", "  (cond\n\
    \    [(empty? arr) (list)]\n    [(even? (first arr)) (list (first arr) 0)]\n \
    \   [else (pluck (rest arr))]))\n", "  (cond [(empty? arr) (list)]\n        [(even?\
    \ (first arr)) (list (first arr) 0)]\n        [else (pluck (rest arr))]))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(even? (first arr)) (pluck (rest arr))]\n\
    \    [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr) empty]\n    [(even?\
    \ (first arr)) (list (first arr) 0)]\n    [else (list-ref (pluck (rest arr)) 0)]))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(even? (first arr)) (list (first arr) 0)]\n\
    \    [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr) (list)]\n   \
    \ [(even? (first arr)) (list (first arr) 0)]\n    [else (list (first arr) 0)]))\n",
  "  (cond\n    [(empty? arr) (list)]\n    [(even? (first arr)) (list (first arr)\
    \ 0)]\n    [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr) (list)]\n\
    \    [(even? (first arr)) (list (first arr) 0)]\n    [else (pluck (rest arr))]))\n",
  "  (if (empty? arr)\n      (list)\n      (let ([evens (filter even? arr)])\n   \
    \     (if (empty? evens)\n            (list)\n            (let ([min-even (apply\
    \ min evens)])\n              (list min-even (index-of min-even arr)))))))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(even? (first arr)) (list (first arr) 0)]\n\
    \    [else (pluck (rest arr))]))\n", "  (let ([evens (filter even? arr)])\n  \
    \  (if (empty? evens)\n        (list)\n        (let ([min-even (apply min evens)])\n\
    \          (list min-even (index-of min-even arr))))))\n", "  (cond\n    [(empty?\
    \ arr) (list)]\n    [(even? (first arr)) (list (first arr) 0)]\n    [else (pluck\
    \ (rest arr))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
