name: HumanEval_68_pluck
language: rkt
prompt: "#lang racket\n\n;; \"Given a list representing a branch of a tree that has\
  \ non-negative integer nodes\n;; your task is to pluck one of the nodes and return\
  \ it.\n;; The plucked node should be the node with the smallest even value.\n;;\
  \ If multiple nodes with the same smallest even value are found return the node\
  \ that has smallest index.\n;; The plucked node should be returned in a list, [\
  \ smalest_value, its index ],\n;; If there are no even values or the given list\
  \ is empty, return [].\n;; Example 1:\n;; >>> (pluck (list 4 2 3))\n;; (list 2 1)\n\
  ;; Explanation: 2 has the smallest even value, and 2 has the smallest index.\n;;\
  \ Example 2:\n;; >>> (pluck (list 1 2 3))\n;; (list 2 1)\n;; Explanation: 2 has\
  \ the smallest even value, and 2 has the smallest index.\n;; Example 3:\n;; >>>\
  \ (pluck (list ))\n;; (list )\n;; Example 4:\n;; >>> (pluck (list 5 0 3 0 4 2))\n\
  ;; (list 0 1)\n;; Explanation: 0 is the smallest value, but  there are two zeros,\n\
  ;; so we will choose the first zero, which has the smallest index.\n;; Constraints:\n\
  ;; * 1 <= nodes.length <= 10000\n;; * 0 <= node.value\n(define (pluck arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n\
  \    (check-equal? (candidate (list 4 2 3)) (list 2 1))\n    (check-equal? (candidate\
  \ (list 1 2 3)) (list 2 1))\n    (check-equal? (candidate (list )) (list ))\n  \
  \  (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))\n    (check-equal? (candidate\
  \ (list 1 2 3 0 5 3)) (list 0 3))\n    (check-equal? (candidate (list 5 4 8 4 8))\
  \ (list 4 1))\n    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))\n    (check-equal?\
  \ (candidate (list 7 9 7 1)) (list ))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? arr) empty]\n        [(even? (first arr)) (list (first\
    \ arr) 0)]\n        [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr)\
    \ (list)]\n    [(and (even? (first arr)) (or (empty? (rest arr)) (not (even? (second\
    \ arr))))) (list (first arr) 0)]\n    [else (let ([rest-pluck (pluck (rest arr))])\n\
    \            (if (empty? rest-pluck)\n                (list)\n               \
    \ (if (< (first rest-pluck) (first arr))\n                    (cons (first rest-pluck)\
    \ (add1 (second rest-pluck)))\n                    (cons (first arr) 1))))]))\n",
  "  (cond\n    [(empty? arr) (list)]\n    [(even? (first arr)) (list (first arr)\
    \ 1)]\n    [else (pluck (rest arr))]))\n", "  (define (pluck-helper arr min-index\
    \ min-value)\n    (cond [(empty? arr) (list min-value min-index)]\n          [(even?\
    \ (first arr))\n           (if (< min-value (first arr))\n               (pluck-helper\
    \ (rest arr) (add1 min-index) (first arr))\n               (pluck-helper (rest\
    \ arr) (add1 min-index) min-value))]\n          [else (pluck-helper (rest arr)\
    \ (add1 min-index) min-value)]))\n  (pluck-helper arr 0 10000))\n", "  (let ([evens\
    \ (filter even? arr)])\n    (if (null? evens)\n        '()\n        (let ([min-even\
    \ (apply min evens)])\n          (list min-even (index-of min-even arr))))))\n",
  "  (cond [(empty? arr) empty]\n        [(even? (first arr)) (cons (first arr) (cons\
    \ 1 empty))]\n        [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr)\
    \ (list)]\n    [(even? (first arr)) (list (first arr) 1)]\n    [(pluck (rest arr))]\n\
    \    [else (list)]))\n", "  (cond [(empty? arr) (list)]\n        [(even? (first\
    \ arr)) (list (first arr) 0)]\n        [else (list (first arr) 1)]))\n", "  (cond\n\
    \    [(empty? arr) (list)]\n    [(even? (first arr)) (pluck-even arr)]\n    [else\
    \ (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr) empty]\n    [(even? (first\
    \ arr)) (list (first arr) 0)]\n    [else (pluck (rest arr))]))\n", "  (cond\n\
    \    [(empty? arr) (list)]\n    [(even? (first arr)) (list (first arr) 1)]\n \
    \   [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr) empty]\n    [(even?\
    \ (first arr)) (cons (first arr) (cons 1 empty))]\n    [else (pluck (rest arr))]))\n",
  "  (cond\n    [(empty? arr) (list)]\n    [(even? (first arr)) (list (first arr)\
    \ 1)]\n    [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr) empty]\n\
    \    [(even? (first arr)) (list (first arr) 0)]\n    [else (pluck (rest arr))]))\n",
  "  (define (pluck-helper arr min-index min-value)\n    (cond\n      [(empty? arr)\
    \ (list min-value min-index)]\n      [(even? (first arr))\n       (if (< (first\
    \ arr) min-value)\n           (pluck-helper (rest arr) 0 (first arr))\n      \
    \     (pluck-helper (rest arr) (+ min-index 1) min-value))]\n      [else (pluck-helper\
    \ (rest arr) (+ min-index 1) min-value)]))\n  (pluck-helper arr 10000 0))\n",
  "  (let ([evens (filter even? arr)])\n    (if (null? evens)\n        '()\n     \
    \   (let ([min (apply min evens)])\n          (list min (index-of min arr))))))\n",
  "  (define (helper arr min-index min-value)\n    (cond [(empty? arr) (list min-value\
    \ min-index)]\n          [(and (even? (first arr)) (< (first arr) min-value))\n\
    \           (helper (rest arr) (add1 min-index) (first arr))]\n          [else\
    \ (helper (rest arr) (add1 min-index) min-value)]))\n  (if (empty? arr) (list)\n\
    \      (helper arr 0 10000)))\n", "  (if (empty? arr)\n      (list)\n      (define\
    \ evens (filter even? arr))\n      (if (empty? evens)\n          (list)\n    \
    \      (list (apply min evens) (index-of (apply min evens) arr)))))\n", "  (cond\
    \ [(empty? arr) (list)]\n        [(even? (first arr)) (list (first arr) 1)]\n\
    \        [else (list (first arr) 1)]))\n", "  (cond\n    [(empty? arr) '()]\n\
    \    [(even? (first arr)) (pluck-even arr)]\n    [else (pluck (rest arr))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
