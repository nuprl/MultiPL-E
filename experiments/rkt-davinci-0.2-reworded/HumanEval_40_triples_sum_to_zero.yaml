name: HumanEval_40_triples_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; triples_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns #t if there are three distinct elements in the list that\n;; sum to\
  \ zero, and #f otherwise.\n;; >>> (triples_sum_to_zero (list 1 3 5 0))\n;; #f\n\
  ;; >>> (triples_sum_to_zero (list 1 3 -2 1))\n;; #t\n;; >>> (triples_sum_to_zero\
  \ (list 1 2 3 7))\n;; #f\n;; >>> (triples_sum_to_zero (list 2 4 -5 3 9 7))\n;; #t\n\
  ;; >>> (triples_sum_to_zero (list 1))\n;; #f\n(define (triples_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 5 -1)) #f)\n    (check-equal? (candidate (list 1 3 -2 1)) #t)\n    (check-equal?\
  \ (candidate (list 1 2 3 7)) #f)\n    (check-equal? (candidate (list 1 2 5 7)) #f)\n\
  \    (check-equal? (candidate (list 2 4 -5 3 9 7)) #t)\n    (check-equal? (candidate\
  \ (list 1)) #f)\n    (check-equal? (candidate (list 1 3 5 -100)) #f)\n    (check-equal?\
  \ (candidate (list 100 3 5 -100)) #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? l) #f]\n    [(and (member (first l) (rest l))\
    \ (member (first l) (rest (rest l)))) #t]\n    [else (triples_sum_to_zero (rest\
    \ l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(and (member (list-ref l 0) (cdr\
    \ l))\n          (member (list-ref l 0) (cddr l))) #t]\n    [else (triples_sum_to_zero\
    \ (cdr l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(and (member (first l) (rest\
    \ l)) (member (first l) (rest (rest l)))) #t]\n    [else (triples_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(and (member (car l) (cdr\
    \ l)) (member (car l) (cddr l))) #t]\n    [else (triples_sum_to_zero (cdr l))]))\n",
  "  (cond\n    [(empty? l) #f]\n    [(and (member (list-ref l 0) (cdr l))\n     \
    \     (member (list-ref l 0) (cddr l))) #t]\n    [else (triples_sum_to_zero (cdr\
    \ l))]))\n", "  (cond ((null? l) #f)\n        ((null? (cdr l)) #f)\n        ((null?\
    \ (cddr l)) #f)\n        ((and (member (car l) (cdr l))\n              (member\
    \ (car l) (cddr l))) #t)\n        (else (triples_sum_to_zero (cdr l)))))\n", " \
    \ (cond\n    [(empty? l) #f]\n    [(and (member (car l) (cdr l)) (member (- (car\
    \ l)) (cdr l))) #t]\n    [else (triples_sum_to_zero (cdr l))]))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(empty? (rest (rest l)))\
    \ #f]\n    [else\n     (cond\n       [(and (zero? (+ (first l) (second l) (third\
    \ l)))\n             (not (member (first l) (rest l)))\n             (not (member\
    \ (second l) (rest l)))\n             (not (member (third l) (rest l))))\n   \
    \     #t]\n       [else\n        (triples_sum_to_zero (rest l))])]))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(empty? (rest (rest l)))\
    \ #f]\n    [else\n     (cond\n       [(= (list-ref l 0) (list-ref l 1) (list-ref\
    \ l 2)) #f]\n       [(= (list-ref l 0) (list-ref l 1) (list-ref l 2)) #f]\n  \
    \     [(= (list-ref l 0) (list-ref l 1) (list-ref l 2)) #f]\n       [else\n  \
    \      (cond\n          [(= (+ (list-ref l 0) (list-ref l 1) (list-ref l 2)) 0)\
    \ #t]\n          [else (triples_sum_to_zero (rest l))])])])\n  )\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(= (length l) 1) #f]\n    [(= (length l) 2) #f]\n \
    \   [else\n     (or (and (member (car l) (cdr l))\n              (member (car\
    \ l) (cddr l)))\n         (triples_sum_to_zero (cdr l)))]))\n", "  (cond\n   \
    \ [(empty? l) #f]\n    [(and (member (car l) (cdr l)) (member (car l) (cddr l)))\
    \ #t]\n    [else (triples_sum_to_zero (cdr l))]))\n", "  (define (triples_sum_to_zero_helper\
    \ l)\n    (cond ((null? l) #f)\n          ((and (member (car l) (cdr l))\n   \
    \             (member (- (car l)) (cdr l)))\n           #t)\n          (else (triples_sum_to_zero_helper\
    \ (cdr l)))))\n  (triples_sum_to_zero_helper l))\n", "  (cond\n    [(empty? l)\
    \ #f]\n    [(and (member (first l) (rest l))\n          (member (first l) (rest\
    \ (rest l)))) #t]\n    [else (triples_sum_to_zero (rest l))]))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(empty? (rest (rest l)))\
    \ #f]\n    [else\n     (let* ([a (first l)]\n            [b (first (rest l))]\n\
    \            [c (first (rest (rest l)))]\n            [rest (rest (rest (rest\
    \ l)))])\n       (or (and (= (+ a b c) 0) #t)\n           (triples_sum_to_zero\
    \ (cons a rest))))]))\n", "  (cond [(empty? l) #f]\n        [(and (member (list-ref\
    \ l 0) (cdr l))\n              (member (list-ref l 0) (cddr l))) #t]\n       \
    \ [else (triples_sum_to_zero (cdr l))]))\n", "  (cond\n    [(empty? l) #f]\n \
    \   [(and (member (list-ref l 0) (cdr l))\n          (member (list-ref l 0) (cddr\
    \ l))) #t]\n    [else (triples_sum_to_zero (cdr l))]))\n", "  (cond\n    [(empty?\
    \ l) #f]\n    [(and (member (car l) (cdr l)) (member (- (car l)) (cdr l))) #t]\n\
    \    [else (triples_sum_to_zero (cdr l))]))\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(and (member (list-ref l 0) (cdr l))\n          (member (list-ref l 0) (cddr\
    \ l))) #t]\n    [else (triples_sum_to_zero (cdr l))]))\n", "  (cond\n    [(null?\
    \ l) #f]\n    [(and (member (car l) (cdr l)) (member (- (car l)) (cdr l))) #t]\n\
    \    [else (triples_sum_to_zero (cdr l))]))\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(and (member (first l) (rest l)) (member (first l) (rest (rest l)))) #t]\n\
    \    [else (triples_sum_to_zero (rest l))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
