language: d
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(char c; s1)\n\
    \    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n\
    \    }\n    foreach(char c; s2)\n    {\n        if(c == '(')\n            c2++;\n\
    \        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0)\n    {\n        if(c2 % 2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c2 == 0)\n\
    \    {\n        if(c1 % 2 == 0)\n            return \"Yes\";\n        else\n \
    \           return \"No\";\n    }\n    if(c1 % 2 == 0 && c2 % 2 == 0)\n      \
    \  return \"Yes\";\n    if(c1 % 2 == 1 && c2 % 2 == 1)\n        return \"Yes\"\
    ;\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjlgu2avs.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpjlgu2avs.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjlgu2avs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count++;\n        else\n     \
    \       count--;\n        if(count < 0)\n            return \"No\";\n    }\n \
    \   count = 0;\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n    \
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpc4gokwpt.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x42908d]

    ??:? void tmpc4gokwpt.__unittest_L46_C1() [0x427cc8]

    ??:? void tmpc4gokwpt.__modtest() [0x4282f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428de6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a889]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a918]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a815]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dbd]

    ??:? runModuleUnitTests [0x42d7b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429550]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n     \
    \   foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n\
    \            else if(c == ')')\n                close++;\n        }\n    }\n \
    \   if(open == close)\n        return \"Yes\";\n    else\n        return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaa__vwd5.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmpaa__vwd5.__unittest_L36_C1() [0x4280ae]

    ??:? void tmpaa__vwd5.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ < 0 && count2 < 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n\
    \        return \"No\";\n    if(count1 > 0)\n    {\n        if(count1 == abs(count2))\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n    {\n        if(count2 == abs(count1))\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0_kagenb.d(71): unittest failure

    ----------------

    ??:? _d_unittestp [0x42914d]

    ??:? void tmp0_kagenb.__unittest_L58_C1() [0x4281e6]

    ??:? void tmp0_kagenb.__modtest() [0x4283b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ea6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a949]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e7d]

    ??:? runModuleUnitTests [0x42d871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429610]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0)\n    {\n        if(c2 > 0)\n            return \"\
    No\";\n        else\n            return \"Yes\";\n    }\n    if(c2 == 0)\n   \
    \ {\n        if(c1 > 0)\n            return \"No\";\n        else\n          \
    \  return \"Yes\";\n    }\n    if(c1 < 0 && c2 < 0)\n    {\n        if(c1 + c2\
    \ == 0)\n            return \"Yes\";\n        else\n            return \"No\"\
    ;\n    }\n    if(c1 > 0 && c2 > 0)\n    {\n        if(c1 + c2 == 0)\n        \
    \    return \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c1\
    \ > 0 && c2 < 0)\n    {\n        if(c1 + c2 == 0)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(c1 < 0 && c2 > 0)\n\
    \    {\n        if(c1 + c2 == 0)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuqf4kno3.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpuqf4kno3.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuqf4kno3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n\
    \            s1_close++;\n    }\n    foreach(char c; s2)\n    {\n        if(c\
    \ == '(')\n            s2_open++;\n        else\n            s2_close++;\n   \
    \ }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"Yes\"\
    ;\n    else if(s1_open == s1_close && s2_open != s2_close)\n    {\n        if(s2_open\
    \ > s2_close)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(s1_open != s1_close && s2_open == s2_close)\n    {\n\
    \        if(s1_open > s1_close)\n            return \"Yes\";\n        else\n \
    \           return \"No\";\n    }\n    else\n    {\n        if(s1_open > s1_close\
    \ && s2_open > s2_close)\n            return \"Yes\";\n        else\n        \
    \    return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp1g9o8qp.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290fd]

    ??:? void tmpp1g9o8qp.__unittest_L63_C1() [0x427d38]

    ??:? void tmpp1g9o8qp.__modtest() [0x428364]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da4b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8f9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a988]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a885]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e2d]

    ??:? runModuleUnitTests [0x42d821]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len = s1.length;\n\
    \    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open = 0;\n   \
    \ int s1_close = 0;\n    int s2_close = 0;\n    foreach(char c; s1)\n    {\n \
    \       if(c == '(')\n            s1_open++;\n        else\n            s1_close++;\n\
    \    }\n    foreach(char c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n\
    \        else\n            s2_close++;\n    }\n    if(s1_open == s1_close && s2_open\
    \ == s2_close)\n        return \"Yes\";\n    else if(s1_open == s1_close && s2_open\
    \ > s2_close)\n    {\n        if(s2_open - s2_close == s1_close)\n           \
    \ return \"Yes\";\n        else\n            return \"No\";\n    }\n    else if(s1_open\
    \ == s1_close && s2_open < s2_close)\n    {\n        if(s1_open == s2_close -\
    \ s2_open)\n            return \"Yes\";\n        else\n            return \"No\"\
    ;\n    }\n    else if(s1_open > s1_close && s2_open == s2_close)\n    {\n    \
    \    if(s1_open - s1_close == s2_close)\n            return \"Yes\";\n       \
    \ else\n            return \"No\";\n    }\n    else if(s1_open < s1_close && s2_open\
    \ == s2_close)\n    {\n        if(s2_open == s1_close - s1_open)\n           \
    \ return \"Yes\";\n        else\n            return \"No\";\n    }\n    else if(s1_open\
    \ > s1_close && s2_open > s2_close)\n    {\n        if(s1_open - s1_close == s2_open\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpge85bpwg.d(74): Error: found `unittest` when expecting `)`

    /tmp/tmpge85bpwg.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpge85bpwg.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpge85bpwg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 > 0 && count2 < 0 && abs(count1) == abs(count2))\n        return \"\
    Yes\";\n    else if(count1 < 0 && count2 > 0 && abs(count1) == abs(count2))\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvanzkz38.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x429145]

    ??:? void tmpvanzkz38.__unittest_L46_C1() [0x4281e2]

    ??:? void tmpvanzkz38.__modtest() [0x4283b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a941]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e75]

    ??:? runModuleUnitTests [0x42d869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429608]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ < 0 && count2 < 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n\
    \        return \"No\";\n    if(count1 < 0 && count2 > 0)\n    {\n        if(count1.abs()\
    \ % 2 == 0)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    if(count1 > 0 && count2 < 0)\n    {\n        if(count2.abs()\
    \ % 2 == 0)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp07m0fc9b.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x42917d]

    ??:? void tmp07m0fc9b.__unittest_L59_C1() [0x427da8]

    ??:? void tmp07m0fc9b.__modtest() [0x4283e8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dacb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ed6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a979]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa08]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a905]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ead]

    ??:? runModuleUnitTests [0x42d8a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429640]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close && s2_open < s2_close)\n        return \"No\";\n    else if(s1_open\
    \ < s1_close && s2_open == s2_close)\n        return \"No\";\n    else if(s1_open\
    \ < s1_close && s2_open < s2_close)\n        return \"No\";\n    else if(s1_open\
    \ > s1_close && s2_open > s2_close)\n        return \"No\";\n    else if(s1_open\
    \ > s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close && s2_open > s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ > s1_close && s2_open < s2_close)\n        return \"Yes\";\n    else\n     \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiki7ctkl.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x42914d]

    ??:? void tmpiki7ctkl.__unittest_L58_C1() [0x427e98]

    ??:? void tmpiki7ctkl.__modtest() [0x4283b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ea6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a949]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e7d]

    ??:? runModuleUnitTests [0x42d871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429610]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n    return\
    \ s.count('(') == s.count(')') ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxin8n4ph.d(22): Error: no property `count` for type `string`

    /tmp/tmpxin8n4ph.d(22): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxin8n4ph.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0]\
    \ = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (i <= n1)\n      \
    \  {\n            dp[i] = dp[i - 1] + (s1[i - 1] == '(' ? 1 : -1);\n        }\n\
    \        else\n        {\n            dp[i] = dp[i - 1] + (s2[i - n1 - 1] == '('\
    \ ? 1 : -1);\n        }\n    }\n    int min = dp[n];\n    for (int i = 0; i <=\
    \ n; i++)\n    {\n        min = min(min, dp[i]);\n    }\n    return min >= 0 ?\
    \ \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm3our9d8.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpm3our9d8.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmpm3our9d8.d(40): Error: function expected before `()`, not `min` of type
    `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm3our9d8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = count(s1, '(');\n\
    \    int c2 = count(s2, '(');\n    int c3 = count(s1, ')');\n    int c4 = count(s2,\
    \ ')');\n    if (c1 == c3 && c2 == c4)\n        return \"Yes\";\n    else\n  \
    \      return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvcmwirpm.d(21): Error: undefined identifier `count`

    /tmp/tmpvcmwirpm.d(22): Error: undefined identifier `count`

    /tmp/tmpvcmwirpm.d(23): Error: undefined identifier `count`

    /tmp/tmpvcmwirpm.d(24): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvcmwirpm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else\n    {\n        int count\
    \ = 0;\n        foreach(c; s1)\n        {\n            if(c == '(')\n        \
    \        count++;\n            else\n                count--;\n            if(count\
    \ < 0)\n                return \"No\";\n        }\n        count = 0;\n      \
    \  foreach(c; s2)\n        {\n            if(c == '(')\n                count++;\n\
    \            else\n                count--;\n            if(count < 0)\n     \
    \           return \"No\";\n        }\n        return \"Yes\";\n    }\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvaevb231.d(72): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291d5]

    ??:? void tmpvaevb231.__unittest_L68_C1() [0x427e10]

    ??:? void tmpvaevb231.__modtest() [0x42843c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f2e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a95d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f05]

    ??:? runModuleUnitTests [0x42d8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429698]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n \
    \           count1--;\n    }\n    foreach(char c; s2)\n    {\n        if(c ==\
    \ '(')\n            count2++;\n        else\n            count2--;\n    }\n  \
    \  if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == 0\
    \ && count2 != 0)\n    {\n        if(count2 % 2 == 0)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(count1 != 0 && count2\
    \ == 0)\n    {\n        if(count1 % 2 == 0)\n            return \"Yes\";\n   \
    \     else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 !=\
    \ 0)\n    {\n        if(count1 % 2 == 0 && count2 % 2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ou7o2q_.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp7ou7o2q_.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ou7o2q_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return\
    \ \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(abs(count1)\
    \ != abs(count2))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr77mxd1s.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x429165]

    ??:? void tmpr77mxd1s.__unittest_L51_C1() [0x4281fe]

    ??:? void tmpr77mxd1s.__modtest() [0x4283cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ebe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a961]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e95]

    ??:? runModuleUnitTests [0x42d889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429628]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string str1 = lst[0];\n    string str2 = lst[1];\n    int count1 = 0;\n    int\
    \ count2 = 0;\n    foreach(char c; str1)\n    {\n        if(c == '(')\n      \
    \      count1++;\n        else\n            count1--;\n    }\n    foreach(char\
    \ c; str2)\n    {\n        if(c == '(')\n            count2++;\n        else\n\
    \            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else if(count1 == 0 && count2 != 0)\n    {\n        if(count2\
    \ % 2 == 0)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(count1 != 0 && count2 == 0)\n    {\n        if(count1\
    \ % 2 == 0)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else\n    {\n        if(count1 % 2 == 0 && count2 % 2 == 0)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkt6_tw0d.d(65): unittest failure

    ----------------

    ??:? _d_unittestp [0x42910d]

    ??:? void tmpkt6_tw0d.__unittest_L61_C1() [0x427d48]

    ??:? void tmpkt6_tw0d.__modtest() [0x428374]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e66]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a909]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a998]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a895]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e3d]

    ??:? runModuleUnitTests [0x42d831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295d0]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n\
    \        else\n            s1_open--;\n        if(s1_open < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  s2_open++;\n        else\n            s2_open--;\n        if(s2_open < 0)\n\
    \            return \"No\";\n    }\n    if(s1_open == 0 && s2_open == 0)\n   \
    \     return \"Yes\";\n    if(s1_open == 0 || s2_open == 0)\n        return \"\
    No\";\n    if(s1_open == s2_open)\n        return \"Yes\";\n    if(s1_open > s2_open)\n\
    \        return match_parens([s1[0..$-s2_open], s2]);\n    else\n        return\
    \ match_parens([s1, s2[0..$-s1_open]]);\n}\nunittest\n{\n    alias candidate =\
    \ match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplvh39b9m.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291c5]

    ??:? void tmplvh39b9m.__unittest_L52_C1() [0x427e04]

    ??:? void tmplvh39b9m.__modtest() [0x428430]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9c1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa50]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a94d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ef5]

    ??:? runModuleUnitTests [0x42d8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429688]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n   \
    \     else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1\
    \ == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2 != 0)\n    \
    \    return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"No\";\n    if(c1\
    \ < 0 && c2 > 0)\n        return \"No\";\n    if(c1 > 0 && c2 < 0)\n        return\
    \ \"No\";\n    if(c1 > 0 && c2 > 0)\n    {\n        if(c1 > c2)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c1 < 0 &&\
    \ c2 < 0)\n    {\n        if(c1 > c2)\n            return \"No\";\n        else\n\
    \            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvl8njrpk.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmpvl8njrpk.__unittest_L63_C1() [0x427d78]

    ??:? void tmpvl8njrpk.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int open1 = 0;\n    int open2 = 0;\n    int close1\
    \ = 0;\n    int close2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            open1++;\n        else\n            close1++;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            open2++;\n        else\n     \
    \       close2++;\n    }\n    if(open1 == close1 && open2 == close2)\n       \
    \ return \"Yes\";\n    if(open1 == close1)\n    {\n        if(open2 > close2)\n\
    \        {\n            if(open2 - close2 == abs(open1 - close1))\n          \
    \      return \"Yes\";\n        }\n        else\n        {\n            if(close2\
    \ - open2 == abs(open1 - close1))\n                return \"Yes\";\n        }\n\
    \    }\n    if(open2 == close2)\n    {\n        if(open1 > close1)\n        {\n\
    \            if(open1 - close1 == abs(open2 - close2))\n                return\
    \ \"Yes\";\n        }\n        else\n        {\n            if(close1 - open1\
    \ == abs(open2 - close2))\n                return \"Yes\";\n        }\n    }\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0qhq8f2_.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp0qhq8f2_.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0qhq8f2_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n\
    \            s1_close++;\n    }\n    foreach(char c; s2)\n    {\n        if(c\
    \ == '(')\n            s2_open++;\n        else\n            s2_close++;\n   \
    \ }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"Yes\"\
    ;\n    else if(s1_open == s1_close && s2_open > s2_close)\n    {\n        if(s2_open\
    \ - s2_close == s1_open)\n            return \"Yes\";\n        else\n        \
    \    return \"No\";\n    }\n    else if(s1_open > s1_close && s2_open == s2_close)\n\
    \    {\n        if(s1_open - s1_close == s2_open)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    else if(s1_open > s1_close\
    \ && s2_open > s2_close)\n    {\n        if(s1_open - s1_close == s2_open - s2_close)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgbj10dnf.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x429125]

    ??:? void tmpgbj10dnf.__unittest_L65_C1() [0x427d60]

    ??:? void tmpgbj10dnf.__modtest() [0x42838c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a921]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e55]

    ??:? runModuleUnitTests [0x42d849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = lst[0] ~ lst[1];\n    int c = 0;\n    foreach(c; s)\n    {\n    \
    \    if(c == '(')\n            c++;\n        else if(c == ')')\n            c--;\n\
    \        if(c < 0)\n            return \"No\";\n    }\n    return c == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp61ocv8rg.d(21): Error: variable `c` is shadowing variable `tmp61ocv8rg.match_parens.c`

    /tmp/tmp61ocv8rg.d(24): Error: cannot modify `immutable` expression `c`

    /tmp/tmp61ocv8rg.d(26): Error: cannot modify `immutable` expression `c`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61ocv8rg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n\
    \        if(c == '(')\n            count++;\n        else\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnn90gifm.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnn90gifm.__unittest_L32_C1() [0x427dee]

    ??:? void tmpnn90gifm.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(char c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(char c; s2)\n    {\n\
    \        if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 < 0 && count2 > 0)\n        return \"Yes\";\n    else if(count1 >\
    \ 0 && count2 < 0)\n        return \"Yes\";\n    else\n        return \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppl_uka4b.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmppl_uka4b.__unittest_L46_C1() [0x427ddc]

    ??:? void tmppl_uka4b.__modtest() [0x4282fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len = s1.length;\n\
    \    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open = 0;\n   \
    \ int s1_close = 0;\n    int s2_close = 0;\n    int s1_open_close = 0;\n    int\
    \ s2_open_close = 0;\n    int s1_close_open = 0;\n    int s2_close_open = 0;\n\
    \    int s1_open_open = 0;\n    int s2_open_open = 0;\n    int s1_close_close\
    \ = 0;\n    int s2_close_close = 0;\n    int s1_open_close_open = 0;\n    int\
    \ s2_open_close_open = 0;\n    int s1_close_open_close = 0;\n    int s2_close_open_close\
    \ = 0;\n    int s1_open_open_close = 0;\n    int s2_open_open_close = 0;\n   \
    \ int s1_close_open_open = 0;\n    int s2_close_open_open = 0;\n    int s1_open_close_close\
    \ = 0;\n    int s2_open_close_close = 0;\n    int s1_close_close_open = 0;\n \
    \   int s2_close_close_open = 0;\n    int s1_open_open_open = 0;\n    int s2_open_open_open\
    \ = 0;\n    int s1_close_close_close = 0;\n    int s2_close_close_close = 0;\n\
    \    int s1_open_open_close_open = 0;\n    int s2_open_open_close_open = 0;\n\
    \    int s1_close_open_open_close = 0;\n    int s2_close_open_open_close = 0;\n\
    \    int s1_open_close_open_close = 0;\n    int s2_open_close_open_close = 0;\n\
    \    int s1_\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxsycvopy.d(58): Error: semicolon expected, not `unittest`

    /tmp/tmpxsycvopy.d(58): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxsycvopy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n\
    \            s1_close++;\n    }\n    foreach(char c; s2)\n    {\n        if(c\
    \ == '(')\n            s2_open++;\n        else\n            s2_close++;\n   \
    \ }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"Yes\"\
    ;\n    if(s1_open == s1_close && s2_open != s2_close)\n        return \"No\";\n\
    \    if(s1_open != s1_close && s2_open == s2_close)\n        return \"No\";\n\
    \    if(s1_open != s1_close && s2_open != s2_close)\n    {\n        if(s1_open\
    \ > s1_close)\n        {\n            if(s2_open > s2_close)\n               \
    \ return \"No\";\n            else\n                return \"Yes\";\n        }\n\
    \        else\n        {\n            if(s2_open > s2_close)\n               \
    \ return \"Yes\";\n            else\n                return \"No\";\n        }\n\
    \    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd2j7z9vp.d(70): unittest failure

    ----------------

    ??:? _d_unittestp [0x429115]

    ??:? void tmpd2j7z9vp.__unittest_L64_C1() [0x427e60]

    ??:? void tmpd2j7z9vp.__modtest() [0x428380]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a911]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a89d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e45]

    ??:? runModuleUnitTests [0x42d839]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == 0 && count2\
    \ != 0)\n    {\n        if(count2 % 2 == 0)\n            return \"Yes\";\n   \
    \     else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 ==\
    \ 0)\n    {\n        if(count1 % 2 == 0)\n            return \"Yes\";\n      \
    \  else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 != 0)\n\
    \    {\n        if(count1 % 2 == 0 && count2 % 2 == 0)\n            return \"\
    Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ptqd4ww.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp4ptqd4ww.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ptqd4ww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n\
    \        if(c == '(')\n            count++;\n        else\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnn90gifm.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnn90gifm.__unittest_L32_C1() [0x427dee]

    ??:? void tmpnn90gifm.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    auto n\
    \ = s.length;\n    auto cnt = 0;\n    foreach(i; 0 .. n)\n    {\n        if(s[i]\
    \ == '(')\n            cnt++;\n        else\n            cnt--;\n        if(cnt\
    \ < 0)\n            return \"No\";\n    }\n    if(cnt == 0)\n        return \"\
    Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxw45dusa.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpxw45dusa.__unittest_L38_C1() [0x427e1a]

    ??:? void tmpxw45dusa.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 + s2;\n    int\
    \ cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n\
    \        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n        \
    \    return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ox_2l5o.d(21): Error: invalid array operation `s1 + s2` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ox_2l5o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0]\
    \ = 0;\n    foreach (i; 0 .. n)\n    {\n        if (i < n1)\n        {\n     \
    \       dp[i + 1] = dp[i] + (s1[i] == '(' ? 1 : -1);\n        }\n        else\n\
    \        {\n            dp[i + 1] = dp[i] + (s2[i - n1] == '(' ? 1 : -1);\n  \
    \      }\n    }\n    return dp.min > 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvyqmxr0p.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpvyqmxr0p.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmpvyqmxr0p.d(37): Error: no property `min` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvyqmxr0p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == count2)\n  \
    \      return \"Yes\";\n    if(count1 == -count2)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4murz53f.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp4murz53f.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4murz53f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n     \
    \   foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n\
    \            else\n                close++;\n        }\n    }\n    if(open ==\
    \ close)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiujzosjp.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmpiujzosjp.__unittest_L36_C1() [0x4280aa]

    ??:? void tmpiujzosjp.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n   \
    \     else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1\
    \ == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2 != 0)\n    \
    \    return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"No\";\n    if(c1\
    \ > 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 && c2 > 0)\n        return\
    \ \"No\";\n    if(c1 > 0 && c2 > 0)\n        return \"Yes\";\n    if(c1 < 0 &&\
    \ c2 < 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0hnwrfo.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x429105]

    ??:? void tmpt0hnwrfo.__unittest_L53_C1() [0x427d44]

    ??:? void tmpt0hnwrfo.__modtest() [0x428370]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a901]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a990]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a88d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e35]

    ??:? runModuleUnitTests [0x42d829]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n    int[]\
    \ b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n    int[]\
    \ e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n    int[]\
    \ h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n    int[]\
    \ k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n    int[]\
    \ nn = new int[n];\n    int[] o = new int[n];\n    int[] p = new int[n];\n   \
    \ int[] q = new int[n];\n    int[] r = new int[n];\n    int[] s = new int[n];\n\
    \    int[] t = new int[n];\n    int[] u = new int[n];\n    int[] v = new int[n];\n\
    \    int[] w = new int[n];\n    int[] x = new int[n];\n    int[] y = new int[n];\n\
    \    int[] z = new int[n];\n    int[] A = new int[n];\n    int[] B = new int[n];\n\
    \    int[] C = new int[n];\n    int[] D = new int[n];\n    int[] E = new int[n];\n\
    \    int[] F = new int[n];\n    int[] G = new int[n];\n    int[] H = new int[n];\n\
    \    int[] I = new int[n];\n    int[] J = new int[n];\n    int[] K = new int[n];\n\
    \    int[] L = new int[n];\n    int[] M = new int[n];\n    int[] N = new int[n];\n\
    \    int[] O = new int[n];\n    int\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp19wpsfbe.d(66): Error: no identifier for declarator `int`

    /tmp/tmp19wpsfbe.d(66): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp19wpsfbe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close && s2_open != s2_close)\n        return \"No\";\n    else if(s1_open\
    \ != s1_close && s2_open == s2_close)\n        return \"No\";\n    else if(s1_open\
    \ != s1_close && s2_open != s2_close)\n    {\n        if(abs(s1_open - s1_close)\
    \ == abs(s2_open - s2_close))\n            return \"Yes\";\n        else\n   \
    \         return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpihpo0whv.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x429165]

    ??:? void tmpihpo0whv.__unittest_L54_C1() [0x427e1a]

    ??:? void tmpihpo0whv.__modtest() [0x4283cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ebe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a961]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e95]

    ??:? runModuleUnitTests [0x42d889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429628]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n        if(count1 < 0)\n            return \"No\";\n    }\n\
    \    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n    \
    \    else\n            count2--;\n        if(count2 < 0)\n            return \"\
    No\";\n    }\n    if(count1 == count2)\n        return \"Yes\";\n    else\n  \
    \      return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj1u3fv4f.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpj1u3fv4f.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj1u3fv4f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = lst[0] ~ lst[1];\n    int c = 0;\n    foreach(c; s)\n    {\n    \
    \    if(c == '(')\n            c++;\n        else if(c == ')')\n            c--;\n\
    \        if(c < 0)\n            return \"No\";\n    }\n    return c == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp61ocv8rg.d(21): Error: variable `c` is shadowing variable `tmp61ocv8rg.match_parens.c`

    /tmp/tmp61ocv8rg.d(24): Error: cannot modify `immutable` expression `c`

    /tmp/tmp61ocv8rg.d(26): Error: cannot modify `immutable` expression `c`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61ocv8rg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == count2)\n  \
    \      return \"Yes\";\n    if(count1 > 0 && count2 > 0)\n        return \"No\"\
    ;\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1 > 0\
    \ && count2 < 0)\n    {\n        if(count1 == -count2)\n            return \"\
    Yes\";\n        else if(count1 > -count2)\n            return \"No\";\n      \
    \  else\n            return \"Yes\";\n    }\n    if(count1 < 0 && count2 > 0)\n\
    \    {\n        if(count2 == -count1)\n            return \"Yes\";\n        else\
    \ if(count2 > -count1)\n            return \"No\";\n        else\n           \
    \ return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmperhm3tm5.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmperhm3tm5.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmperhm3tm5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(char c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(char c; s2)\n    {\n\
    \        if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ < 0 && count2 < 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n\
    \        return \"No\";\n    if(count1 > 0)\n    {\n        if(count1 == abs(count2))\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n    {\n        if(count2 == abs(count1))\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbqctxkj1.d(71): unittest failure

    ----------------

    ??:? _d_unittestp [0x42914d]

    ??:? void tmpbqctxkj1.__unittest_L58_C1() [0x4281e6]

    ??:? void tmpbqctxkj1.__modtest() [0x4283b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ea6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a949]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e7d]

    ??:? runModuleUnitTests [0x42d871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429610]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n   \
    \     else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1\
    \ == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2 != 0)\n    \
    \    return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"No\";\n    if(c1\
    \ > 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 && c2 > 0)\n        return\
    \ \"No\";\n    if(c1 > 0 && c2 > 0)\n        return \"Yes\";\n    if(c1 < 0 &&\
    \ c2 < 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0hnwrfo.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x429105]

    ??:? void tmpt0hnwrfo.__unittest_L53_C1() [0x427d44]

    ??:? void tmpt0hnwrfo.__modtest() [0x428370]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a901]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a990]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a88d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e35]

    ??:? runModuleUnitTests [0x42d829]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return\
    \ \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1\
    \ < 0 && count2 > 0)\n    {\n        if(abs(count1) == count2)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1 > 0\
    \ && count2 < 0)\n    {\n        if(count1 == abs(count2))\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7fyo_ve3.d(76): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291a5]

    ??:? void tmp7fyo_ve3.__unittest_L63_C1() [0x428242]

    ??:? void tmp7fyo_ve3.__modtest() [0x428410]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42daf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428efe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a92d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ed5]

    ??:? runModuleUnitTests [0x42d8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429668]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n    int count\
    \ = 0;\n    foreach(char c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpllpanepf.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmpllpanepf.__unittest_L34_C1() [0x427e02]

    ??:? void tmpllpanepf.__modtest() [0x4282a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b261]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42e189]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42948c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n\
    \        {\n            if(c == '(')\n                count++;\n            else\n\
    \                count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnjaa2nhu.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpnjaa2nhu.__unittest_L34_C1() [0x427dda]

    ??:? void tmpnjaa2nhu.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count++;\n        else\n     \
    \       count--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n   \
    \         count++;\n        else\n            count--;\n    }\n    if(count ==\
    \ 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp39ltquds.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmp39ltquds.__unittest_L41_C1() [0x428102]

    ??:? void tmp39ltquds.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == c2)\n        return \"Yes\";\n    if(c1 < 0 && c2 > 0)\n\
    \        return \"Yes\";\n    if(c1 > 0 && c2 < 0)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdb1s3jdy.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpdb1s3jdy.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdb1s3jdy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else\n    {\n        if(count1\
    \ > 0)\n        {\n            if(count2 > 0)\n            {\n               \
    \ if(count1 > count2)\n                    return \"Yes\";\n                else\n\
    \                    return \"No\";\n            }\n            else\n       \
    \     {\n                if(count1 > abs(count2))\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n        }\n        else\n        {\n            if(count2 > 0)\n    \
    \        {\n                if(abs(count1) > count2)\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n            else\n            {\n                if(abs(count1) > abs(count2))\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n    }\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1eo6cyti.d(85): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291c5]

    ??:? void tmp1eo6cyti.__unittest_L81_C1() [0x427df0]

    ??:? void tmp1eo6cyti.__modtest() [0x428430]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9c1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa50]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a94d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ef5]

    ??:? runModuleUnitTests [0x42d8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429688]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n     \
    \   foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n\
    \            else if(c == ')')\n                close++;\n        }\n    }\n \
    \   return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxb29gm6x.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmpxb29gm6x.__unittest_L33_C1() [0x4280aa]

    ??:? void tmpxb29gm6x.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int open1 = 0;\n    int open2 = 0;\n    int close1 = 0;\n\
    \    int close2 = 0;\n    foreach(char c; s1)\n    {\n        if(c == '(')\n \
    \           open1++;\n        else\n            close1++;\n    }\n    foreach(char\
    \ c; s2)\n    {\n        if(c == '(')\n            open2++;\n        else\n  \
    \          close2++;\n    }\n    if(open1 == close1 && open2 == close2)\n    \
    \    return \"Yes\";\n    if(open1 == close1 && open2 != close2)\n    {\n    \
    \    if(open2 > close2)\n            return \"Yes\";\n        else\n         \
    \   return \"No\";\n    }\n    if(open1 != close1 && open2 == close2)\n    {\n\
    \        if(open1 > close1)\n            return \"Yes\";\n        else\n     \
    \       return \"No\";\n    }\n    if(open1 > close1 && open2 > close2)\n    \
    \    return \"Yes\";\n    if(open1 < close1 && open2 < close2)\n        return\
    \ \"Yes\";\n    if(open1 > close1 && open2 < close2)\n    {\n        if(open1\
    \ - close1 == close2 - open2)\n            return \"Yes\";\n        else\n   \
    \         return \"No\";\n    }\n    if(open1 < close1 && open2 > close2)\n  \
    \  {\n        if(open2 - close2 == close1 - open1)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgc11986n.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpgc11986n.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgc11986n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = lst[0] ~ lst[1];\n    int c = 0;\n    foreach(c; s)\n    {\n    \
    \    if(c == '(')\n            c++;\n        else if(c == ')')\n            c--;\n\
    \        if(c < 0)\n            return \"No\";\n    }\n    return c == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp61ocv8rg.d(21): Error: variable `c` is shadowing variable `tmp61ocv8rg.match_parens.c`

    /tmp/tmp61ocv8rg.d(24): Error: cannot modify `immutable` expression `c`

    /tmp/tmp61ocv8rg.d(26): Error: cannot modify `immutable` expression `c`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61ocv8rg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    auto n\
    \ = s.length;\n    auto cnt = 0;\n    foreach(i; 0 .. n)\n    {\n        if(s[i]\
    \ == '(')\n            cnt++;\n        else\n            cnt--;\n        if(cnt\
    \ < 0)\n            return \"No\";\n    }\n    if(cnt == 0)\n        return \"\
    Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxw45dusa.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpxw45dusa.__unittest_L38_C1() [0x427e1a]

    ??:? void tmpxw45dusa.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n    int[]\
    \ b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n    int[]\
    \ e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n    int[]\
    \ h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n    int[]\
    \ k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n    int[]\
    \ nn = new int[n];\n    int[] o = new int[n];\n    int[] p = new int[n];\n   \
    \ int[] q = new int[n];\n    int[] r = new int[n];\n    int[] s = new int[n];\n\
    \    int[] t = new int[n];\n    int[] u = new int[n];\n    int[] v = new int[n];\n\
    \    int[] w = new int[n];\n    int[] x = new int[n];\n    int[] y = new int[n];\n\
    \    int[] z = new int[n];\n    int[] aa = new int[n];\n    int[] bb = new int[n];\n\
    \    int[] cc = new int[n];\n    int[] dd = new int[n];\n    int[] ee = new int[n];\n\
    \    int[] ff = new int[n];\n    int[] gg = new int[n];\n    int[] hh = new int[n];\n\
    \    int[] ii = new int[n];\n    int[] jj = new int[n];\n    int[] kk = new int[n];\n\
    \    int[] ll = new int[n];\n    int[] mm = new int[n];\n    int[] nnn = new int[n];\n\
    \    int[] oo\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5k2dhb76.d(65): Error: semicolon expected, not `unittest`

    /tmp/tmp5k2dhb76.d(65): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5k2dhb76.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n        if(count1 < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  count2++;\n        else\n            count2--;\n        if(count2 < 0)\n  \
    \          return \"No\";\n    }\n    if(count1 == 0 && count2 == 0)\n       \
    \ return \"Yes\";\n    if(count1 == count2)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpobqkgek6.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290a5]

    ??:? void tmpobqkgek6.__unittest_L47_C1() [0x427ce0]

    ??:? void tmpobqkgek6.__modtest() [0x42830c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9f3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dfe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a930]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a82d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dd5]

    ??:? runModuleUnitTests [0x42d7c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429568]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close)\n    {\n        if(s2_open > s2_close)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    else if(s2_open == s2_close)\n\
    \    {\n        if(s1_open > s1_close)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    else\n        return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeh2gfu8w.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290cd]

    ??:? void tmpeh2gfu8w.__unittest_L58_C1() [0x427d08]

    ??:? void tmpeh2gfu8w.__modtest() [0x428334]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a958]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a855]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dfd]

    ??:? runModuleUnitTests [0x42d7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429590]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n    return\
    \ s.count('(') == s.count(')') ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxin8n4ph.d(22): Error: no property `count` for type `string`

    /tmp/tmpxin8n4ph.d(22): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxin8n4ph.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            count++;\n        else\n  \
    \          count--;\n    }\n    foreach(char c; s2)\n    {\n        if(c == '(')\n\
    \            count++;\n        else\n            count--;\n    }\n    if(count\
    \ == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9kwb3ftb.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmp9kwb3ftb.__unittest_L40_C1() [0x428102]

    ??:? void tmp9kwb3ftb.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n    int[]\
    \ b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n    int[]\
    \ e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n    int[]\
    \ h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n    int[]\
    \ k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n    int[]\
    \ o = new int[n];\n    int[] p = new int[n];\n    int[] q = new int[n];\n    int[]\
    \ r = new int[n];\n    int[] s = new int[n];\n    int[] t = new int[n];\n    int[]\
    \ u = new int[n];\n    int[] v = new int[n];\n    int[] w = new int[n];\n    int[]\
    \ x = new int[n];\n    int[] y = new int[n];\n    int[] z = new int[n];\n    int[]\
    \ A = new int[n];\n    int[] B = new int[n];\n    int[] C = new int[n];\n    int[]\
    \ D = new int[n];\n    int[] E = new int[n];\n    int[] F = new int[n];\n    int[]\
    \ G = new int[n];\n    int[] H = new int[n];\n    int[] I = new int[n];\n    int[]\
    \ J = new int[n];\n    int[] K = new int[n];\n    int[] L = new int[n];\n    int[]\
    \ M = new int[n];\n    int[] N = new int[n];\n    int[] O = new int[n];\n    int[]\
    \ P = new int[n];\n    int[]\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpps4bdgkd.d(66): Error: no identifier for declarator `int[]`

    /tmp/tmpps4bdgkd.d(66): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpps4bdgkd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return\
    \ \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(abs(count1)\
    \ == abs(count2))\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_rr28573.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x429165]

    ??:? void tmp_rr28573.__unittest_L51_C1() [0x4281fe]

    ??:? void tmp_rr28573.__modtest() [0x4283cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ebe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a961]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e95]

    ??:? runModuleUnitTests [0x42d889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429628]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n\
    \            s1_close++;\n    }\n    foreach(char c; s2)\n    {\n        if(c\
    \ == '(')\n            s2_open++;\n        else\n            s2_close++;\n   \
    \ }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"Yes\"\
    ;\n    if(s1_open == s1_close && s2_open > s2_close)\n        return \"Yes\";\n\
    \    if(s2_open == s2_close && s1_open > s1_close)\n        return \"Yes\";\n\
    \    if(s1_open > s1_close && s2_open > s2_close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n \
    \           count1--;\n    }\n    foreach(char c; s2)\n    {\n        if(c ==\
    \ '(')\n            count2++;\n        else\n            count2--;\n    }\n  \
    \  if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == 0\
    \ && count2 != 0)\n    {\n        if(count2 % 2 == 0)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(count1 != 0 && count2\
    \ == 0)\n    {\n        if(count1 % 2 == 0)\n            return \"Yes\";\n   \
    \     else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 !=\
    \ 0)\n    {\n        if(count1 % 2 == 0 && count2 % 2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ou7o2q_.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp7ou7o2q_.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ou7o2q_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] arr = new int[n];\n    int\
    \ i = 0;\n    int j = 0;\n    int k = 0;\n    int cnt = 0;\n    while (i < n1)\n\
    \    {\n        if (s1[i] == '(')\n        {\n            cnt++;\n        }\n\
    \        else\n        {\n            cnt--;\n        }\n        arr[k] = cnt;\n\
    \        i++;\n        k++;\n    }\n    while (j < n2)\n    {\n        if (s2[j]\
    \ == '(')\n        {\n            cnt++;\n        }\n        else\n        {\n\
    \            cnt--;\n        }\n        arr[k] = cnt;\n        j++;\n        k++;\n\
    \    }\n    int min = arr[0];\n    for (int l = 1; l < n; l++)\n    {\n      \
    \  if (arr[l] < min)\n        {\n            min = arr[l];\n        }\n    }\n\
    \    if (min >= 0)\n    {\n        return \"Yes\";\n    }\n    else\n    {\n \
    \       return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3jw6oxoi.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp3jw6oxoi.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3jw6oxoi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ + s2_open == s1_close + s2_close)\n        return \"Yes\";\n    else\n     \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf5rnx4e6.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x429065]

    ??:? void tmpf5rnx4e6.__unittest_L44_C1() [0x428112]

    ??:? void tmpf5rnx4e6.__modtest() [0x4282cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a861]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d95]

    ??:? runModuleUnitTests [0x42d789]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429528]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 < 0 && count2 < 0)\n        return\
    \ \"No\";\n    if(count1 > 0 && count2 > 0)\n        return \"No\";\n    if(count1\
    \ > 0 && count2 < 0)\n    {\n        if(abs(count1) == abs(count2))\n        \
    \    return \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1\
    \ < 0 && count2 > 0)\n    {\n        if(abs(count1) == abs(count2))\n        \
    \    return \"Yes\";\n        else\n            return \"No\";\n    }\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptgr2owf0.d(76): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291ed]

    ??:? void tmptgr2owf0.__unittest_L63_C1() [0x428286]

    ??:? void tmptgr2owf0.__modtest() [0x428454]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9e9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a975]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f1d]

    ??:? runModuleUnitTests [0x42d911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296b0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n  \
    \      if(c == '(')\n            cnt++;\n        else\n            cnt--;\n  \
    \      if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz0qmix39.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpz0qmix39.__unittest_L32_C1() [0x427dee]

    ??:? void tmpz0qmix39.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close && s2_open > s2_close)\n    {\n        if(s2_open - s2_close ==\
    \ s1_open)\n            return \"Yes\";\n        else\n            return \"No\"\
    ;\n    }\n    else if(s1_open > s1_close && s2_open == s2_close)\n    {\n    \
    \    if(s1_open - s1_close == s2_open)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    else if(s1_open > s1_close && s2_open\
    \ > s2_close)\n    {\n        if(s1_open - s1_close == s2_open - s2_close)\n \
    \           return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqgk95enj.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x429125]

    ??:? void tmpqgk95enj.__unittest_L65_C1() [0x427d60]

    ??:? void tmpqgk95enj.__modtest() [0x42838c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a921]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e55]

    ??:? runModuleUnitTests [0x42d849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0]\
    \ = 0;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = dp[i - 1];\n     \
    \   if (i <= n1 && s1[i - 1] == '(') {\n            dp[i]++;\n        }\n    \
    \    if (i <= n2 && s2[i - 1] == '(') {\n            dp[i]++;\n        }\n   \
    \     if (i > n1 && s1[i - n1 - 1] == ')') {\n            dp[i]--;\n        }\n\
    \        if (i > n2 && s2[i - n2 - 1] == ')') {\n            dp[i]--;\n      \
    \  }\n    }\n    return dp.canFind!(x => x == 0) ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi4009gap.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpi4009gap.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmpi4009gap.d(41): Error: no property `canFind` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi4009gap.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == count2)\n  \
    \      return \"Yes\";\n    if(count1 == -count2)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4murz53f.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp4murz53f.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4murz53f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string a = lst[0];\n    string b = lst[1];\n    int a_count = 0;\n    int b_count\
    \ = 0;\n    foreach(c; a)\n    {\n        if(c == '(')\n            a_count++;\n\
    \        else\n            a_count--;\n    }\n    foreach(c; b)\n    {\n     \
    \   if(c == '(')\n            b_count++;\n        else\n            b_count--;\n\
    \    }\n    if(a_count == 0 && b_count == 0)\n        return \"Yes\";\n    if(a_count\
    \ == 0)\n        return b_count > 0 ? \"Yes\" : \"No\";\n    if(b_count == 0)\n\
    \        return a_count > 0 ? \"Yes\" : \"No\";\n    if(a_count > 0 && b_count\
    \ > 0)\n        return a_count == b_count ? \"Yes\" : \"No\";\n    if(a_count\
    \ < 0 && b_count < 0)\n        return a_count == b_count ? \"Yes\" : \"No\";\n\
    \    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4seblb6n.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x429115]

    ??:? void tmp4seblb6n.__unittest_L49_C1() [0x427dde]

    ??:? void tmp4seblb6n.__modtest() [0x42837c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a911]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a89d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e45]

    ??:? runModuleUnitTests [0x42d839]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ auto s = lst[0] ~ lst[1];\n    auto c = 0;\n    foreach(c; s)\n    {\n     \
    \   if(c == '(')\n            c++;\n        else if(c > 0)\n            c--;\n\
    \        else\n            return \"No\";\n    }\n    return c == 0 ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbu97xjx9.d(21): Error: variable `c` is shadowing variable `tmpbu97xjx9.match_parens.c`

    /tmp/tmpbu97xjx9.d(24): Error: cannot modify `immutable` expression `c`

    /tmp/tmpbu97xjx9.d(26): Error: cannot modify `immutable` expression `c`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbu97xjx9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n  \
    \      if(c == '(')\n            cnt++;\n        else if(c == ')')\n         \
    \   cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return\
    \ cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp45k2k4jn.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmp45k2k4jn.__unittest_L32_C1() [0x427df6]

    ??:? void tmp45k2k4jn.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n    int[]\
    \ b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n    int[]\
    \ e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n    int[]\
    \ h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n    int[]\
    \ k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n    int[]\
    \ o = new int[n];\n    int[] p = new int[n];\n    int[] q = new int[n];\n    int[]\
    \ r = new int[n];\n    int[] t = new int[n];\n    int[] u = new int[n];\n    int[]\
    \ v = new int[n];\n    int[] w = new int[n];\n    int[] x = new int[n];\n    int[]\
    \ y = new int[n];\n    int[] z = new int[n];\n    int[] A = new int[n];\n    int[]\
    \ B = new int[n];\n    int[] C = new int[n];\n    int[] D = new int[n];\n    int[]\
    \ E = new int[n];\n    int[] F = new int[n];\n    int[] G = new int[n];\n    int[]\
    \ H = new int[n];\n    int[] I = new int[n];\n    int[] J = new int[n];\n    int[]\
    \ K = new int[n];\n    int[] L = new int[n];\n    int[] M = new int[n];\n    int[]\
    \ N = new int[n];\n    int[] O = new int[n];\n    int[] P = new int[n];\n    int[]\
    \ Q = new int[n];\n    int[]\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb7p4fij1.d(66): Error: no identifier for declarator `int[]`

    /tmp/tmpb7p4fij1.d(66): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb7p4fij1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = count(s1, '(');\n\
    \    int s1_close = count(s1, ')');\n    int s2_open = count(s2, '(');\n    int\
    \ s2_close = count(s2, ')');\n    if (s1_open == s1_close && s2_open == s2_close)\n\
    \        return \"Yes\";\n    if (s1_open == s1_close)\n        return s2_open\
    \ > s2_close ? \"Yes\" : \"No\";\n    if (s2_open == s2_close)\n        return\
    \ s1_open > s1_close ? \"Yes\" : \"No\";\n    if (s1_open > s1_close && s2_open\
    \ > s2_close)\n        return \"Yes\";\n    if (s1_open < s1_close && s2_open\
    \ < s2_close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8a97pf6j.d(21): Error: undefined identifier `count`

    /tmp/tmp8a97pf6j.d(22): Error: undefined identifier `count`

    /tmp/tmp8a97pf6j.d(23): Error: undefined identifier `count`

    /tmp/tmp8a97pf6j.d(24): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8a97pf6j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return\
    \ \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1\
    \ > 0 && count2 < 0)\n    {\n        if(count1 == -count2)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1 < 0\
    \ && count2 > 0)\n    {\n        if(count2 == -count1)\n            return \"\
    Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpupw5h7eu.d(76): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmpupw5h7eu.__unittest_L63_C1() [0x4281ee]

    ??:? void tmpupw5h7eu.__modtest() [0x4283a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count++;\n        else\n     \
    \       count--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n   \
    \         count++;\n        else\n            count--;\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpc0_ajb3y.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpc0_ajb3y.__unittest_L38_C1() [0x4280fe]

    ??:? void tmpc0_ajb3y.__modtest() [0x4282b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ int open = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n    \
    \    if(c == '(')\n            open++;\n        else\n            close++;\n \
    \   }\n    foreach(char c; lst[1])\n    {\n        if(c == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbwvy4amu.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpbwvy4amu.__unittest_L39_C1() [0x4280fa]

    ??:? void tmpbwvy4amu.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len = s1.length;\n\
    \    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open = 0;\n   \
    \ int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n    {\n      \
    \  if(c == '(')\n            s1_open++;\n        else\n            s1_close++;\n\
    \    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n\
    \        else\n            s2_close++;\n    }\n    if(s1_open == s1_close && s2_open\
    \ == s2_close)\n        return \"Yes\";\n    if(s1_open == s1_close)\n    {\n\
    \        if(s2_open > s2_close)\n            return \"Yes\";\n        else\n \
    \           return \"No\";\n    }\n    if(s2_open == s2_close)\n    {\n      \
    \  if(s1_open > s1_close)\n            return \"Yes\";\n        else\n       \
    \     return \"No\";\n    }\n    if(s1_open > s1_close)\n    {\n        if(s2_open\
    \ > s2_close)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    if(s2_open > s2_close)\n    {\n        if(s1_open > s1_close)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph03s6xtz.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmph03s6xtz.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph03s6xtz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int l1 = s1.length;\n    int\
    \ l2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0\
    \ && c2 == 0)\n        return \"No\";\n    if(c1 > 0 && c2 > 0)\n        return\
    \ \"No\";\n    if(c1 < 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 &&\
    \ c2 > 0)\n    {\n        if(c1 == -c2)\n            return \"Yes\";\n       \
    \ else\n            return \"No\";\n    }\n    if(c1 > 0 && c2 < 0)\n    {\n \
    \       if(c1 == -c2)\n            return \"Yes\";\n        else\n           \
    \ return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpconz2npu.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpconz2npu.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpconz2npu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return\
    \ \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1\
    \ > 0 && count2 < 0)\n    {\n        if(count1 == abs(count2))\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1 < 0\
    \ && count2 > 0)\n    {\n        if(abs(count1) == count2)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4qg67dzy.d(76): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291a5]

    ??:? void tmp4qg67dzy.__unittest_L63_C1() [0x428242]

    ??:? void tmp4qg67dzy.__modtest() [0x428410]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42daf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428efe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a92d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ed5]

    ??:? runModuleUnitTests [0x42d8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429668]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ < 0 && count2 < 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n\
    \        return \"No\";\n    if(count1 > 0)\n    {\n        if(count1 == count2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n    {\n        if(count1 == count2)\n            return \"Yes\";\n\
    \        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8dbh3e37.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290dd]

    ??:? void tmp8dbh3e37.__unittest_L58_C1() [0x427d1c]

    ??:? void tmp8dbh3e37.__modtest() [0x428348]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8d9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a968]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a865]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e0d]

    ??:? runModuleUnitTests [0x42d801]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else\n    {\n        if(count1\
    \ > 0)\n        {\n            if(count2 > 0)\n            {\n               \
    \ if(count1 == count2)\n                    return \"Yes\";\n                else\n\
    \                    return \"No\";\n            }\n            else\n       \
    \     {\n                if(count1 > abs(count2))\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n        }\n        else\n        {\n            if(count2 > 0)\n    \
    \        {\n                if(abs(count1) > count2)\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n            else\n            {\n                if(count1 == count2)\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n    }\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoplyrduk.d(85): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291ad]

    ??:? void tmpoplyrduk.__unittest_L81_C1() [0x427dd8]

    ??:? void tmpoplyrduk.__modtest() [0x428418]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dafb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9a9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa38]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a935]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428edd]

    ??:? runModuleUnitTests [0x42d8d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429670]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == 0 && count2\
    \ != 0)\n    {\n        if(count2 % 2 == 0)\n            return \"Yes\";\n   \
    \     else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 ==\
    \ 0)\n    {\n        if(count1 % 2 == 0)\n            return \"Yes\";\n      \
    \  else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 != 0)\n\
    \    {\n        if(count1 % 2 == 0 && count2 % 2 == 0)\n            return \"\
    Yes\";\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp86ogv5xa.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp86ogv5xa.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmp86ogv5xa.d(17): Error: function `tmp86ogv5xa.match_parens` no `return
    exp;` or `assert(0);` at end of function

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp86ogv5xa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 ~ s2;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmo8tpd_f.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpmo8tpd_f.__unittest_L37_C1() [0x427e0a]

    ??:? void tmpmo8tpd_f.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d993]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42d769]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429508]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ // your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string\
    \ s = s1 ~ s2;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c ==\
    \ '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4gcb9s2l.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmp4gcb9s2l.__unittest_L38_C1() [0x427e0a]

    ??:? void tmp4gcb9s2l.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d993]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42d769]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429508]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else if(c == ')')\n            count2++;\n    }\n    foreach(c; s2)\n\
    \    {\n        if(c == '(')\n            count1++;\n        else if(c == ')')\n\
    \            count2++;\n    }\n    if(count1 == count2)\n        return \"Yes\"\
    ;\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp623d6b_3.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x42905d]

    ??:? void tmp623d6b_3.__unittest_L42_C1() [0x42810e]

    ??:? void tmp623d6b_3.__modtest() [0x4282c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428db6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a859]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7e5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d8d]

    ??:? runModuleUnitTests [0x42d781]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429520]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ int open = 0;\n    int close = 0;\n    foreach(c; lst[0])\n    {\n        if(c\
    \ == '(')\n            open++;\n        else\n            close++;\n    }\n  \
    \  foreach(c; lst[1])\n    {\n        if(c == '(')\n            open++;\n    \
    \    else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5bodzz_a.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmp5bodzz_a.__unittest_L40_C1() [0x4280fa]

    ??:? void tmp5bodzz_a.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n  \
    \      if(c == '(')\n            cnt++;\n        else\n            cnt--;\n  \
    \      if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz0qmix39.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpz0qmix39.__unittest_L32_C1() [0x427dee]

    ??:? void tmpz0qmix39.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    auto n\
    \ = s.length;\n    auto count = 0;\n    foreach(i; 0 .. n)\n    {\n        if(s[i]\
    \ == '(')\n            count++;\n        else\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp21fvzvu8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmp21fvzvu8.__unittest_L38_C1() [0x427e1a]

    ??:? void tmp21fvzvu8.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n\
    \            s1_close++;\n    }\n    foreach(char c; s2)\n    {\n        if(c\
    \ == '(')\n            s2_open++;\n        else\n            s2_close++;\n   \
    \ }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"Yes\"\
    ;\n    if(s1_open == s1_close && s2_open != s2_close)\n        return \"No\";\n\
    \    if(s1_open != s1_close && s2_open == s2_close)\n        return \"No\";\n\
    \    if(s1_open != s1_close && s2_open != s2_close)\n    {\n        if(s1_open\
    \ > s1_close)\n        {\n            if(s2_open > s2_close)\n               \
    \ return \"No\";\n            else\n                return \"Yes\";\n        }\n\
    \        else\n        {\n            if(s2_open > s2_close)\n               \
    \ return \"Yes\";\n            else\n                return \"No\";\n        }\n\
    \    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd2j7z9vp.d(70): unittest failure

    ----------------

    ??:? _d_unittestp [0x429115]

    ??:? void tmpd2j7z9vp.__unittest_L64_C1() [0x427e60]

    ??:? void tmpd2j7z9vp.__modtest() [0x428380]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a911]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a89d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e45]

    ??:? runModuleUnitTests [0x42d839]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(char c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(char c; s2)\n    {\n\
    \        if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else\n    {\n        if(count1\
    \ > 0)\n        {\n            if(count2 > 0)\n            {\n               \
    \ if(count1 == count2)\n                    return \"Yes\";\n                else\n\
    \                    return \"No\";\n            }\n            else\n       \
    \     {\n                if(count1 > abs(count2))\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n        }\n        else\n        {\n            if(count2 > 0)\n    \
    \        {\n                if(abs(count1) > count2)\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n            else\n            {\n                if(count1 == count2)\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n    }\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpny53n0et.d(85): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291ad]

    ??:? void tmpny53n0et.__unittest_L81_C1() [0x427dd8]

    ??:? void tmpny53n0et.__modtest() [0x428418]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dafb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9a9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa38]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a935]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428edd]

    ??:? runModuleUnitTests [0x42d8d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429670]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n\
    \        else\n            s1_open--;\n        if(s1_open < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  s2_open++;\n        else\n            s2_open--;\n        if(s2_open < 0)\n\
    \            return \"No\";\n    }\n    if(s1_open == 0 && s2_open == 0)\n   \
    \     return \"Yes\";\n    if(s1_open == 0 || s2_open == 0)\n        return \"\
    No\";\n    if(s1_open == s2_open)\n        return \"Yes\";\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp07_depyy.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290bd]

    ??:? void tmp07_depyy.__unittest_L49_C1() [0x427cfc]

    ??:? void tmp07_depyy.__modtest() [0x428328]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8b9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a948]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a845]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ded]

    ??:? runModuleUnitTests [0x42d7e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429580]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 + s2;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp82iq0tnz.d(21): Error: invalid array operation `s1 + s2` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp82iq0tnz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n\
    \        else\n            s1_open--;\n        if(s1_open < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  s2_open++;\n        else\n            s2_open--;\n        if(s2_open < 0)\n\
    \            return \"No\";\n    }\n    if(s1_open == 0 && s2_open == 0)\n   \
    \     return \"Yes\";\n    if(s1_open == 0 || s2_open == 0)\n        return \"\
    No\";\n    if(s1_open == s2_open)\n        return \"Yes\";\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp07_depyy.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290bd]

    ??:? void tmp07_depyy.__unittest_L49_C1() [0x427cfc]

    ??:? void tmp07_depyy.__modtest() [0x428328]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8b9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a948]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a845]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ded]

    ??:? runModuleUnitTests [0x42d7e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429580]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0]\
    \ = 0;\n    for (int i = 1; i <= n; i++) \n    {\n        dp[i] = dp[i - 1];\n\
    \        if (i <= n1 && s1[i - 1] == '(') \n        {\n            dp[i]++;\n\
    \        }\n        else if (i > n1 && s2[i - n1 - 1] == '(') \n        {\n  \
    \          dp[i]++;\n        }\n        else \n        {\n            dp[i]--;\n\
    \        }\n    }\n    for (int i = 0; i <= n; i++) \n    {\n        if (dp[i]\
    \ < 0) \n        {\n            return \"No\";\n        }\n    }\n    return \"\
    Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpww0q9u45.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpww0q9u45.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpww0q9u45.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else if(count1 > 0 && count2\
    \ < 0)\n        return \"No\";\n    else if(count1 < 0 && count2 > 0)\n      \
    \  return \"No\";\n    else if(count1 > 0 && count2 > 0)\n    {\n        if(count1\
    \ == count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(count1 < 0 && count2 < 0)\n    {\n        if(count1\
    \ == count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvwzluj1w.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmpvwzluj1w.__unittest_L63_C1() [0x427d78]

    ??:? void tmpvwzluj1w.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == count2)\n  \
    \      return \"Yes\";\n    if(count1 < 0 && count2 > 0)\n    {\n        if(count1\
    \ + count2 == 0)\n            return \"Yes\";\n        return \"No\";\n    }\n\
    \    if(count1 > 0 && count2 < 0)\n    {\n        if(count1 + count2 == 0)\n \
    \           return \"Yes\";\n        return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplqgxy89w.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmplqgxy89w.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplqgxy89w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else if(count1 < 0 && count2\
    \ > 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n      \
    \  return \"No\";\n    else if(count1 > 0 && count2 > 0)\n    {\n        if(count1\
    \ > count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(count1 < 0 && count2 < 0)\n    {\n        if(count1\
    \ < count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaut7b_yz.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmpaut7b_yz.__unittest_L63_C1() [0x427d78]

    ??:? void tmpaut7b_yz.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len = s1.length;\n\
    \    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open = 0;\n   \
    \ int s1_close = 0;\n    int s2_close = 0;\n    int i = 0;\n    int j = 0;\n \
    \   int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n\
    \    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd\
    \ = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n \
    \   int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm\
    \ = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n \
    \   int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv\
    \ = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n \
    \   int aaa = 0;\n    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int\
    \ eee = 0;\n    int fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii\
    \ = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int lll = 0;\n   \nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy9xuyoak.d(84): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy9xuyoak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else if(count1 > 0 && count2\
    \ < 0)\n        return \"No\";\n    else if(count1 < 0 && count2 > 0)\n      \
    \  return \"No\";\n    else if(count1 > 0 && count2 > 0)\n    {\n        if(count1\
    \ == count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(count1 < 0 && count2 < 0)\n    {\n        if(count1\
    \ == count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvwzluj1w.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmpvwzluj1w.__unittest_L63_C1() [0x427d78]

    ??:? void tmpvwzluj1w.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n     \
    \   foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n\
    \            else\n                close++;\n        }\n    }\n    if(open ==\
    \ close)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiujzosjp.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmpiujzosjp.__unittest_L36_C1() [0x4280aa]

    ??:? void tmpiujzosjp.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return\
    \ \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1\
    \ < 0 && count2 > 0)\n    {\n        if(abs(count1) == count2)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1 > 0\
    \ && count2 < 0)\n    {\n        if(count1 == abs(count2))\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7fyo_ve3.d(76): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291a5]

    ??:? void tmp7fyo_ve3.__unittest_L63_C1() [0x428242]

    ??:? void tmp7fyo_ve3.__modtest() [0x428410]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42daf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428efe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a92d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ed5]

    ??:? runModuleUnitTests [0x42d8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429668]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = count(s1, '(');\n\
    \    int s1_close = count(s1, ')');\n    int s2_open = count(s2, '(');\n    int\
    \ s2_close = count(s2, ')');\n    if (s1_open == s1_close && s2_open == s2_close)\n\
    \        return \"Yes\";\n    if (s1_open == s1_close && s2_open != s2_close)\n\
    \        return \"No\";\n    if (s1_open != s1_close && s2_open == s2_close)\n\
    \        return \"No\";\n    if (s1_open != s1_close && s2_open != s2_close)\n\
    \    {\n        if (abs(s1_open - s1_close) == abs(s2_open - s2_close))\n    \
    \        return \"Yes\";\n        else\n            return \"No\";\n    }\n  \
    \  return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpovhc6hqh.d(21): Error: undefined identifier `count`

    /tmp/tmpovhc6hqh.d(22): Error: undefined identifier `count`

    /tmp/tmpovhc6hqh.d(23): Error: undefined identifier `count`

    /tmp/tmpovhc6hqh.d(24): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpovhc6hqh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close && s2_open > s2_close)\n        return \"Yes\";\n    if(s2_open\
    \ == s2_close && s1_open > s1_close)\n        return \"Yes\";\n    if(s1_open\
    \ > s1_close && s2_open > s2_close)\n        return \"Yes\";\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9_uw0a1c.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290c5]

    ??:? void tmp9_uw0a1c.__unittest_L49_C1() [0x427d04]

    ??:? void tmp9_uw0a1c.__modtest() [0x428330]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8c1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a950]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a84d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428df5]

    ??:? runModuleUnitTests [0x42d7e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429588]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int cnt = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            cnt++;\n        else\n            cnt--;\n\
    \    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            cnt++;\n\
    \        else\n            cnt--;\n    }\n    if(cnt != 0)\n        return \"\
    No\";\n    int[] dp = new int[n+1];\n    dp[0] = 0;\n    for(int i = 1; i <= n;\
    \ i++)\n    {\n        dp[i] = dp[i-1];\n        if(i <= n1)\n        {\n    \
    \        if(s1[i-1] == '(')\n                dp[i]++;\n            else\n    \
    \            dp[i]--;\n        }\n        else\n        {\n            if(s2[i-n1-1]\
    \ == '(')\n                dp[i]++;\n            else\n                dp[i]--;\n\
    \        }\n    }\n    if(dp[n] != 0)\n        return \"No\";\n    int min = dp[0];\n\
    \    foreach(i; dp)\n    {\n        if(i < min)\n            min = i;\n    }\n\
    \    if(min < 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsl644jyh.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpsl644jyh.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsl644jyh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n  \
    \      if(c == '(')\n            cnt++;\n        else if(c == ')')\n         \
    \   cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return\
    \ cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp45k2k4jn.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmp45k2k4jn.__unittest_L32_C1() [0x427df6]

    ??:? void tmp45k2k4jn.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close && s2_open > s2_close)\n        return \"Yes\";\n    if(s2_open\
    \ == s2_close && s1_open > s1_close)\n        return \"Yes\";\n    if(s1_open\
    \ > s1_close && s2_open > s2_close)\n        return \"Yes\";\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9_uw0a1c.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290c5]

    ??:? void tmp9_uw0a1c.__unittest_L49_C1() [0x427d04]

    ??:? void tmp9_uw0a1c.__modtest() [0x428330]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8c1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a950]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a84d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428df5]

    ??:? runModuleUnitTests [0x42d7e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429588]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close)\n    {\n        if(s2_open > s2_close)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(s2_open == s2_close)\n\
    \    {\n        if(s1_open > s1_close)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    if(s1_open > s1_close)\n    {\n      \
    \  if(s2_open > s2_close)\n            return \"Yes\";\n        else\n       \
    \     return \"No\";\n    }\n    if(s2_open > s2_close)\n    {\n        if(s1_open\
    \ > s1_close)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp19r0wm_z.d(75): unittest failure

    ----------------

    ??:? _d_unittestp [0x429135]

    ??:? void tmp19r0wm_z.__unittest_L71_C1() [0x427d70]

    ??:? void tmp19r0wm_z.__modtest() [0x42839c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a931]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e65]

    ??:? runModuleUnitTests [0x42d859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0]\
    \ = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        dp[i] = dp[i - 1];\n\
    \        if (i <= n1)\n        {\n            if (s1[i - 1] == '(')\n        \
    \        dp[i]++;\n            else\n                dp[i]--;\n        }\n   \
    \     else\n        {\n            if (s2[i - n1 - 1] == '(')\n              \
    \  dp[i]++;\n            else\n                dp[i]--;\n        }\n        if\
    \ (dp[i] < 0)\n            return \"No\";\n    }\n    return dp[n] == 0 ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmper998zp6.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmper998zp6.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmper998zp6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n\
    \        else\n            s1_open--;\n        if(s1_open < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  s2_open++;\n        else\n            s2_open--;\n        if(s2_open < 0)\n\
    \            return \"No\";\n    }\n    if(s1_open == 0 && s2_open == 0)\n   \
    \     return \"Yes\";\n    if(s1_open > 0 && s2_open < 0)\n        return \"Yes\"\
    ;\n    if(s1_open < 0 && s2_open > 0)\n        return \"Yes\";\n    return \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8h88dfql.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290c5]

    ??:? void tmp8h88dfql.__unittest_L49_C1() [0x427d00]

    ??:? void tmp8h88dfql.__modtest() [0x42832c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8c1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a950]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a84d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428df5]

    ??:? runModuleUnitTests [0x42d7e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429588]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] arr = new int[n];\n    int\
    \ i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < n1)\n    {\n        if\
    \ (s1[i] == '(')\n            arr[k++] = 1;\n        else\n            arr[k++]\
    \ = -1;\n        i++;\n    }\n    while (j < n2)\n    {\n        if (s2[j] ==\
    \ '(')\n            arr[k++] = 1;\n        else\n            arr[k++] = -1;\n\
    \        j++;\n    }\n    int sum = 0;\n    int min = 0;\n    int max = 0;\n \
    \   for (int l = 0; l < n; l++)\n    {\n        sum += arr[l];\n        min =\
    \ min(min, sum);\n        max = max(max, sum);\n    }\n    if (max > 0 || min\
    \ < 0)\n        return \"No\";\n    else\n        return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfl8_ho7y.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpfl8_ho7y.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmpfl8_ho7y.d(50): Error: function expected before `()`, not `min` of type
    `int`

    /tmp/tmpfl8_ho7y.d(51): Error: function expected before `()`, not `max` of type
    `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfl8_ho7y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int l1 = s1.length;\n    int\
    \ l2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0\
    \ && c2 == 0)\n        return \"No\";\n    if(c1 > 0 && c2 < 0)\n        return\
    \ \"No\";\n    if(c1 < 0 && c2 > 0)\n        return \"No\";\n    if(c1 > 0 &&\
    \ c2 > 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 < 0)\n        return \"\
    Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgz7b9df.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpwgz7b9df.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwgz7b9df.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == 0 && count2\
    \ != 0)\n    {\n        if(count2 % 2 == 0)\n            return \"Yes\";\n   \
    \     else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 ==\
    \ 0)\n    {\n        if(count1 % 2 == 0)\n            return \"Yes\";\n      \
    \  else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 != 0)\n\
    \    {\n        if(count1 % 2 == 0 && count2 % 2 == 0)\n            return \"\
    Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ptqd4ww.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp4ptqd4ww.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ptqd4ww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0)\n        return \"No\";\n    if(count2 == 0)\n        return \"No\";\n\
    \    if(count1 > 0 && count2 > 0)\n        return \"No\";\n    if(count1 < 0 &&\
    \ count2 < 0)\n        return \"No\";\n    if(abs(count1) == abs(count2))\n  \
    \      return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv0ks53pk.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x429155]

    ??:? void tmpv0ks53pk.__unittest_L51_C1() [0x4281f2]

    ??:? void tmpv0ks53pk.__modtest() [0x4283c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42daa3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428eae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a951]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e85]

    ??:? runModuleUnitTests [0x42d879]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429618]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close)\n    {\n        if(s2_open > s2_close)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(s2_open == s2_close)\n\
    \    {\n        if(s1_open > s1_close)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    if(s1_open > s1_close)\n    {\n      \
    \  if(s2_open > s2_close)\n            return \"Yes\";\n        else\n       \
    \     return \"No\";\n    }\n    if(s2_open > s2_close)\n    {\n        if(s1_open\
    \ > s1_close)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp19r0wm_z.d(75): unittest failure

    ----------------

    ??:? _d_unittestp [0x429135]

    ??:? void tmp19r0wm_z.__unittest_L71_C1() [0x427d70]

    ??:? void tmp19r0wm_z.__modtest() [0x42839c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a931]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e65]

    ??:? runModuleUnitTests [0x42d859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 + s2;\n    int\
    \ cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n\
    \        else\n            cnt--;\n        if(cnt < 0)\n            return \"\
    No\";\n    }\n    if(cnt == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpogkmwxu0.d(21): Error: invalid array operation `s1 + s2` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogkmwxu0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int open1 = 0;\n    int open2 = 0;\n    int close1 = 0;\n\
    \    int close2 = 0;\n    int i = 0;\n    int j = 0;\n    while (i < n1) {\n \
    \       if (s1[i] == '(') {\n            open1++;\n        } else {\n        \
    \    close1++;\n        }\n        i++;\n    }\n    while (j < n2) {\n       \
    \ if (s2[j] == '(') {\n            open2++;\n        } else {\n            close2++;\n\
    \        }\n        j++;\n    }\n    if (open1 == close1 && open2 == close2) {\n\
    \        return \"Yes\";\n    }\n    if (open1 == close1 && open2 != close2) {\n\
    \        if (open2 > close2) {\n            return \"Yes\";\n        } else {\n\
    \            return \"No\";\n        }\n    }\n    if (open1 != close1 && open2\
    \ == close2) {\n        if (open1 > close1) {\n            return \"Yes\";\n \
    \       } else {\n            return \"No\";\n        }\n    }\n    if (open1\
    \ != close1 && open2 != close2) {\n        if (open1 > close1 && open2 > close2)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate =\
    \ match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyef4uena.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpyef4uena.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyef4uena.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(string s1; lst)\n        s ~= s1;\n    int count\
    \ = 0;\n    foreach(char c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9_v_2ngi.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmp9_v_2ngi.__unittest_L34_C1() [0x427e02]

    ??:? void tmp9_v_2ngi.__modtest() [0x4282a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b261]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42e189]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42948c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close)\n    {\n        if(s2_open > s2_close)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(s2_open == s2_close)\n\
    \    {\n        if(s1_open > s1_close)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    if(s1_open > s1_close)\n    {\n      \
    \  if(s2_open > s2_close)\n            return \"Yes\";\n        else\n       \
    \     return \"No\";\n    }\n    if(s2_open > s2_close)\n    {\n        if(s1_open\
    \ > s1_close)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp19r0wm_z.d(75): unittest failure

    ----------------

    ??:? _d_unittestp [0x429135]

    ??:? void tmp19r0wm_z.__unittest_L71_C1() [0x427d70]

    ??:? void tmp19r0wm_z.__modtest() [0x42839c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a931]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e65]

    ??:? runModuleUnitTests [0x42d859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == c2)\n        return \"Yes\";\n    if(c1 > 0 && c2 < 0)\n\
    \    {\n        if(c1 == abs(c2))\n            return \"Yes\";\n    }\n    if(c1\
    \ < 0 && c2 > 0)\n    {\n        if(abs(c1) == c2)\n            return \"Yes\"\
    ;\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptdjllzug.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmptdjllzug.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptdjllzug.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0]\
    \ = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        dp[i] = dp[i - 1];\n\
    \        if (i <= n1 && s1[i - 1] == '(')\n            dp[i]++;\n        else\
    \ if (i <= n1 && s1[i - 1] == ')')\n            dp[i]--;\n        else if (i <=\
    \ n2 && s2[i - 1] == '(')\n            dp[i]++;\n        else if (i <= n2 && s2[i\
    \ - 1] == ')')\n            dp[i]--;\n        if (dp[i] < 0)\n            return\
    \ \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpatdh45qs.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpatdh45qs.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatdh45qs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close && s2_open > s2_close)\n    {\n        if(s2_open - s2_close ==\
    \ s1_open)\n            return \"Yes\";\n        else\n            return \"No\"\
    ;\n    }\n    else if(s1_open > s1_close && s2_open == s2_close)\n    {\n    \
    \    if(s1_open - s1_close == s2_open)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    else if(s1_open > s1_close && s2_open\
    \ > s2_close)\n    {\n        if(s1_open - s1_close == s2_open - s2_close)\n \
    \           return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqgk95enj.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x429125]

    ??:? void tmpqgk95enj.__unittest_L65_C1() [0x427d60]

    ??:? void tmpqgk95enj.__modtest() [0x42838c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a921]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e55]

    ??:? runModuleUnitTests [0x42d849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int open = 0;\n    int close = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            open++;\n        else\n      \
    \      close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        open++;\n        else\n            close++;\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hwayqw4.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp5hwayqw4.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hwayqw4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    for (int\
    \ i = 0; i < len1; i++)\n    {\n        if (s1[i] == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    for (int i = 0; i < len2; i++)\n\
    \    {\n        if (s2[i] == '(')\n            count2++;\n        else\n     \
    \       count2--;\n    }\n    if (count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    if (count1 == 0 && count2 != 0)\n        return \"No\";\n    if\
    \ (count1 != 0 && count2 == 0)\n        return \"No\";\n    if (count1 > 0 &&\
    \ count2 > 0)\n        return \"No\";\n    if (count1 < 0 && count2 < 0)\n   \
    \     return \"No\";\n    if (count1 < 0 && count2 > 0)\n    {\n        if (abs(count1)\
    \ == count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    if (count1 > 0 && count2 < 0)\n    {\n        if (abs(count2)\
    \ == count1)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkk9vb7lk.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpkk9vb7lk.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkk9vb7lk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else if(c\
    \ == ')')\n            s1_close++;\n    }\n    foreach(char c; s2)\n    {\n  \
    \      if(c == '(')\n            s2_open++;\n        else if(c == ')')\n     \
    \       s2_close++;\n    }\n    if(s1_open == s1_close && s2_open == s2_close)\n\
    \        return \"Yes\";\n    else if(s1_open == s1_close && s2_open > s2_close)\n\
    \    {\n        if(s2_open - s2_close == s1_open)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    else if(s1_open == s1_close\
    \ && s2_open < s2_close)\n    {\n        if(s1_open == s2_close - s2_open)\n \
    \           return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else if(s1_open > s1_close && s2_open == s2_close)\n    {\n        if(s1_open\
    \ - s1_close == s2_open)\n            return \"Yes\";\n        else\n        \
    \    return \"No\";\n    }\n    else if(s1_open < s1_close && s2_open == s2_close)\n\
    \    {\n        if(s2_open == s1_close - s1_open)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    else if(s1_open > s1_close\
    \ && s2_open > s2_close)\n    {\n        if(s1_open - s1_close == s2_open - s2_close)\n\
    \            return \"Yes\";\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplupm1opw.d(73): Error: found `unittest` instead of statement

    /tmp/tmplupm1opw.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplupm1opw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ > 0 && count2 < 0)\n        return \"Yes\";\n    if(count1 < 0 && count2 > 0)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn9nmq07h.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmpn9nmq07h.__unittest_L45_C1() [0x427ddc]

    ??:? void tmpn9nmq07h.__modtest() [0x4282fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close)\n    {\n        if(s2_open > s2_close)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    else if(s2_open == s2_close)\n\
    \    {\n        if(s1_open > s1_close)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    else\n        return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeh2gfu8w.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290cd]

    ??:? void tmpeh2gfu8w.__unittest_L58_C1() [0x427d08]

    ??:? void tmpeh2gfu8w.__modtest() [0x428334]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a958]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a855]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dfd]

    ??:? runModuleUnitTests [0x42d7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429590]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len = s1.length;\n\
    \    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open = 0;\n   \
    \ int s1_close = 0;\n    int s2_close = 0;\n    int s1_open_close = 0;\n    int\
    \ s2_open_close = 0;\n    int s1_close_open = 0;\n    int s2_close_open = 0;\n\
    \    int s1_open_open = 0;\n    int s2_open_open = 0;\n    int s1_close_close\
    \ = 0;\n    int s2_close_close = 0;\n    int s1_open_open_close = 0;\n    int\
    \ s2_open_open_close = 0;\n    int s1_open_close_open = 0;\n    int s2_open_close_open\
    \ = 0;\n    int s1_close_open_close = 0;\n    int s2_close_open_close = 0;\n \
    \   int s1_close_close_open = 0;\n    int s2_close_close_open = 0;\n    int s1_open_close_close\
    \ = 0;\n    int s2_open_close_close = 0;\n    int s1_open_open_open = 0;\n   \
    \ int s2_open_open_open = 0;\n    int s1_close_close_close = 0;\n    int s2_close_close_close\
    \ = 0;\n    int s1_open_open_open_close = 0;\n    int s2_open_open_open_close\
    \ = 0;\n    int s1_open_open_close_open = 0;\n    int s2_open_open_close_open\
    \ = 0;\n    int s1_open_close_open_close = 0;\n    int s2_open_close_open_close\
    \ = 0;\n    int s1_close_open_close_open = 0;\n    int s2_close_open_close_open\
    \ = 0;\n   \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4u7_yzwz.d(58): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4u7_yzwz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(char c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else if(c == ')')\n            count1--;\n    }\n    foreach(char c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else if(c ==\
    \ ')')\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n   \
    \     return \"Yes\";\n    else if(count1 == 0 && count2 != 0)\n    {\n      \
    \  if(count2 > 0)\n        {\n            if(count2 % 2 == 0)\n              \
    \  return \"Yes\";\n            else\n                return \"No\";\n       \
    \ }\n        else\n        {\n            if(count2 % 2 == 0)\n              \
    \  return \"Yes\";\n            else\n                return \"No\";\n       \
    \ }\n    }\n    else if(count1 != 0 && count2 == 0)\n    {\n        if(count1\
    \ > 0)\n        {\n            if(count1 % 2 == 0)\n                return \"\
    Yes\";\n            else\n                return \"No\";\n        }\n        else\n\
    \        {\n            if(count1 % 2 == 0)\n                return \"Yes\";\n\
    \            else\n                return \"No\";\n        }\n    }\n    else\n\
    \    {\n        if(count1 > 0 && count2 > 0)\n        {\n            if(count1\
    \ % 2 == 0 && count2 % 2 == 0)\n                return \"Yes\";\n            else\n\
    \                return \"No\";\n        }\n        else if(count1 < 0 && count2\
    \ < 0)\n        {\n            if(count1 % 2 == 0 && count2 % 2 == 0)\n      \
    \          return \"Yes\";\n            else\n                return \"No\";\n\
    \        }\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6fmmrbqm.d(97): unittest failure

    ----------------

    ??:? _d_unittestp [0x429205]

    ??:? void tmp6fmmrbqm.__unittest_L93_C1() [0x427e40]

    ??:? void tmp6fmmrbqm.__modtest() [0x42846c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42aa01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a98d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f35]

    ??:? runModuleUnitTests [0x42d929]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len = s1.length;\n\
    \    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open = 0;\n   \
    \ int s1_close = 0;\n    int s2_close = 0;\n    int s1_total = 0;\n    int s2_total\
    \ = 0;\n    int total = 0;\n    int s1_i = 0;\n    int s2_i = 0;\n    int s1_j\
    \ = 0;\n    int s2_j = 0;\n    int s1_k = 0;\n    int s2_k = 0;\n    int s1_l\
    \ = 0;\n    int s2_l = 0;\n    int s1_m = 0;\n    int s2_m = 0;\n    int s1_n\
    \ = 0;\n    int s2_n = 0;\n    int s1_o = 0;\n    int s2_o = 0;\n    int s1_p\
    \ = 0;\n    int s2_p = 0;\n    int s1_q = 0;\n    int s2_q = 0;\n    int s1_r\
    \ = 0;\n    int s2_r = 0;\n    int s1_s = 0;\n    int s2_s = 0;\n    int s1_t\
    \ = 0;\n    int s2_t = 0;\n    int s1_u = 0;\n    int s2_u = 0;\n    int s1_v\
    \ = 0;\n    int s2_v = 0;\n    int s1_w = 0;\n    int s2_w = 0;\n    int s1_x\
    \ = 0;\n    int s2_x = 0;\n    int s1_y = 0;\n    int s2_y = 0;\n    int s1_z\
    \ = 0;\n    int s2_z = 0;\n    int s1_aa = 0;\n    int s2_aa = 0;\n    int s1_bb\
    \ = 0;\n    int s2\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdivvxre7.d(70): Error: semicolon expected, not `unittest`

    /tmp/tmpdivvxre7.d(70): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdivvxre7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(char\
    \ c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n \
    \           count1--;\n    }\n    foreach(char c; s2)\n    {\n        if(c ==\
    \ '(')\n            count2++;\n        else\n            count2--;\n    }\n  \
    \  if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == 0\
    \ && count2 != 0)\n    {\n        if(count2 % 2 == 0)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(count1 != 0 && count2\
    \ == 0)\n    {\n        if(count1 % 2 == 0)\n            return \"Yes\";\n   \
    \     else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 !=\
    \ 0)\n    {\n        if(count1 % 2 == 0 && count2 % 2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ou7o2q_.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp7ou7o2q_.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ou7o2q_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161330
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int l1 = s1.length;\n    int\
    \ l2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0\
    \ && c2 == 0)\n        return \"No\";\n    if(c1 > 0 && c2 < 0)\n        return\
    \ \"No\";\n    if(c1 < 0 && c2 > 0)\n        return \"No\";\n    if(c1 > 0 &&\
    \ c2 > 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 < 0)\n        return \"\
    Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgz7b9df.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpwgz7b9df.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwgz7b9df.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else if(count1 < 0 && count2\
    \ > 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n      \
    \  return \"No\";\n    else if(count1 < 0 && count2 < 0)\n    {\n        if(abs(count1)\
    \ == abs(count2))\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n    else if(count1 > 0 && count2 > 0)\n    {\n        if(abs(count1)\
    \ == abs(count2))\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8u52pzok.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291ed]

    ??:? void tmp8u52pzok.__unittest_L63_C1() [0x427e14]

    ??:? void tmp8u52pzok.__modtest() [0x428454]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9e9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a975]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f1d]

    ??:? runModuleUnitTests [0x42d911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296b0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string str1 = lst[0];\n    string str2 = lst[1];\n    string str = str1 + str2;\n\
    \    int count = 0;\n    foreach(c; str)\n    {\n        if(c == '(')\n      \
    \      count++;\n        else if(c == ')')\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc8c09_yp.d(21): Error: invalid array operation `str1 + str2` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc8c09_yp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s3 = s1 ~ s2;\n   \
    \ int count = 0;\n    foreach(c; s3)\n    {\n        if(c == '(')\n          \
    \  count++;\n        else if(c == ')')\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp778aifot.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmp778aifot.__unittest_L37_C1() [0x427e0a]

    ??:? void tmp778aifot.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d993]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42d769]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429508]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0\
    \ && c2 == 0)\n        return \"No\";\n    if(c1 > 0 && c2 < 0)\n        return\
    \ \"No\";\n    if(c1 < 0 && c2 > 0)\n        return \"No\";\n    if(c1 > 0 &&\
    \ c2 > 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 < 0)\n        return \"\
    Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm73ule3n.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpm73ule3n.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm73ule3n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    int open_diff\
    \ = abs(s1_open - s2_open);\n    int close_diff = abs(s1_close - s2_close);\n\
    \    if(open_diff == close_diff)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphzvd97qm.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290d5]

    ??:? void tmphzvd97qm.__unittest_L46_C1() [0x427cfc]

    ??:? void tmphzvd97qm.__modtest() [0x42833c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e2e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a960]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a85d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e05]

    ??:? runModuleUnitTests [0x42d7f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429598]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 < 0 && count2 < 0)\n        return\
    \ \"No\";\n    if(count1 > 0 && count2 > 0)\n        return \"No\";\n    if(count1\
    \ < 0 && count2 > 0)\n    {\n        if(abs(count1) > count2)\n            return\
    \ \"No\";\n        else\n            return \"Yes\";\n    }\n    if(count1 > 0\
    \ && count2 < 0)\n    {\n        if(count1 > abs(count2))\n            return\
    \ \"No\";\n        else\n            return \"Yes\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt58gj58w.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291a5]

    ??:? void tmpt58gj58w.__unittest_L63_C1() [0x427edc]

    ??:? void tmpt58gj58w.__modtest() [0x428410]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42daf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428efe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a92d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ed5]

    ??:? runModuleUnitTests [0x42d8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429668]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close && s2_open > s2_close)\n        return \"Yes\";\n    if(s2_open\
    \ == s2_close && s1_open > s1_close)\n        return \"Yes\";\n    if(s1_open\
    \ > s1_close && s2_open > s2_close)\n        return \"Yes\";\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9_uw0a1c.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290c5]

    ??:? void tmp9_uw0a1c.__unittest_L49_C1() [0x427d04]

    ??:? void tmp9_uw0a1c.__modtest() [0x428330]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8c1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a950]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a84d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428df5]

    ??:? runModuleUnitTests [0x42d7e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429588]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close)\n    {\n        if(s2_open > s2_close)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(s2_open == s2_close)\n\
    \    {\n        if(s1_open > s1_close)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    if(s1_open > s1_close)\n    {\n      \
    \  if(s2_open > s2_close)\n            return \"Yes\";\n        else\n       \
    \     return \"No\";\n    }\n    if(s2_open > s2_close)\n    {\n        if(s1_open\
    \ > s1_close)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp19r0wm_z.d(75): unittest failure

    ----------------

    ??:? _d_unittestp [0x429135]

    ??:? void tmp19r0wm_z.__unittest_L71_C1() [0x427d70]

    ??:? void tmp19r0wm_z.__modtest() [0x42839c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a931]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e65]

    ??:? runModuleUnitTests [0x42d859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n    int count\
    \ = 0;\n    foreach(char c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjj9hwyjl.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpjj9hwyjl.__unittest_L34_C1() [0x427e0a]

    ??:? void tmpjj9hwyjl.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = count(s1, '(');\n\
    \    int s1_close = count(s1, ')');\n    int s2_open = count(s2, '(');\n    int\
    \ s2_close = count(s2, ')');\n    if (s1_open == s1_close && s2_open == s2_close)\n\
    \        return \"Yes\";\n    if (s1_open == s1_close && s2_open != s2_close)\n\
    \        return \"No\";\n    if (s1_open != s1_close && s2_open == s2_close)\n\
    \        return \"No\";\n    if (s1_open != s1_close && s2_open != s2_close)\n\
    \    {\n        int diff = abs(s1_open - s1_close);\n        if (diff == abs(s2_open\
    \ - s2_close))\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80uwrmr2.d(21): Error: undefined identifier `count`

    /tmp/tmp80uwrmr2.d(22): Error: undefined identifier `count`

    /tmp/tmp80uwrmr2.d(23): Error: undefined identifier `count`

    /tmp/tmp80uwrmr2.d(24): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80uwrmr2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n   \
    \     else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1\
    \ == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 < 0)\n      \
    \  return \"No\";\n    if(c1 < 0 && c2 > 0)\n    {\n        if(c1 + c2 == 0)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    if(c1 > 0 && c2 < 0)\n    {\n        if(c1 + c2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjdd_3_ri.d(66): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290e5]

    ??:? void tmpjdd_3_ri.__unittest_L57_C1() [0x427fa9]

    ??:? void tmpjdd_3_ri.__modtest() [0x42834c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e3e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8e1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a970]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a86d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e15]

    ??:? runModuleUnitTests [0x42d809]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n   \
    \     else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1\
    \ == 0 && c2 == 0)\n        return \"Yes\";\n    else if(c1 == 0 && c2 != 0)\n\
    \        return \"No\";\n    else if(c1 != 0 && c2 == 0)\n        return \"No\"\
    ;\n    else\n    {\n        if(c1 == c2)\n            return \"Yes\";\n      \
    \  else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvidcsbvi.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290ad]

    ??:? void tmpvidcsbvi.__unittest_L51_C1() [0x427ce8]

    ??:? void tmpvidcsbvi.__modtest() [0x428314]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9fb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8a9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a938]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a835]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ddd]

    ??:? runModuleUnitTests [0x42d7d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429570]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ auto a = lst[0];\n    auto b = lst[1];\n    auto c = a ~ b;\n    auto d = b\
    \ ~ a;\n    auto e = a ~ a;\n    auto f = b ~ b;\n    auto g = a ~ b ~ a;\n  \
    \  auto h = b ~ a ~ b;\n    auto i = a ~ b ~ b;\n    auto j = b ~ a ~ a;\n   \
    \ auto k = a ~ a ~ b;\n    auto l = b ~ b ~ a;\n    auto m = a ~ a ~ a;\n    auto\
    \ n = b ~ b ~ b;\n    auto o = a ~ b ~ a ~ b;\n    auto p = b ~ a ~ b ~ a;\n \
    \   auto q = a ~ b ~ b ~ a;\n    auto r = b ~ a ~ a ~ b;\n    auto s = a ~ a ~\
    \ b ~ a;\n    auto t = b ~ b ~ a ~ b;\n    auto u = a ~ a ~ a ~ a;\n    auto v\
    \ = b ~ b ~ b ~ b;\n    auto w = a ~ b ~ a ~ b ~ a;\n    auto x = b ~ a ~ b ~\
    \ a ~ b;\n    auto y = a ~ b ~ b ~ a ~ b;\n    auto z = b ~ a ~ a ~ b ~ a;\n \
    \   auto aa = a ~ a ~ b ~ a ~ b;\n    auto bb = b ~ b ~ a ~ b ~ a;\n    auto cc\
    \ = a ~ a ~ a ~ a ~ a;\n    auto dd = b ~ b ~ b ~ b ~ b;\n    auto ee = a ~ b\
    \ ~ a ~ b ~ a ~ b;\n    auto ff = b ~ a ~ b ~ a ~ b ~ a;\n    auto gg = a ~ b\
    \ ~ b ~ a ~ b ~ a;\n    auto hh = b ~ a ~ a ~ b ~ a ~ b;\n    auto ii = a ~ a\
    \ ~ b ~ a ~ b ~ a;\n    auto jj = b ~ b ~ a ~ b ~ a ~ b;\n    auto kk = a ~ a\
    \ ~ a ~ a ~ a ~ a;\n    auto ll = b ~ b ~ b ~ b ~ b ~ b\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9j4t1xlj.d(57): Error: semicolon expected following auto declaration,
    not `unittest`

    /tmp/tmp9j4t1xlj.d(57): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9j4t1xlj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n\
    \        else\n            s1_open--;\n    }\n    foreach(c; s2)\n    {\n    \
    \    if(c == '(')\n            s2_open++;\n        else\n            s2_open--;\n\
    \    }\n    if(s1_open == 0 && s2_open == 0)\n        return \"Yes\";\n    if(s1_open\
    \ == 0 && s2_open < 0)\n        return \"Yes\";\n    if(s1_open > 0 && s2_open\
    \ == 0)\n        return \"Yes\";\n    if(s1_open > 0 && s2_open < 0)\n       \
    \ return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy3zgflt_.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290ad]

    ??:? void tmpy3zgflt_.__unittest_L47_C1() [0x427df8]

    ??:? void tmpy3zgflt_.__modtest() [0x428318]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9fb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8a9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a938]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a835]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ddd]

    ??:? runModuleUnitTests [0x42d7d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429570]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return\
    \ \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(abs(count1)\
    \ != abs(count2))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr77mxd1s.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x429165]

    ??:? void tmpr77mxd1s.__unittest_L51_C1() [0x4281fe]

    ??:? void tmpr77mxd1s.__modtest() [0x4283cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ebe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a961]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e95]

    ??:? runModuleUnitTests [0x42d889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429628]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == 0)\n    {\n\
    \        if(count2 < 0)\n            return \"No\";\n        if(count2 % 2 ==\
    \ 0)\n            return \"Yes\";\n        else\n            return \"No\";\n\
    \    }\n    if(count2 == 0)\n    {\n        if(count1 < 0)\n            return\
    \ \"No\";\n        if(count1 % 2 == 0)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    if(count1 < 0 || count2 < 0)\n       \
    \ return \"No\";\n    if(count1 % 2 == 0 && count2 % 2 == 0)\n        return \"\
    Yes\";\n    if(count1 % 2 == 1 && count2 % 2 == 1)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqi0_l9nh.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpqi0_l9nh.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqi0_l9nh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 > 0 && count2 < 0 && abs(count1) == abs(count2))\n        return \"\
    Yes\";\n    else if(count1 < 0 && count2 > 0 && abs(count1) == abs(count2))\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvanzkz38.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x429145]

    ??:? void tmpvanzkz38.__unittest_L46_C1() [0x4281e2]

    ??:? void tmpvanzkz38.__modtest() [0x4283b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a941]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e75]

    ??:? runModuleUnitTests [0x42d869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429608]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0]\
    \ = 0;\n    for (int i = 1; i <= n; i++) {\n        if (i <= n1) {\n         \
    \   dp[i] = dp[i - 1] + (s1[i - 1] == '(' ? 1 : -1);\n        } else {\n     \
    \       dp[i] = dp[i - 1] + (s2[i - 1 - n1] == '(' ? 1 : -1);\n        }\n   \
    \ }\n    if (dp[n] != 0) {\n        return \"No\";\n    }\n    for (int i = 0;\
    \ i <= n; i++) {\n        if (dp[i] < 0) {\n            return \"No\";\n     \
    \   }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyr33diye.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpyr33diye.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyr33diye.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close && abs(s2_open - s2_close) == 1)\n        return \"Yes\";\n    else\
    \ if(s2_open == s2_close && abs(s1_open - s1_close) == 1)\n        return \"Yes\"\
    ;\n    else if(abs(s1_open - s1_close) == 1 && abs(s2_open - s2_close) == 1)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpft2xs6mz.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x429155]

    ??:? void tmpft2xs6mz.__unittest_L50_C1() [0x427e0a]

    ??:? void tmpft2xs6mz.__modtest() [0x4283bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42daa3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428eae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a951]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e85]

    ??:? runModuleUnitTests [0x42d879]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429618]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_count = 0;\n    int\
    \ s2_count = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n           \
    \ s1_count++;\n        else\n            s1_count--;\n    }\n    foreach(c; s2)\n\
    \    {\n        if(c == '(')\n            s2_count++;\n        else\n        \
    \    s2_count--;\n    }\n    if(s1_count == 0 && s2_count == 0)\n        return\
    \ \"Yes\";\n    else if(s1_count == 0 && s2_count != 0)\n    {\n        if(s2_count\
    \ % 2 == 0)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(s1_count != 0 && s2_count == 0)\n    {\n        if(s1_count\
    \ % 2 == 0)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(s1_count != 0 && s2_count != 0)\n    {\n        if(s1_count\
    \ % 2 == 0 && s2_count % 2 == 0)\n            return \"Yes\";\n        else if(s1_count\
    \ % 2 != 0 && s2_count % 2 != 0)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpejwusc_9.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x429165]

    ??:? void tmpejwusc_9.__unittest_L64_C1() [0x427e32]

    ??:? void tmpejwusc_9.__modtest() [0x4283d0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ebe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a961]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e95]

    ??:? runModuleUnitTests [0x42d889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429628]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ // Write your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n\
    \    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c ==\
    \ '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n        \
    \    c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1\
    \ == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0 && c2 == 0)\n     \
    \   return \"No\";\n    if(c1 < 0 && c2 < 0)\n        return \"No\";\n    if(c1\
    \ > 0 && c2 > 0)\n        return \"No\";\n    if(c1 < 0 && c2 > 0)\n    {\n  \
    \      if(c1 == -c2)\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n    if(c1 > 0 && c2 < 0)\n    {\n        if(c1 == -c2)\n   \
    \         return \"Yes\";\n        else\n            return \"No\";\n    }\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp869lmzx6.d(77): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmp869lmzx6.__unittest_L64_C1() [0x4281ee]

    ??:? void tmp869lmzx6.__modtest() [0x4283a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close)\n    {\n        if(s2_open > s2_close)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(s2_open == s2_close)\n\
    \    {\n        if(s1_open > s1_close)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    if(s1_open > s1_close)\n    {\n      \
    \  if(s2_open > s2_close)\n            return \"Yes\";\n        else\n       \
    \     return \"No\";\n    }\n    if(s2_open > s2_close)\n    {\n        if(s1_open\
    \ > s1_close)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp19r0wm_z.d(75): unittest failure

    ----------------

    ??:? _d_unittestp [0x429135]

    ??:? void tmp19r0wm_z.__unittest_L71_C1() [0x427d70]

    ??:? void tmp19r0wm_z.__modtest() [0x42839c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a931]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e65]

    ??:? runModuleUnitTests [0x42d859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0\
    \ && c2 == 0)\n        return \"No\";\n    if(c1 > 0 && c2 < 0)\n        return\
    \ \"No\";\n    if(c1 < 0 && c2 > 0)\n        return \"No\";\n    if(c1 > 0 &&\
    \ c2 > 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 < 0)\n        return \"\
    Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm73ule3n.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpm73ule3n.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm73ule3n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int l1 = s1.length;\n    int\
    \ l2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0)\n    {\n        if(c2 % 2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c2 == 0)\n\
    \    {\n        if(c1 % 2 == 0)\n            return \"Yes\";\n        else\n \
    \           return \"No\";\n    }\n    if(c1 % 2 == 0 && c2 % 2 == 0)\n      \
    \  return \"Yes\";\n    if(c1 % 2 == 1 && c2 % 2 == 1)\n        return \"Yes\"\
    ;\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk24h88wm.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpk24h88wm.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk24h88wm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string result = \"Yes\";\n    int open = 0;\n    int close = 0;\n    foreach(string\
    \ s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n\
    \                open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open != close)\n        result = \"No\";\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3vnlo7zl.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmp3vnlo7zl.__unittest_L36_C1() [0x4280c2]

    ??:? void tmp3vnlo7zl.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close && s2_open > s2_close)\n    {\n        if(s2_open - s2_close ==\
    \ s1_open)\n            return \"Yes\";\n        else\n            return \"No\"\
    ;\n    }\n    else if(s1_open > s1_close && s2_open == s2_close)\n    {\n    \
    \    if(s1_open - s1_close == s2_open)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    else if(s1_open > s1_close && s2_open\
    \ > s2_close)\n    {\n        if(s1_open - s1_close == s2_open - s2_close)\n \
    \           return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqgk95enj.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x429125]

    ??:? void tmpqgk95enj.__unittest_L65_C1() [0x427d60]

    ??:? void tmpqgk95enj.__modtest() [0x42838c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a921]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e55]

    ??:? runModuleUnitTests [0x42d849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 ~ s2;\n    int\
    \ cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n\
    \        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n        \
    \    return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6imigz1g.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmp6imigz1g.__unittest_L34_C1() [0x427e06]

    ??:? void tmp6imigz1g.__modtest() [0x4282a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d98b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a839]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42d761]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429500]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open\
    \ == s1_close && s2_open > s2_close)\n    {\n        if(s2_open - s2_close ==\
    \ s1_open)\n            return \"Yes\";\n        else\n            return \"No\"\
    ;\n    }\n    else if(s1_open > s1_close && s2_open == s2_close)\n    {\n    \
    \    if(s1_open - s1_close == s2_open)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    else if(s1_open > s1_close && s2_open\
    \ > s2_close)\n    {\n        if(s1_open - s1_close == s2_open - s2_close)\n \
    \           return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqgk95enj.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x429125]

    ??:? void tmpqgk95enj.__unittest_L65_C1() [0x427d60]

    ??:? void tmpqgk95enj.__modtest() [0x42838c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a921]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e55]

    ??:? runModuleUnitTests [0x42d849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    return s;\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplwjqe884.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fbd]

    ??:? void tmplwjqe884.__unittest_L24_C1() [0x427bf8]

    ??:? void tmplwjqe884.__modtest() [0x428224]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e333]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1e1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b270]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b16d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ced]

    ??:? runModuleUnitTests [0x42e109]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42940c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == count2)\n  \
    \      return \"Yes\";\n    if(count1 == -count2)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4murz53f.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp4murz53f.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4murz53f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 ~ s2;\n    int\
    \ cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n\
    \        else\n            cnt--;\n        if(cnt < 0)\n            return \"\
    No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp__dvvvza.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x429035]

    ??:? void tmp__dvvvza.__unittest_L34_C1() [0x427dfe]

    ??:? void tmp__dvvvza.__modtest() [0x4282a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d983]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a831]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d65]

    ??:? runModuleUnitTests [0x42d759]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close)\n    {\n        if(s2_open > s2_close)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    if(s2_open == s2_close)\n\
    \    {\n        if(s1_open > s1_close)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    if(s1_open > s1_close)\n    {\n      \
    \  if(s2_open > s2_close)\n            return \"Yes\";\n        else\n       \
    \     return \"No\";\n    }\n    if(s2_open > s2_close)\n    {\n        if(s1_open\
    \ > s1_close)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp19r0wm_z.d(75): unittest failure

    ----------------

    ??:? _d_unittestp [0x429135]

    ??:? void tmp19r0wm_z.__unittest_L71_C1() [0x427d70]

    ??:? void tmp19r0wm_z.__modtest() [0x42839c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a931]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e65]

    ??:? runModuleUnitTests [0x42d859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] arr = new int[n];\n    int\
    \ i = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            arr[i]\
    \ = 1;\n        else\n            arr[i] = -1;\n        i++;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            arr[i] = 1;\n        else\n  \
    \          arr[i] = -1;\n        i++;\n    }\n    int sum = 0;\n    foreach(e;\
    \ arr)\n    {\n        sum += e;\n        if(sum < 0)\n            return \"No\"\
    ;\n    }\n    if(sum == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmrt344ih.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpmrt344ih.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmrt344ih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 > 0 && count2 < 0 && abs(count1) == abs(count2))\n        return \"\
    Yes\";\n    else if(count1 < 0 && count2 > 0 && abs(count1) == abs(count2))\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvanzkz38.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x429145]

    ??:? void tmpvanzkz38.__unittest_L46_C1() [0x4281e2]

    ??:? void tmpvanzkz38.__modtest() [0x4283b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a941]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e75]

    ??:? runModuleUnitTests [0x42d869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429608]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int l1 = s1.length;\n    int\
    \ l2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < l1;\
    \ i++)\n    {\n        if (s1[i] == '(')\n            c1++;\n        else\n  \
    \          c1--;\n    }\n    for (int i = 0; i < l2; i++)\n    {\n        if (s2[i]\
    \ == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if (c1\
    \ == 0 && c2 == 0)\n        return \"Yes\";\n    if (c1 == 0 && c2 != 0)\n   \
    \     return \"No\";\n    if (c1 != 0 && c2 == 0)\n        return \"No\";\n  \
    \  if (c1 > 0 && c2 > 0)\n        return \"No\";\n    if (c1 < 0 && c2 < 0)\n\
    \        return \"No\";\n    if (c1 > 0 && c2 < 0)\n    {\n        if (c1 == -c2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    if (c1 < 0 && c2 > 0)\n    {\n        if (c2 == -c1)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqt0a6x8z.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpqt0a6x8z.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqt0a6x8z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else\n    {\n        if(count1\
    \ > 0)\n        {\n            if(count2 > 0)\n            {\n               \
    \ if(count1 > count2)\n                    return \"Yes\";\n                else\n\
    \                    return \"No\";\n            }\n            else\n       \
    \     {\n                if(count1 > abs(count2))\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n        }\n        else\n        {\n            if(count2 > 0)\n    \
    \        {\n                if(abs(count1) > count2)\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n            else\n            {\n                if(abs(count1) > abs(count2))\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n    }\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1eo6cyti.d(85): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291c5]

    ??:? void tmp1eo6cyti.__unittest_L81_C1() [0x427df0]

    ??:? void tmp1eo6cyti.__modtest() [0x428430]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9c1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa50]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a94d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ef5]

    ??:? runModuleUnitTests [0x42d8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429688]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n    int cnt\
    \ = 0;\n    foreach(char c; s)\n    {\n        if(c == '(')\n            cnt++;\n\
    \        else\n            cnt--;\n        if(cnt < 0)\n            return \"\
    No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqsonwanj.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmpqsonwanj.__unittest_L34_C1() [0x427e02]

    ??:? void tmpqsonwanj.__modtest() [0x4282a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b261]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42e189]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42948c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l =\
    \ 0;\n    int cnt = 0;\n    int cnt2 = 0;\n    int cnt3 = 0;\n    int cnt4 = 0;\n\
    \    int cnt5 = 0;\n    int cnt6 = 0;\n    int cnt7 = 0;\n    int cnt8 = 0;\n\
    \    int cnt9 = 0;\n    int cnt10 = 0;\n    int cnt11 = 0;\n    int cnt12 = 0;\n\
    \    int cnt13 = 0;\n    int cnt14 = 0;\n    int cnt15 = 0;\n    int cnt16 = 0;\n\
    \    int cnt17 = 0;\n    int cnt18 = 0;\n    int cnt19 = 0;\n    int cnt20 = 0;\n\
    \    int cnt21 = 0;\n    int cnt22 = 0;\n    int cnt23 = 0;\n    int cnt24 = 0;\n\
    \    int cnt25 = 0;\n    int cnt26 = 0;\n    int cnt27 = 0;\n    int cnt28 = 0;\n\
    \    int cnt29 = 0;\n    int cnt30 = 0;\n    int cnt31 = 0;\n    int cnt32 = 0;\n\
    \    int cnt33 = 0;\n    int cnt34 = 0;\n    int cnt35 = 0;\n    int cnt36 = 0;\n\
    \    int cnt37 = 0;\n    int cnt38 = 0;\n    int cnt39 = 0;\n    int cnt40 = 0;\n\
    \    int cnt41 = 0;\n    int cnt42 = 0;\n    int cnt43 = 0;\n    int cnt44 = 0;\n\
    \    int cnt45 = 0;\n    int cnt46 = 0;\n    int cnt47 = 0;\n    int cnt48 = 0;\n\
    \    int cnt49 =\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwff2y6or.d(76): Error: expression expected, not `unittest`

    /tmp/tmpwff2y6or.d(77): Error: semicolon expected, not `{`

    /tmp/tmpwff2y6or.d(93): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwff2y6or.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n\
    \        else\n            s1_open--;\n        if(s1_open < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  s2_open++;\n        else\n            s2_open--;\n        if(s2_open < 0)\n\
    \            return \"No\";\n    }\n    if(s1_open == 0 && s2_open == 0)\n   \
    \     return \"Yes\";\n    if(s1_open == s2_open)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp30ide3xs.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290a5]

    ??:? void tmp30ide3xs.__unittest_L47_C1() [0x427ce0]

    ??:? void tmp30ide3xs.__modtest() [0x42830c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9f3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dfe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a930]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a82d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dd5]

    ??:? runModuleUnitTests [0x42d7c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429568]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else if(count1 > 0 && count2\
    \ < 0)\n        return \"No\";\n    else if(count1 < 0 && count2 > 0)\n      \
    \  return \"No\";\n    else if(count1 > 0 && count2 > 0)\n    {\n        if(count1\
    \ == count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(count1 < 0 && count2 < 0)\n    {\n        if(count1\
    \ == count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvwzluj1w.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmpvwzluj1w.__unittest_L63_C1() [0x427d78]

    ??:? void tmpvwzluj1w.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0)\n    {\n        if(c2 == 2)\n            return \"\
    Yes\";\n        else\n            return \"No\";\n    }\n    if(c2 == 0)\n   \
    \ {\n        if(c1 == 2)\n            return \"Yes\";\n        else\n        \
    \    return \"No\";\n    }\n    if(c1 == 2 && c2 == 2)\n        return \"Yes\"\
    ;\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4sm3thuf.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp4sm3thuf.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4sm3thuf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0]\
    \ = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (i <= n1)\n      \
    \  {\n            dp[i] = dp[i - 1] + (s1[i - 1] == '(' ? 1 : -1);\n        }\n\
    \        else\n        {\n            dp[i] = dp[i - 1] + (s2[i - n1 - 1] == '('\
    \ ? 1 : -1);\n        }\n    }\n    if (dp[n] != 0)\n    {\n        return \"\
    No\";\n    }\n    int min = dp[0];\n    for (int i = 1; i <= n; i++)\n    {\n\
    \        min = min(min, dp[i]);\n    }\n    if (min >= 0)\n    {\n        return\
    \ \"Yes\";\n    }\n    for (int i = 0; i <= n; i++)\n    {\n        if (dp[i]\
    \ == min)\n        {\n            return \"Yes\";\n        }\n    }\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpajnj__jc.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpajnj__jc.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmpajnj__jc.d(44): Error: function expected before `()`, not `min` of type
    `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajnj__jc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n\
    \        else\n            s1_open--;\n    }\n    foreach(c; s2)\n    {\n    \
    \    if(c == '(')\n            s2_open++;\n        else\n            s2_open--;\n\
    \    }\n    if(s1_open == 0 && s2_open == 0)\n        return \"Yes\";\n    if(s1_open\
    \ == 0 && s2_open != 0)\n        return \"No\";\n    if(s1_open != 0 && s2_open\
    \ == 0)\n        return \"No\";\n    if(s1_open < 0 && s2_open > 0)\n        return\
    \ \"No\";\n    if(s1_open > 0 && s2_open < 0)\n        return \"No\";\n    if(s1_open\
    \ > 0 && s2_open > 0)\n    {\n        if(s1_open == s2_open)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(s1_open <\
    \ 0 && s2_open < 0)\n    {\n        if(s1_open == s2_open)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpogabep13.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmpogabep13.__unittest_L63_C1() [0x427d78]

    ??:? void tmpogabep13.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n    int[]\
    \ b = new int[n];\n    int i = 0;\n    foreach(c; s1)\n    {\n        if(c ==\
    \ '(')\n            a[i] = 1;\n        else\n            a[i] = -1;\n        i++;\n\
    \    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            b[i] = 1;\n\
    \        else\n            b[i] = -1;\n        i++;\n    }\n    int[] c = new\
    \ int[n];\n    foreach(i; 0..n)\n    {\n        c[i] = a[i] + b[i];\n    }\n \
    \   int[] d = new int[n];\n    d[0] = c[0];\n    foreach(i; 1..n)\n    {\n   \
    \     d[i] = d[i-1] + c[i];\n    }\n    foreach(i; 0..n)\n    {\n        if(d[i]\
    \ == 0)\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpszjc7uj6.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpszjc7uj6.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmpszjc7uj6.d(44): Error: variable `i` is shadowing variable `tmpszjc7uj6.match_parens.i`

    /tmp/tmpszjc7uj6.d(50): Error: variable `i` is shadowing variable `tmpszjc7uj6.match_parens.i`

    /tmp/tmpszjc7uj6.d(54): Error: variable `i` is shadowing variable `tmpszjc7uj6.match_parens.i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpszjc7uj6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            c1++;\n        else\n            c1--;\n  \
    \  }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n   \
    \     else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0)\n    {\n        if(c2 % 2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c2 == 0)\n\
    \    {\n        if(c1 % 2 == 0)\n            return \"Yes\";\n        else\n \
    \           return \"No\";\n    }\n    if(c1 < 0 && c2 < 0)\n    {\n        if(c1\
    \ + c2 == 0)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    if(c1 > 0 && c2 > 0)\n    {\n        if(c1 + c2 == 0)\n    \
    \        return \"Yes\";\n        else\n            return \"No\";\n    }\n  \
    \  return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_xe8k6rl.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp_xe8k6rl.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_xe8k6rl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return\
    \ \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1\
    \ > 0 && count2 < 0)\n    {\n        if(count1 == abs(count2))\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1 < 0\
    \ && count2 > 0)\n    {\n        if(abs(count1) == count2)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps7wm6dpn.d(17): Error: function `tmps7wm6dpn.match_parens` no `return
    exp;` or `assert(0);` at end of function

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps7wm6dpn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0)\n        return count2 > 0 ? \"Yes\" : \"No\";\n    if(count2 == 0)\n\
    \        return count1 < 0 ? \"Yes\" : \"No\";\n    if(count1 > 0 && count2 <\
    \ 0)\n        return abs(count1) == abs(count2) ? \"Yes\" : \"No\";\n    if(count1\
    \ < 0 && count2 > 0)\n        return abs(count1) == abs(count2) ? \"Yes\" : \"\
    No\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprv_0qq_l.d(61): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291bd]

    ??:? void tmprv_0qq_l.__unittest_L49_C1() [0x4281e4]

    ??:? void tmprv_0qq_l.__modtest() [0x428424]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9b9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa48]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a945]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428eed]

    ??:? runModuleUnitTests [0x42d8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429680]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int\
    \ n2 = s2.length;\n    int[] c1 = new int[n1];\n    int[] c2 = new int[n2];\n\
    \    int cnt1 = 0;\n    int cnt2 = 0;\n    for (int i = 0; i < n1; i++) {\n  \
    \      if (s1[i] == '(') {\n            cnt1++;\n        } else {\n          \
    \  cnt1--;\n        }\n        c1[i] = cnt1;\n    }\n    for (int i = 0; i < n2;\
    \ i++) {\n        if (s2[i] == '(') {\n            cnt2++;\n        } else {\n\
    \            cnt2--;\n        }\n        c2[i] = cnt2;\n    }\n    if (cnt1 !=\
    \ cnt2) {\n        return \"No\";\n    }\n    int min1 = min(c1);\n    int min2\
    \ = min(c2);\n    int max1 = max(c1);\n    int max2 = max(c2);\n    if (min1 <\
    \ 0 && min2 < 0) {\n        if (min1 + min2 != 0) {\n            return \"No\"\
    ;\n        }\n    }\n    if (max1 > 0 && max2 > 0) {\n        if (max1 + max2\
    \ != 0) {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoqivsvil.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpoqivsvil.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmpoqivsvil.d(46): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpoqivsvil.d(47): Error: undefined identifier `min`, did you mean variable
    `min1`?

    /tmp/tmpoqivsvil.d(48): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpoqivsvil.d(49): Error: undefined identifier `max`, did you mean variable
    `max1`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoqivsvil.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(abs(s1_open\
    \ - s1_close) == abs(s2_open - s2_close))\n        return \"Yes\";\n    else\n\
    \        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwhx5rhn6.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290dd]

    ??:? void tmpwhx5rhn6.__unittest_L44_C1() [0x427d92]

    ??:? void tmpwhx5rhn6.__modtest() [0x428344]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8d9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a968]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a865]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e0d]

    ??:? runModuleUnitTests [0x42d801]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    auto len\
    \ = s.length;\n    auto count = 0;\n    foreach(i; 0 .. len)\n    {\n        if(s[i]\
    \ == '(')\n            count++;\n        else\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi3dhuq3x.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpi3dhuq3x.__unittest_L38_C1() [0x427e1a]

    ??:? void tmpi3dhuq3x.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string str = \"\";\n    foreach(i; lst)\n        str ~= i;\n    return str;\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplgnt2u89.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fbd]

    ??:? void tmplgnt2u89.__unittest_L24_C1() [0x427bf8]

    ??:? void tmplgnt2u89.__modtest() [0x428224]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e333]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1e1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b270]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b16d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ced]

    ??:? runModuleUnitTests [0x42e109]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42940c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else if(count1 < 0 && count2\
    \ > 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n      \
    \  return \"No\";\n    else if(count1 > 0 && count2 > 0)\n    {\n        if(count1\
    \ == count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(count1 < 0 && count2 < 0)\n    {\n        if(count1\
    \ == count2)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpirn667jw.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmpirn667jw.__unittest_L63_C1() [0x427d78]

    ??:? void tmpirn667jw.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161334
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 =\
    \ 0;\n    foreach(char c; s1)\n    {\n        if(c == '(')\n            c1++;\n\
    \        else\n            c1--;\n    }\n    foreach(char c; s2)\n    {\n    \
    \    if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n\
    \    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2 !=\
    \ 0)\n        return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"No\"\
    ;\n    if(c1 > 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 && c2 > 0)\n\
    \        return \"No\";\n    if(c1 > 0 && c2 > 0)\n        return \"Yes\";\n \
    \   if(c1 < 0 && c2 < 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8psseobi.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x429105]

    ??:? void tmp8psseobi.__unittest_L53_C1() [0x427d44]

    ??:? void tmp8psseobi.__modtest() [0x428370]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a901]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a990]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a88d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e35]

    ??:? runModuleUnitTests [0x42d829]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len = s1.length;\n\
    \    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open = 0;\n   \
    \ int s1_close = 0;\n    int s2_close = 0;\n    for (int i = 0; i < s1_len; i++)\n\
    \    {\n        if (s1[i] == '(')\n            s1_open++;\n        else\n    \
    \        s1_close++;\n    }\n    for (int i = 0; i < s2_len; i++)\n    {\n   \
    \     if (s2[i] == '(')\n            s2_open++;\n        else\n            s2_close++;\n\
    \    }\n    if (s1_open == s1_close && s2_open == s2_close)\n        return \"\
    Yes\";\n    if (s1_open == s1_close && s2_open != s2_close)\n        return \"\
    No\";\n    if (s1_open != s1_close && s2_open == s2_close)\n        return \"\
    No\";\n    if (s1_open != s1_close && s2_open != s2_close)\n    {\n        if\
    \ (s1_open > s1_close)\n        {\n            if (s2_open > s2_close)\n     \
    \       {\n                if (s1_open - s1_close == s2_open - s2_close)\n   \
    \                 return \"Yes\";\n                else\n                    return\
    \ \"No\";\n            }\n            else\n            {\n                if\
    \ (s1_open - s1_close == s2_close - s2_open)\n                    return \"Yes\"\
    ;\n                else\n                    return \"No\";\n            }\n \
    \       }\n        else\n        {\n            if (s2_open > s2_close)\n    \
    \        {\n                if (s1_close - s1_open == s2_open - s2_close)\n  \
    \                  return \"Yes\";\n                else\n                   \
    \ return \"No\";\n            }\n            else\n           \nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf09pa4mk.d(77): Error: found `unittest` instead of statement

    /tmp/tmpf09pa4mk.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpf09pa4mk.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf09pa4mk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            s1_open++;\n        else\n         \
    \   s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open\
    \ == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    if(s1_open\
    \ == s1_close && s2_open < s2_close)\n        return \"No\";\n    if(s1_open <\
    \ s1_close && s2_open == s2_close)\n        return \"No\";\n    if(s1_open < s1_close\
    \ && s2_open < s2_close)\n        return \"No\";\n    if(s1_open > s1_close &&\
    \ s2_open > s2_close)\n        return \"No\";\n    if(s1_open > s1_close && s2_open\
    \ < s2_close)\n        return \"No\";\n    if(s1_open < s1_close && s2_open >\
    \ s2_close)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpa9pktkfe.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x42912d]

    ??:? void tmpa9pktkfe.__unittest_L55_C1() [0x427d6c]

    ??:? void tmpa9pktkfe.__modtest() [0x428398]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a929]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e5d]

    ??:? runModuleUnitTests [0x42d851]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161334
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n    return\
    \ s.count(\"(\") == s.count(\")\") ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppmulmg67.d(22): Error: no property `count` for type `string`

    /tmp/tmppmulmg67.d(22): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppmulmg67.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 ~ s2;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmo8tpd_f.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpmo8tpd_f.__unittest_L37_C1() [0x427e0a]

    ??:? void tmpmo8tpd_f.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d993]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42d769]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429508]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int\
    \ s2_open = 0;\n    foreach(char c; s1)\n    {\n        if(c == '(')\n       \
    \     s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(char\
    \ c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n\
    \            s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n       \
    \ return \"Yes\";\n    if(s1_open == 0 && s2_open != 0)\n        return \"No\"\
    ;\n    if(s1_open != 0 && s2_open == 0)\n        return \"No\";\n    if(s1_open\
    \ > 0 && s2_open < 0)\n        return \"No\";\n    if(s1_open < 0 && s2_open >\
    \ 0)\n        return \"No\";\n    if(s1_open > 0 && s2_open > 0)\n        return\
    \ \"Yes\";\n    if(s1_open < 0 && s2_open < 0)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvk34l72o.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x429105]

    ??:? void tmpvk34l72o.__unittest_L53_C1() [0x427d44]

    ??:? void tmpvk34l72o.__modtest() [0x428370]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a901]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a990]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a88d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e35]

    ??:? runModuleUnitTests [0x42d829]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161334
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    int balance\
    \ = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            balance++;\n\
    \        else\n            balance--;\n        if(balance < 0)\n            return\
    \ \"No\";\n    }\n    return balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplw4b_c1o.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x429035]

    ??:? void tmplw4b_c1o.__unittest_L34_C1() [0x427dfe]

    ??:? void tmplw4b_c1o.__modtest() [0x4282a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d983]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a831]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d65]

    ??:? runModuleUnitTests [0x42d759]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161334
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 ==\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return\
    \ \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1\
    \ > 0 && count2 < 0)\n    {\n        if(abs(count1) > abs(count2))\n         \
    \   return \"No\";\n        else\n            return \"Yes\";\n    }\n    if(count1\
    \ < 0 && count2 > 0)\n    {\n        if(abs(count1) > abs(count2))\n         \
    \   return \"No\";\n        else\n            return \"Yes\";\n    }\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprpl66so0.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291ed]

    ??:? void tmprpl66so0.__unittest_L63_C1() [0x427f20]

    ??:? void tmprpl66so0.__modtest() [0x428454]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9e9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a975]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f1d]

    ??:? runModuleUnitTests [0x42d911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296b0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n    int count\
    \ = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxp5mzsn4.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpxp5mzsn4.__unittest_L34_C1() [0x427e0a]

    ??:? void tmpxp5mzsn4.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161334
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n  \
    \  int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == 0 && count2\
    \ != 0)\n    {\n        if(count2 % 2 == 0)\n            return \"Yes\";\n   \
    \     else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 ==\
    \ 0)\n    {\n        if(count1 % 2 == 0)\n            return \"Yes\";\n      \
    \  else\n            return \"No\";\n    }\n    if(count1 != 0 && count2 != 0)\n\
    \    {\n        if(abs(count1) == abs(count2))\n            return \"Yes\";\n\
    \        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_18dkv9e.d(21): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp_18dkv9e.d(22): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmp_18dkv9e.d(17): Error: function `tmp_18dkv9e.match_parens` no `return
    exp;` or `assert(0);` at end of function

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 > 0 && count2 < 0 && abs(count1) == abs(count2))\n        return \"\
    Yes\";\n    else if(count1 < 0 && count2 > 0 && abs(count1) == abs(count2))\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvanzkz38.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x429145]

    ??:? void tmpvanzkz38.__unittest_L46_C1() [0x4281e2]

    ??:? void tmpvanzkz38.__modtest() [0x4283b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a941]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e75]

    ??:? runModuleUnitTests [0x42d869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429608]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 + s2;\n    int\
    \ cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n\
    \        else\n            cnt--;\n        if(cnt < 0)\n            return \"\
    No\";\n    }\n    if(cnt == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpogkmwxu0.d(21): Error: invalid array operation `s1 + s2` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogkmwxu0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n    int count\
    \ = 0;\n    foreach(char c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpllpanepf.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmpllpanepf.__unittest_L34_C1() [0x427e02]

    ??:? void tmpllpanepf.__modtest() [0x4282a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b261]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42e189]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42948c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161331
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n     \
    \   if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ > 0 && count2 < 0)\n        return \"Yes\";\n    if(count1 < 0 && count2 > 0)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn9nmq07h.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmpn9nmq07h.__unittest_L45_C1() [0x427ddc]

    ??:? void tmpn9nmq07h.__modtest() [0x4282fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string a = lst[0];\n    string b = lst[1];\n    int a_open = 0;\n    int b_open\
    \ = 0;\n    foreach(c; a)\n    {\n        if(c == '(')\n            a_open++;\n\
    \        else\n            a_open--;\n        if(a_open < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; b)\n    {\n        if(c == '(')\n           \
    \ b_open++;\n        else\n            b_open--;\n        if(b_open < 0)\n   \
    \         return \"No\";\n    }\n    if(abs(a_open - b_open) % 2 == 0)\n     \
    \   return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate =\
    \ match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf_tqc2hh.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290f5]

    ??:? void tmpf_tqc2hh.__unittest_L45_C1() [0x427d20]

    ??:? void tmpf_tqc2hh.__modtest() [0x428360]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a980]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a87d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e25]

    ??:? runModuleUnitTests [0x42d819]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161334
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 + s2;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp82iq0tnz.d(21): Error: invalid array operation `s1 + s2` (possible
    missing [])

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp82iq0tnz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161332
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int l1 = s1.length;\n    int\
    \ l2 = s2.length;\n    int l = l1 + l2;\n    int c = 0;\n    int i = 0;\n    int\
    \ j = 0;\n    int k = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n   \
    \ int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int a = 0;\n    int b = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n\
    \    int g = 0;\n    int h = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk\
    \ = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n \
    \   int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu\
    \ = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy = 0;\n \
    \   int zz = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd\
    \ = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n \
    \   int iii = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int mmm = 0;\n    int\
    \ nnn = 0;\n    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr\
    \ = 0;\n    int sss = 0;\n    int ttt = 0;\n    int uuu = 0;\nunittest\n{\n  \
    \  alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8dll71dn.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8dll71dn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161333
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n            \n*/\nstring match_parens(string[] lst) \n{\n   \
    \ string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2\
    \ = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else if(c == ')')\n            count2++;\n    }\n    foreach(c; s2)\n\
    \    {\n        if(c == '(')\n            count1++;\n        else if(c == ')')\n\
    \            count2++;\n    }\n    if(count1 == count2)\n        return \"Yes\"\
    ;\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp623d6b_3.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x42905d]

    ??:? void tmp623d6b_3.__unittest_L42_C1() [0x42810e]

    ??:? void tmp623d6b_3.__modtest() [0x4282c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428db6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a859]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7e5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d8d]

    ??:? runModuleUnitTests [0x42d781]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429520]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161332
