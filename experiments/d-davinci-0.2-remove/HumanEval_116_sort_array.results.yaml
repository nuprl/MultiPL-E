language: d
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort!((a, b) => {\n        int a_ones = countOnes(a);\n        int b_ones\
    \ = countOnes(b);\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n\
    \    })(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqe98vc8c.d(15): Error: template instance `sort!((a, b) => ()

    {

    int a_ones = countOnes(a);

    int b_ones = countOnes(b);

    return a_ones == b_ones ? a - b : a_ones - b_ones;

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqe98vc8c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        return a1 == b1 ? a - b : a1 - b1;\n    });\n   \
    \ return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6x_h8jrp.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6x_h8jrp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_tuple = arr.map!(a\
    \ => tuple(a, a.countOnes));\n    arr_tuple.sort!((a, b) => a[1] < b[1] || (a[1]\
    \ == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a => a[0]).array;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptkvk3sy4.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptkvk3sy4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    auto arr_with_ones = arr.map!(a => tuple(a, countOnes(a)));\n    arr_with_ones.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8iywasp9.d(15): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8iywasp9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(x => tuple(x, x.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(x =>\
    \ x[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc7dmooti.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc7dmooti.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpug9esk2q.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpug9esk2q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.map!(x\
    \ => tuple(x, x.countOnes, x.countOnes == 0 ? x : x.countOnes)).sort!((x, y) =>\
    \ x[1] < y[1] || (x[1] == y[1] && x[2] < y[2]));\n    return a.map!(x => x[0]).array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdbsfjbgr.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdbsfjbgr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort!((a, b) => (a.countOnes > b.countOnes) || (a.countOnes == b.countOnes\
    \ && a > b))(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbymadq8m.d(15): Error: template instance `sort!((a, b) => a.countOnes
    > b.countOnes || a.countOnes == b.countOnes && (a > b))` template `sort` is not
    defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbymadq8m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => countOnes(a) == countOnes(b) ? a - b : countOnes(a)\
    \ - countOnes(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm8mqgqx1.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm8mqgqx1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto aa = a.to!string(2);\n       \
    \ auto bb = b.to!string(2);\n        if (aa.count('1') == bb.count('1'))\n   \
    \         return a < b;\n        return aa.count('1') < bb.count('1');\n    });\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqk9umygh.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqk9umygh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) =>\n    {\n        auto aa = a.to!string(2);\n        auto\
    \ bb = b.to!string(2);\n        return aa.count('1') == bb.count('1') ? a - b\
    \ : aa.count('1') - bb.count('1');\n    });\n    return a;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg8xpiau9.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8xpiau9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0ltjc4y.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0ltjc4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) => \n    {\n        auto a_ = a.to!string(2);\n       \
    \ auto b_ = b.to!string(2);\n        auto a_ones = a_.count('1');\n        auto\
    \ b_ones = b_.count('1');\n        return a_ones == b_ones ? a < b : a_ones <\
    \ b_ones;\n    });\n    return arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyg57930y.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyg57930y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt_wl21ye.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt_wl21ye.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sorted.sort!((a, b) => \n    {\n        int aOnes = countOnes(a);\n     \
    \   int bOnes = countOnes(b);\n        if (aOnes == bOnes)\n            return\
    \ a - b;\n        return aOnes - bOnes;\n    });\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdnh2jqvr.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdnh2jqvr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto aa = a.to!string(2);\n        auto\
    \ bb = b.to!string(2);\n        if (aa.count('1') == bb.count('1'))\n        \
    \    return a < b;\n        return aa.count('1') < bb.count('1');\n    });\n \
    \   return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7w7gy5lv.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7w7gy5lv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpctau4uqu.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpctau4uqu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes();\n        auto b_ones = b.countOnes();\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmdub5pod.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmdub5pod.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n      \
    \  auto b_ones = countOnes(b);\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzqz_lwih.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzqz_lwih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2);\n        auto\
    \ b1 = b.to!string(2);\n        auto a2 = a1.count('1');\n        auto b2 = b1.count('1');\n\
    \        if (a2 == b2)\n            return a < b;\n        return a2 < b2;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2fdat9sf.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2fdat9sf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    // Your code here\n\
    \    return arr.sort!((a, b) => \n    {\n        auto aBits = a.to!string.count('1');\n\
    \        auto bBits = b.to!string.count('1');\n        return aBits == bBits ?\
    \ a < b : aBits < bBits;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpttnxy0we.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttnxy0we.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sorted.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n    \
    \    auto b_ones = countOnes(b);\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzalls39f.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzalls39f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto aOnes = a.countOnes();\n        auto bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmovb3q30.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmovb3q30.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyoo9gkmx.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyoo9gkmx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0ltjc4y.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0ltjc4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_bzypfyb.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_bzypfyb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result = new\
    \ long[arr.length];\n    int[] ones = new int[arr.length];\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        ones[i] = countOnes(arr[i]);\n    }\n \
    \   sort(ones, arr);\n    return arr;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbmd2d1g1.d(18): Error: undefined identifier `countOnes`

    /tmp/tmpbmd2d1g1.d(20): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbmd2d1g1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes, a.countOnes > 0 ? a\
    \ : 0));\n    arr_tuple.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[2] <\
    \ b[2]));\n    return arr_tuple.map!(a => a[0]).array;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpszgqjcm1.d(15): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpszgqjcm1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n \
    \       auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n          \
    \  return a.compare(b);\n        return a_ones.compare(b_ones);\n    });\n   \
    \ return arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2suj82zq.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2suj82zq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n      \
    \  auto b_ones = countOnes(b);\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzqz_lwih.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzqz_lwih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbakavqk7.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbakavqk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n\
    \        return a1 == b1 ? a - b : a1 - b1;\n    });\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqjugbitu.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqjugbitu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) {\n        auto a_ones = a.countOnes;\n        auto b_ones\
    \ = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw8iozqyn.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw8iozqyn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => a.countOnes() == b.countOnes() ? a.compare(b) : a.countOnes().compare(b.countOnes()));\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppv5u6jjy.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppv5u6jjy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfi8m1vv4.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfi8m1vv4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes == b.countOnes) ? a < b : a.countOnes <\
    \ b.countOnes);\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3g18m64t.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3g18m64t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    long[] sorted = arr.dup;\n    sorted.sort!((a, b) => \n    {\n        int\
    \ a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n        return a_ones\
    \ == b_ones ? a - b : a_ones - b_ones;\n    });\n    return sorted;\n}\n/*\n \
    \   This is the best solution I have found so far.\n    It is a bit more complicated\
    \ than the one I came up with, but it is also\n    more efficient.\n    The idea\
    \ is to use a custom sort function that compares the number of ones\n    in the\
    \ binary representation of the numbers.\n    If the number of ones is the same,\
    \ then the numbers are compared directly.\n    The sort function is passed to\
    \ the sort method of the array.\n    The sort method is called with the dup method,\
    \ which creates a copy of the\n    array.\n    This is because the sort method\
    \ sorts the array in place.\n    The sorted array is returned.\n*/\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprku09i8a.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprku09i8a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result = new\
    \ long[arr.length];\n    long[] tmp = new long[arr.length];\n    long[] ones =\
    \ new long[arr.length];\n    long[] zeros = new long[arr.length];\n    long[]\
    \ tmp_ones = new long[arr.length];\n    long[] tmp_zeros = new long[arr.length];\n\
    \    long[] tmp_result = new long[arr.length];\n    long[] tmp_tmp = new long[arr.length];\n\
    \    long[] tmp_tmp_result = new long[arr.length];\n    long[] tmp_tmp_tmp = new\
    \ long[arr.length];\n    long[] tmp_tmp_tmp_result = new long[arr.length];\n \
    \   long[] tmp_tmp_tmp_tmp = new long[arr.length];\n    long[] tmp_tmp_tmp_tmp_result\
    \ = new long[arr.length];\n    long[] tmp_tmp_tmp_tmp_tmp = new long[arr.length];\n\
    \    long[] tmp_tmp_tmp_tmp_tmp_result = new long[arr.length];\n    long[] tmp_tmp_tmp_tmp_tmp_tmp\
    \ = new long[arr.length];\n    long[] tmp_tmp_tmp_tmp_tmp_tmp_result = new long[arr.length];\n\
    \    long[] tmp_tmp_tmp_tmp_tmp_tmp_tmp = new long[arr.length];\n    long[] tmp_tmp_tmp_tmp_tmp_tmp_tmp_result\
    \ = new long[arr.length];\n    long[] tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp = new long[arr.length];\n\
    \    long[] tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_result = new long[arr.length];\n \
    \   long[] tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp = new long[arr.length];\n    long[]\
    \ tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_result = new long[arr.length];\n    long[]\
    \ tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp_tmp = new long[arr.length];\n    long[]\
    \ tmp_tmp_tmp_tmp_\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbi_mv5sy.d(39): Error: semicolon expected, not `unittest`

    /tmp/tmpbi_mv5sy.d(39): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbi_mv5sy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(x => tuple(x, countOnes(x)));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(x =>\
    \ x[0]).array;\n}\n/*\n    This is the most efficient way to sort an array of\
    \ numbers based on the number of ones in their binary representation.\n    The\
    \ map function creates a tuple of the number and the number of ones in its binary\
    \ representation.\n    The sort function sorts the array based on the number of\
    \ ones in ascending order.\n    If the number of ones is the same, it sorts based\
    \ on the decimal value.\n    The map function returns an array of the numbers.\n\
    */\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9xk8jrvz.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9xk8jrvz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto aa = a.to!string(2);\n       \
    \ auto bb = b.to!string(2);\n        auto a1 = aa.count('1');\n        auto b1\
    \ = bb.count('1');\n        if (a1 == b1)\n            return a < b;\n       \
    \ return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvmazhwvc.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvmazhwvc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ede7iqc.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ede7iqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] ret = arr.dup;\n\
    \    ret.sort!((a, b) =>\n    {\n        int a_ones = a.countOnes;\n        int\
    \ b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return a -\
    \ b;\n        return a_ones - b_ones;\n    });\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_rh0qmcy.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_rh0qmcy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0ltjc4y.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0ltjc4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) =>\n    {\n        auto a_ = a.to!string(2);\n        auto\
    \ b_ = b.to!string(2);\n        auto a_ones = a_.count('1');\n        auto b_ones\
    \ = b_.count('1');\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n\
    \    });\n    return arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpycc_rlet.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpycc_rlet.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto sort_func = (a,\
    \ b) =>\n    {\n        auto a_ones = a.countOneBits;\n        auto b_ones = b.countOneBits;\n\
    \        if (a_ones == b_ones)\n            return a < b ? -1 : 1;\n        return\
    \ a_ones < b_ones ? -1 : 1;\n    };\n    arr.sort(sort_func);\n    return arr;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9b7v7t3p.d(14): Error: variable `tmp9b7v7t3p.sort_array.sort_func`
    type `void` is inferred from initializer `(a, b) => ()

    {

    auto a_ones = a.countOneBits;

    auto b_ones = b.countOneBits;

    if (a_ones == b_ones)

    return a < b ? -1 : 1;

    return a_ones < b_ones ? -1 : 1;

    }

    `, and variables cannot be of type `void`

    /tmp/tmp9b7v7t3p.d(14): Error: template lambda has no value

    /tmp/tmp9b7v7t3p.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9b7v7t3p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0ltjc4y.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0ltjc4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sorted.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n    \
    \    auto b_ones = countOnes(b);\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzalls39f.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzalls39f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort!((a, b) => {\n        int aOnes = countOnes(a);\n        int bOnes =\
    \ countOnes(b);\n        if (aOnes == bOnes)\n            return a < b;\n    \
    \    return aOnes < bOnes;\n    })(sorted);\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbudz743m.d(15): Error: template instance `sort!((a, b) => ()

    {

    int aOnes = countOnes(a);

    int bOnes = countOnes(b);

    if (aOnes == bOnes)

    return a < b;

    return aOnes < bOnes;

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbudz743m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto\
    \ b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n\
    \    });\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2uchpjvi.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2uchpjvi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sorted.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n    \
    \    auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a - b;\n        return a_ones - b_ones;\n    });\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbdyxae9x.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbdyxae9x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n \
    \       auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl_2ow1w_.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_2ow1w_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) =>\n    {\n        auto a_ = a.to!string(2);\n        auto\
    \ b_ = b.to!string(2);\n        auto a_ones = a_.count('1');\n        auto b_ones\
    \ = b_.count('1');\n        if (a_ones == b_ones)\n            return a < b;\n\
    \        return a_ones < b_ones;\n    });\n    return arr_;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpigcxnbb4.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpigcxnbb4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n\
    \        auto b_ones = countOnes(b);\n        if (a_ones == b_ones)\n        \
    \    return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplyck0zx0.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplyck0zx0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdlycplee.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdlycplee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n        auto\
    \ b_ones = countOnes(b);\n        return a_ones < b_ones || (a_ones == b_ones\
    \ && a < b);\n    })(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz57p4m10.d(15): Error: template instance `sort!((a, b) => ()

    {

    auto a_ones = countOnes(a);

    auto b_ones = countOnes(b);

    return a_ones < b_ones || a_ones == b_ones && (a < b);

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz57p4m10.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => {\n        auto a_ones = a.countOnes;\n        auto\
    \ b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return a <\
    \ b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkgbk2klh.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkgbk2klh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2).count('1');\n\
    \        auto b1 = b.to!string(2).count('1');\n        return a1 == b1 ? a < b\
    \ : a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9oksz835.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9oksz835.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        return a1 == b1 ? a - b : a1 - b1;\n    });\n   \
    \ return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp109mtbzf.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp109mtbzf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result = new\
    \ long[arr.length];\n    long[] ones = new long[arr.length];\n    long[] zeros\
    \ = new long[arr.length];\n    int index = 0;\n    int index2 = 0;\n    foreach(long\
    \ i; arr)\n    {\n        if(i == 0)\n        {\n            zeros[index2] = i;\n\
    \            index2++;\n        }\n        else\n        {\n            ones[index]\
    \ = i;\n            index++;\n        }\n    }\n    ones = ones[0..index];\n \
    \   zeros = zeros[0..index2];\n    ones.sort!((a, b) => countOnes(a) < countOnes(b));\n\
    \    ones.sort!((a, b) => a < b);\n    zeros.sort!((a, b) => a < b);\n    result\
    \ = ones ~ zeros;\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsphx6wnv.d(34): Error: no property `sort` for type `long[]`

    /tmp/tmpsphx6wnv.d(35): Error: no property `sort` for type `long[]`

    /tmp/tmpsphx6wnv.d(36): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsphx6wnv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpctau4uqu.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpctau4uqu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n \
    \       auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n          \
    \  return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphg8zo2xt.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphg8zo2xt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(a => tuple(a, countOnes(a)));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprw06gm0m.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprw06gm0m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sorted.sort!((a, b) =>\n    {\n        long aOnes = a.countOnes;\n      \
    \  long bOnes = b.countOnes;\n        if (aOnes == bOnes)\n            return\
    \ a - b;\n        return aOnes - bOnes;\n    });\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwtlyektg.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwtlyektg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes() == b.countOnes()) ? a.compare(b) : a.countOnes().compare(b.countOnes()));\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpai2d1j23.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpai2d1j23.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) => \n    {\n        auto a_ones = countOnes(a);\n\
    \        auto b_ones = countOnes(b);\n        if (a_ones == b_ones)\n        \
    \    return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmtomkmvo.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmtomkmvo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbakavqk7.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbakavqk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        return a1 == b1 ? a - b : a1 - b1;\n    });\n   \
    \ return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6x_h8jrp.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6x_h8jrp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a >\
    \ b ? 1 : 0;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n \
    \   assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppged03jf.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppged03jf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes > b.countOnes) || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprz0pzkk5.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprz0pzkk5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string(2).count('1');\n\
    \        auto b1 = b.to!string(2).count('1');\n        return a1 == b1 ? a - b\
    \ : a1 - b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoq7kawrr.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoq7kawrr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0ltjc4y.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0ltjc4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyoo9gkmx.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyoo9gkmx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto sort_by_ones =\
    \ (a, b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones =\
    \ b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n \
    \   };\n    return arr.sort!sort_by_ones;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvvlf5dbh.d(14): Error: variable `tmpvvlf5dbh.sort_array.sort_by_ones`
    type `void` is inferred from initializer `(a, b) => ()

    {

    auto a_ones = a.countOnes;

    auto b_ones = b.countOnes;

    return a_ones == b_ones ? a - b : a_ones - b_ones;

    }

    `, and variables cannot be of type `void`

    /tmp/tmpvvlf5dbh.d(14): Error: template lambda has no value

    /tmp/tmpvvlf5dbh.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvvlf5dbh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpua12xejg.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpua12xejg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n \
    \       auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n          \
    \  return a - b;\n        return a_ones - b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmpofhetg.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmpofhetg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto\
    \ b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n\
    \    });\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2uchpjvi.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2uchpjvi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0ltjc4y.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0ltjc4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    auto arr3 = arr.dup;\n    auto arr4 = arr.dup;\n    arr2.sort!((a, b) =>\
    \ a.countOnes > b.countOnes);\n    arr3.sort!((a, b) => a.countOnes < b.countOnes);\n\
    \    arr4.sort!((a, b) => a.countOnes == b.countOnes);\n    arr2.sort!((a, b)\
    \ => a > b);\n    arr3.sort!((a, b) => a < b);\n    arr4.sort!((a, b) => a ==\
    \ b);\n    return arr2 ~ arr3 ~ arr4;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi_su1sa5.d(17): Error: no property `sort` for type `long[]`

    /tmp/tmpi_su1sa5.d(18): Error: no property `sort` for type `long[]`

    /tmp/tmpi_su1sa5.d(19): Error: no property `sort` for type `long[]`

    /tmp/tmpi_su1sa5.d(20): Error: no property `sort` for type `long[]`

    /tmp/tmpi_su1sa5.d(21): Error: no property `sort` for type `long[]`

    /tmp/tmpi_su1sa5.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi_su1sa5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = countOnes(a);\n        auto\
    \ b1 = countOnes(b);\n        return a1 == b1 ? a - b : a1 - b1;\n    });\n  \
    \  return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0n2qtol2.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0n2qtol2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes > b.countOnes);\n    arr2.sort!((a, b) =>\
    \ a.countOnes == b.countOnes && a > b);\n    return arr2;\n}\nunittest\n{\n  \
    \  alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5pfxamft.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp5pfxamft.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pfxamft.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto aa = a.to!string(2);\n       \
    \ auto bb = b.to!string(2);\n        auto a1 = aa.count('1');\n        auto b1\
    \ = bb.count('1');\n        if (a1 == b1)\n            return a > b;\n       \
    \ return a1 > b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp17ecamtp.d(15): Error: no property `sort` for type `long[]`

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes > b.countOnes || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_mlh78_t.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_mlh78_t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto onesA = countOnes(a);\n       \
    \ auto onesB = countOnes(b);\n        if (onesA == onesB)\n            return\
    \ a < b;\n        return onesA < onesB;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprhrehazm.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprhrehazm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => a.countOnes.cmp(b.countOnes) || a.cmp(b));\n    return\
    \ a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo9pkx8fw.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo9pkx8fw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result = new\
    \ long[arr.length];\n    int[] ones = new int[arr.length];\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        ones[i] = countOnes(arr[i]);\n    }\n \
    \   auto arr_tup = zip(arr, ones);\n    sort(arr_tup);\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        result[i] = arr_tup[i][0];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv_ugd0ks.d(18): Error: undefined identifier `countOnes`

    /tmp/tmpv_ugd0ks.d(20): Error: undefined identifier `zip`

    /tmp/tmpv_ugd0ks.d(21): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv_ugd0ks.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0ltjc4y.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0ltjc4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n      \
    \  auto b_ones = countOnes(b);\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzqz_lwih.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzqz_lwih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes == b.countOnes) ? a - b : a.countOnes -\
    \ b.countOnes);\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvwn6nldt.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvwn6nldt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes == b.countOnes) ? a.compare(b) : a.countOnes.compare(b.countOnes));\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmd5qn3zg.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmd5qn3zg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes > b.countOnes || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_mlh78_t.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_mlh78_t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes == b.countOnes) ? a < b : a.countOnes <\
    \ b.countOnes);\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3g18m64t.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3g18m64t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes > b.countOnes)\
    \ ? 1 : (a.countOnes < b.countOnes) ? -1 : (a > b) ? 1 : -1);\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo6j_lyjx.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo6j_lyjx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6bi7crck.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6bi7crck.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) {\n        auto aBits = a.countOnes;\n        auto bBits\
    \ = b.countOnes;\n        return aBits == bBits ? a - b : aBits - bBits;\n   \
    \ });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvy74jca9.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvy74jca9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] temp = new long[arr.length];\n\
    \    long[] ones = new long[arr.length];\n    long[] zeros = new long[arr.length];\n\
    \    long[] result = new long[arr.length];\n    long[] temp2 = new long[arr.length];\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb =\
    \ 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n   \
    \ int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk =\
    \ 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n   \
    \ int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt =\
    \ 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n   \
    \ int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n    int bbb = 0;\n    int ccc\
    \ = 0;\n    int ddd = 0;\n    int eee = 0;\n    int fff = 0;\n    int ggg = 0;\n\
    \    int hhh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int\
    \ lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n    int ooo = 0\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp761ferea.d(78): Error: semicolon expected, not `unittest`

    /tmp/tmp761ferea.d(78): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp761ferea.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbakavqk7.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbakavqk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdlycplee.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdlycplee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n         \
    \   return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8aspu5mw.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8aspu5mw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes) || a.cmp(b));\n    return\
    \ arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1vujl18b.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1vujl18b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) =>\n    {\n        auto c = a.countOnes;\n        auto d =\
    \ b.countOnes;\n        return c == d ? a - b : c - d;\n    });\n    return a;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_gexnrzf.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_gexnrzf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => {\n        auto a_ones = a.countOnes;\n        auto\
    \ b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return a -\
    \ b;\n        return a_ones - b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ltqa0wu.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ltqa0wu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort!((a, b) => \n    {\n        int aOnes = countOnes(a);\n        int bOnes\
    \ = countOnes(b);\n        return aOnes < bOnes || (aOnes == bOnes && a < b);\n\
    \    })(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnjxqpq03.d(15): Error: template instance `sort!((a, b) => ()

    {

    int aOnes = countOnes(a);

    int bOnes = countOnes(b);

    return aOnes < bOnes || aOnes == bOnes && (a < b);

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnjxqpq03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) =>\n    {\n        auto a_ = a.to!string(2);\n        auto\
    \ b_ = b.to!string(2);\n        auto a_ones = a_.count!((c) => c == '1');\n  \
    \      auto b_ones = b_.count!((c) => c == '1');\n        if (a_ones == b_ones)\n\
    \            return a < b;\n        return a_ones < b_ones;\n    });\n    return\
    \ arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgce6rtn2.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgce6rtn2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) =>\n    {\n        int a_ones = a.countOnes;\n  \
    \      int b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpraukrote.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpraukrote.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbakavqk7.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbakavqk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(a => tuple(a, countOnes(a)));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprw06gm0m.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprw06gm0m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto sort_by_ones =\
    \ (long a, long b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto\
    \ b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return a <\
    \ b;\n        return a_ones < b_ones;\n    };\n    arr.sort(sort_by_ones);\n \
    \   return arr;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3gg293ro.d(16): Error: no property `countOnes` for type `long`

    /tmp/tmp3gg293ro.d(17): Error: no property `countOnes` for type `long`

    /tmp/tmp3gg293ro.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3gg293ro.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto aa = a.to!string(2);\n       \
    \ auto bb = b.to!string(2);\n        auto a1 = aa.count('1');\n        auto b1\
    \ = bb.count('1');\n        if (a1 == b1)\n            return a - b;\n       \
    \ return a1 - b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyu_3e9ql.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyu_3e9ql.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => a.countOnes > b.countOnes ? 1 : a.countOnes < b.countOnes\
    \ ? -1 : a > b ? 1 : a < b ? -1 : 0);\n    return a;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpejpbl93w.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpejpbl93w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => a.countOnes > b.countOnes || (a.countOnes == b.countOnes\
    \ && a > b));\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw3i25dzi.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw3i25dzi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(a =>\
    \ a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpug9esk2q.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpug9esk2q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a1 = a.to!string(2).count('1');\n\
    \        auto b1 = b.to!string(2).count('1');\n        if (a1 == b1)\n       \
    \     return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3un25298.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3un25298.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes == b.countOnes) ? a - b : a.countOnes -\
    \ b.countOnes);\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvwn6nldt.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvwn6nldt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a - b;\n        return a_ones - b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp173v3xin.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp173v3xin.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => {\n        auto a_ones = a.countOnes;\n        auto\
    \ b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return a -\
    \ b;\n        return a_ones - b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ltqa0wu.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ltqa0wu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a - b;\n        return a_ones - b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp173v3xin.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp173v3xin.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes() == b.countOnes()) ? (a < b) : (a.countOnes()\
    \ < b.countOnes()));\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc27f1oqu.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc27f1oqu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        return a_ones < b_ones ? -1 : a_ones >\
    \ b_ones ? 1 : a < b ? -1 : a > b ? 1 : 0;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgjmnsrh4.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgjmnsrh4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n        auto\
    \ b_ones = b.countOnes;\n        return a_ones < b_ones ? -1 : a_ones > b_ones\
    \ ? 1 : a < b ? -1 : a > b ? 1 : 0;\n    });\n    return a;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmrul71no.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmrul71no.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort(sorted, (a, b) =>\n    {\n        int aOnes = countOnes(a);\n      \
    \  int bOnes = countOnes(b);\n        return aOnes == bOnes ? a - b : aOnes -\
    \ bOnes;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpql7grlj_.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpql7grlj_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result = new\
    \ long[arr.length];\n    long[] temp = new long[arr.length];\n    long[] temp2\
    \ = new long[arr.length];\n    long[] temp3 = new long[arr.length];\n    long[]\
    \ temp4 = new long[arr.length];\n    long[] temp5 = new long[arr.length];\n  \
    \  long[] temp6 = new long[arr.length];\n    long[] temp7 = new long[arr.length];\n\
    \    long[] temp8 = new long[arr.length];\n    long[] temp9 = new long[arr.length];\n\
    \    long[] temp10 = new long[arr.length];\n    long[] temp11 = new long[arr.length];\n\
    \    long[] temp12 = new long[arr.length];\n    long[] temp13 = new long[arr.length];\n\
    \    long[] temp14 = new long[arr.length];\n    long[] temp15 = new long[arr.length];\n\
    \    long[] temp16 = new long[arr.length];\n    long[] temp17 = new long[arr.length];\n\
    \    long[] temp18 = new long[arr.length];\n    long[] temp19 = new long[arr.length];\n\
    \    long[] temp20 = new long[arr.length];\n    long[] temp21 = new long[arr.length];\n\
    \    long[] temp22 = new long[arr.length];\n    long[] temp23 = new long[arr.length];\n\
    \    long[] temp24 = new long[arr.length];\n    long[] temp25 = new long[arr.length];\n\
    \    long[] temp26 = new long[arr.length];\n    long[] temp27 = new long[arr.length];\n\
    \    long[] temp28 = new long[arr.length];\n    long[] temp29 = new long[arr.length];\n\
    \    long[] temp30 = new long[arr.length];\n    long[] temp31 = new long[arr.length];\n\
    \    long[] temp32 = new long[arr.length];\n    long[] temp33 = new long[arr.length];\n\
    \    long[] temp34 = new long[arr.length];\n    long[] temp35 = new long[arr.length];\n\
    \    long[] temp36 = new\nunittest\n{\n    alias candidate = sort_array;\n\n \
    \   assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph4avkuzd.d(51): Error: basic type expected, not `unittest`

    /tmp/tmph4avkuzd.d(51): Error: semicolon expected, not `unittest`

    /tmp/tmph4avkuzd.d(51): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph4avkuzd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto cmp = (a, b) =>\
    \ \n    {\n        int a1 = a.countOnes;\n        int b1 = b.countOnes;\n    \
    \    if (a1 == b1)\n            return a - b;\n        return a1 - b1;\n    };\n\
    \    return arr.sort!cmp();\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbpzy27oq.d(14): Error: variable `tmpbpzy27oq.sort_array.cmp` type
    `void` is inferred from initializer `(a, b) => ()

    {

    int a1 = a.countOnes;

    int b1 = b.countOnes;

    if (a1 == b1)

    return a - b;

    return a1 - b1;

    }

    `, and variables cannot be of type `void`

    /tmp/tmpbpzy27oq.d(14): Error: template lambda has no value

    /tmp/tmpbpzy27oq.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpzy27oq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => {\n        auto a_ones = a.countOnes;\n        auto\
    \ b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return a <\
    \ b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkgbk2klh.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkgbk2klh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbakavqk7.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbakavqk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ede7iqc.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ede7iqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpctau4uqu.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpctau4uqu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a - b;\n        return a_ones - b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp173v3xin.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp173v3xin.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n      \
    \  auto b_ones = countOnes(b);\n        return a_ones == b_ones ? a.compare(b)\
    \ : a_ones.compare(b_ones);\n    });\n    return arr2;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1vonta0h.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1vonta0h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes > b.countOnes || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_mlh78_t.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_mlh78_t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    return arr.sort!((a, b) => {\n        int aOnes = a.countOnes;\n        int\
    \ bOnes = b.countOnes;\n        if (aOnes == bOnes)\n            return a - b;\n\
    \        return aOnes - bOnes;\n    });\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa_1g50hl.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa_1g50hl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort(sorted, (a, b) => \n    {\n        long aOnes = countOnes(a);\n    \
    \    long bOnes = countOnes(b);\n        return aOnes == bOnes ? a - b : aOnes\
    \ - bOnes;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1gy6uquu.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1gy6uquu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto aa = a.to!string(2);\n        auto\
    \ bb = b.to!string(2);\n        return aa.count('1') == bb.count('1') ? a - b\
    \ : aa.count('1') - bb.count('1');\n    });\n    return arr2;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcg8yp_xq.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcg8yp_xq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_bzypfyb.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_bzypfyb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n      \
    \  auto b_ones = countOnes(b);\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzqz_lwih.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzqz_lwih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto sorted = arr.dup;\n\
    \    sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n     \
    \   auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwn9lzwy8.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwn9lzwy8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto s = arr.dup;\n\
    \    s.sort!((a, b) =>\n    {\n        auto a_ones = countOnes(a);\n        auto\
    \ b_ones = countOnes(b);\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n\
    \    });\n    return s;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_gkqk26h.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_gkqk26h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) =>\n    {\n        auto a_ = a.to!string(2);\n        auto\
    \ b_ = b.to!string(2);\n        return a_.count('1') == b_.count('1') ? a < b\
    \ : a_.count('1') < b_.count('1');\n    });\n    return arr_;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqk4opila.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqk4opila.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort!((a, b) =>\n    {\n        long onesA = a.countOnes;\n        long onesB\
    \ = b.countOnes;\n        return onesA == onesB ? a < b : onesA < onesB;\n   \
    \ })(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph_aiv_72.d(15): Error: template instance `sort!((a, b) => ()

    {

    long onesA = a.countOnes;

    long onesB = b.countOnes;

    return onesA == onesB ? a < b : onesA < onesB;

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph_aiv_72.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhlhcm05.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhlhcm05.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort!((a, b) => \n    {\n        int a1 = a.countOnes;\n        int b1 =\
    \ b.countOnes;\n        if (a1 != b1)\n            return a1 < b1;\n        return\
    \ a < b;\n    })(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbue9v_43.d(15): Error: template instance `sort!((a, b) => ()

    {

    int a1 = a.countOnes;

    int b1 = b.countOnes;

    if (a1 != b1)

    return a1 < b1;

    return a < b;

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbue9v_43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto aa = a.to!string(2);\n        auto\
    \ bb = b.to!string(2);\n        return aa.count('1') == bb.count('1') ? a - b\
    \ : aa.count('1') - bb.count('1');\n    });\n    return arr2;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcg8yp_xq.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcg8yp_xq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a >\
    \ b ? 1 : 0;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n \
    \   assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp45uaxwmq.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp45uaxwmq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto sorted = arr.dup;\n\
    \    sorted.sort!((a, b) =>\n    {\n        auto aBin = a.to!string(2);\n    \
    \    auto bBin = b.to!string(2);\n        auto aOnes = aBin.count('1');\n    \
    \    auto bOnes = bBin.count('1');\n        if (aOnes == bOnes)\n            return\
    \ a < b;\n        return aOnes < bOnes;\n    });\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgcy7diwf.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcy7diwf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        return a1 == b1 ? a - b : a1 - b1;\n    });\n   \
    \ return arr2;\n}\n/*\n    Example:\n    sort_array([1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10]) == [1, 2, 4, 8, 3, 5, 6, 9, 10, 7]\n*/\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpva7g6ep7.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpva7g6ep7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result = new\
    \ long[arr.length];\n    long[] ones = new long[arr.length];\n    long[] zeros\
    \ = new long[arr.length];\n    long[] temp = new long[arr.length];\n    long[]\
    \ temp2 = new long[arr.length];\n    long[] temp3 = new long[arr.length];\n  \
    \  long[] temp4 = new long[arr.length];\n    long[] temp5 = new long[arr.length];\n\
    \    long[] temp6 = new long[arr.length];\n    long[] temp7 = new long[arr.length];\n\
    \    long[] temp8 = new long[arr.length];\n    long[] temp9 = new long[arr.length];\n\
    \    long[] temp10 = new long[arr.length];\n    long[] temp11 = new long[arr.length];\n\
    \    long[] temp12 = new long[arr.length];\n    long[] temp13 = new long[arr.length];\n\
    \    long[] temp14 = new long[arr.length];\n    long[] temp15 = new long[arr.length];\n\
    \    long[] temp16 = new long[arr.length];\n    long[] temp17 = new long[arr.length];\n\
    \    long[] temp18 = new long[arr.length];\n    long[] temp19 = new long[arr.length];\n\
    \    long[] temp20 = new long[arr.length];\n    long[] temp21 = new long[arr.length];\n\
    \    long[] temp22 = new long[arr.length];\n    long[] temp23 = new long[arr.length];\n\
    \    long[] temp24 = new long[arr.length];\n    long[] temp25 = new long[arr.length];\n\
    \    long[] temp26 = new long[arr.length];\n    long[] temp27 = new long[arr.length];\n\
    \    long[] temp28 = new long[arr.length];\n    long[] temp29 = new long[arr.length];\n\
    \    long[] temp30 = new long[arr.length];\n    long[] temp31 = new long[arr.length];\n\
    \    long[] temp32 = new long[arr.length];\n    long[] temp33 = new long[arr.length];\n\
    \    long[] temp34 = new long\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11kbuo3p.d(51): Error: semicolon expected, not `unittest`

    /tmp/tmp11kbuo3p.d(51): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11kbuo3p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a - b;\n      \
    \  return a1 - b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz7mzgp43.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz7mzgp43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes == b.countOnes) ? a.compare(b) : a.countOnes.compare(b.countOnes));\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmd5qn3zg.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmd5qn3zg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => {\n        auto aBin = a.to!string(2);\n        auto\
    \ bBin = b.to!string(2);\n        auto aOnes = aBin.count('1');\n        auto\
    \ bOnes = bBin.count('1');\n        if (aOnes == bOnes)\n            return a\
    \ < b;\n        return aOnes < bOnes;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx2cqmc8w.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx2cqmc8w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto aOnes = a.countOnes;\n        auto bOnes = b.countOnes;\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzzsmefbu.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzzsmefbu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ede7iqc.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ede7iqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => countOnes(a) == countOnes(b) ? a - b : countOnes(a)\
    \ - countOnes(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm8mqgqx1.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm8mqgqx1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(a => tuple(a, a.countOnes)).array;\n    arr_with_ones.sort!((a, b)\
    \ => a[1] == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return arr_with_ones.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfa_y28bl.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfa_y28bl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result = arr.dup;\n\
    \    result.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n    \
    \    auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaeyotjpg.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaeyotjpg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1gq46xva.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1gq46xva.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] result = new\
    \ long[arr.length];\n    long[] ones = new long[arr.length];\n    long[] zeros\
    \ = new long[arr.length];\n    long[] temp = new long[arr.length];\n    int i\
    \ = 0;\n    foreach(long x; arr)\n    {\n        temp[i] = x;\n        i++;\n\
    \    }\n    i = 0;\n    foreach(long x; arr)\n    {\n        ones[i] = count_ones(x);\n\
    \        i++;\n    }\n    i = 0;\n    foreach(long x; arr)\n    {\n        zeros[i]\
    \ = count_zeros(x);\n        i++;\n    }\n    i = 0;\n    foreach(long x; arr)\n\
    \    {\n        result[i] = x;\n        i++;\n    }\n    i = 0;\n    foreach(long\
    \ x; arr)\n    {\n        result[i] = temp[i];\n        i++;\n    }\n    i = 0;\n\
    \    foreach(long x; arr)\n    {\n        result[i] = temp[i];\n        i++;\n\
    \    }\n    i = 0;\n    foreach(long x; arr)\n    {\n        result[i] = temp[i];\n\
    \        i++;\n    }\n    i = 0;\n    foreach(long x; arr)\n    {\n        result[i]\
    \ = temp[i];\n        i++;\n    }\n    i = 0;\n    foreach(long x; arr)\n    {\n\
    \        result[i] = temp[i];\n        i++;\n    }\n    i = 0;\n    foreach(long\
    \ x; arr)\n    {\n        result[i] = temp[i];\n        i++;\n    }\n    i = 0;\n\
    \    foreach(long x; arr)\n    {\n        result[i] = temp[i];\n        i++;\n\
    \    }\n    i = 0;\n    foreach(long x; arr)\n    {\n        result[i] = temp[i];\n\
    \        i++;\n    }\n    i = 0;\n    foreach\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1o8vclln.d(92): Error: found `unittest` when expecting `(`

    /tmp/tmp1o8vclln.d(93): Error: basic type expected, not `{`

    /tmp/tmp1o8vclln.d(93): Error: no identifier for declarator `_error_`

    /tmp/tmp1o8vclln.d(93): Error: found `{` when expecting `;`

    /tmp/tmp1o8vclln.d(94): Error: expression expected, not `alias`

    /tmp/tmp1o8vclln.d(94): Error: found `candidate` when expecting `)`

    /tmp/tmp1o8vclln.d(94): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1o8vclln.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_ = arr.dup;\n\
    \    arr_.sort!((a, b) => \n    {\n        auto a_ = a.to!string(2);\n       \
    \ auto b_ = b.to!string(2);\n        return a_.count('1') == b_.count('1') ? a\
    \ < b : a_.count('1') < b_.count('1');\n    });\n    return arr_;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmpqsoilk.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmpqsoilk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu6rb8nbt.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu6rb8nbt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sorted.sort!((a, b) => \n    {\n        int a_ones = a.countOnes;\n     \
    \   int b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a - b;\n        return a_ones - b_ones;\n    });\n    return sorted;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr9kuzoe1.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9kuzoe1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(x => tuple(x, countOnes(x)));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_with_ones.map!(x =>\
    \ x[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzzdnirgk.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzzdnirgk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes > b.countOnes || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_mlh78_t.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_mlh78_t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        return a1 == b1 ? a - b : a1 - b1;\n    });\n   \
    \ return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp109mtbzf.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp109mtbzf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones\
    \ - b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxqldg7ya.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxqldg7ya.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto aa = a.to!string(2);\n       \
    \ auto bb = b.to!string(2);\n        auto a1 = aa.count('1');\n        auto b1\
    \ = bb.count('1');\n        if (a1 == b1)\n            return a < b;\n       \
    \ return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvmazhwvc.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvmazhwvc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbakavqk7.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbakavqk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => {\n        auto aa = a.to!string(2);\n        auto bb\
    \ = b.to!string(2);\n        return aa.count('1') == bb.count('1') ? a - b : aa.count('1')\
    \ - bb.count('1');\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpku65t883.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpku65t883.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes();\n        auto b_ones = b.countOnes();\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6vp6yif3.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6vp6yif3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto cmp = (a, b) {\n\
    \        auto a_ones = count(a.to!string, '1');\n        auto b_ones = count(b.to!string,\
    \ '1');\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    };\n\
    \    return arr.sort!cmp;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp64wb00pw.d(14): Error: variable `tmp64wb00pw.sort_array.cmp` type
    `void` is inferred from initializer `(a, b)

    {

    auto a_ones = count(a.to!string, ''1'');

    auto b_ones = count(b.to!string, ''1'');

    return a_ones == b_ones ? a - b : a_ones - b_ones;

    }

    `, and variables cannot be of type `void`

    /tmp/tmp64wb00pw.d(14): Error: template lambda has no value

    /tmp/tmp64wb00pw.d(19): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp64wb00pw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbakavqk7.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbakavqk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a - b;\n        return a_ones - b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp173v3xin.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp173v3xin.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) {\n        auto a_ones = a.countOnes;\n        auto b_ones\
    \ = b.countOnes;\n        return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 :\
    \ a < b ? -1 : a > b ? 1 : 0;\n    });\n    return arr2;\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoxwoucrw.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoxwoucrw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = countOnes(a);\n        auto\
    \ b1 = countOnes(b);\n        if (a1 == b1)\n            return a < b;\n     \
    \   return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1dddnfl6.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1dddnfl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => (a.countOnes == b.countOnes) ? a.compare(b) : a.countOnes.compare(b.countOnes));\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmd5qn3zg.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmd5qn3zg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) => a.countOnes > b.countOnes || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76k87v3g.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76k87v3g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => {\n        auto a1 = a.countOnes;\n        auto b1 =\
    \ b.countOnes;\n        return a1 == b1 ? a - b : a1 - b1;\n    });\n    return\
    \ arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwmahdw4w.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwmahdw4w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163129
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n      \
    \  auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a - b;\n        return a_ones - b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp173v3xin.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp173v3xin.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) {\n        auto a_ones = a.countOnes;\n        auto b_ones\
    \ = b.countOnes;\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw8iozqyn.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw8iozqyn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort!((a, b) =>\n    {\n        long aOnes = a.countOnes;\n        long bOnes\
    \ = b.countOnes;\n        return aOnes == bOnes ? a - b : aOnes - bOnes;\n   \
    \ })(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgm3axi9i.d(15): Error: template instance `sort!((a, b) => ()

    {

    long aOnes = a.countOnes;

    long bOnes = b.countOnes;

    return aOnes == bOnes ? a - b : aOnes - bOnes;

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgm3axi9i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163129
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] ones = arr.map!(a\
    \ => a.countOnes).array;\n    return arr.zip(ones).sort!((a, b) => a[1] < b[1]\
    \ || (a[1] == b[1] && a[0] < b[0])).map!(a => a[0]).array;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7b6qwdfc.d(14): Error: no property `map` for type `long[]`

    /tmp/tmp7b6qwdfc.d(15): Error: no property `zip` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7b6qwdfc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(a => tuple(a, countOnes(a)));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return arr_with_ones.map!(a => a[0]).array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76j71z64.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76j71z64.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163129
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n\
    \        return a1 == b1 ? a < b : a1 < b1;\n    });\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd_2gw5_k.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd_2gw5_k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163129
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    long[] sorted = arr.dup;\n    sort!((a, b) => (a.countOnes > b.countOnes)\
    \ || (a.countOnes == b.countOnes && a > b))(sorted);\n    return sorted;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbw9qv5_x.d(16): Error: template instance `sort!((a, b) => a.countOnes
    > b.countOnes || a.countOnes == b.countOnes && (a > b))` template `sort` is not
    defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbw9qv5_x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    // your code here\n\
    \    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n        auto a_ones\
    \ = a.countOnes;\n        auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n\
    \            return a < b;\n        return a_ones < b_ones;\n    });\n    return\
    \ arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbfly_jhl.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbfly_jhl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163129
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n       \
    \ auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n            return\
    \ a < b;\n        return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0ltjc4y.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0ltjc4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    // Your code here\n\
    \    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes > b.countOnes\
    \ || (a.countOnes == b.countOnes && a > b));\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2bobkcyi.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2bobkcyi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163129
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        if (a1 == b1)\n            return a < b;\n      \
    \  return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbakavqk7.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbakavqk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n        auto\
    \ b1 = b.countOnes;\n        return a1 == b1 ? a - b : a1 - b1;\n    });\n   \
    \ return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6x_h8jrp.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6x_h8jrp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto aOnes = a.countOnes;\n        auto bOnes = b.countOnes;\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzzsmefbu.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzzsmefbu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto a = arr.dup;\n\
    \    a.sort!((a, b) => a.countOnes > b.countOnes || (a.countOnes == b.countOnes\
    \ && a > b));\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw3i25dzi.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw3i25dzi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto cmp = (a, b) =>\n\
    \    {\n        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n\
    \        if (aOnes == bOnes)\n            return a - b;\n        return aOnes\
    \ - bOnes;\n    };\n    return arr.sort(cmp);\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt4bqr2_l.d(14): Error: variable `tmpt4bqr2_l.sort_array.cmp` type
    `void` is inferred from initializer `(a, b) => ()

    {

    int aOnes = countOnes(a);

    int bOnes = countOnes(b);

    if (aOnes == bOnes)

    return a - b;

    return aOnes - bOnes;

    }

    `, and variables cannot be of type `void`

    /tmp/tmpt4bqr2_l.d(14): Error: template lambda has no value

    /tmp/tmpt4bqr2_l.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt4bqr2_l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    arr.sort!((a, b) =>\n\
    \    {\n        auto aOnes = a.countOnes;\n        auto bOnes = b.countOnes;\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n    return arr;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpml7nv977.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpml7nv977.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163129
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort!((a, b) => \n    {\n        int a1 = a.countOnes;\n        int b1 =\
    \ b.countOnes;\n        return a1 < b1 ? -1 : a1 > b1 ? 1 : a < b ? -1 : a > b\
    \ ? 1 : 0;\n    })(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpswwy09mk.d(15): Error: template instance `sort!((a, b) => ()

    {

    int a1 = a.countOnes;

    int b1 = b.countOnes;

    return a1 < b1 ? -1 : a1 > b1 ? 1 : a < b ? -1 : a > b ? 1 : 0;

    }

    )` template `sort` is not defined, did you mean sqrt?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpswwy09mk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_with_ones =\
    \ arr.map!(a => tuple(a, a.countOnes));\n    arr_with_ones.sort!((a, b) => a[1]\
    \ == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return arr_with_ones.map!(a => a[0]).array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr929x2_6.d(14): Error: no property `map` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr929x2_6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => \n    {\n        auto aa = a.to!string(2);\n       \
    \ auto bb = b.to!string(2);\n        auto aaa = aa.count(\"1\");\n        auto\
    \ bbb = bb.count(\"1\");\n        if (aaa == bbb)\n            return a < b;\n\
    \        return aaa < bbb;\n    });\n    return arr2;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdb4cp54l.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdb4cp54l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163129
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes();\n        auto b_ones = b.countOnes();\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6vp6yif3.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6vp6yif3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) =>\n    {\n        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpximyca1y.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpximyca1y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163129
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    long[] sorted = arr.dup;\n\
    \    sort(sorted, (a, b) =>\n    {\n        int aOnes = countOnes(a);\n      \
    \  int bOnes = countOnes(b);\n        return aOnes == bOnes ? a - b : aOnes -\
    \ bOnes;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpql7grlj_.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpql7grlj_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n \
    \       auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl_2ow1w_.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_2ow1w_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    auto arr3 = arr.dup;\n    auto arr4 = arr.dup;\n    auto arr5 = arr.dup;\n\
    \    auto arr6 = arr.dup;\n    auto arr7 = arr.dup;\n    auto arr8 = arr.dup;\n\
    \    auto arr9 = arr.dup;\n    auto arr10 = arr.dup;\n    auto arr11 = arr.dup;\n\
    \    auto arr12 = arr.dup;\n    auto arr13 = arr.dup;\n    auto arr14 = arr.dup;\n\
    \    auto arr15 = arr.dup;\n    auto arr16 = arr.dup;\n    auto arr17 = arr.dup;\n\
    \    auto arr18 = arr.dup;\n    auto arr19 = arr.dup;\n    auto arr20 = arr.dup;\n\
    \    auto arr21 = arr.dup;\n    auto arr22 = arr.dup;\n    auto arr23 = arr.dup;\n\
    \    auto arr24 = arr.dup;\n    auto arr25 = arr.dup;\n    auto arr26 = arr.dup;\n\
    \    auto arr27 = arr.dup;\n    auto arr28 = arr.dup;\n    auto arr29 = arr.dup;\n\
    \    auto arr30 = arr.dup;\n    auto arr31 = arr.dup;\n    auto arr32 = arr.dup;\n\
    \    auto arr33 = arr.dup;\n    auto arr34 = arr.dup;\n    auto arr35 = arr.dup;\n\
    \    auto arr36 = arr.dup;\n    auto arr37 = arr.dup;\n    auto arr38 = arr.dup;\n\
    \    auto arr39 = arr.dup;\n    auto arr40 = arr.dup;\n    auto arr41 = arr.dup;\n\
    \    auto arr42 = arr.dup;\n    auto arr43 = arr.dup;\n    auto arr44 = arr.dup;\n\
    \    auto arr45 = arr.dup;\n    auto arr46 = arr.dup;\n    auto arr47 = arr.dup;\n\
    \    auto arr\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wcjj5jl.d(61): Error: no identifier for declarator `arr`

    /tmp/tmp6wcjj5jl.d(61): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wcjj5jl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) => a.countOnes > b.countOnes || (a.countOnes == b.countOnes\
    \ && a > b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_mlh78_t.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_mlh78_t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163128
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    \
    \            \n*/\nlong[] sort_array(long[] arr) \n{\n    return arr.sort!((a,\
    \ b) => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyoo9gkmx.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyoo9gkmx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163127
