language: d
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int vowel_index = -1;\n    int distance = -1;\n  \
    \  while(index--)\n    {\n        if(vowels.find(word[index]) != -1)\n       \
    \ {\n            vowel_index = index;\n            break;\n        }\n    }\n\
    \    if(vowel_index == -1)\n        return result;\n    index = vowel_index;\n\
    \    while(index--)\n    {\n        if(vowels.find(word[index]) == -1)\n     \
    \   {\n            if(distance == -1)\n            {\n                distance\
    \ = vowel_index - index;\n                result = word[vowel_index];\n      \
    \      }\n            else\n            {\n                if(vowel_index - index\
    \ < distance)\n                {\n                    distance = vowel_index -\
    \ index;\n                    result = word[vowel_index];\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1_46grct.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp1_46grct.d(24): Error: no property `find` for type `string`

    /tmp/tmp1_46grct.d(35): Error: no property `find` for type `string`

    /tmp/tmp1_46grct.d(40): Error: cannot implicitly convert expression `word[cast(ulong)vowel_index]`
    of type `immutable(char)` to `string`

    /tmp/tmp1_46grct.d(47): Error: cannot implicitly convert expression `word[cast(ulong)vowel_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_46grct.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = \"\";\n    auto last_consonant = \"\";\n    foreach(c;\
    \ word)\n    {\n        if(vowels.canFind(c))\n        {\n            last_vowel\
    \ = c;\n        }\n        else if(consonants.canFind(c))\n        {\n       \
    \     last_consonant = c;\n        }\n    }\n    return last_vowel;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpitebiu6j.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpitebiu6j.d(25): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmpitebiu6j.d(27): Error: no property `canFind` for type `string`

    /tmp/tmpitebiu6j.d(29): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpitebiu6j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ closest_vowel_index = -1;\n    int closest_vowel_distance = -1;\n    int word_length\
    \ = word.length;\n    for (int i = word_length - 1; i >= 0; i--)\n    {\n    \
    \    if (vowels.find(word[i]) != -1)\n        {\n            if (i == word_length\
    \ - 1)\n            {\n                return \"\";\n            }\n         \
    \   else\n            {\n                if (closest_vowel_distance == -1)\n \
    \               {\n                    closest_vowel_distance = word_length -\
    \ i - 1;\n                    closest_vowel_index = i;\n                }\n  \
    \              else\n                {\n                    if (word_length -\
    \ i - 1 < closest_vowel_distance)\n                    {\n                   \
    \     closest_vowel_distance = word_length - i - 1;\n                        closest_vowel_index\
    \ = i;\n                    }\n                }\n            }\n        }\n \
    \   }\n    if (closest_vowel_index != -1)\n    {\n        result = word[closest_vowel_index..closest_vowel_index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpizesvyds.d(21): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpizesvyds.d(24): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpizesvyds.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                if (vowels.find(word[index - 1]) == -1)\n                {\n\
    \                    result = word[index..$];\n                    break;\n  \
    \              }\n            }\n            else if (index == 0)\n          \
    \  {\n                if (vowels.find(word[index + 1]) == -1)\n              \
    \  {\n                    result = word[index..$];\n                    break;\n\
    \                }\n            }\n            else\n            {\n         \
    \       if (vowels.find(word[index - 1]) == -1 && vowels.find(word[index + 1])\
    \ == -1)\n                {\n                    result = word[index..$];\n  \
    \                  break;\n                }\n            }\n        }\n     \
    \   index--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprn8iy5nf.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmprn8iy5nf.d(22): Error: no property `find` for type `string`

    /tmp/tmprn8iy5nf.d(26): Error: no property `find` for type `string`

    /tmp/tmprn8iy5nf.d(34): Error: no property `find` for type `string`

    /tmp/tmprn8iy5nf.d(42): Error: no property `find` for type `string`

    /tmp/tmprn8iy5nf.d(42): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprn8iy5nf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    while(index--)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(index > 0 && vowels.find(word[index-1]) ==\
    \ -1)\n            {\n                if(index < word.length-1 && vowels.find(word[index+1])\
    \ == -1)\n                {\n                    result = word[index..$];\n  \
    \                  break;\n                }\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmsxdc3ct.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpmsxdc3ct.d(22): Error: no property `find` for type `string`

    /tmp/tmpmsxdc3ct.d(24): Error: no property `find` for type `string`

    /tmp/tmpmsxdc3ct.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmsxdc3ct.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int len = word.length;\n    int\
    \ i = len - 1;\n    while (i >= 0)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            if (i == len - 1)\n                return \"\";\n\
    \            else if (vowels.find(word[i + 1]) == -1)\n                return\
    \ word[i .. i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3_3c6ld3.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp3_3c6ld3.d(22): Error: no property `find` for type `string`

    /tmp/tmp3_3c6ld3.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_3c6ld3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int[]\
    \ vowel_indexes = [];\n    foreach(i, c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n            vowel_indexes ~= i;\n    }\n    if(vowel_indexes.length\
    \ == 0)\n        return result;\n    int min_distance = word.length;\n    foreach(i;\
    \ vowel_indexes)\n    {\n        int distance = word.length - i;\n        if(distance\
    \ < min_distance)\n        {\n            min_distance = distance;\n         \
    \   result = word[i..$];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbvax2k76.d(22): Error: no property `find` for type `string`

    /tmp/tmpbvax2k76.d(23): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpbvax2k76.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpbvax2k76.d(30): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbvax2k76.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int distance = 0;\n    int min_distance = word.length;\n   \
    \ foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n  \
    \          if(i > 0 && vowels.find(word[i-1]) == -1)\n            {\n        \
    \        distance = word.length - i;\n                if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         index = i;\n                }\n            }\n        }\n    }\n   \
    \ if(index > 0)\n    {\n        result = word[index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3vqrr118.d(21): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp3vqrr118.d(24): Error: no property `find` for type `string`

    /tmp/tmp3vqrr118.d(26): Error: no property `find` for type `string`

    /tmp/tmp3vqrr118.d(28): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp3vqrr118.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp3vqrr118.d(39): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3vqrr118.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                if (vowels.find(word[index - 1]) == -1)\n                {\n\
    \                    result = word[index];\n                    break;\n     \
    \           }\n            }\n            else if (index == 0)\n            {\n\
    \                if (vowels.find(word[index + 1]) == -1)\n                {\n\
    \                    result = word[index];\n                    break;\n     \
    \           }\n            }\n            else\n            {\n              \
    \  if (vowels.find(word[index - 1]) == -1 && vowels.find(word[index + 1]) == -1)\n\
    \                {\n                    result = word[index];\n              \
    \      break;\n                }\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpux28tcst.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpux28tcst.d(22): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(26): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(28): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    /tmp/tmpux28tcst.d(34): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(36): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    /tmp/tmpux28tcst.d(42): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(42): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(44): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpux28tcst.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int distance = word.length;\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i < index)\n            {\n                index = i;\n     \
    \           distance = word.length - i;\n                result = word[i];\n \
    \           }\n            else if (i == index)\n            {\n             \
    \   if (word.length - i < distance)\n                {\n                    distance\
    \ = word.length - i;\n                    result = word[i];\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpctms7d0b.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpctms7d0b.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpctms7d0b.d(21): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpctms7d0b.d(23): Error: no property `find` for type `string`

    /tmp/tmpctms7d0b.d(28): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmpctms7d0b.d(29): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmpctms7d0b.d(35): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmpctms7d0b.d(36): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpctms7d0b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min = word.length;\n    foreach(i, ch; word)\n    {\n  \
    \      if(vowels.find(ch) != -1)\n        {\n            if(i > 0 && i < word.length\
    \ - 1)\n            {\n                if(vowels.find(word[i-1]) == -1 && vowels.find(word[i+1])\
    \ == -1)\n                {\n                    if(abs(word.length - i) < min)\n\
    \                    {\n                        min = abs(word.length - i);\n\
    \                        index = i;\n                    }\n                }\n\
    \            }\n        }\n    }\n    if(index != 0)\n    {\n        result =\
    \ word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplxm3izzr.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplxm3izzr.d(23): Error: no property `find` for type `string`

    /tmp/tmplxm3izzr.d(27): Error: no property `find` for type `string`

    /tmp/tmplxm3izzr.d(27): Error: no property `find` for type `string`

    /tmp/tmplxm3izzr.d(31): Error: cannot implicitly convert expression `abs(word.length
    - i)` of type `ulong` to `int`

    /tmp/tmplxm3izzr.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmplxm3izzr.d(40): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplxm3izzr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ last_vowel_index = -1;\n    for (int i = word.length - 1; i >= 0; i--)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            last_vowel_index\
    \ = i;\n            break;\n        }\n    }\n    if (last_vowel_index == -1)\n\
    \        return result;\n    int first_consonant_index = -1;\n    for (int i =\
    \ last_vowel_index - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ == -1)\n        {\n            first_consonant_index = i;\n            break;\n\
    \        }\n    }\n    if (first_consonant_index == -1)\n        return result;\n\
    \    for (int i = last_vowel_index + 1; i < word.length; i++)\n    {\n       \
    \ if (vowels.find(word[i]) == -1)\n        {\n            if (i - last_vowel_index\
    \ < last_vowel_index - first_consonant_index)\n                return word[last_vowel_index..last_vowel_index];\n\
    \            else\n                return word[first_consonant_index..first_consonant_index];\n\
    \        }\n    }\n    return word[first_consonant_index..first_consonant_index];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxfbedk3x.d(20): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpxfbedk3x.d(22): Error: no property `find` for type `string`

    /tmp/tmpxfbedk3x.d(33): Error: no property `find` for type `string`

    /tmp/tmpxfbedk3x.d(43): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxfbedk3x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    int distance = 0;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = word[i];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr9lge95k.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpr9lge95k.d(23): Error: no property `find` for type `string`

    /tmp/tmpr9lge95k.d(25): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmpr9lge95k.d(29): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9lge95k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = word.length;\n  \
    \  int vowel_index = -1;\n    int consonant_index = -1;\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            vowel_index = i;\n            if (consonant_index != -1)\n      \
    \      {\n                if (vowel_index - consonant_index < index)\n       \
    \         {\n                    index = vowel_index - consonant_index;\n    \
    \            }\n            }\n        }\n        else\n        {\n          \
    \  consonant_index = i;\n        }\n    }\n    if (index == word.length)\n   \
    \ {\n        return \"\";\n    }\n    return word[vowel_index];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdx73p65z.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpdx73p65z.d(21): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpdx73p65z.d(23): Error: no property `find` for type `string`

    /tmp/tmpdx73p65z.d(43): Error: cannot implicitly convert expression `word[cast(ulong)vowel_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdx73p65z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = -1;\n    int min_distance = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  int distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if (index != -1)\n    {\n       \
    \ result = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqx7l7lll.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpqx7l7lll.d(23): Error: no property `find` for type `string`

    /tmp/tmpqx7l7lll.d(25): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmpqx7l7lll.d(35): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqx7l7lll.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string result = \"\";\n    int min_distance = word.length;\n    for (int\
    \ i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            int distance = word.length - i;\n            if (i > 0\
    \ && consonants.find(word[i - 1]) != -1)\n            {\n                if (distance\
    \ < min_distance)\n                {\n                    min_distance = distance;\n\
    \                    result = word[i];\n                }\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn1lbdq0r.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpn1lbdq0r.d(23): Error: no property `find` for type `string`

    /tmp/tmpn1lbdq0r.d(25): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmpn1lbdq0r.d(26): Error: no property `find` for type `string`

    /tmp/tmpn1lbdq0r.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn1lbdq0r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int min_distance = index;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = index\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                result = c;\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3im7nozw.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp3im7nozw.d(23): Error: no property `canFind` for type `string`

    /tmp/tmp3im7nozw.d(25): Error: cannot implicitly convert expression `cast(ulong)index
    - i` of type `ulong` to `int`

    /tmp/tmp3im7nozw.d(29): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3im7nozw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto found = false;\n    auto index = word.length;\n    foreach(i; 0 ..\
    \ word.length)\n    {\n        if(vowels.canFind(word[i]))\n        {\n      \
    \      if(i > 0 && consonants.canFind(word[i-1]))\n            {\n           \
    \     if(i < word.length-1 && consonants.canFind(word[i+1]))\n               \
    \ {\n                    found = true;\n                    index = i;\n     \
    \               break;\n                }\n            }\n        }\n    }\n \
    \   if(found)\n    {\n        return word[index..index+1];\n    }\n    else\n\
    \    {\n        return \"\";\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmr5j5kh8.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpmr5j5kh8.d(25): Error: no property `canFind` for type `string`

    /tmp/tmpmr5j5kh8.d(27): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmr5j5kh8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = -1;\n    int min_distance\
    \ = word.length;\n    for (int i = word.length-1; i >= 0; i--)\n    {\n      \
    \  if (vowels.find(word[i]) != -1)\n        {\n            int distance = word.length\
    \ - i;\n            if (distance < min_distance)\n            {\n            \
    \    index = i;\n                min_distance = distance;\n            }\n   \
    \     }\n    }\n    if (index == -1)\n        return \"\";\n    return word[index..$];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5yggi5r9.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp5yggi5r9.d(20): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp5yggi5r9.d(22): Error: no property `find` for type `string`

    /tmp/tmp5yggi5r9.d(24): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5yggi5r9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int i = word.length - 1;\n  \
    \  while (i >= 0) {\n        if (vowels.find(word[i]) != -1) {\n            if\
    \ (i == word.length - 1) {\n                return \"\";\n            }\n    \
    \        if (vowels.find(word[i + 1]) == -1) {\n                return word[i\
    \ .. i];\n            }\n        }\n        i--;\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpil2ceuk0.d(18): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpil2ceuk0.d(20): Error: no property `find` for type `string`

    /tmp/tmpil2ceuk0.d(24): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpil2ceuk0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto result = \"\";\n    auto last_consonant = \"\";\n    auto last_vowel\
    \ = \"\";\n    auto last_vowel_index = 0;\n    auto last_consonant_index = 0;\n\
    \    auto word_length = word.length;\n    auto word_length_minus_one = word_length\
    \ - 1;\n    auto word_length_minus_two = word_length - 2;\n    auto word_length_minus_three\
    \ = word_length - 3;\n    auto word_length_minus_four = word_length - 4;\n   \
    \ auto word_length_minus_five = word_length - 5;\n    auto word_length_minus_six\
    \ = word_length - 6;\n    auto word_length_minus_seven = word_length - 7;\n  \
    \  auto word_length_minus_eight = word_length - 8;\n    auto word_length_minus_nine\
    \ = word_length - 9;\n    auto word_length_minus_ten = word_length - 10;\n   \
    \ auto word_length_minus_eleven = word_length - 11;\n    auto word_length_minus_twelve\
    \ = word_length - 12;\n    auto word_length_minus_thirteen = word_length - 13;\n\
    \    auto word_length_minus_fourteen = word_length - 14;\n    auto word_length_minus_fifteen\
    \ = word_length - 15;\n    auto word_length_minus_sixteen = word_length - 16;\n\
    \    auto word_length_minus_seventeen = word_length - 17;\n    auto word_length_minus_eighteen\
    \ = word_length - 18;\n    auto word_length_minus_nineteen = word_length - 19;\n\
    \    auto word_length_minus_twenty = word_length - 20;\n    auto word_length_minus_twenty_one\
    \ = word_length - 21;\n    auto word_length_minus_twenty_two = word_length - 22;\n\
    \    auto word_length_minus_twenty_three = word_length - 23;\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprhpzji25.d(48): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprhpzji25.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    // your code here\n    string vowels = \"aeiou\";\n    int last_vowel\
    \ = -1;\n    int last_consonant = -1;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            last_vowel\
    \ = i;\n        }\n        else\n        {\n            last_consonant = i;\n\
    \        }\n        if (last_vowel != -1 && last_consonant != -1)\n        {\n\
    \            return word[last_vowel..$];\n        }\n    }\n    return \"\";\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp107g2u7f.d(23): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp107g2u7f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = \"\";\n    auto last_consonant = \"\";\n    auto result\
    \ = \"\";\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n   \
    \     {\n            last_vowel = c;\n        }\n        else if(consonants.canFind(c))\n\
    \        {\n            last_consonant = c;\n        }\n        if(last_vowel\
    \ != \"\" && last_consonant != \"\")\n        {\n            result = last_vowel;\n\
    \            last_vowel = \"\";\n            last_consonant = \"\";\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0bp0ozub.d(24): Error: no property `canFind` for type `string`

    /tmp/tmp0bp0ozub.d(26): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp0bp0ozub.d(28): Error: no property `canFind` for type `string`

    /tmp/tmp0bp0ozub.d(30): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0bp0ozub.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string result = \"\";\n    int min_distance = word.length;\n    int distance\
    \ = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int\
    \ m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n   \
    \ int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n\
    \    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n\
    \    int g = 0;\n    int h = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk\
    \ = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n \
    \   int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt\
    \ = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n \
    \   int yy = 0;\n    int zz = 0;\n    foreach(immutable char ch; word)\n    {\n\
    \        if(ch == 'b')\n        {\n            b = i;\n        }\n        if(ch\
    \ == 'c')\n        {\n            c = i;\n        }\n        if(ch == 'd')\n \
    \       {\n            d = i;\n        }\n        if(ch == 'f')\n        {\n \
    \           f = i;\n        }\n        if(ch == 'g')\n        {\n            g\
    \ = i;\n        }\n        if(ch == 'h')\n        {\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkrekdt4j.d(90): Error: found `unittest` instead of statement

    /tmp/tmpkrekdt4j.d(108): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpkrekdt4j.d(108): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkrekdt4j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int last_vowel_index = -1;\n\
    \    int last_consonant_index = -1;\n    string result = \"\";\n    foreach(i,\
    \ char c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n        \
    \    last_vowel_index = i;\n        }\n        else\n        {\n            if(last_vowel_index\
    \ != -1 && last_consonant_index != -1)\n            {\n                if(i -\
    \ last_vowel_index < last_vowel_index - last_consonant_index)\n              \
    \  {\n                    result = word[last_vowel_index..last_vowel_index];\n\
    \                }\n            }\n            last_consonant_index = i;\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjuiwtapa.d(23): Error: no property `find` for type `string`

    /tmp/tmpjuiwtapa.d(25): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpjuiwtapa.d(36): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjuiwtapa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int i = 0;\n    int j = 0;\n\
    \    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n\
    \    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n\
    \    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int ii =\
    \ 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n   \
    \ int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr =\
    \ 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n   \
    \ int ww = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aa =\
    \ 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n   \
    \ int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int\
    \ sss = 0;\n    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\
    \ = 0;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkacapfpv.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkacapfpv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int min_distance = word.length;\n    foreach(i, c;\
    \ word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = index - i;\n            if(distance < min_distance)\n            {\n     \
    \           min_distance = distance;\n                result = c;\n          \
    \  }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3wy384e.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpk3wy384e.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpk3wy384e.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpk3wy384e.d(25): Error: cannot implicitly convert expression `cast(ulong)index
    - i` of type `ulong` to `int`

    /tmp/tmpk3wy384e.d(29): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3wy384e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto result = \"\";\n    auto last_consonant = -1;\n    auto first_vowel\
    \ = -1;\n    auto i = 0;\n    foreach(c; word)\n    {\n        if(consonants.canFind(c))\n\
    \        {\n            last_consonant = i;\n        }\n        else if(vowels.canFind(c))\n\
    \        {\n            if(last_consonant != -1)\n            {\n            \
    \    if(first_vowel == -1)\n                {\n                    first_vowel\
    \ = i;\n                }\n                else\n                {\n         \
    \           if(abs(last_consonant - i) < abs(last_consonant - first_vowel))\n\
    \                    {\n                        first_vowel = i;\n           \
    \         }\n                }\n            }\n        }\n        i++;\n    }\n\
    \    if(first_vowel != -1)\n    {\n        result = word[first_vowel..first_vowel+1];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe8un3cny.d(25): Error: no property `canFind` for type `string`

    /tmp/tmpe8un3cny.d(29): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe8un3cny.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    bool is_vowel = false;\n    while (index >= 0)\n\
    \    {\n        if (vowels.canFind(word[index]))\n        {\n            is_vowel\
    \ = true;\n            break;\n        }\n        index--;\n    }\n    if (is_vowel)\n\
    \    {\n        int i = index;\n        while (i >= 0)\n        {\n          \
    \  if (!vowels.canFind(word[i]))\n            {\n                result = word[index];\n\
    \                break;\n            }\n            i--;\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxcta5nw1.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpxcta5nw1.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpxcta5nw1.d(35): Error: no property `canFind` for type `string`

    /tmp/tmpxcta5nw1.d(37): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxcta5nw1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    import std.algorithm : find, findAdjacent;\n    import std.array\
    \ : array;\n    import std.range : take, drop;\n    import std.conv : to;\n  \
    \  import std.string : toLower;\n    import std.typecons : tuple;\n    import\
    \ std.math : abs;\n    import std.algorithm : max, min;\n    import std.range\
    \ : iota;\n    import std.typecons : tuple;\n    import std.algorithm : map;\n\
    \    import std.range : retro;\n    import std.algorithm : retroMap;\n    import\
    \ std.algorithm : retroFind;\n    import std.algorithm : retroFindAdjacent;\n\
    \    import std.algorithm : retroFindAdjacent!(a => a[0] == a[1]);\n    import\
    \ std.algorithm : retroFindAdjacent!(a => a[0] != a[1]);\n    import std.algorithm\
    \ : retroFindAdjacent!(a => a[0] == a[1]);\n    import std.algorithm : retroFindAdjacent!(a\
    \ => a[0] != a[1]);\n    import std.algorithm : retroFindAdjacent!(a => a[0] ==\
    \ a[1]);\n    import std.algorithm : retroFindAdjacent!(a => a[0] != a[1]);\n\
    \    import std.algorithm : retroFindAdjacent!(a => a[0] == a[1]);\n    import\
    \ std.algorithm : retroFindAdjacent!(a => a[0] != a[1]);\n    import std.algorithm\
    \ : retroFindAdjacent!(a => a[0] == a[1]);\n    import std.algorithm : retroFindAdjacent!(a\
    \ => a[0] != a[1]);\n    import std.algorithm : retroFindAdjacent!(a => a[0] ==\
    \ a[1]);\n    import std.algorithm : retroFindAdjacent!(a => a[0] != a[1]);\n\
    \    import std.algorithm : retroFindAdjacent!(a => a[0] == a[1]);\n    import\
    \ std.algorithm : retroFindAdj\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbt3qo6ib.d(32): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(33): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(34): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(35): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(36): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(37): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(38): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(39): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(40): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(41): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(42): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(43): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(44): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(46): Error: `;` expected

    /tmp/tmpbt3qo6ib.d(64): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbt3qo6ib.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = -1;\n    auto last_consonant = -1;\n    foreach(i, c;\
    \ word)\n    {\n        if(vowels.canFind(c))\n        {\n            last_vowel\
    \ = i;\n        }\n        else if(consonants.canFind(c))\n        {\n       \
    \     last_consonant = i;\n        }\n        if(last_vowel > last_consonant)\n\
    \        {\n            return word[last_vowel..$];\n        }\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_q6865z0.d(23): Error: no property `canFind` for type `string`

    /tmp/tmp_q6865z0.d(25): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp_q6865z0.d(27): Error: no property `canFind` for type `string`

    /tmp/tmp_q6865z0.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_q6865z0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int pos = 0;\n    int len = word.length;\n    string vowels =\
    \ \"aeiou\";\n    string result = \"\";\n    while (pos < len)\n    {\n      \
    \  if (vowels.find(word[pos]) != -1)\n        {\n            if (pos > 0 && pos\
    \ < len - 1)\n            {\n                if (vowels.find(word[pos - 1]) ==\
    \ -1 && vowels.find(word[pos + 1]) == -1)\n                {\n               \
    \     result = word[pos];\n                    break;\n                }\n   \
    \         }\n        }\n        pos++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzaydr2wk.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpzaydr2wk.d(23): Error: no property `find` for type `string`

    /tmp/tmpzaydr2wk.d(27): Error: no property `find` for type `string`

    /tmp/tmpzaydr2wk.d(27): Error: no property `find` for type `string`

    /tmp/tmpzaydr2wk.d(29): Error: cannot implicitly convert expression `word[cast(ulong)pos]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzaydr2wk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    int distance = 0;\n    int last_consonant_index\
    \ = -1;\n    int first_vowel_index = -1;\n    int i = 0;\n    foreach(c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            if(last_consonant_index\
    \ != -1)\n            {\n                distance = i - last_consonant_index;\n\
    \                if(distance < min_distance)\n                {\n            \
    \        min_distance = distance;\n                    first_vowel_index = i;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      last_consonant_index = i;\n        }\n        i++;\n    }\n    if(first_vowel_index\
    \ != -1)\n    {\n        result = word[first_vowel_index..first_vowel_index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz2y3g5ia.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpz2y3g5ia.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2y3g5ia.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int len = word.length;\n    int\
    \ i = len - 1;\n    while (i > 0)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            if (vowels.find(word[i - 1]) == -1)\n          \
    \      return word[i];\n        }\n        i--;\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp61awii7v.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp61awii7v.d(22): Error: no property `find` for type `string`

    /tmp/tmp61awii7v.d(24): Error: no property `find` for type `string`

    /tmp/tmp61awii7v.d(25): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61awii7v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = \"\";\n    auto last_consonant = \"\";\n    auto result\
    \ = \"\";\n    foreach(c; word)\n    {\n        if(vowels.canFind(c))\n      \
    \  {\n            last_vowel = c;\n        }\n        else if(consonants.canFind(c))\n\
    \        {\n            last_consonant = c;\n        }\n        if(last_vowel\
    \ != \"\" && last_consonant != \"\")\n        {\n            result = last_vowel;\n\
    \            last_vowel = \"\";\n            last_consonant = \"\";\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxbv2jyyl.d(24): Error: no property `canFind` for type `string`

    /tmp/tmpxbv2jyyl.d(26): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmpxbv2jyyl.d(28): Error: no property `canFind` for type `string`

    /tmp/tmpxbv2jyyl.d(30): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxbv2jyyl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    // your code here\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min = word.length;\n    for(int\
    \ i = word.length - 1; i >= 0; i--)\n    {\n        if(vowels.find(word[i]) !=\
    \ -1)\n        {\n            if(i < min)\n            {\n                min\
    \ = i;\n                index = i;\n            }\n        }\n    }\n    if(index\
    \ != 0)\n    {\n        result = word[index];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd6rp39sz.d(21): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpd6rp39sz.d(22): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpd6rp39sz.d(24): Error: no property `find` for type `string`

    /tmp/tmpd6rp39sz.d(35): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd6rp39sz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    int distance;\n    foreach(i, c; word)\n  \
    \  {\n        if(vowels.find(c) != -1)\n        {\n            distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   result = c;\n                min_distance = distance;\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp748yxtag.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp748yxtag.d(23): Error: no property `find` for type `string`

    /tmp/tmp748yxtag.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp748yxtag.d(28): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp748yxtag.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_consonant = 0;\n    auto last_vowel = 0;\n    for (auto i = word.length\
    \ - 1; i >= 0; --i)\n    {\n        if (consonants.canFind(word[i]))\n       \
    \ {\n            last_consonant = i;\n            break;\n        }\n    }\n \
    \   for (auto i = last_consonant - 1; i >= 0; --i)\n    {\n        if (vowels.canFind(word[i]))\n\
    \        {\n            last_vowel = i;\n            break;\n        }\n    }\n\
    \    if (last_consonant == 0 || last_vowel == 0)\n        return \"\";\n    return\
    \ word[last_vowel..last_consonant];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz1nxwzuv.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpz1nxwzuv.d(25): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpz1nxwzuv.d(31): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz1nxwzuv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int min_distance = word.length;\n    int last_consonant =\
    \ -1;\n    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (last_consonant != -1)\n            {\n  \
    \              distance = i - last_consonant;\n                if (distance <\
    \ min_distance)\n                {\n                    min_distance = distance;\n\
    \                    result = word[i];\n                }\n            }\n   \
    \     }\n        else\n        {\n            last_consonant = i;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjrira1t1.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjrira1t1.d(24): Error: no property `find` for type `string`

    /tmp/tmpjrira1t1.d(32): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjrira1t1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                if (vowels.find(word[index - 1]) == -1)\n                {\n\
    \                    result = word[index];\n                    break;\n     \
    \           }\n            }\n            else if (index == 0)\n            {\n\
    \                if (vowels.find(word[index + 1]) == -1)\n                {\n\
    \                    result = word[index];\n                    break;\n     \
    \           }\n            }\n            else\n            {\n              \
    \  if (vowels.find(word[index - 1]) == -1 && vowels.find(word[index + 1]) == -1)\n\
    \                {\n                    result = word[index];\n              \
    \      break;\n                }\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpux28tcst.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpux28tcst.d(22): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(26): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(28): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    /tmp/tmpux28tcst.d(34): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(36): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    /tmp/tmpux28tcst.d(42): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(42): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(44): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpux28tcst.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = 0;\n    int distance = 0;\n    int word_length\
    \ = word.length;\n    int vowel_length = vowels.length;\n    for (int i = 0; i\
    \ < word_length; i++)\n    {\n        for (int j = 0; j < vowel_length; j++)\n\
    \        {\n            if (word[i] == vowels[j])\n            {\n           \
    \     distance = word_length - i;\n                if (distance < min_distance\
    \ || min_distance == 0)\n                {\n                    min_distance =\
    \ distance;\n                    index = i;\n                }\n            }\n\
    \        }\n    }\n    if (min_distance != 0)\n    {\n        result = word[index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_g4pup6u.d(22): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_g4pup6u.d(23): Error: cannot implicitly convert expression `vowels.length`
    of type `ulong` to `int`

    /tmp/tmp_g4pup6u.d(41): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_g4pup6u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int last_vowel_index = -1;\n\
    \    int last_consonant_index = -1;\n    int word_length = word.length;\n    for\
    \ (int i = 0; i < word_length; i++)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            last_vowel_index = i;\n        }\n        else\n\
    \        {\n            last_consonant_index = i;\n        }\n        if (last_vowel_index\
    \ != -1 && last_consonant_index != -1)\n        {\n            break;\n      \
    \  }\n    }\n    if (last_vowel_index == -1 || last_consonant_index == -1)\n \
    \   {\n        return \"\";\n    }\n    return word[last_vowel_index];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5cz06fmp.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp5cz06fmp.d(23): Error: no property `find` for type `string`

    /tmp/tmp5cz06fmp.d(40): Error: cannot implicitly convert expression `word[cast(ulong)last_vowel_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5cz06fmp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int i = 0;\n    while(i < word.length)\n    {\n  \
    \      if(vowels.find(word[i]) != -1)\n        {\n            if(i != 0 && i !=\
    \ word.length - 1)\n            {\n                if(vowels.find(word[i-1]) ==\
    \ -1 && vowels.find(word[i+1]) == -1)\n                {\n                   \
    \ if(abs(i - index) < abs(index - word.length))\n                    {\n     \
    \                   index = i;\n                    }\n                }\n   \
    \         }\n        }\n        i++;\n    }\n    if(index != word.length)\n  \
    \  {\n        result = word[index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp42xy_h9b.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp42xy_h9b.d(23): Error: no property `find` for type `string`

    /tmp/tmp42xy_h9b.d(27): Error: no property `find` for type `string`

    /tmp/tmp42xy_h9b.d(27): Error: no property `find` for type `string`

    /tmp/tmp42xy_h9b.d(40): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp42xy_h9b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = \"\";\n    auto last_consonant = \"\";\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            last_vowel\
    \ = c;\n        }\n        else if(consonants.canFind(c))\n        {\n       \
    \     last_consonant = c;\n        }\n    }\n    return last_vowel;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpunn67_g0.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpunn67_g0.d(25): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmpunn67_g0.d(27): Error: no property `canFind` for type `string`

    /tmp/tmpunn67_g0.d(29): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpunn67_g0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ last_vowel_index = -1;\n    int last_consonant_index = -1;\n    int i = 0;\n\
    \    foreach(c; word)\n    {\n        if(vowels.canFind(c))\n        {\n     \
    \       last_vowel_index = i;\n        }\n        else\n        {\n          \
    \  if(last_vowel_index != -1)\n            {\n                last_consonant_index\
    \ = i;\n                break;\n            }\n        }\n        i++;\n    }\n\
    \    if(last_vowel_index != -1 && last_consonant_index != -1)\n    {\n       \
    \ result = word[last_vowel_index..last_vowel_index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe14uv4k9.d(24): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe14uv4k9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index != 0)\n    {\n        result = word[index..$];\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ur0jj7g.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp9ur0jj7g.d(23): Error: no property `canFind` for type `string`

    /tmp/tmp9ur0jj7g.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp9ur0jj7g.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ur0jj7g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index > 0 && index < word.length - 1)\n    {\n        result\
    \ = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgjcbfg56.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpgjcbfg56.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpgjcbfg56.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpgjcbfg56.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpgjcbfg56.d(35): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgjcbfg56.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                if (vowels.find(word[index - 1]) == -1)\n                {\n\
    \                    result = word[index];\n                    break;\n     \
    \           }\n            }\n            else if (index == 0)\n            {\n\
    \                if (vowels.find(word[index + 1]) == -1)\n                {\n\
    \                    result = word[index];\n                    break;\n     \
    \           }\n            }\n            else\n            {\n              \
    \  if (vowels.find(word[index - 1]) == -1 && vowels.find(word[index + 1]) == -1)\n\
    \                {\n                    result = word[index];\n              \
    \      break;\n                }\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpux28tcst.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpux28tcst.d(22): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(26): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(28): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    /tmp/tmpux28tcst.d(34): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(36): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    /tmp/tmpux28tcst.d(42): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(42): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(44): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpux28tcst.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_consonant = word.length;\n    auto last_vowel = word.length;\n\
    \    for (size_t i = word.length; i > 0; --i)\n    {\n        if (consonants.canFind(word[i]))\n\
    \        {\n            last_consonant = i;\n            break;\n        }\n \
    \   }\n    for (size_t i = last_consonant; i > 0; --i)\n    {\n        if (vowels.canFind(word[i]))\n\
    \        {\n            last_vowel = i;\n            break;\n        }\n    }\n\
    \    if (last_vowel == word.length)\n        return \"\";\n    return word[last_vowel..$];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdoyalkdv.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpdoyalkdv.d(31): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdoyalkdv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    import std.algorithm.comparison : equal;\n    import std.algorithm.searching\
    \ : find;\n    import std.algorithm.iteration : filter;\n    import std.range\
    \ : retro;\n    import std.array : array;\n    import std.conv : to;\n    import\
    \ std.string : toLower;\n    import std.ascii : isAlpha;\n    import std.math\
    \ : abs;\n    import std.typecons : tuple;\n    import std.range : retro;\n  \
    \  import std.algorithm.comparison : equal;\n    import std.algorithm.searching\
    \ : find;\n    import std.algorithm.iteration : filter;\n    import std.range\
    \ : retro;\n    import std.array : array;\n    import std.conv : to;\n    import\
    \ std.string : toLower;\n    import std.ascii : isAlpha;\n    import std.math\
    \ : abs;\n    import std.typecons : tuple;\n    import std.range : retro;\n  \
    \  import std.algorithm.comparison : equal;\n    import std.algorithm.searching\
    \ : find;\n    import std.algorithm.iteration : filter;\n    import std.range\
    \ : retro;\n    import std.array : array;\n    import std.conv : to;\n    import\
    \ std.string : toLower;\n    import std.ascii : isAlpha;\n    import std.math\
    \ : abs;\n    import std.typecons : tuple;\n    import std.range : retro;\n  \
    \  import std.algorithm.comparison : equal;\n    import std.algorithm.searching\
    \ : find;\n    import std.algorithm.iteration : filter;\n    import std.range\
    \ : retro;\n    import std.array : array;\n    import std.conv : to;\n    import\
    \ std.string : toLower;\n    import std.ascii : isAlpha;\n    import std.math\
    \ : abs;\n    import std.typecons : tuple;\n    import std.range : retro;\n  \
    \  import std.algorithm.comparison : equal;\n    import std.algorithm.searching\
    \ : find;\n    import std.algorithm.iteration : filter;\n   \nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsag5o_.d(65): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsag5o_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int pos = word.length;\n    int\
    \ vowel_pos = -1;\n    while (pos--)\n    {\n        if (vowels.find(word[pos])\
    \ != -1)\n        {\n            vowel_pos = pos;\n            break;\n      \
    \  }\n    }\n    if (vowel_pos == -1)\n        return \"\";\n    pos = vowel_pos;\n\
    \    while (pos--)\n    {\n        if (vowels.find(word[pos]) == -1)\n       \
    \ {\n            return word[vowel_pos..$];\n        }\n    }\n    return \"\"\
    ;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkt5mfe98.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpkt5mfe98.d(22): Error: no property `find` for type `string`

    /tmp/tmpkt5mfe98.d(33): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkt5mfe98.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length - 1;\n    while (pos >= 0)\n    {\n        if (vowels.find(word[pos])\
    \ != -1)\n        {\n            if (pos > 0 && vowels.find(word[pos - 1]) ==\
    \ -1)\n            {\n                result = word[pos];\n                break;\n\
    \            }\n            else if (pos < word.length - 1 && vowels.find(word[pos\
    \ + 1]) == -1)\n            {\n                result = word[pos];\n         \
    \       break;\n            }\n        }\n        pos--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaflmi_vm.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpaflmi_vm.d(22): Error: no property `find` for type `string`

    /tmp/tmpaflmi_vm.d(24): Error: no property `find` for type `string`

    /tmp/tmpaflmi_vm.d(26): Error: cannot implicitly convert expression `word[cast(ulong)pos]`
    of type `immutable(char)` to `string`

    /tmp/tmpaflmi_vm.d(29): Error: no property `find` for type `string`

    /tmp/tmpaflmi_vm.d(31): Error: cannot implicitly convert expression `word[cast(ulong)pos]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaflmi_vm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = \"\";\n    auto last_consonant = \"\";\n    auto result\
    \ = \"\";\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n   \
    \     {\n            last_vowel = c;\n        }\n        else if(consonants.canFind(c))\n\
    \        {\n            last_consonant = c;\n        }\n        if(last_vowel\
    \ != \"\" && last_consonant != \"\")\n        {\n            result = last_vowel;\n\
    \            last_vowel = \"\";\n            last_consonant = \"\";\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0bp0ozub.d(24): Error: no property `canFind` for type `string`

    /tmp/tmp0bp0ozub.d(26): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp0bp0ozub.d(28): Error: no property `canFind` for type `string`

    /tmp/tmp0bp0ozub.d(30): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0bp0ozub.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min = int.max;\n    int index = 0;\n    foreach(i, c; word)\n    {\n       \
    \ if(vowels.canFind(c))\n        {\n            if(i > 0 && i < word.length -\
    \ 1)\n            {\n                if(!vowels.canFind(word[i - 1]) && !vowels.canFind(word[i\
    \ + 1]))\n                {\n                    if(min > abs(word.length - i))\n\
    \                    {\n                        min = abs(word.length - i);\n\
    \                        index = i;\n                    }\n                }\n\
    \            }\n        }\n    }\n    if(index > 0)\n    {\n        result = word[index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmlf1p7of.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpmlf1p7of.d(27): Error: no property `canFind` for type `string`

    /tmp/tmpmlf1p7of.d(27): Error: no property `canFind` for type `string`

    /tmp/tmpmlf1p7of.d(31): Error: cannot implicitly convert expression `abs(word.length
    - i)` of type `ulong` to `int`

    /tmp/tmpmlf1p7of.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpmlf1p7of.d(40): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmlf1p7of.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length - 1;\n    while (pos >= 0)\n    {\n        if (vowels.find(word[pos])\
    \ != -1)\n        {\n            if (pos > 0 && vowels.find(word[pos - 1]) ==\
    \ -1)\n            {\n                result = word[pos];\n                break;\n\
    \            }\n            else if (pos < word.length - 1 && vowels.find(word[pos\
    \ + 1]) == -1)\n            {\n                result = word[pos];\n         \
    \       break;\n            }\n        }\n        pos--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaflmi_vm.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpaflmi_vm.d(22): Error: no property `find` for type `string`

    /tmp/tmpaflmi_vm.d(24): Error: no property `find` for type `string`

    /tmp/tmpaflmi_vm.d(26): Error: cannot implicitly convert expression `word[cast(ulong)pos]`
    of type `immutable(char)` to `string`

    /tmp/tmpaflmi_vm.d(29): Error: no property `find` for type `string`

    /tmp/tmpaflmi_vm.d(31): Error: cannot implicitly convert expression `word[cast(ulong)pos]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaflmi_vm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            if(i < index &&\
    \ i > 0)\n            {\n                if(!vowels.canFind(word[i-1]) && !vowels.canFind(word[i+1]))\n\
    \                {\n                    if(abs(word.length - i) < distance)\n\
    \                    {\n                        distance = abs(word.length - i);\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps25jlyn5.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmps25jlyn5.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmps25jlyn5.d(23): Error: no property `canFind` for type `string`

    /tmp/tmps25jlyn5.d(27): Error: no property `canFind` for type `string`

    /tmp/tmps25jlyn5.d(27): Error: no property `canFind` for type `string`

    /tmp/tmps25jlyn5.d(31): Error: cannot implicitly convert expression `abs(word.length
    - i)` of type `ulong` to `int`

    /tmp/tmps25jlyn5.d(32): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps25jlyn5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int len = word.length;\n    int i = len - 1;\n    int j = len\
    \ - 1;\n    int k = len - 1;\n    while(i >= 0)\n    {\n        if(word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n\
    \        {\n            j = i;\n            break;\n        }\n        i--;\n\
    \    }\n    while(k >= 0)\n    {\n        if(word[k] != 'a' && word[k] != 'e'\
    \ && word[k] != 'i' && word[k] != 'o' && word[k] != 'u')\n        {\n        \
    \    break;\n        }\n        k--;\n    }\n    if(j == len - 1)\n    {\n   \
    \     return \"\";\n    }\n    else if(j == k - 1)\n    {\n        return word[j..$];\n\
    \    }\n    else\n    {\n        return word[j..$];\n    }\n}\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9s_ab9wj.d(17): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9s_ab9wj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int distance = word.length;\n    foreach(i, letter;\
    \ word)\n    {\n        if(vowels.canFind(letter))\n        {\n            int\
    \ new_distance = abs(index - i);\n            if(new_distance < distance)\n  \
    \          {\n                distance = new_distance;\n                result\
    \ = letter;\n            }\n        }\n        else\n        {\n            index\
    \ = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5t10ey9a.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp5t10ey9a.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp5t10ey9a.d(23): Error: no property `canFind` for type `string`

    /tmp/tmp5t10ey9a.d(25): Error: cannot implicitly convert expression `abs(cast(ulong)index
    - i)` of type `ulong` to `int`

    /tmp/tmp5t10ey9a.d(29): Error: cannot implicitly convert expression `letter` of
    type `immutable(char)` to `string`

    /tmp/tmp5t10ey9a.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5t10ey9a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int[]\
    \ pos = [0,0];\n    int[] dist = [0,0];\n    int min = 0;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            if (i > 0 && i < word.length - 1)\n            {\n       \
    \         if (vowels.find(word[i-1]) == -1 && vowels.find(word[i+1]) == -1)\n\
    \                {\n                    if (i > min)\n                    {\n\
    \                        min = i;\n                        result = word[i];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8cvglpw_.d(24): Error: no property `find` for type `string`

    /tmp/tmp8cvglpw_.d(28): Error: no property `find` for type `string`

    /tmp/tmp8cvglpw_.d(28): Error: no property `find` for type `string`

    /tmp/tmp8cvglpw_.d(33): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8cvglpw_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int i = word.length;\n    while(i--)\n    {\n        if(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n\
    \        {\n            if(i == 0)\n                return \"\";\n           \
    \ if(word[i-1] != 'a' && word[i-1] != 'e' && word[i-1] != 'i' && word[i-1] !=\
    \ 'o' && word[i-1] != 'u')\n                return word[i..$];\n        }\n  \
    \  }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuvbe11l7.d(17): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuvbe11l7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index != 0)\n    {\n        result = word[index..$];\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ur0jj7g.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp9ur0jj7g.d(23): Error: no property `canFind` for type `string`

    /tmp/tmp9ur0jj7g.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp9ur0jj7g.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ur0jj7g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_consonant = -1;\n    auto first_vowel = -1;\n    auto result\
    \ = \"\";\n    foreach(i, c; word)\n    {\n        if(consonants.canFind(c))\n\
    \        {\n            last_consonant = i;\n        }\n        else if(vowels.canFind(c))\n\
    \        {\n            if(last_consonant != -1)\n            {\n            \
    \    if(first_vowel == -1)\n                {\n                    first_vowel\
    \ = i;\n                }\n                else if(i - last_consonant < first_vowel\
    \ - last_consonant)\n                {\n                    first_vowel = i;\n\
    \                }\n            }\n        }\n    }\n    if(first_vowel != -1)\n\
    \    {\n        result = word[first_vowel..first_vowel+1];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2mcr3g19.d(24): Error: no property `canFind` for type `string`

    /tmp/tmp2mcr3g19.d(26): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp2mcr3g19.d(28): Error: no property `canFind` for type `string`

    /tmp/tmp2mcr3g19.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp2mcr3g19.d(38): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2mcr3g19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length;\n    while(pos--)\n    {\n        if(vowels.find(word[pos])\
    \ != -1)\n        {\n            if(pos == 0)\n                return result;\n\
    \            if(vowels.find(word[pos-1]) == -1)\n                return word[pos..$];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp110u3h7z.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp110u3h7z.d(22): Error: no property `find` for type `string`

    /tmp/tmp110u3h7z.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp110u3h7z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    int distance = 0;\n    int vowel_index = 0;\n\
    \    int word_index = 0;\n    for (int i = 0; i < word.length; i++)\n    {\n \
    \       if (vowels.find(word[i]) != -1)\n        {\n            vowel_index =\
    \ i;\n            for (int j = i + 1; j < word.length; j++)\n            {\n \
    \               if (vowels.find(word[j]) == -1)\n                {\n         \
    \           distance = j - vowel_index;\n                    if (distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     word_index = vowel_index;\n                    }\n     \
    \               break;\n                }\n            }\n        }\n    }\n \
    \   if (min_distance != word.length)\n    {\n        result = word[word_index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi2t5d_uw.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpi2t5d_uw.d(25): Error: no property `find` for type `string`

    /tmp/tmpi2t5d_uw.d(30): Error: no property `find` for type `string`

    /tmp/tmpi2t5d_uw.d(45): Error: cannot implicitly convert expression `word[cast(ulong)word_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi2t5d_uw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = ' ';\n    auto last_consonant = ' ';\n    foreach(i,\
    \ c; word.retro)\n    {\n        if(vowels.canFind(c))\n        {\n          \
    \  last_vowel = c;\n            if(last_consonant != ' ')\n                return\
    \ last_vowel.idup;\n        }\n        else if(consonants.canFind(c))\n      \
    \  {\n            last_consonant = c;\n            if(last_vowel != ' ')\n   \
    \             return last_vowel.idup;\n        }\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_0z1jg6p.d(21): Error: no property `retro` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_0z1jg6p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int min_distance = word.length;\n    for (int i =\
    \ word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i < index)\n            {\n                index =\
    \ i;\n                result = word[i];\n            }\n        }\n        else\n\
    \        {\n            if (i < index)\n            {\n                int distance\
    \ = index - i;\n                if (distance < min_distance)\n               \
    \ {\n                    min_distance = distance;\n                }\n       \
    \     }\n        }\n    }\n    if (min_distance == word.length)\n    {\n     \
    \   return \"\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_in0aiwq.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_in0aiwq.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_in0aiwq.d(21): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp_in0aiwq.d(23): Error: no property `find` for type `string`

    /tmp/tmp_in0aiwq.d(28): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_in0aiwq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int last_vowel_index = -1;\n\
    \    int last_consonant_index = -1;\n    for (int i = 0; i < word.length; i++)\
    \ \n    {\n        if (vowels.find(word[i]) != -1) \n        {\n            last_vowel_index\
    \ = i;\n        } \n        else \n        {\n            last_consonant_index\
    \ = i;\n        }\n        if (last_vowel_index != -1 && last_consonant_index\
    \ != -1) \n        {\n            break;\n        }\n    }\n    if (last_vowel_index\
    \ == -1 || last_consonant_index == -1) \n    {\n        return \"\";\n    }\n\
    \    return word[last_vowel_index];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0hhutspm.d(22): Error: no property `find` for type `string`

    /tmp/tmp0hhutspm.d(39): Error: cannot implicitly convert expression `word[cast(ulong)last_vowel_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hhutspm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int closest = -1;\n    int distance\
    \ = 0;\n    for (int i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (closest == -1)\n            {\n         \
    \       closest = i;\n                distance = word.length - i;\n          \
    \  }\n            else\n            {\n                int d = word.length - i;\n\
    \                if (d < distance)\n                {\n                    closest\
    \ = i;\n                    distance = d;\n                }\n            }\n\
    \        }\n    }\n    if (closest == -1)\n        return \"\";\n    return word[closest..$];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe_407ui1.d(20): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpe_407ui1.d(22): Error: no property `find` for type `string`

    /tmp/tmpe_407ui1.d(27): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmpe_407ui1.d(31): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_407ui1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = word.length;\n    int index = 0;\n    foreach(i, c; word)\n    {\n\
    \        if(vowels.find(c) != -1)\n        {\n            if(i > 0 && vowels.find(word[i-1])\
    \ == -1 && i < word.length-1 && vowels.find(word[i+1]) == -1)\n            {\n\
    \                if(abs(i - word.length) < distance)\n                {\n    \
    \                distance = abs(i - word.length);\n                    index =\
    \ i;\n                }\n            }\n        }\n    }\n    if(index != 0)\n\
    \    {\n        result = word[index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu278f2rv.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpu278f2rv.d(23): Error: no property `find` for type `string`

    /tmp/tmpu278f2rv.d(25): Error: no property `find` for type `string`

    /tmp/tmpu278f2rv.d(25): Error: no property `find` for type `string`

    /tmp/tmpu278f2rv.d(29): Error: cannot implicitly convert expression `abs(i - word.length)`
    of type `ulong` to `int`

    /tmp/tmpu278f2rv.d(30): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpu278f2rv.d(37): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu278f2rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int n = word.length;\n    string\
    \ result = \"\";\n    int min_distance = n;\n    for (int i = 0; i < n; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = n - i;\n            if (distance < min_distance)\n            {\n        \
    \        min_distance = distance;\n                result = word[i..$];\n    \
    \        }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp08gu0ptk.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp08gu0ptk.d(23): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp08gu0ptk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int[] vowels = [ 'a', 'e', 'i', 'o', 'u' ];\n    int[] consonants\
    \ = [ 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's',\
    \ 't', 'v', 'w', 'x', 'y', 'z' ];\n    int[] word_chars = word.dup.map!(a => a.toString().toLowerCase().front).array;\n\
    \    int[] word_vowels = word_chars.filter!(a => a in vowels).array;\n    int[]\
    \ word_consonants = word_chars.filter!(a => a in consonants).array;\n    int[]\
    \ word_vowels_consonants = word_vowels.filter!(a => a in word_consonants).array;\n\
    \    if (word_vowels_consonants.length == 0)\n        return \"\";\n    int[]\
    \ word_vowels_consonants_indexes = word_chars.map!(a => a in word_vowels_consonants).array.enumerate.filter!(a\
    \ => a[1]).map!(a => a[0]).array;\n    int[] word_vowels_consonants_indexes_pairs\
    \ = word_vowels_consonants_indexes.chunks(2).map!(a => a.array).array;\n    int[]\
    \ word_vowels_consonants_indexes_pairs_distances = word_vowels_consonants_indexes_pairs.map!(a\
    \ => a[1] - a[0]).array;\n    int[] word_vowels_consonants_indexes_pairs_distances_min\
    \ = word_vowels_consonants_indexes_pairs_distances.min;\n    int[] word_vowels_consonants_indexes_pairs_distances_min_index\
    \ = word_vowels_consonants_indexes_pairs_distances.enumerate.filter!(a =>\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppte74kr3.d(30): Error: expression expected, not `unittest`

    /tmp/tmppte74kr3.d(31): Error: found `{` when expecting `)` following template
    argument list

    /tmp/tmppte74kr3.d(32): Error: semicolon expected, not `alias`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppte74kr3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_index = -1;\n    int min_distance = int.max;\n    int word_length = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = 0;\n            int j = i;\n            while(j < word_length)\n\
    \            {\n                if(vowels.canFind(word[j]))\n                {\n\
    \                    break;\n                }\n                distance++;\n\
    \                j++;\n            }\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                min_index\
    \ = i;\n            }\n        }\n    }\n    if(min_index != -1)\n    {\n    \
    \    result = word[min_index..min_index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwk7fuccb.d(21): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpwk7fuccb.d(24): Error: no property `canFind` for type `string`

    /tmp/tmpwk7fuccb.d(27): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpwk7fuccb.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpwk7fuccb.d(40): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwk7fuccb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int word_len = word.length;\n\
    \    int vowel_len = vowels.length;\n    int i = 0;\n    int j = 0;\n    int k\
    \ = 0;\n    int min_dist = word_len;\n    int dist = 0;\n    int vowel_idx = 0;\n\
    \    string closest_vowel = \"\";\n    for (i = 0; i < word_len; i++)\n    {\n\
    \        for (j = 0; j < vowel_len; j++)\n        {\n            if (word[i] ==\
    \ vowels[j])\n            {\n                for (k = i + 1; k < word_len; k++)\n\
    \                {\n                    if (vowels.find(word[k]) == -1)\n    \
    \                {\n                        dist = k - i;\n                  \
    \      if (dist < min_dist)\n                        {\n                     \
    \       min_dist = dist;\n                            vowel_idx = i;\n       \
    \                 }\n                        break;\n                    }\n \
    \               }\n            }\n        }\n    }\n    if (min_dist < word_len)\n\
    \    {\n        closest_vowel = word[vowel_idx..vowel_idx];\n    }\n    return\
    \ closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe061ot88.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpe061ot88.d(19): Error: cannot implicitly convert expression `vowels.length`
    of type `ulong` to `int`

    /tmp/tmpe061ot88.d(35): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe061ot88.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto len = word.length;\n    auto found = false;\n    auto last_consonant\
    \ = 0;\n    auto last_vowel = 0;\n    for (auto i = len - 1; i >= 0; i--)\n  \
    \  {\n        if (consonants.canFind(word[i]))\n        {\n            last_consonant\
    \ = i;\n            if (found)\n                break;\n        }\n        else\
    \ if (vowels.canFind(word[i]))\n        {\n            last_vowel = i;\n     \
    \       found = true;\n        }\n    }\n    if (found)\n        return word[last_vowel..last_consonant];\n\
    \    else\n        return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy7t0hd79.d(25): Error: no property `canFind` for type `string`

    /tmp/tmpy7t0hd79.d(27): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpy7t0hd79.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpy7t0hd79.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy7t0hd79.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            if(distance >\
    \ abs(i - index))\n            {\n                distance = abs(i - index);\n\
    \                result = c;\n            }\n        }\n        else\n       \
    \ {\n            index = i;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp32ap8u87.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp32ap8u87.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp32ap8u87.d(23): Error: no property `find` for type `string`

    /tmp/tmp32ap8u87.d(27): Error: cannot implicitly convert expression `abs(i - cast(ulong)index)`
    of type `ulong` to `int`

    /tmp/tmp32ap8u87.d(28): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp32ap8u87.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp32ap8u87.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int closest = -1;\n    int closest_dist\
    \ = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int dist = word.length - i;\n            if(dist < closest_dist)\n\
    \            {\n                closest = i;\n                closest_dist = dist;\n\
    \            }\n        }\n    }\n    if(closest == -1)\n        return \"\";\n\
    \    else\n        return word[closest..$];\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4x3viyfw.d(22): Error: no property `canFind` for type `string`

    /tmp/tmp4x3viyfw.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp4x3viyfw.d(27): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4x3viyfw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    // your code here\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int index = word.length - 1;\n    while(index >= 0)\n  \
    \  {\n        if(vowels.find(word[index]) != -1)\n        {\n            if(index\
    \ == word.length - 1)\n            {\n                result = \"\";\n       \
    \         break;\n            }\n            else if(vowels.find(word[index +\
    \ 1]) == -1)\n            {\n                result = word[index];\n         \
    \       break;\n            }\n        }\n        index--;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzok0gx2w.d(20): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpzok0gx2w.d(23): Error: no property `find` for type `string`

    /tmp/tmpzok0gx2w.d(30): Error: no property `find` for type `string`

    /tmp/tmpzok0gx2w.d(32): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzok0gx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length;\n    while(pos--)\n    {\n        if(vowels.find(word[pos])\
    \ != -1)\n        {\n            if(pos == 0)\n                return result;\n\
    \            else if(vowels.find(word[pos-1]) != -1)\n                continue;\n\
    \            else\n                return word[pos..$];\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw_iphoum.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpw_iphoum.d(22): Error: no property `find` for type `string`

    /tmp/tmpw_iphoum.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw_iphoum.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            if(i > 0 && i\
    \ < word.length - 1)\n            {\n                if(vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n                {\n                \
    \    if(abs(word.length - i) < min_distance)\n                    {\n        \
    \                min_distance = abs(word.length - i);\n                      \
    \  index = i;\n                    }\n                }\n            }\n     \
    \   }\n    }\n    if(index != 0)\n    {\n        result = word[index];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0vmt9xxd.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp0vmt9xxd.d(23): Error: no property `find` for type `string`

    /tmp/tmp0vmt9xxd.d(27): Error: no property `find` for type `string`

    /tmp/tmp0vmt9xxd.d(27): Error: no property `find` for type `string`

    /tmp/tmp0vmt9xxd.d(31): Error: cannot implicitly convert expression `abs(word.length
    - i)` of type `ulong` to `int`

    /tmp/tmp0vmt9xxd.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp0vmt9xxd.d(40): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0vmt9xxd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpobztdc_z.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(22): Error: no property `canFind` for type `string`

    /tmp/tmpobztdc_z.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(28): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobztdc_z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length - 1;\n    while (pos >= 0)\n    {\n        if (vowels.find(word[pos])\
    \ != -1)\n        {\n            if (pos > 0 && vowels.find(word[pos - 1]) ==\
    \ -1)\n            {\n                result = word[pos];\n                break;\n\
    \            }\n            else if (pos < word.length - 1 && vowels.find(word[pos\
    \ + 1]) == -1)\n            {\n                result = word[pos];\n         \
    \       break;\n            }\n        }\n        pos--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaflmi_vm.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpaflmi_vm.d(22): Error: no property `find` for type `string`

    /tmp/tmpaflmi_vm.d(24): Error: no property `find` for type `string`

    /tmp/tmpaflmi_vm.d(26): Error: cannot implicitly convert expression `word[cast(ulong)pos]`
    of type `immutable(char)` to `string`

    /tmp/tmpaflmi_vm.d(29): Error: no property `find` for type `string`

    /tmp/tmpaflmi_vm.d(31): Error: cannot implicitly convert expression `word[cast(ulong)pos]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaflmi_vm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string closest_vowel = \"\";\n\
    \    int closest_vowel_index = -1;\n    int closest_vowel_distance = -1;\n   \
    \ int word_length = word.length;\n    int vowel_length = vowels.length;\n    int\
    \ word_index = word_length - 1;\n    int vowel_index = vowel_length - 1;\n   \
    \ while (word_index >= 0)\n    {\n        if (vowels.find(word[word_index]) !=\
    \ -1)\n        {\n            int distance = word_length - word_index;\n     \
    \       if (closest_vowel_distance == -1 || distance < closest_vowel_distance)\n\
    \            {\n                closest_vowel_distance = distance;\n         \
    \       closest_vowel_index = vowel_index;\n            }\n        }\n       \
    \ word_index--;\n    }\n    if (closest_vowel_index != -1)\n    {\n        closest_vowel\
    \ = vowels[closest_vowel_index];\n    }\n    return closest_vowel;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmz087aqm.d(21): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpmz087aqm.d(22): Error: cannot implicitly convert expression `vowels.length`
    of type `ulong` to `int`

    /tmp/tmpmz087aqm.d(27): Error: no property `find` for type `string`

    /tmp/tmpmz087aqm.d(40): Error: cannot implicitly convert expression `vowels[cast(ulong)closest_vowel_index]`
    of type `immutable(char)` to `string`

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int len = word.length;\n    int\
    \ i = len - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i]) != -1)\
    \ {\n            if (i == len - 1) {\n                return \"\";\n         \
    \   }\n            if (vowels.find(word[i + 1]) == -1) {\n                return\
    \ word[i..$];\n            }\n        }\n        i--;\n    }\n    return \"\"\
    ;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprj0k89ip.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmprj0k89ip.d(21): Error: no property `find` for type `string`

    /tmp/tmprj0k89ip.d(25): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprj0k89ip.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int j = i;\n            while(j > 0 && vowels.canFind(word[j-1]))\n\
    \                j--;\n            if(j > 0 && !vowels.canFind(word[j-1]))\n \
    \           {\n                int k = i;\n                while(k < word.length\
    \ && vowels.canFind(word[k+1]))\n                    k++;\n                if(k\
    \ < word.length && !vowels.canFind(word[k+1]))\n                {\n          \
    \          if(abs(i - j) < distance)\n                    {\n                \
    \        distance = abs(i - j);\n                        result = word[i..i];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpji8unyyp.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpji8unyyp.d(22): Error: no property `canFind` for type `string`

    /tmp/tmpji8unyyp.d(24): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpji8unyyp.d(25): Error: no property `canFind` for type `string`

    /tmp/tmpji8unyyp.d(27): Error: no property `canFind` for type `string`

    /tmp/tmpji8unyyp.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpji8unyyp.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpji8unyyp.d(32): Error: no property `canFind` for type `string`

    /tmp/tmpji8unyyp.d(36): Error: cannot implicitly convert expression `abs(i - cast(ulong)j)`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpji8unyyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length;\n    int min_pos = word.length;\n    foreach(i; 0 .. word.length)\n\
    \    {\n        if(vowels.canFind(word[i]))\n        {\n            pos = i;\n\
    \            if(pos - min_pos > 1)\n            {\n                result = word[min_pos];\n\
    \                break;\n            }\n            else\n            {\n    \
    \            min_pos = pos;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq4n121tg.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpq4n121tg.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpq4n121tg.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpq4n121tg.d(25): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpq4n121tg.d(28): Error: cannot implicitly convert expression `word[cast(ulong)min_pos]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4n121tg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    int closest = -1;\n    int closest_index = 0;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i > 0 && consonants.find(word[i-1]) != -1)\n            {\n \
    \               if (i < word.length - 1 && consonants.find(word[i+1]) != -1)\n\
    \                {\n                    if (closest == -1 || abs(i - closest)\
    \ < closest_index)\n                    {\n                        closest = i;\n\
    \                        closest_index = abs(i - closest);\n                 \
    \   }\n                }\n            }\n        }\n    }\n    if (closest ==\
    \ -1)\n        return \"\";\n    return word[closest..$];\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnxhsaq_m.d(23): Error: no property `find` for type `string`

    /tmp/tmpnxhsaq_m.d(25): Error: no property `find` for type `string`

    /tmp/tmpnxhsaq_m.d(27): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnxhsaq_m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpobztdc_z.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(22): Error: no property `canFind` for type `string`

    /tmp/tmpobztdc_z.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(28): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobztdc_z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                index--;\n                continue;\n            }\n        \
    \    if (vowels.find(word[index + 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn4u9ahwz.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpn4u9ahwz.d(22): Error: no property `find` for type `string`

    /tmp/tmpn4u9ahwz.d(29): Error: no property `find` for type `string`

    /tmp/tmpn4u9ahwz.d(31): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn4u9ahwz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto result = \"\";\n    auto temp = \"\";\n    auto distance = 0;\n  \
    \  auto temp_distance = 0;\n    auto last_vowel = 0;\n    auto first_consonant\
    \ = 0;\n    auto last_consonant = 0;\n    auto first_vowel = 0;\n    auto i =\
    \ 0;\n    auto j = 0;\n    auto k = 0;\n    auto l = 0;\n    auto m = 0;\n   \
    \ auto n = 0;\n    auto o = 0;\n    auto p = 0;\n    auto q = 0;\n    auto r =\
    \ 0;\n    auto s = 0;\n    auto t = 0;\n    auto u = 0;\n    auto v = 0;\n   \
    \ auto w = 0;\n    auto x = 0;\n    auto y = 0;\n    auto z = 0;\n    auto a =\
    \ 0;\n    auto b = 0;\n    auto c = 0;\n    auto d = 0;\n    auto e = 0;\n   \
    \ auto f = 0;\n    auto g = 0;\n    auto h = 0;\n    auto ii = 0;\n    auto jj\
    \ = 0;\n    auto kk = 0;\n    auto ll = 0;\n    auto mm = 0;\n    auto nn = 0;\n\
    \    auto oo = 0;\n    auto pp = 0;\n    auto qq = 0;\n    auto rr = 0;\n    auto\
    \ ss = 0;\n    auto tt = 0;\n    auto uu = 0;\n    auto vv = 0;\n    auto ww =\
    \ 0;\n    auto xx = 0;\n    auto yy = 0;\n    auto zz = 0;\n    auto aa = 0;\n\
    \    auto bb = 0;\n    auto cc = 0;\n    auto dd = 0;\n    auto ee = 0;\n    auto\
    \ ff = 0;\n    auto gg = 0;\n    auto hh = 0;\n    auto iii = 0;\n    auto jjj\
    \ = 0;\n    auto kkk = 0\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphhp1apf4.d(82): Error: semicolon expected following auto declaration,
    not `unittest`

    /tmp/tmphhp1apf4.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphhp1apf4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int closest = -1;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            if(closest\
    \ == -1)\n                closest = i;\n            else\n            {\n    \
    \            if(abs(i - closest) < abs(i - word.length))\n                   \
    \ closest = i;\n            }\n        }\n    }\n    return closest == -1 ? \"\
    \" : word[closest..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqadbed3q.d(21): Error: no property `canFind` for type `string`

    /tmp/tmpqadbed3q.d(24): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpqadbed3q.d(28): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqadbed3q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index > 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (vowels.find(word[index - 1]) == -1)\n   \
    \         {\n                result = word[index];\n                break;\n \
    \           }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4h0dxe5.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp_4h0dxe5.d(22): Error: no property `find` for type `string`

    /tmp/tmp_4h0dxe5.d(24): Error: no property `find` for type `string`

    /tmp/tmp_4h0dxe5.d(26): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_4h0dxe5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int i = index - 1;\n    while (i >= 0)\n    {\n  \
    \      if (vowels.find(word[i]) != -1)\n        {\n            if (i == 0)\n \
    \           {\n                if (vowels.find(word[i + 1]) == -1)\n         \
    \       {\n                    index = i;\n                    break;\n      \
    \          }\n            }\n            else if (i == index - 1)\n          \
    \  {\n                if (vowels.find(word[i - 1]) == -1)\n                {\n\
    \                    index = i;\n                    break;\n                }\n\
    \            }\n            else\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            index = i;\n                    break;\n                }\n     \
    \       }\n        }\n        i--;\n    }\n    if (index != word.length)\n   \
    \ {\n        result = word[index..$];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmqetpn54.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpmqetpn54.d(23): Error: no property `find` for type `string`

    /tmp/tmpmqetpn54.d(27): Error: no property `find` for type `string`

    /tmp/tmpmqetpn54.d(35): Error: no property `find` for type `string`

    /tmp/tmpmqetpn54.d(43): Error: no property `find` for type `string`

    /tmp/tmpmqetpn54.d(43): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmqetpn54.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min = word.length;\n    foreach(c; word)\n    {\n      \
    \  if(vowels.find(c) != -1)\n        {\n            if(index > 0 && index < word.length\
    \ - 1)\n            {\n                if(vowels.find(word[index - 1]) == -1 &&\
    \ vowels.find(word[index + 1]) == -1)\n                {\n                   \
    \ if(abs(word.length - index) < min)\n                    {\n                \
    \        min = abs(word.length - index);\n                        result = c;\n\
    \                    }\n                }\n            }\n        }\n        index++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt1xjd4n6.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpt1xjd4n6.d(23): Error: no property `find` for type `string`

    /tmp/tmpt1xjd4n6.d(27): Error: no property `find` for type `string`

    /tmp/tmpt1xjd4n6.d(27): Error: no property `find` for type `string`

    /tmp/tmpt1xjd4n6.d(31): Error: cannot implicitly convert expression `abs(word.length
    - cast(ulong)index)` of type `ulong` to `int`

    /tmp/tmpt1xjd4n6.d(32): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt1xjd4n6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ last_vowel_index = -1;\n    int last_consonant_index = -1;\n    int i = 0;\n\
    \    foreach(c; word)\n    {\n        if(vowels.canFind(c))\n        {\n     \
    \       last_vowel_index = i;\n        }\n        else\n        {\n          \
    \  if(last_vowel_index != -1)\n            {\n                last_consonant_index\
    \ = i;\n                break;\n            }\n        }\n        i++;\n    }\n\
    \    if(last_vowel_index != -1 && last_consonant_index != -1)\n    {\n       \
    \ result = word[last_vowel_index..last_vowel_index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe14uv4k9.d(24): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe14uv4k9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    foreach(i, v; word)\n \
    \   {\n        if(vowels.canFind(v))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index > 0 && index < word.length - 1)\n    {\n        result\
    \ = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwt3a0uuh.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpwt3a0uuh.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpwt3a0uuh.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpwt3a0uuh.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpwt3a0uuh.d(35): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwt3a0uuh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int last_vowel_index = -1;\n\
    \    int last_consonant_index = -1;\n    int closest_vowel_index = -1;\n    int\
    \ closest_consonant_index = -1;\n    int closest_distance = -1;\n    foreach(i,\
    \ char c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n        \
    \    last_vowel_index = i;\n            if(last_consonant_index != -1)\n     \
    \       {\n                int distance = i - last_consonant_index;\n        \
    \        if(closest_distance == -1 || distance < closest_distance)\n         \
    \       {\n                    closest_distance = distance;\n                \
    \    closest_vowel_index = i;\n                    closest_consonant_index = last_consonant_index;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      last_consonant_index = i;\n        }\n    }\n    if(closest_vowel_index\
    \ == -1)\n    {\n        return \"\";\n    }\n    return word[closest_vowel_index..$];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptybkpqjb.d(25): Error: no property `find` for type `string`

    /tmp/tmptybkpqjb.d(27): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmptybkpqjb.d(30): Error: cannot implicitly convert expression `i - cast(ulong)last_consonant_index`
    of type `ulong` to `int`

    /tmp/tmptybkpqjb.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmptybkpqjb.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptybkpqjb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int min_distance = word.length;\n    foreach(i, c;\
    \ word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = index - i;\n            if(distance < min_distance)\n            {\n     \
    \           min_distance = distance;\n                result = c;\n          \
    \  }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3wy384e.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpk3wy384e.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpk3wy384e.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpk3wy384e.d(25): Error: cannot implicitly convert expression `cast(ulong)index
    - i` of type `ulong` to `int`

    /tmp/tmpk3wy384e.d(29): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3wy384e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto result = \"\";\n    auto last_vowel = \"\";\n    auto last_consonant\
    \ = \"\";\n    auto last_vowel_index = 0;\n    auto last_consonant_index = 0;\n\
    \    auto i = 0;\n    foreach(c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            last_vowel = c;\n            last_vowel_index = i;\n \
    \       }\n        else if(consonants.canFind(c))\n        {\n            last_consonant\
    \ = c;\n            last_consonant_index = i;\n        }\n        i++;\n    }\n\
    \    if(last_vowel_index > last_consonant_index)\n    {\n        result = last_vowel;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2_3nmg5v.d(27): Error: no property `canFind` for type `string`

    /tmp/tmp2_3nmg5v.d(29): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp2_3nmg5v.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp2_3nmg5v.d(34): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2_3nmg5v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int n = word.length;\n    int\
    \ i = n - 1;\n    while (i >= 0)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i == n - 1)\n                return \"\";\n      \
    \      else if (vowels.find(word[i + 1]) == -1)\n                return word[i\
    \ .. i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprb3c_rsk.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmprb3c_rsk.d(22): Error: no property `find` for type `string`

    /tmp/tmprb3c_rsk.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprb3c_rsk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = 0;\n    int min_dist = word.length;\n    foreach(i, c; word)\n    {\n\
    \        if(vowels.canFind(c))\n        {\n            int dist = word.length\
    \ - i;\n            if(dist < min_dist)\n            {\n                min_dist\
    \ = dist;\n                pos = i;\n            }\n        }\n    }\n    if(pos\
    \ != 0)\n    {\n        result = word[pos..$];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmx9s37vl.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpmx9s37vl.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpmx9s37vl.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpmx9s37vl.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmx9s37vl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int last_vowel_index = -1;\n\
    \    int closest_vowel_index = -1;\n    int closest_vowel_distance = int.max;\n\
    \    foreach(i, ch; word)\n    {\n        if(vowels.canFind(ch))\n        {\n\
    \            if(last_vowel_index != -1)\n            {\n                int distance\
    \ = i - last_vowel_index;\n                if(distance < closest_vowel_distance)\n\
    \                {\n                    closest_vowel_distance = distance;\n \
    \                   closest_vowel_index = i;\n                }\n            }\n\
    \            last_vowel_index = i;\n        }\n    }\n    if(closest_vowel_index\
    \ == -1)\n        return \"\";\n    return word[closest_vowel_index..$];\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpprril_n6.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpprril_n6.d(27): Error: cannot implicitly convert expression `i - cast(ulong)last_vowel_index`
    of type `ulong` to `int`

    /tmp/tmpprril_n6.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpprril_n6.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpprril_n6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = word.length;\n  \
    \  while(index--)\n    {\n        if(vowels.find(word[index]) != -1)\n       \
    \ {\n            if(index == 0)\n                return \"\";\n            if(vowels.find(word[index\
    \ - 1]) == -1)\n                return word[index..$];\n        }\n    }\n   \
    \ return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n \
    \   assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn7j64gm7.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpn7j64gm7.d(21): Error: no property `find` for type `string`

    /tmp/tmpn7j64gm7.d(25): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn7j64gm7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = int.max;\n    int distance = 0;\n    int index = 0;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                index = i;\n      \
    \      }\n        }\n    }\n    if(min_distance != int.max)\n    {\n        result\
    \ = word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuqk_6mjh.d(24): Error: no property `canFind` for type `string`

    /tmp/tmpuqk_6mjh.d(26): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpuqk_6mjh.d(30): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuqk_6mjh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    // your code here\n    string vowels = \"aeiou\";\n    int last_vowel\
    \ = -1;\n    int last_consonant = -1;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            last_vowel\
    \ = i;\n        }\n        else\n        {\n            last_consonant = i;\n\
    \        }\n        if (last_vowel != -1 && last_consonant != -1)\n        {\n\
    \            if (last_vowel < last_consonant)\n            {\n               \
    \ return word[last_vowel..last_vowel];\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzsoy4h4_.d(23): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzsoy4h4_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpobztdc_z.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(22): Error: no property `canFind` for type `string`

    /tmp/tmpobztdc_z.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(28): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobztdc_z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                index--;\n                continue;\n            }\n        \
    \    else if (vowels.find(word[index + 1]) != -1)\n            {\n           \
    \     index--;\n                continue;\n            }\n            else\n \
    \           {\n                result = word[index];\n                break;\n\
    \            }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplcydo4a6.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmplcydo4a6.d(22): Error: no property `find` for type `string`

    /tmp/tmplcydo4a6.d(29): Error: no property `find` for type `string`

    /tmp/tmplcydo4a6.d(36): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplcydo4a6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, v; word)\n    {\n        if(vowels.canFind(v))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = v;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf5d5esn0.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpf5d5esn0.d(22): Error: no property `canFind` for type `string`

    /tmp/tmpf5d5esn0.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpf5d5esn0.d(28): Error: cannot implicitly convert expression `v` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf5d5esn0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                index--;\n                continue;\n            }\n        \
    \    if (vowels.find(word[index + 1]) == -1)\n            {\n                result\
    \ = word[index..$];\n                break;\n            }\n        }\n      \
    \  index--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn3d3f57f.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpn3d3f57f.d(22): Error: no property `find` for type `string`

    /tmp/tmpn3d3f57f.d(29): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn3d3f57f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    static string vowels = \"aeiou\";\n    static string consonants\
    \ = \"bcdfghjklmnpqrstvwxyz\";\n    static string vowels_and_consonants = vowels\
    \ ~ consonants;\n    static string consonants_and_vowels = consonants ~ vowels;\n\
    \    static string consonants_and_consonants = consonants ~ consonants;\n    static\
    \ string vowels_and_vowels = vowels ~ vowels;\n    static string vowels_consonants_vowels\
    \ = vowels_and_consonants ~ vowels;\n    static string consonants_vowels_consonants\
    \ = consonants_and_vowels ~ consonants;\n    static string consonants_consonants_vowels\
    \ = consonants_and_consonants ~ vowels;\n    static string vowels_consonants_consonants\
    \ = vowels_and_consonants ~ consonants;\n    static string consonants_vowels_vowels\
    \ = consonants_and_vowels ~ vowels;\n    static string vowels_vowels_consonants\
    \ = vowels_and_vowels ~ consonants;\n    static string vowels_consonants_vowels_consonants\
    \ = vowels_consonants_vowels ~ consonants;\n    static string consonants_vowels_consonants_vowels\
    \ = consonants_vowels_consonants ~ vowels;\n    static string consonants_consonants_vowels_consonants\
    \ = consonants_consonants_vowels ~ consonants;\n    static string vowels_consonants_consonants_vowels\
    \ = vowels_consonants_consonants ~ vowels;\n    static string consonants_vowels_vowels_consonants\
    \ = consonants_vowels_vowels ~ consonants;\n    static string vowels_vowels_consonants_vowels\
    \ = vowels_vowels_consonants ~ vowels;\n    static string vowels_consonants_vowels_consonants_vowels\
    \ = vowels_consonants_vowels_consonants ~ vow\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp68l3iw70.d(36): Error: semicolon expected, not `unittest`

    /tmp/tmp68l3iw70.d(36): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp68l3iw70.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int distance = 0;\n    int min_distance = word.length;\n   \
    \ foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n  \
    \          int left_distance = 0;\n            int right_distance = 0;\n     \
    \       for(int j = i - 1; j >= 0; j--)\n            {\n                if(vowels.find(word[j])\
    \ != -1)\n                    break;\n                left_distance++;\n     \
    \       }\n            for(int j = i + 1; j < word.length; j++)\n            {\n\
    \                if(vowels.find(word[j]) != -1)\n                    break;\n\
    \                right_distance++;\n            }\n            distance = left_distance\
    \ + right_distance;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                index = i;\n      \
    \      }\n        }\n    }\n    if(index != 0)\n        result = word[index];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwd2st18.d(21): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmppwd2st18.d(24): Error: no property `find` for type `string`

    /tmp/tmppwd2st18.d(28): Error: cannot implicitly convert expression `i - 1LU`
    of type `ulong` to `int`

    /tmp/tmppwd2st18.d(30): Error: no property `find` for type `string`

    /tmp/tmppwd2st18.d(34): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmppwd2st18.d(36): Error: no property `find` for type `string`

    /tmp/tmppwd2st18.d(44): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmppwd2st18.d(49): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwd2st18.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto result = \"\";\n    auto last_consonant = \"\";\n    auto last_vowel\
    \ = \"\";\n    auto last_vowel_index = 0;\n    auto last_consonant_index = 0;\n\
    \    auto word_length = word.length;\n    for (int i = 0; i < word_length; i++)\n\
    \    {\n        auto current_char = word[i];\n        if (vowels.find(current_char)\
    \ != -1)\n        {\n            last_vowel = current_char;\n            last_vowel_index\
    \ = i;\n        }\n        else if (consonants.find(current_char) != -1)\n   \
    \     {\n            last_consonant = current_char;\n            last_consonant_index\
    \ = i;\n        }\n    }\n    if (last_vowel_index > last_consonant_index)\n \
    \   {\n        result = last_vowel;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps_3sltni.d(28): Error: no property `find` for type `string`

    /tmp/tmps_3sltni.d(30): Error: cannot implicitly convert expression `current_char`
    of type `immutable(char)` to `string`

    /tmp/tmps_3sltni.d(33): Error: no property `find` for type `string`

    /tmp/tmps_3sltni.d(35): Error: cannot implicitly convert expression `current_char`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps_3sltni.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int i = word.length - 1;\n    while (i >= 0)\n    {\n       \
    \ if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u')\n        {\n            if (i == word.length - 1)\n        \
    \        return \"\";\n            else if (word[i + 1] == 'a' || word[i + 1]\
    \ == 'e' || word[i + 1] == 'i' || word[i + 1] == 'o' || word[i + 1] == 'u')\n\
    \                return \"\";\n            else\n                return word[i\
    \ .. i];\n        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphu5fws85.d(17): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphu5fws85.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = word.length - 1;\n\
    \    while (index >= 0)\n    {\n        if (vowels.canFind(word[index]))\n   \
    \     {\n            if (index == word.length - 1)\n                return \"\"\
    ;\n            else if (vowels.canFind(word[index + 1]))\n                return\
    \ \"\";\n            else\n                return word[index .. index];\n    \
    \    }\n        index--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4be9u2o0.d(18): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp4be9u2o0.d(21): Error: no property `canFind` for type `string`

    /tmp/tmp4be9u2o0.d(25): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4be9u2o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = -1;\n    int min_distance\
    \ = int.max;\n    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.indexOf(word[i])\
    \ != -1)\n        {\n            int distance = word.length - i;\n           \
    \ if (distance < min_distance)\n            {\n                min_distance =\
    \ distance;\n                index = i;\n            }\n        }\n    }\n   \
    \ if (index == -1)\n        return \"\";\n    return word[index..$];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps2eork9w.d(22): Error: no property `indexOf` for type `string`

    /tmp/tmps2eork9w.d(24): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps2eork9w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = word.length;\n    foreach(immutable char c; word)\n    {\n      \
    \  if(vowels.indexOf(c) != -1)\n        {\n            int index = word.indexOf(c);\n\
    \            if(index > 0 && index < word.length - 1)\n            {\n       \
    \         if(vowels.indexOf(word[index - 1]) == -1 && vowels.indexOf(word[index\
    \ + 1]) == -1)\n                {\n                    if(distance > abs(word.length\
    \ - index))\n                    {\n                        distance = abs(word.length\
    \ - index);\n                        result = c;\n                    }\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwc6pgpon.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpwc6pgpon.d(22): Error: no property `indexOf` for type `string`

    /tmp/tmpwc6pgpon.d(24): Error: no property `indexOf` for type `string`

    /tmp/tmpwc6pgpon.d(27): Error: no property `indexOf` for type `string`

    /tmp/tmpwc6pgpon.d(27): Error: no property `indexOf` for type `string`

    /tmp/tmpwc6pgpon.d(31): Error: cannot implicitly convert expression `abs(word.length
    - cast(ulong)index)` of type `ulong` to `int`

    /tmp/tmpwc6pgpon.d(32): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwc6pgpon.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int min = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            if(i > 0 && i <\
    \ word.length - 1)\n            {\n                if(!vowels.canFind(word[i -\
    \ 1]) && !vowels.canFind(word[i + 1]))\n                {\n                  \
    \  if(abs(i - word.length) < min)\n                    {\n                   \
    \     min = abs(i - word.length);\n                        result = c;\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt5sc2rzz.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpt5sc2rzz.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpt5sc2rzz.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpt5sc2rzz.d(27): Error: no property `canFind` for type `string`

    /tmp/tmpt5sc2rzz.d(27): Error: no property `canFind` for type `string`

    /tmp/tmpt5sc2rzz.d(31): Error: cannot implicitly convert expression `abs(i - word.length)`
    of type `ulong` to `int`

    /tmp/tmpt5sc2rzz.d(32): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt5sc2rzz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                index--;\n                continue;\n            }\n        \
    \    if (vowels.find(word[index + 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn4u9ahwz.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpn4u9ahwz.d(22): Error: no property `find` for type `string`

    /tmp/tmpn4u9ahwz.d(29): Error: no property `find` for type `string`

    /tmp/tmpn4u9ahwz.d(31): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn4u9ahwz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ last_consonant = -1;\n    int last_vowel = -1;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  last_vowel = i;\n        }\n        else\n        {\n            last_consonant\
    \ = i;\n        }\n        if (last_consonant != -1 && last_vowel != -1)\n   \
    \     {\n            if (abs(last_consonant - last_vowel) < abs(result.length))\n\
    \            {\n                result = word[last_vowel..$];\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph5gd39f9.d(23): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph5gd39f9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    import std.algorithm;\n    import std.range;\n    import std.array;\n\
    \    import std.conv;\n    import std.string;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.stdio;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.stdio;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.conv;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std.stdio;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.array;\n   \
    \ import std.conv;\n    import std.string;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.stdio;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.stdio;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.conv;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.math;\n    import std.stdio;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.array;\n   \
    \ import std.conv;\n    import std.string;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.stdio;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.stdio;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.conv;\n    import\
    \ std.string;\n   \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphhfv4f2z.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphhfv4f2z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index > 0 && index < word.length - 1)\n    {\n        result\
    \ = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgjcbfg56.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpgjcbfg56.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpgjcbfg56.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpgjcbfg56.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpgjcbfg56.d(35): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgjcbfg56.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto is_vowel = [](char c) {\n        return c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u';\n    };\n    auto is_consonant = [](char\
    \ c) {\n        return !is_vowel(c);\n    };\n    auto is_consonant_pair = [=](char\
    \ c1, char c2) {\n        return is_consonant(c1) && is_consonant(c2);\n    };\n\
    \    auto is_vowel_between_consonants = [=](char c) {\n        return is_vowel(c)\
    \ && is_consonant_pair(word[$-2], word[$-1]);\n    };\n    auto closest_vowel\
    \ = find(word, is_vowel_between_consonants);\n    return closest_vowel.empty ?\
    \ \"\" : closest_vowel[0..1];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpus6efkgg.d(17): Error: found `c` when expecting `.` following char

    /tmp/tmpus6efkgg.d(17): Error: found `)` when expecting identifier following `char`.

    /tmp/tmpus6efkgg.d(17): Error: found `{` when expecting `,`

    /tmp/tmpus6efkgg.d(18): Error: expression expected, not `return`

    /tmp/tmpus6efkgg.d(18): Error: found `c` when expecting `,`

    /tmp/tmpus6efkgg.d(18): Error: expression expected, not `==`

    /tmp/tmpus6efkgg.d(18): Error: found `97U` when expecting `,`

    /tmp/tmpus6efkgg.d(18): Error: expression expected, not `||`

    /tmp/tmpus6efkgg.d(18): Error: found `c` when expecting `,`

    /tmp/tmpus6efkgg.d(18): Error: expression expected, not `==`

    /tmp/tmpus6efkgg.d(18): Error: found `101U` when expecting `,`

    /tmp/tmpus6efkgg.d(18): Error: expression expected, not `||`

    /tmp/tmpus6efkgg.d(18): Error: found `c` when expecting `,`

    /tmp/tmpus6efkgg.d(18): Error: expression expected, not `==`

    /tmp/tmpus6efkgg.d(18): Error: found `105U` when expecting `,`

    /tmp/tmpus6efkgg.d(18): Error: expression expected, not `||`

    /tmp/'
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    while(index > 0)\n    {\n        if(vowels.find(word[index])\
    \ != -1)\n        {\n            if(vowels.find(word[index-1]) == -1)\n      \
    \      {\n                result = word[index];\n                break;\n    \
    \        }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp03q9u57g.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp03q9u57g.d(22): Error: no property `find` for type `string`

    /tmp/tmp03q9u57g.d(24): Error: no property `find` for type `string`

    /tmp/tmp03q9u57g.d(26): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp03q9u57g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index != 0)\n    {\n        result = word[index..$];\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ur0jj7g.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp9ur0jj7g.d(23): Error: no property `canFind` for type `string`

    /tmp/tmp9ur0jj7g.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp9ur0jj7g.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ur0jj7g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int i = word.length;\n    while(i--)\n    {\n        if(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n\
    \        {\n            if(i == 0)\n                return \"\";\n           \
    \ else if(word[i-1] == 'a' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1]\
    \ == 'o' || word[i-1] == 'u')\n                continue;\n            else\n \
    \               return word[i..$];\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj_3dvrjz.d(17): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj_3dvrjz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = -1;\n    auto last_consonant = -1;\n    auto result =\
    \ \"\";\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n     \
    \   {\n            last_vowel = i;\n        }\n        else if(consonants.canFind(c))\n\
    \        {\n            last_consonant = i;\n        }\n        if(last_vowel\
    \ != -1 && last_consonant != -1 && last_vowel > last_consonant)\n        {\n \
    \           result = word[last_vowel..$];\n            break;\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcdxzd6hw.d(24): Error: no property `canFind` for type `string`

    /tmp/tmpcdxzd6hw.d(26): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpcdxzd6hw.d(28): Error: no property `canFind` for type `string`

    /tmp/tmpcdxzd6hw.d(30): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcdxzd6hw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = word.length;\n  \
    \  int closest = index;\n    int closest_index = index;\n    int closest_vowel\
    \ = index;\n    int closest_vowel_index = index;\n    foreach(i, c; word)\n  \
    \  {\n        if(vowels.find(c) != -1)\n        {\n            if(i < closest_vowel)\n\
    \            {\n                closest_vowel = i;\n                closest_vowel_index\
    \ = index;\n            }\n        }\n        else\n        {\n            if(i\
    \ < closest)\n            {\n                closest = i;\n                closest_index\
    \ = index;\n            }\n        }\n        index--;\n    }\n    if(closest_vowel_index\
    \ < closest_index)\n    {\n        return word[closest_vowel];\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz2k5wpfc.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpz2k5wpfc.d(25): Error: no property `find` for type `string`

    /tmp/tmpz2k5wpfc.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpz2k5wpfc.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpz2k5wpfc.d(45): Error: cannot implicitly convert expression `word[cast(ulong)closest_vowel]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2k5wpfc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = \"\";\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            last_vowel = c;\n        }\n        else if(consonants.canFind(c))\n\
    \        {\n            if(last_vowel != \"\")\n            {\n              \
    \  return last_vowel;\n            }\n        }\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpur5s8v24.d(22): Error: no property `canFind` for type `string`

    /tmp/tmpur5s8v24.d(24): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmpur5s8v24.d(26): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpur5s8v24.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    int vowel_index = -1;\n    while (index >= 0)\n\
    \    {\n        if (vowels.find(word[index]) != -1)\n        {\n            vowel_index\
    \ = index;\n            break;\n        }\n        index--;\n    }\n    if (vowel_index\
    \ == -1)\n        return result;\n    index = vowel_index - 1;\n    while (index\
    \ >= 0)\n    {\n        if (vowels.find(word[index]) == -1)\n        {\n     \
    \       result = word[vowel_index];\n            break;\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpczgyvmyq.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpczgyvmyq.d(23): Error: no property `find` for type `string`

    /tmp/tmpczgyvmyq.d(35): Error: no property `find` for type `string`

    /tmp/tmpczgyvmyq.d(37): Error: cannot implicitly convert expression `word[cast(ulong)vowel_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpczgyvmyq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    import std.algorithm.comparison : equal;\n    import std.array\
    \ : array;\n    import std.range : iota;\n    import std.conv : to;\n    import\
    \ std.string : toLower;\n    import std.math : abs;\n    import std.algorithm\
    \ : min;\n    import std.typecons : tuple;\n    import std.range : map;\n    import\
    \ std.range : filter;\n    import std.range : zip;\n    import std.range : take;\n\
    \    import std.range : drop;\n    import std.range : cycle;\n    import std.range\
    \ : retro;\n    import std.range : takeExactly;\n    import std.range : dropExactly;\n\
    \    import std.range : retro;\n    import std.range : retro;\n    import std.range\
    \ : retro;\n    import std.range : retro;\n    import std.range : retro;\n   \
    \ import std.range : retro;\n    import std.range : retro;\n    import std.range\
    \ : retro;\n    import std.range : retro;\n    import std.range : retro;\n   \
    \ import std.range : retro;\n    import std.range : retro;\n    import std.range\
    \ : retro;\n    import std.range : retro;\n    import std.range : retro;\n   \
    \ import std.range : retro;\n    import std.range : retro;\n    import std.range\
    \ : retro;\n    import std.range : retro;\n    import std.range : retro;\n   \
    \ import std.range : retro;\n    import std.range : retro;\n    import std.range\
    \ : retro;\n    import std.range : retro;\n    import std.range : retro;\n   \
    \ import std.range : retro;\n    import std.range : retro;\n    import std.range\
    \ : retro;\n    import std.range : retro;\n    import std.range : retro;\n   \
    \ import std.range : retro;\n    import std.range : retro;\n    import std.range\
    \ : retro;\n    import std.range : retro;\n    import std.range : retro;\n   \
    \ import std.range : retro;\n    import std.range : retro;\n    import std.range\
    \ : retro;\n    import std\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_kydi7xj.d(73): Error: `;` expected

    /tmp/tmp_kydi7xj.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_kydi7xj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = -1;\n    int distance = 0;\n    int min_distance = 0;\n    int word_length\
    \ = word.length;\n    int vowels_length = vowels.length;\n    int i = 0;\n   \
    \ int j = 0;\n    int k = 0;\n    for (i = 0; i < word_length; i++)\n    {\n \
    \       for (j = 0; j < vowels_length; j++)\n        {\n            if (word[i]\
    \ == vowels[j])\n            {\n                for (k = i + 1; k < word_length;\
    \ k++)\n                {\n                    if (word[k] == 'a' || word[k] ==\
    \ 'e' || word[k] == 'i' || word[k] == 'o' || word[k] == 'u')\n               \
    \     {\n                        distance = k - i;\n                        if\
    \ (distance < min_distance || min_distance == 0)\n                        {\n\
    \                            min_distance = distance;\n                      \
    \      index = i;\n                        }\n                        break;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if (index != -1)\n    {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tqbmmww.d(22): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_tqbmmww.d(23): Error: cannot implicitly convert expression `vowels.length`
    of type `ulong` to `int`

    /tmp/tmp_tqbmmww.d(51): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tqbmmww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int n = word.length;\n    string\
    \ res = \"\";\n    int min = n;\n    for (int i = 0; i < n; i++)\n    {\n    \
    \    if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0 && vowels.find(word[i-1])\
    \ == -1)\n            {\n                if (i < min)\n                {\n   \
    \                 min = i;\n                    res = word[i];\n             \
    \   }\n            }\n            if (i < n-1 && vowels.find(word[i+1]) == -1)\n\
    \            {\n                if (n-i-1 < min)\n                {\n        \
    \            min = n-i-1;\n                    res = word[i];\n              \
    \  }\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjetpyvzo.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjetpyvzo.d(23): Error: no property `find` for type `string`

    /tmp/tmpjetpyvzo.d(25): Error: no property `find` for type `string`

    /tmp/tmpjetpyvzo.d(30): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmpjetpyvzo.d(33): Error: no property `find` for type `string`

    /tmp/tmpjetpyvzo.d(38): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjetpyvzo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto result = \"\";\n    auto last_consonant = -1;\n    auto first_vowel\
    \ = -1;\n    auto i = 0;\n    foreach(c; word)\n    {\n        if(consonants.canFind(c))\n\
    \        {\n            last_consonant = i;\n        }\n        else if(vowels.canFind(c))\n\
    \        {\n            if(last_consonant != -1)\n            {\n            \
    \    if(first_vowel == -1)\n                {\n                    first_vowel\
    \ = i;\n                }\n                else\n                {\n         \
    \           if(abs(last_consonant - i) < abs(last_consonant - first_vowel))\n\
    \                    {\n                        first_vowel = i;\n           \
    \         }\n                }\n            }\n        }\n        i++;\n    }\n\
    \    if(first_vowel != -1)\n    {\n        result = word[first_vowel];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf96e7_08.d(25): Error: no property `canFind` for type `string`

    /tmp/tmpf96e7_08.d(29): Error: no property `canFind` for type `string`

    /tmp/tmpf96e7_08.d(50): Error: cannot implicitly convert expression `word[cast(ulong)first_vowel]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf96e7_08.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ last_consonant = -1;\n    int first_vowel = -1;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (last_consonant != -1)\n            {\n                if (first_vowel ==\
    \ -1)\n                {\n                    first_vowel = i;\n             \
    \   }\n                else\n                {\n                    if (i - last_consonant\
    \ < first_vowel - last_consonant)\n                    {\n                   \
    \     first_vowel = i;\n                    }\n                }\n           \
    \ }\n        }\n        else\n        {\n            last_consonant = i;\n   \
    \     }\n    }\n    if (first_vowel != -1)\n    {\n        result = word[first_vowel];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwlsaqhy6.d(23): Error: no property `find` for type `string`

    /tmp/tmpwlsaqhy6.d(47): Error: cannot implicitly convert expression `word[cast(ulong)first_vowel]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwlsaqhy6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int[] vowel_positions = [];\n\
    \    foreach(int i, char c; word)\n    {\n        if(vowels.canFind(c))\n    \
    \        vowel_positions ~= i;\n    }\n    if(vowel_positions.length == 0)\n \
    \       return \"\";\n    int closest_vowel_index = vowel_positions[0];\n    foreach(int\
    \ i; vowel_positions)\n    {\n        if(abs(i - word.length) < abs(closest_vowel_index\
    \ - word.length))\n            closest_vowel_index = i;\n    }\n    return word[closest_vowel_index..closest_vowel_index];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2hj45vra.d(21): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2hj45vra.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    foreach(i, char c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index != 0)\n    {\n        result = word[index..$];\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpasecocsq.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpasecocsq.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpasecocsq.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpasecocsq.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasecocsq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index != 0)\n    {\n        result = word[index..$];\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ur0jj7g.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp9ur0jj7g.d(23): Error: no property `canFind` for type `string`

    /tmp/tmp9ur0jj7g.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp9ur0jj7g.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ur0jj7g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min = word.length;\n    foreach(i, c; word)\n    {\n   \
    \     if(vowels.find(c) != -1)\n        {\n            if(i > 0 && i < word.length\
    \ - 1)\n            {\n                if(vowels.find(word[i - 1]) == -1 && vowels.find(word[i\
    \ + 1]) == -1)\n                {\n                    if(abs(word.length - i)\
    \ < min)\n                    {\n                        min = abs(word.length\
    \ - i);\n                        index = i;\n                    }\n         \
    \       }\n            }\n        }\n    }\n    if(index != 0)\n    {\n      \
    \  result = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0rvepu_.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpf0rvepu_.d(23): Error: no property `find` for type `string`

    /tmp/tmpf0rvepu_.d(27): Error: no property `find` for type `string`

    /tmp/tmpf0rvepu_.d(27): Error: no property `find` for type `string`

    /tmp/tmpf0rvepu_.d(31): Error: cannot implicitly convert expression `abs(word.length
    - i)` of type `ulong` to `int`

    /tmp/tmpf0rvepu_.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpf0rvepu_.d(40): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0rvepu_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = -1;\n    int min_dist\
    \ = int.max;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int dist = word.length - i;\n            if(dist < min_dist)\n\
    \            {\n                min_dist = dist;\n                index = i;\n\
    \            }\n        }\n    }\n    if(index == -1)\n        return \"\";\n\
    \    return word[index..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxya7wdyw.d(22): Error: no property `canFind` for type `string`

    /tmp/tmpxya7wdyw.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpxya7wdyw.d(28): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxya7wdyw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int closest = -1;\n    int index\
    \ = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.indexOf(word[index])\
    \ != -1)\n        {\n            closest = index;\n            break;\n      \
    \  }\n        index--;\n    }\n    if (closest == -1)\n        return \"\";\n\
    \    index = closest - 1;\n    while (index >= 0)\n    {\n        if (vowels.indexOf(word[index])\
    \ == -1)\n        {\n            return word[closest..$];\n        }\n       \
    \ index--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8j3ve0kn.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8j3ve0kn.d(22): Error: no property `indexOf` for type `string`

    /tmp/tmp8j3ve0kn.d(34): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8j3ve0kn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpobztdc_z.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(22): Error: no property `canFind` for type `string`

    /tmp/tmpobztdc_z.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(28): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobztdc_z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int i = word.length - 1;\n  \
    \  while (i >= 0)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i == word.length - 1)\n                return \"\";\n       \
    \     else if (vowels.find(word[i+1]) == -1)\n                return word[i..i];\n\
    \        }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmnls2dhm.d(18): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpmnls2dhm.d(21): Error: no property `find` for type `string`

    /tmp/tmpmnls2dhm.d(25): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmnls2dhm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int min_distance = word.length;\n    foreach(i, v;\
    \ word)\n    {\n        if(vowels.canFind(v))\n        {\n            int distance\
    \ = index - i;\n            if(distance < min_distance)\n            {\n     \
    \           min_distance = distance;\n                result = v;\n          \
    \  }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkkm3027j.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpkkm3027j.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpkkm3027j.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpkkm3027j.d(25): Error: cannot implicitly convert expression `cast(ulong)index
    - i` of type `ulong` to `int`

    /tmp/tmpkkm3027j.d(29): Error: cannot implicitly convert expression `v` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkkm3027j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    bool found = false;\n    while(index > 0)\n    {\n\
    \        if(vowels.find(word[index]) != -1)\n        {\n            if(vowels.find(word[index\
    \ - 1]) == -1)\n            {\n                result = word[index];\n       \
    \         found = true;\n                break;\n            }\n        }\n  \
    \      index--;\n    }\n    if(found)\n        return result;\n    else\n    \
    \    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1h6xwch9.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp1h6xwch9.d(23): Error: no property `find` for type `string`

    /tmp/tmp1h6xwch9.d(25): Error: no property `find` for type `string`

    /tmp/tmp1h6xwch9.d(27): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1h6xwch9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    static string vowels = \"aeiou\";\n    static string consonants\
    \ = \"bcdfghjklmnpqrstvwxyz\";\n    int i = word.length - 1;\n    int j = i;\n\
    \    while (i >= 0)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i == 0)\n                return \"\";\n            if (consonants.find(word[i\
    \ - 1]) != -1)\n                return word[i..$];\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqvrcedmd.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpqvrcedmd.d(23): Error: no property `find` for type `string`

    /tmp/tmpqvrcedmd.d(27): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqvrcedmd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                index--;\n                continue;\n            }\n        \
    \    if (vowels.find(word[index + 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn4u9ahwz.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpn4u9ahwz.d(22): Error: no property `find` for type `string`

    /tmp/tmpn4u9ahwz.d(29): Error: no property `find` for type `string`

    /tmp/tmpn4u9ahwz.d(31): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn4u9ahwz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index > 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (vowels.find(word[index - 1]) == -1)\n   \
    \         {\n                result = word[index];\n                break;\n \
    \           }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4h0dxe5.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp_4h0dxe5.d(22): Error: no property `find` for type `string`

    /tmp/tmp_4h0dxe5.d(24): Error: no property `find` for type `string`

    /tmp/tmp_4h0dxe5.d(26): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_4h0dxe5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = word.length;\n  \
    \  int vowel_index = -1;\n    int vowel_distance = index;\n    while (index--)\n\
    \    {\n        if (vowels.canFind(word[index]))\n        {\n            if (index\
    \ > 0 && vowels.canFind(word[index - 1]))\n                continue;\n       \
    \     if (index < word.length - 1 && vowels.canFind(word[index + 1]))\n      \
    \          continue;\n            if (index < vowel_distance)\n            {\n\
    \                vowel_distance = index;\n                vowel_index = index;\n\
    \            }\n        }\n    }\n    if (vowel_index == -1)\n        return \"\
    \";\n    return word[vowel_index..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6u7nllzu.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp6u7nllzu.d(23): Error: no property `canFind` for type `string`

    /tmp/tmp6u7nllzu.d(25): Error: no property `canFind` for type `string`

    /tmp/tmp6u7nllzu.d(27): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6u7nllzu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length;\n    int min_dist = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int dist = pos -\
    \ i;\n            if(dist < min_dist)\n            {\n                min_dist\
    \ = dist;\n                result = c;\n            }\n        }\n        pos--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpztrvv2tm.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpztrvv2tm.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpztrvv2tm.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpztrvv2tm.d(25): Error: cannot implicitly convert expression `cast(ulong)pos
    - i` of type `ulong` to `int`

    /tmp/tmpztrvv2tm.d(29): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztrvv2tm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int distance = 0;\n    int min_distance = 0;\n    int min_index\
    \ = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n   \
    \     {\n            index = i;\n            distance = word.length - index;\n\
    \            if(distance < min_distance || min_distance == 0)\n            {\n\
    \                min_distance = distance;\n                min_index = index;\n\
    \            }\n        }\n    }\n    if(min_distance == 0)\n    {\n        return\
    \ result;\n    }\n    else\n    {\n        return word[min_index..$];\n    }\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpffvpjuw0.d(25): Error: no property `find` for type `string`

    /tmp/tmpffvpjuw0.d(27): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpffvpjuw0.d(28): Error: cannot implicitly convert expression `word.length
    - cast(ulong)index` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpffvpjuw0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.canFind(word[index]))\n\
    \        {\n            if (index == word.length - 1)\n            {\n       \
    \         if (index - 1 >= 0)\n                {\n                    if (!vowels.canFind(word[index\
    \ - 1]))\n                    {\n                        result = word[index..$];\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n            else if (index == 0)\n            {\n              \
    \  if (word.length > 1)\n                {\n                    if (!vowels.canFind(word[index\
    \ + 1]))\n                    {\n                        result = word[index..$];\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n            else\n            {\n                if (!vowels.canFind(word[index\
    \ - 1]) && !vowels.canFind(word[index + 1]))\n                {\n            \
    \        result = word[index..$];\n                    break;\n              \
    \  }\n            }\n        }\n        index--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6l_34liu.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp6l_34liu.d(22): Error: no property `canFind` for type `string`

    /tmp/tmp6l_34liu.d(28): Error: no property `canFind` for type `string`

    /tmp/tmp6l_34liu.d(39): Error: no property `canFind` for type `string`

    /tmp/tmp6l_34liu.d(48): Error: no property `canFind` for type `string`

    /tmp/tmp6l_34liu.d(48): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6l_34liu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int i = word.length;\n    while(i--)\n\
    \    {\n        if(vowels.find(word[i]) != -1)\n        {\n            if(i !=\
    \ 0 && vowels.find(word[i-1]) == -1)\n                return word[i..$];\n   \
    \         else if(i != word.length-1 && vowels.find(word[i+1]) == -1)\n      \
    \          return word[i..$];\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr0jrutj8.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpr0jrutj8.d(21): Error: no property `find` for type `string`

    /tmp/tmpr0jrutj8.d(23): Error: no property `find` for type `string`

    /tmp/tmpr0jrutj8.d(25): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr0jrutj8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    // your code here\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int pos = word.length;\n    int min_dist = word.length;\n\
    \    for (int i = word.length - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != -1) {\n            if (pos - i < min_dist) {\n                min_dist =\
    \ pos - i;\n                result = word[i..$];\n            }\n            pos\
    \ = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp308nihwq.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp308nihwq.d(21): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp308nihwq.d(22): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp308nihwq.d(23): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp308nihwq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string closest_vowel = \"\";\n\
    \    int closest_vowel_index = -1;\n    int closest_vowel_distance = -1;\n   \
    \ int word_length = word.length;\n    for (int i = 0; i < word_length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word_length - i;\n            if (closest_vowel_distance == -1 || distance\
    \ < closest_vowel_distance)\n            {\n                closest_vowel_distance\
    \ = distance;\n                closest_vowel_index = i;\n            }\n     \
    \   }\n    }\n    if (closest_vowel_index != -1)\n    {\n        closest_vowel\
    \ = word[closest_vowel_index..closest_vowel_index];\n    }\n    return closest_vowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsfxbqp2q.d(21): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpsfxbqp2q.d(24): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsfxbqp2q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    import std.algorithm;\n    import std.array;\n    import std.range;\n\
    \    import std.string;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.stdio;\n    import std.conv;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.string;\n    import std.typecons;\n   \
    \ import std.math;\n    import std.stdio;\n    import std.conv;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.string;\n  \
    \  import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.conv;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.string;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.stdio;\n    import std.conv;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.string;\n    import std.typecons;\n   \
    \ import std.math;\n    import std.stdio;\n    import std.conv;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.string;\n  \
    \  import std.typecons;\n    import std.math;\n    import std.stdio;\n    import\
    \ std.conv;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.string;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.stdio;\n    import std.conv;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.string;\n    import std.typecons;\n   \
    \ import std.math;\n    import std.stdio;\n    import std.conv;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.string;\n  \
    \  import std.typecons;\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ distance = 0;\n    int minDistance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            distance = word.length\
    \ - i;\n            if(distance < minDistance)\n            {\n              \
    \  minDistance = distance;\n                result = c;\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwn7avgeq.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpwn7avgeq.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpwn7avgeq.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpwn7avgeq.d(29): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwn7avgeq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length;\n    int min_dist = word.length;\n    foreach(c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int dist = pos -\
    \ word.rfind(c);\n            if(dist < min_dist)\n            {\n           \
    \     min_dist = dist;\n                result = c;\n            }\n        }\n\
    \        pos--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjlpm3k0r.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjlpm3k0r.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjlpm3k0r.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpjlpm3k0r.d(25): Error: no property `rfind` for type `string`

    /tmp/tmpjlpm3k0r.d(29): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjlpm3k0r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            distance = word.length - i;\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               index = i;\n            }\n        }\n    }\n    if (index !=\
    \ word.length)\n    {\n        result = word[index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp5vt2foy.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpp5vt2foy.d(21): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpp5vt2foy.d(22): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpp5vt2foy.d(24): Error: no property `find` for type `string`

    /tmp/tmpp5vt2foy.d(26): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmpp5vt2foy.d(36): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp5vt2foy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            int distance = word.length - i;\n           \
    \ if(distance < min_distance)\n            {\n                result = c;\n  \
    \              min_distance = distance;\n            }\n        }\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz0iuqi4.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpbz0iuqi4.d(22): Error: no property `find` for type `string`

    /tmp/tmpbz0iuqi4.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpbz0iuqi4.d(27): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int distance = 0;\n    int min_distance = 0;\n    int min_index\
    \ = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int\
    \ m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n   \
    \ int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n\
    \    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n\
    \    int g = 0;\n    int h = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk\
    \ = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n \
    \   int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt\
    \ = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n \
    \   int yy = 0;\n    int zz = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc\
    \ = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n \
    \   int hh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int\
    \ lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n    int ooo = 0;\n    int ppp\
    \ = 0;\n    int qqq = 0;\n    int rrr = 0;\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbg1_85c3.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbg1_85c3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = word.length;\n  \
    \  int result = -1;\n    int distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            if(i > 0 && i <\
    \ word.length - 1)\n            {\n                if(!vowels.canFind(word[i -\
    \ 1]) && !vowels.canFind(word[i + 1]))\n                {\n                  \
    \  if(abs(index - i) < distance)\n                    {\n                    \
    \    distance = abs(index - i);\n                        result = i;\n       \
    \             }\n                }\n            }\n        }\n    }\n    if(result\
    \ == -1)\n        return \"\";\n    return word[result..result];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfculf6se.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpfculf6se.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpfculf6se.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpfculf6se.d(27): Error: no property `canFind` for type `string`

    /tmp/tmpfculf6se.d(27): Error: no property `canFind` for type `string`

    /tmp/tmpfculf6se.d(31): Error: cannot implicitly convert expression `abs(cast(ulong)index
    - i)` of type `ulong` to `int`

    /tmp/tmpfculf6se.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfculf6se.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (i > 0 && i < word.length - 1)\n            {\n                if (vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n                {\n                \
    \    if (min_distance > abs(i - word.length + 1))\n                    {\n   \
    \                     min_distance = abs(i - word.length + 1);\n             \
    \           index = i;\n                    }\n                }\n           \
    \ }\n        }\n    }\n    if (index != 0)\n    {\n        result = word[index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjy05pg1s.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjy05pg1s.d(23): Error: no property `find` for type `string`

    /tmp/tmpjy05pg1s.d(27): Error: no property `find` for type `string`

    /tmp/tmpjy05pg1s.d(27): Error: no property `find` for type `string`

    /tmp/tmpjy05pg1s.d(31): Error: cannot implicitly convert expression `abs(cast(ulong)i
    - word.length + 1LU)` of type `ulong` to `int`

    /tmp/tmpjy05pg1s.d(40): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int index = word.length - 1;\n\
    \    while (index >= 0)\n    {\n        if (vowels.canFind(word[index]))\n   \
    \     {\n            if (index == word.length - 1)\n                return \"\"\
    ;\n            if (vowels.canFind(word[index + 1]))\n                return \"\
    \";\n            return word[index .. index];\n        }\n        index--;\n \
    \   }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprjhx5f_5.d(18): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmprjhx5f_5.d(21): Error: no property `canFind` for type `string`

    /tmp/tmprjhx5f_5.d(25): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjhx5f_5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int distance = 0;\n    int min_distance = 0;\n    int word_length\
    \ = word.length;\n    int vowel_length = vowels.length;\n    int vowel_index =\
    \ 0;\n    int vowel_distance = 0;\n    int vowel_min_distance = 0;\n    int vowel_min_index\
    \ = 0;\n    int vowel_min_index_distance = 0;\n    int vowel_min_index_distance_index\
    \ = 0;\n    int vowel_min_index_distance_index_distance = 0;\n    int vowel_min_index_distance_index_distance_index\
    \ = 0;\n    int vowel_min_index_distance_index_distance_index_distance = 0;\n\
    \    int vowel_min_index_distance_index_distance_index_distance_index = 0;\n \
    \   int vowel_min_index_distance_index_distance_index_distance_index_distance\
    \ = 0;\n    int vowel_min_index_distance_index_distance_index_distance_index_distance_index\
    \ = 0;\n    int vowel_min_index_distance_index_distance_index_distance_index_distance_index_distance\
    \ = 0;\n    int vowel_min_index_distance_index_distance_index_distance_index_distance_index_distance_index\
    \ = 0;\n    int vowel_min_index_distance_index_distance_index_distance_index_distance_index_distance_index_distance\
    \ = 0;\n    int vowel_min_index_distance_index_distance_index_distance_index_distance_index_distance_index_distance_index\
    \ = 0;\n    int vowel_min_index_distance_index_distance_index_distance_index_distance_index_distance_index_distance_index_distance\
    \ = 0;\n    int vowel_min_index_distance_index_distance_index_distance_index_distance_index_distance_index_distance_index_distance_index\
    \ = 0;\n    int vowel_min_index_distance_index_distance_index_distance_index_distance_index_distance_index_distance_index_distance_index_distance\
    \ = 0;\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw1kjuawx.d(44): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw1kjuawx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string result = \"\";\n    int index = 0;\n    int min_index = 0;\n   \
    \ int min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            if(index > 0 && consonants.find(word[index -\
    \ 1]) != -1)\n            {\n                if(index < word.length - 1 && consonants.find(word[index\
    \ + 1]) != -1)\n                {\n                    if(index - min_index <\
    \ min_distance)\n                    {\n                        min_distance =\
    \ index - min_index;\n                        result = c;\n                  \
    \  }\n                }\n                else\n                {\n           \
    \         min_index = index;\n                }\n            }\n        }\n  \
    \      index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbpcfaroo.d(22): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpbpcfaroo.d(25): Error: no property `find` for type `string`

    /tmp/tmpbpcfaroo.d(27): Error: no property `find` for type `string`

    /tmp/tmpbpcfaroo.d(29): Error: no property `find` for type `string`

    /tmp/tmpbpcfaroo.d(34): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpcfaroo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = -1;\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index != -1)\n    {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphy361d4a.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmphy361d4a.d(23): Error: no property `canFind` for type `string`

    /tmp/tmphy361d4a.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmphy361d4a.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphy361d4a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index > 0 && vowels.find(word[index - 1])\
    \ == -1)\n            {\n                result = word[index];\n             \
    \   break;\n            }\n            else if (index < word.length - 1 && vowels.find(word[index\
    \ + 1]) == -1)\n            {\n                result = word[index];\n       \
    \         break;\n            }\n        }\n        index--;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwwqwwwdm.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpwwqwwwdm.d(22): Error: no property `find` for type `string`

    /tmp/tmpwwqwwwdm.d(24): Error: no property `find` for type `string`

    /tmp/tmpwwqwwwdm.d(26): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    /tmp/tmpwwqwwwdm.d(29): Error: no property `find` for type `string`

    /tmp/tmpwwqwwwdm.d(31): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwwqwwwdm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    int distance = 0;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = word[i..$];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4h3kgjps.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp4h3kgjps.d(23): Error: no property `find` for type `string`

    /tmp/tmp4h3kgjps.d(25): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4h3kgjps.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int[] vowels = [ 'a', 'e', 'i', 'o', 'u' ];\n    int[] consonants\
    \ = [ 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's',\
    \ 't', 'v', 'w', 'x', 'y', 'z' ];\n    int[] word_chars = word.dup.map!(a => a.toLower).array;\n\
    \    int[] vowels_positions = word_chars.filter!(a => a in vowels).map!(a => word_chars.indexOf(a)).array;\n\
    \    int[] consonants_positions = word_chars.filter!(a => a in consonants).map!(a\
    \ => word_chars.indexOf(a)).array;\n    int[] consonants_positions_before_vowels\
    \ = consonants_positions.filter!(a => a < vowels_positions[0]).array;\n    int[]\
    \ consonants_positions_after_vowels = consonants_positions.filter!(a => a > vowels_positions[$\
    \ - 1]).array;\n    int[] consonants_positions_between_vowels = consonants_positions.filter!(a\
    \ => a > vowels_positions[0] && a < vowels_positions[$ - 1]).array;\n    int[]\
    \ consonants_positions_between_vowels_sorted = consonants_positions_between_vowels.sort.array;\n\
    \    int[] consonants_positions_between_vowels_sorted_reversed = consonants_positions_between_vowels_sorted.dup.reverse.array;\n\
    \    int[] consonants_positions_between_vowels_sorted_reversed_with_vowels = consonants_positions_between_vowels_sorted_reversed.dup.insert(vowels_positions[0],\
    \ 0).insert(vowels_positions[$ - 1], $).array;\n    int[] consonants_positions_between\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ccmh59m.d(27): Error: `$` is valid only inside [] of index or
    slice

    /tmp/tmp9ccmh59m.d(29): Error: semicolon expected, not `unittest`

    /tmp/tmp9ccmh59m.d(29): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ccmh59m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    auto last_vowel = word.rfind(vowels);\n\
    \    if (last_vowel == -1)\n        return \"\";\n    auto first_consonant = word.rfind(\"\
    bcdfghjklmnpqrstvwxyz\");\n    if (first_consonant == -1)\n        return \"\"\
    ;\n    if (first_consonant > last_vowel)\n        return \"\";\n    return word[last_vowel..last_vowel+1];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeblyhjfw.d(18): Error: no property `rfind` for type `string`

    /tmp/tmpeblyhjfw.d(21): Error: no property `rfind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeblyhjfw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length;\n    int distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            if(i > index)\n\
    \            {\n                break;\n            }\n            if(i < index)\n\
    \            {\n                index = i;\n                result = c;\n    \
    \        }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzxktkn6g.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpzxktkn6g.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpzxktkn6g.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpzxktkn6g.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpzxktkn6g.d(32): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzxktkn6g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int i = word.length;\n    while(i--)\n\
    \    {\n        if(vowels.find(word[i]) != -1)\n        {\n            if(i !=\
    \ 0 && vowels.find(word[i-1]) == -1)\n                return word[i..$];\n   \
    \         else if(i != word.length-1 && vowels.find(word[i+1]) == -1)\n      \
    \          return word[i..$];\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr0jrutj8.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpr0jrutj8.d(21): Error: no property `find` for type `string`

    /tmp/tmpr0jrutj8.d(23): Error: no property `find` for type `string`

    /tmp/tmpr0jrutj8.d(25): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr0jrutj8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index > 0) {\n        if (vowels.find(word[index])\
    \ != -1) {\n            if (vowels.find(word[index - 1]) == -1) {\n          \
    \      result = word[index];\n                break;\n            }\n        }\n\
    \        index--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpswkhqn3o.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpswkhqn3o.d(21): Error: no property `find` for type `string`

    /tmp/tmpswkhqn3o.d(22): Error: no property `find` for type `string`

    /tmp/tmpswkhqn3o.d(23): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpswkhqn3o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int last_vowel_index = -1;\n\
    \    int last_consonant_index = -1;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            last_vowel_index\
    \ = i;\n        }\n        else\n        {\n            last_consonant_index =\
    \ i;\n        }\n        if (last_vowel_index > last_consonant_index)\n      \
    \  {\n            return word[last_vowel_index..last_vowel_index];\n        }\n\
    \    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqcebryov.d(22): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqcebryov.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int i = word.length - 1;\n  \
    \  while (i >= 0)\n    {\n        if (vowels.canFind(word[i]))\n        {\n  \
    \          if (i == word.length - 1)\n                return \"\";\n         \
    \   if (vowels.canFind(word[i + 1]))\n                return \"\";\n         \
    \   return word[i .. i];\n        }\n        i--;\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkc4kr3a5.d(18): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpkc4kr3a5.d(21): Error: no property `canFind` for type `string`

    /tmp/tmpkc4kr3a5.d(25): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkc4kr3a5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length;\n    for (int i = word.length - 1; i >= 0; i--)\n    {\n\
    \        if (vowels.find(word[i]) != -1)\n        {\n            if (i == word.length\
    \ - 1)\n            {\n                result = \"\";\n                break;\n\
    \            }\n            else if (vowels.find(word[i + 1]) == -1)\n       \
    \     {\n                result = word[i];\n                break;\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnfqzbw63.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpnfqzbw63.d(20): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpnfqzbw63.d(22): Error: no property `find` for type `string`

    /tmp/tmpnfqzbw63.d(29): Error: no property `find` for type `string`

    /tmp/tmpnfqzbw63.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnfqzbw63.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto word_len = word.length;\n    auto last_consonant_pos = word_len;\n\
    \    auto closest_vowel_pos = word_len;\n    auto closest_vowel_distance = word_len;\n\
    \    for (int i = word_len - 1; i >= 0; i--)\n    {\n        if (consonants.canFind(word[i]))\n\
    \        {\n            last_consonant_pos = i;\n            break;\n        }\n\
    \    }\n    for (int i = last_consonant_pos - 1; i >= 0; i--)\n    {\n       \
    \ if (vowels.canFind(word[i]))\n        {\n            if (last_consonant_pos\
    \ - i < closest_vowel_distance)\n            {\n                closest_vowel_distance\
    \ = last_consonant_pos - i;\n                closest_vowel_pos = i;\n        \
    \    }\n        }\n    }\n    if (closest_vowel_pos == word_len)\n        return\
    \ \"\";\n    return word[closest_vowel_pos..closest_vowel_pos+1];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprsvyir2j.d(23): Error: cannot implicitly convert expression `word_len
    - 1LU` of type `ulong` to `int`

    /tmp/tmprsvyir2j.d(25): Error: no property `canFind` for type `string`

    /tmp/tmprsvyir2j.d(31): Error: cannot implicitly convert expression `last_consonant_pos
    - 1LU` of type `ulong` to `int`

    /tmp/tmprsvyir2j.d(33): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprsvyir2j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                result = c;\n              \
    \  min_distance = distance;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppzwnkb3x.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmppzwnkb3x.d(22): Error: no property `canFind` for type `string`

    /tmp/tmppzwnkb3x.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmppzwnkb3x.d(27): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppzwnkb3x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index > 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (vowels.find(word[index - 1]) == -1)\n   \
    \         {\n                result = word[index];\n                break;\n \
    \           }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4h0dxe5.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp_4h0dxe5.d(22): Error: no property `find` for type `string`

    /tmp/tmp_4h0dxe5.d(24): Error: no property `find` for type `string`

    /tmp/tmp_4h0dxe5.d(26): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_4h0dxe5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int minDistance = word.length;\n    foreach(v; vowels)\n   \
    \ {\n        index = word.find(v);\n        if(index != -1)\n        {\n     \
    \       if(index > 0 && index < word.length - 1)\n            {\n            \
    \    if(vowels.find(word[index - 1]) == -1 && vowels.find(word[index + 1]) ==\
    \ -1)\n                {\n                    if(index < minDistance)\n      \
    \              {\n                        minDistance = index;\n             \
    \           result = v;\n                    }\n                }\n          \
    \  }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvsrih6ml.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpvsrih6ml.d(23): Error: no property `find` for type `string`

    /tmp/tmpvsrih6ml.d(28): Error: no property `find` for type `string`

    /tmp/tmpvsrih6ml.d(28): Error: no property `find` for type `string`

    /tmp/tmpvsrih6ml.d(33): Error: cannot implicitly convert expression `v` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvsrih6ml.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ last_vowel_index = -1;\n    int last_consonant_index = -1;\n    for (int i =\
    \ 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n \
    \       {\n            last_vowel_index = i;\n        }\n        else\n      \
    \  {\n            last_consonant_index = i;\n        }\n        if (last_vowel_index\
    \ != -1 && last_consonant_index != -1)\n        {\n            if (last_vowel_index\
    \ > last_consonant_index)\n            {\n                result = word[last_vowel_index];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp93zq7uo7.d(23): Error: no property `find` for type `string`

    /tmp/tmp93zq7uo7.d(35): Error: cannot implicitly convert expression `word[cast(ulong)last_vowel_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp93zq7uo7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == word.length - 1)\n            {\n\
    \                if (vowels.find(word[index - 1]) == -1)\n                {\n\
    \                    result = word[index];\n                    break;\n     \
    \           }\n            }\n            else if (index == 0)\n            {\n\
    \                if (vowels.find(word[index + 1]) == -1)\n                {\n\
    \                    result = word[index];\n                    break;\n     \
    \           }\n            }\n            else\n            {\n              \
    \  if (vowels.find(word[index - 1]) == -1 && vowels.find(word[index + 1]) == -1)\n\
    \                {\n                    result = word[index];\n              \
    \      break;\n                }\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpux28tcst.d(19): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpux28tcst.d(22): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(26): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(28): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    /tmp/tmpux28tcst.d(34): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(36): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    /tmp/tmpux28tcst.d(42): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(42): Error: no property `find` for type `string`

    /tmp/tmpux28tcst.d(44): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpux28tcst.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int n = word.length;\n    int\
    \ i = n - 1;\n    while (i >= 0) {\n        if (vowels.find(word[i]) != -1) {\n\
    \            if (i == n - 1) {\n                return \"\";\n            }\n\
    \            if (vowels.find(word[i + 1]) == -1) {\n                return word[i\
    \ .. i];\n            }\n        }\n        i--;\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphyiekmka.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmphyiekmka.d(21): Error: no property `find` for type `string`

    /tmp/tmphyiekmka.d(25): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphyiekmka.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int last_vowel_index = -1;\n\
    \    int last_consonant_index = -1;\n    int closest_vowel_index = -1;\n    int\
    \ closest_consonant_index = -1;\n    int distance = 0;\n    int closest_distance\
    \ = 0;\n    foreach(int i, char c; word)\n    {\n        if(vowels.find(c) !=\
    \ -1)\n        {\n            last_vowel_index = i;\n            if(last_consonant_index\
    \ != -1)\n            {\n                distance = i - last_consonant_index;\n\
    \                if(distance < closest_distance || closest_distance == 0)\n  \
    \              {\n                    closest_distance = distance;\n         \
    \           closest_vowel_index = i;\n                    closest_consonant_index\
    \ = last_consonant_index;\n                }\n            }\n        }\n     \
    \   else\n        {\n            last_consonant_index = i;\n        }\n    }\n\
    \    if(closest_vowel_index == -1)\n    {\n        return \"\";\n    }\n    return\
    \ word[closest_vowel_index..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpttjwqni2.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttjwqni2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  int distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if (index > 0 && index < word.length\
    \ - 1)\n    {\n        string vowels = \"aeiou\";\n        if (vowels.find(word[index\
    \ - 1]) == -1 && vowels.find(word[index + 1]) == -1)\n        {\n            result\
    \ = word[index];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuhewd6vc.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpuhewd6vc.d(23): Error: no property `find` for type `string`

    /tmp/tmpuhewd6vc.d(25): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmpuhewd6vc.d(35): Error: variable `vowels` is shadowing variable `tmpuhewd6vc.get_closest_vowel.vowels`

    /tmp/tmpuhewd6vc.d(36): Error: no property `find` for type `string`

    /tmp/tmpuhewd6vc.d(36): Error: no property `find` for type `string`

    /tmp/tmpuhewd6vc.d(38): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuhewd6vc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    int i = word.length;\n    while(i--)\n    {\n        if(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n\
    \        {\n            if(i == 0)\n                return \"\";\n           \
    \ if(word[i-1] == 'a' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1] ==\
    \ 'o' || word[i-1] == 'u')\n                continue;\n            return word[i..$];\n\
    \        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7w013d87.d(17): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7w013d87.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string result = \"\";\n    int index = word.length - 1;\n    int vowel_index\
    \ = -1;\n    int consonant_index = -1;\n    while (index >= 0)\n    {\n      \
    \  if (vowels.find(word[index]) != -1)\n        {\n            vowel_index = index;\n\
    \            break;\n        }\n        index--;\n    }\n    if (vowel_index ==\
    \ -1)\n        return result;\n    index = vowel_index - 1;\n    while (index\
    \ >= 0)\n    {\n        if (consonants.find(word[index]) != -1)\n        {\n \
    \           consonant_index = index;\n            break;\n        }\n        index--;\n\
    \    }\n    if (consonant_index == -1)\n        return result;\n    index = vowel_index\
    \ + 1;\n    while (index < word.length)\n    {\n        if (consonants.find(word[index])\
    \ != -1)\n        {\n            if (abs(vowel_index - consonant_index) < abs(index\
    \ - vowel_index))\n                return result;\n            else\n        \
    \        return word[vowel_index..$];\n        }\n        index++;\n    }\n  \
    \  return word[vowel_index..$];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp28piq6et.d(20): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp28piq6et.d(25): Error: no property `find` for type `string`

    /tmp/tmp28piq6et.d(37): Error: no property `find` for type `string`

    /tmp/tmp28piq6et.d(49): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp28piq6et.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_consonant = \"\";\n    auto last_vowel = \"\";\n    foreach(i,\
    \ c; word) {\n        if(consonants.canFind(c)) {\n            last_consonant\
    \ = c;\n        } else if(vowels.canFind(c)) {\n            last_vowel = c;\n\
    \        }\n    }\n    return last_vowel;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8jrb2_5m.d(22): Error: no property `canFind` for type `string`

    /tmp/tmp8jrb2_5m.d(23): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp8jrb2_5m.d(24): Error: no property `canFind` for type `string`

    /tmp/tmp8jrb2_5m.d(25): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8jrb2_5m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ pos = word.length;\n    int min_dist = word.length;\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i < pos)\n            {\n                pos = i;\n         \
    \       min_dist = word.length - i;\n            }\n            else if (i ==\
    \ pos)\n            {\n                min_dist = min(min_dist, word.length -\
    \ i);\n            }\n        }\n    }\n    if (min_dist != word.length)\n   \
    \ {\n        result = word[pos..$];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph9u0_jpr.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmph9u0_jpr.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmph9u0_jpr.d(21): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmph9u0_jpr.d(23): Error: no property `find` for type `string`

    /tmp/tmph9u0_jpr.d(28): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmph9u0_jpr.d(32): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9u0_jpr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = -1;\n    int min_distance = int.max;\n    foreach(i, c; word)\n    {\n\
    \        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   index = i;\n                min_distance = distance;\n            }\n    \
    \    }\n    }\n    if(index != -1)\n    {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy6uvg_tx.d(23): Error: no property `canFind` for type `string`

    /tmp/tmpy6uvg_tx.d(25): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpy6uvg_tx.d(28): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy6uvg_tx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpobztdc_z.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(22): Error: no property `canFind` for type `string`

    /tmp/tmpobztdc_z.d(24): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpobztdc_z.d(28): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobztdc_z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string res = \"\";\n    int min_dist\
    \ = int.max;\n    int dist = 0;\n    for (int i = 0; i < word.length; i++)\n \
    \   {\n        if (vowels.indexOf(word[i]) != -1)\n        {\n            dist\
    \ = 0;\n            for (int j = i + 1; j < word.length; j++)\n            {\n\
    \                if (vowels.indexOf(word[j]) == -1)\n                {\n     \
    \               dist++;\n                }\n                else\n           \
    \     {\n                    break;\n                }\n            }\n      \
    \      if (dist < min_dist)\n            {\n                min_dist = dist;\n\
    \                res = word[i];\n            }\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd2avgb6k.d(23): Error: no property `indexOf` for type `string`

    /tmp/tmpd2avgb6k.d(28): Error: no property `indexOf` for type `string`

    /tmp/tmpd2avgb6k.d(40): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2avgb6k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164222
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_consonant = word.rfind(consonants);\n    auto first_vowel = word.find(vowels);\n\
    \    if (last_consonant == -1 || first_vowel == -1)\n        return \"\";\n  \
    \  auto last_vowel = word.rfind(vowels);\n    if (last_vowel == -1)\n        return\
    \ \"\";\n    if (last_vowel < last_consonant)\n        return \"\";\n    auto\
    \ distance = last_vowel - last_consonant;\n    auto closest_vowel = word[last_vowel];\n\
    \    for (auto i = last_vowel - 1; i > last_consonant; --i)\n    {\n        if\
    \ (vowels.find(word[i]) != -1)\n        {\n            if (last_vowel - i < distance)\n\
    \            {\n                distance = last_vowel - i;\n                closest_vowel\
    \ = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzjke4v6b.d(19): Error: no property `rfind` for type `string`

    /tmp/tmpzjke4v6b.d(20): Error: no property `find` for type `string`

    /tmp/tmpzjke4v6b.d(23): Error: no property `rfind` for type `string`

    /tmp/tmpzjke4v6b.d(32): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzjke4v6b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = -1;\n    int min = word.length;\n    for (int i = word.length - 1; i\
    \ >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n    \
    \        if (i > 0 && vowels.find(word[i - 1]) == -1)\n            {\n       \
    \         if (i < min)\n                {\n                    min = i;\n    \
    \                index = i;\n                }\n            }\n        }\n   \
    \ }\n    if (index != -1)\n    {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcvddb34o.d(20): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpcvddb34o.d(21): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpcvddb34o.d(23): Error: no property `find` for type `string`

    /tmp/tmpcvddb34o.d(25): Error: no property `find` for type `string`

    /tmp/tmpcvddb34o.d(37): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvddb34o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_consonant = word.length;\n    auto first_vowel = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(consonants.canFind(c))\n        {\n\
    \            last_consonant = i;\n        }\n        else if(vowels.canFind(c))\n\
    \        {\n            first_vowel = i;\n            break;\n        }\n    }\n\
    \    if(last_consonant < first_vowel)\n    {\n        return \"\";\n    }\n  \
    \  auto closest_vowel = word.length;\n    foreach(i, c; word[last_consonant..])\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            closest_vowel =\
    \ i + last_consonant;\n            break;\n        }\n    }\n    if(closest_vowel\
    \ < first_vowel)\n    {\n        return \"\";\n    }\n    return word[closest_vowel..closest_vowel+1];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_5mqlcbs.d(38): Error: expression expected, not `]`

    /tmp/tmp_5mqlcbs.d(38): Error: found `)` when expecting `,`

    /tmp/tmp_5mqlcbs.d(46): Error: found `if` when expecting `,`

    /tmp/tmp_5mqlcbs.d(46): Error: found `<` when expecting `)`

    /tmp/tmp_5mqlcbs.d(46): Error: missing `{ ... }` for function literal

    /tmp/tmp_5mqlcbs.d(46): Error: found `first_vowel` when expecting `,`

    /tmp/tmp_5mqlcbs.d(46): Error: expression expected, not `)`

    /tmp/tmp_5mqlcbs.d(47): Error: found `{` when expecting `,`

    /tmp/tmp_5mqlcbs.d(48): Error: expression expected, not `return`

    /tmp/tmp_5mqlcbs.d(48): Error: found `""` when expecting `,`

    /tmp/tmp_5mqlcbs.d(48): Error: expression expected, not `;`

    /tmp/tmp_5mqlcbs.d(49): Error: found `}` when expecting `,`

    /tmp/tmp_5mqlcbs.d(50): Error: expression expected, not `return`

    /tmp/tmp_5mqlcbs.d(50): Error: found `word` when expecting `,`

    /tmp/tmp_5mqlcbs.d(50): Error: found `..` when expecting `,`

    /tmp/tmp_5mqlcbs.d(50): Error: found `;` when expecting `,`

    /tmp/tmp_5mqlcbs.d(51): Erro'
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string ret = \"\";\n    int last_vowel\
    \ = -1;\n    int last_consonant = -1;\n    for (int i = 0; i < word.length; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            last_vowel\
    \ = i;\n        }\n        else\n        {\n            last_consonant = i;\n\
    \        }\n        if (last_vowel != -1 && last_consonant != -1)\n        {\n\
    \            if (last_vowel > last_consonant)\n            {\n               \
    \ ret = word[last_vowel];\n            }\n        }\n    }\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd4xf3mpb.d(23): Error: no property `find` for type `string`

    /tmp/tmpd4xf3mpb.d(35): Error: cannot implicitly convert expression `word[cast(ulong)last_vowel]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd4xf3mpb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = \"\";\n    auto last_consonant = \"\";\n    for (int\
    \ i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.indexOf(word[i])\
    \ != -1)\n        {\n            last_vowel = word[i];\n            if (last_consonant\
    \ != \"\")\n                return last_vowel;\n        }\n        else if (consonants.indexOf(word[i])\
    \ != -1)\n        {\n            last_consonant = word[i];\n        }\n    }\n\
    \    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcnm9zfb3.d(21): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpcnm9zfb3.d(23): Error: no property `indexOf` for type `string`

    /tmp/tmpcnm9zfb3.d(25): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmpcnm9zfb3.d(29): Error: no property `indexOf` for type `string`

    /tmp/tmpcnm9zfb3.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcnm9zfb3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    auto vowels = \"aeiou\";\n    auto consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    auto last_vowel = \"\";\n    auto last_consonant = \"\";\n    auto result\
    \ = \"\";\n    foreach(c; word)\n    {\n        if(vowels.canFind(c))\n      \
    \  {\n            last_vowel = c;\n        }\n        else if(consonants.canFind(c))\n\
    \        {\n            last_consonant = c;\n        }\n        if(last_vowel\
    \ != \"\" && last_consonant != \"\")\n        {\n            result = last_vowel;\n\
    \            last_vowel = \"\";\n            last_consonant = \"\";\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxbv2jyyl.d(24): Error: no property `canFind` for type `string`

    /tmp/tmpxbv2jyyl.d(26): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmpxbv2jyyl.d(28): Error: no property `canFind` for type `string`

    /tmp/tmpxbv2jyyl.d(30): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxbv2jyyl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164221
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    string result = \"\";\n    int\
    \ index = 0;\n    int min_distance = 0;\n    int distance = 0;\n    int last_vowel_index\
    \ = -1;\n    int last_consonant_index = -1;\n    foreach(i, c; word)\n    {\n\
    \        if(vowels.canFind(c))\n        {\n            last_vowel_index = i;\n\
    \            if(last_consonant_index != -1)\n            {\n                distance\
    \ = i - last_consonant_index;\n                if(distance < min_distance || min_distance\
    \ == 0)\n                {\n                    min_distance = distance;\n   \
    \                 index = i;\n                }\n            }\n        }\n  \
    \      else\n        {\n            last_consonant_index = i;\n        }\n   \
    \ }\n    if(index != 0)\n    {\n        result = word[index..$];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphvq6bnh6.d(26): Error: no property `canFind` for type `string`

    /tmp/tmphvq6bnh6.d(28): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmphvq6bnh6.d(31): Error: cannot implicitly convert expression `i - cast(ulong)last_consonant_index`
    of type `ulong` to `int`

    /tmp/tmphvq6bnh6.d(35): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmphvq6bnh6.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvq6bnh6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowels = \"aeiou\";\n    int pos = word.length;\n    while(pos--)\n\
    \    {\n        if(vowels.find(word[pos]) != -1)\n        {\n            if(pos\
    \ != 0 && vowels.find(word[pos-1]) == -1)\n                return word[pos..$];\n\
    \            else if(pos != word.length-1 && vowels.find(word[pos+1]) == -1)\n\
    \                return word[pos..$];\n        }\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm5853sks.d(18): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpm5853sks.d(21): Error: no property `find` for type `string`

    /tmp/tmpm5853sks.d(23): Error: no property `find` for type `string`

    /tmp/tmpm5853sks.d(25): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm5853sks.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n                    \n*/\nstring get_closest_vowel(string\
    \ word) \n{\n    static string vowels = \"aeiou\";\n    static string consonants\
    \ = \"bcdfghjklmnpqrstvwxyz\";\n    int len = word.length;\n    if (len < 3) return\
    \ \"\";\n    int i = len - 1;\n    while (i > 0)\n    {\n        if (consonants.find(word[i])\
    \ != -1)\n        {\n            if (vowels.find(word[i - 1]) != -1)\n       \
    \     {\n                return word[i - 1..i];\n            }\n            else\
    \ if (consonants.find(word[i - 1]) != -1)\n            {\n                i -=\
    \ 2;\n            }\n            else\n            {\n                return \"\
    \";\n            }\n        }\n        else\n        {\n            i--;\n   \
    \     }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb5fnf5hx.d(19): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpb5fnf5hx.d(24): Error: no property `find` for type `string`

    /tmp/tmpb5fnf5hx.d(26): Error: no property `find` for type `string`

    /tmp/tmpb5fnf5hx.d(30): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5fnf5hx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164223
