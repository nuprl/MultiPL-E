language: d
name: HumanEval_110_exchange
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int oddCount = 0;\n    foreach(e; lst1)\n    {\n\
    \        if(e % 2 != 0)\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(e; lst2)\n    {\n        if(e % 2 != 0)\n        {\n            oddCount--;\n\
    \        }\n    }\n    if(oddCount == 0)\n    {\n        return \"YES\";\n   \
    \ }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprwy62l2k.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmprwy62l2k.__unittest_L41_C1() [0x428195]

    ??:? void tmprwy62l2k.__modtest() [0x428480]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b59e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430641]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b575]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee\
    \ = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n \
    \   int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn\
    \ = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n \
    \   int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww\
    \ = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n\
    \    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int\
    \ fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int\
    \ sss = 0;\n    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\
    \ = 0;\n    int\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpde5bmely.d(85): Error: no identifier for declarator `int`

    /tmp/tmpde5bmely.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde5bmely.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto evens = lst1.filter!(x => x % 2 == 0);\n  \
    \  auto odds = lst2.filter!(x => x % 2 != 0);\n    if (evens.length >= lst1.length)\n\
    \        return \"YES\";\n    if (odds.length >= lst2.length)\n        return\
    \ \"YES\";\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi0lf6w_x.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpi0lf6w_x.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi0lf6w_x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(a => a % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(a => a % 2 == 0);\n    if (lst1_odd.length\
    \ > lst2_even.length)\n        return \"NO\";\n    else\n        return \"YES\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjtp0t387.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpjtp0t387.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjtp0t387.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int lst1_odd = 0;\n    int lst2_even = 0;\n    foreach(l;\
    \ lst1)\n    {\n        if(l % 2 != 0)\n            lst1_odd++;\n    }\n    foreach(l;\
    \ lst2)\n    {\n        if(l % 2 == 0)\n            lst2_even++;\n    }\n    if(lst1_odd\
    \ == lst2_even)\n        return \"YES\";\n    else\n        return \"NO\";\n}\n\
    unittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_5rx3q9u.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmp_5rx3q9u.__unittest_L34_C1() [0x4283cb]

    ??:? void tmp_5rx3q9u.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(long x; lst1)\n    {\n\
    \        if(x % 2 != 0)\n        {\n            count++;\n        }\n    }\n \
    \   foreach(long x; lst2)\n    {\n        if(x % 2 == 0)\n        {\n        \
    \    count--;\n        }\n    }\n    if(count <= 0)\n    {\n        return \"\
    YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n\
    \    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(num;\
    \ lst1)\n    {\n        if(num % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(num; lst2)\n    {\n        if(num % 2 == 0)\n        {\n        \
    \    evenCount++;\n        }\n        else\n        {\n            oddCount++;\n\
    \        }\n    }\n    if(evenCount % 2 == 0)\n    {\n        return \"YES\";\n\
    \    }\n    else\n    {\n        return \"NO\";\n    }\n}\n/*\n    You are given\
    \ a list of numbers.\n    You have to find the number of pairs of numbers in the\
    \ list that have a difference of k.\n    For example, if the list is [1, 7, 5,\
    \ 9, 2, 12, 3] and k = 2,\n    there are four pairs with difference 2: (1, 3),\
    \ (3, 5), (5, 7), (7, 9).\n    It is assumed that the input list will be non-empty.\n\
    */\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeezn4p21.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpeezn4p21.__unittest_L57_C1() [0x4281a9]

    ??:? void tmpeezn4p21.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count1 = 0;\n    int count2 = 0;\n    foreach(var\
    \ i; lst1)\n    {\n        if(i % 2 == 0)\n        {\n            count1++;\n\
    \        }\n    }\n    foreach(var i; lst2)\n    {\n        if(i % 2 == 0)\n \
    \       {\n            count2++;\n        }\n    }\n    if(count1 == lst1.length\
    \ || count2 == lst2.length)\n    {\n        return \"YES\";\n    }\n    else\n\
    \    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpovvrl2wv.d(19): Error: undefined identifier `var`

    /tmp/tmpovvrl2wv.d(26): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpovvrl2wv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int oddCount = 0;\n    foreach(i; lst1)\n    {\n\
    \        if(i % 2 != 0)\n        {\n            oddCount++;\n        }\n    }\n\
    \    int evenCount = 0;\n    foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n\
    \        {\n            evenCount++;\n        }\n    }\n    if(oddCount == evenCount)\n\
    \    {\n        return \"YES\";\n    }\n    else\n    {\n        return \"NO\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3j_9t61k.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmp3j_9t61k.__unittest_L42_C1() [0x4283cf]

    ??:? void tmp3j_9t61k.__modtest() [0x428488]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    int count1 = 0;\n    int count2 = 0;\n    int count3 = 0;\n    int count4\
    \ = 0;\n    int count5 = 0;\n    int count6 = 0;\n    int count7 = 0;\n    int\
    \ count8 = 0;\n    int count9 = 0;\n    int count10 = 0;\n    int count11 = 0;\n\
    \    int count12 = 0;\n    int count13 = 0;\n    int count14 = 0;\n    int count15\
    \ = 0;\n    int count16 = 0;\n    int count17 = 0;\n    int count18 = 0;\n   \
    \ int count19 = 0;\n    int count20 = 0;\n    int count21 = 0;\n    int count22\
    \ = 0;\n    int count23 = 0;\n    int count24 = 0;\n    int count25 = 0;\n   \
    \ int count26 = 0;\n    int count27 = 0;\n    int count28 = 0;\n    int count29\
    \ = 0;\n    int count30 = 0;\n    int count31 = 0;\n    int count32 = 0;\n   \
    \ int count33 = 0;\n    int count34 = 0;\n    int count35 = 0;\n    int count36\
    \ = 0;\n    int count37 = 0;\n    int count38 = 0;\n    int count39 = 0;\n   \
    \ int count40 = 0;\n    int count41 = 0;\n    int count42 = 0;\n    int count43\
    \ = 0;\n    int count44 = 0;\n    int count45 = 0;\n    int count46 = 0;\n   \
    \ int count47 = 0;\n    int count48 = 0;\n    int count49 = 0;\n    int count50\
    \ = 0;\n    int count51 = 0;\n    int count52 = 0;\n    int count53 = 0;\n   \
    \ int count54 = 0;\n    int count55 = 0;\n    int count56 = 0;\n    int count57\
    \ = 0;\n    int count58 = 0;\n    int count59 = 0;\n    int count60 = 0;\n   \
    \ int count61 = 0;\n\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgj5q1bo.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwgj5q1bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even1 = 0;\n    int even2 = 0;\n    int odd1\
    \ = 0;\n    int odd2 = 0;\n    foreach(i; lst1)\n    {\n        if(i % 2 == 0)\n\
    \            even1++;\n        else\n            odd1++;\n    }\n    foreach(i;\
    \ lst2)\n    {\n        if(i % 2 == 0)\n            even2++;\n        else\n \
    \           odd2++;\n    }\n    if(even1 + even2 == lst1.length + lst2.length)\n\
    \        return \"YES\";\n    if(odd1 + odd2 == lst1.length + lst2.length)\n \
    \       return \"NO\";\n    if(even1 + odd2 >= lst1.length)\n        return \"\
    YES\";\n    if(odd1 + even2 >= lst1.length)\n        return \"YES\";\n    return\
    \ \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8gfqeajq.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428785]

    ??:? void tmp8gfqeajq.__unittest_L45_C1() [0x4280b1]

    ??:? void tmp8gfqeajq.__modtest() [0x428508]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c717]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b626]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43073d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430bec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306c9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5fd]

    ??:? runModuleUnitTests [0x42c4ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(x => x % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(x => x % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h1c5dic.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp6h1c5dic.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h1c5dic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    int count1 = 0;\n    int count2 = 0;\n    int count3 = 0;\n    int count4\
    \ = 0;\n    int count5 = 0;\n    int count6 = 0;\n    int count7 = 0;\n    int\
    \ count8 = 0;\n    int count9 = 0;\n    int count10 = 0;\n    int count11 = 0;\n\
    \    int count12 = 0;\n    int count13 = 0;\n    int count14 = 0;\n    int count15\
    \ = 0;\n    int count16 = 0;\n    int count17 = 0;\n    int count18 = 0;\n   \
    \ int count19 = 0;\n    int count20 = 0;\n    int count21 = 0;\n    int count22\
    \ = 0;\n    int count23 = 0;\n    int count24 = 0;\n    int count25 = 0;\n   \
    \ int count26 = 0;\n    int count27 = 0;\n    int count28 = 0;\n    int count29\
    \ = 0;\n    int count30 = 0;\n    int count31 = 0;\n    int count32 = 0;\n   \
    \ int count33 = 0;\n    int count34 = 0;\n    int count35 = 0;\n    int count36\
    \ = 0;\n    int count37 = 0;\n    int count38 = 0;\n    int count39 = 0;\n   \
    \ int count40 = 0;\n    int count41 = 0;\n    int count42 = 0;\n    int count43\
    \ = 0;\n    int count44 = 0;\n    int count45 = 0;\n    int count46 = 0;\n   \
    \ int count47 = 0;\n    int count48 = 0;\n    int count49 = 0;\n    int count50\
    \ = 0;\n    int count51 = 0;\n    int count52 = 0;\n    int count53 = 0;\n   \
    \ int count54 = 0;\n    int count55 = 0;\n    int count56 = 0;\n    int count57\
    \ = 0;\n    int count58 = 0;\n    int count59 = 0;\n    int count60 = 0;\n   \
    \ int count61 = 0;\n\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgj5q1bo.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwgj5q1bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 1)\n            odd1++;\n    }\n    foreach(e;\
    \ lst2)\n    {\n        if(e % 2 == 1)\n            odd2++;\n    }\n    if(odd1\
    \ == odd2)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4c_dqctv.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmp4c_dqctv.__unittest_L34_C1() [0x428199]

    ??:? void tmp4c_dqctv.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int n = lst1.length;\n    int m = lst2.length;\n\
    \    int i = 0;\n    int j = 0;\n    while(i < n && j < m)\n    {\n        if(lst1[i]\
    \ % 2 == 0)\n        {\n            i++;\n        }\n        else if(lst2[j] %\
    \ 2 == 0)\n        {\n            long temp = lst1[i];\n            lst1[i] =\
    \ lst2[j];\n            lst2[j] = temp;\n            i++;\n            j++;\n\
    \        }\n        else\n        {\n            j++;\n        }\n    }\n    for(i\
    \ = 0; i < n; i++)\n    {\n        if(lst1[i] % 2 != 0)\n        {\n         \
    \   return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nunittest\n{\n  \
    \  alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3u5v7msq.d(17): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmp3u5v7msq.d(18): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3u5v7msq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int n = lst1.length;\n    int m = lst2.length;\n\
    \    int[] a = new int[n];\n    int[] b = new int[m];\n    for (int i = 0; i <\
    \ n; i++)\n    {\n        if (lst1[i] % 2 == 0)\n            a[i] = 1;\n     \
    \   else\n            a[i] = 0;\n    }\n    for (int i = 0; i < m; i++)\n    {\n\
    \        if (lst2[i] % 2 == 0)\n            b[i] = 1;\n        else\n        \
    \    b[i] = 0;\n    }\n    int sum1 = 0;\n    int sum2 = 0;\n    for (int i =\
    \ 0; i < n; i++)\n        sum1 += a[i];\n    for (int i = 0; i < m; i++)\n   \
    \     sum2 += b[i];\n    if (sum1 + sum2 >= n)\n        return \"YES\";\n    else\n\
    \        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n \
    \   assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjcnflxza.d(17): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmpjcnflxza.d(18): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjcnflxza.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even = 0;\n    int odd = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            even++;\n        else\n  \
    \          odd++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \            even++;\n        else\n            odd++;\n    }\n    if(even % 2\
    \ == 0 && odd % 2 == 0)\n        return \"YES\";\n    else\n        return \"\
    NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdwuc01il.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428725]

    ??:? void tmpdwuc01il.__unittest_L38_C1() [0x4281bd]

    ??:? void tmpdwuc01il.__modtest() [0x4284a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306dd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b8c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430669]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b59d]

    ??:? runModuleUnitTests [0x42c48d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b74]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    // Write your code here\n    int count = 0;\n  \
    \  foreach(e; lst1)\n    {\n        if(e % 2 != 0)\n        {\n            count++;\n\
    \        }\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n     \
    \   {\n            count--;\n        }\n    }\n    if(count == 0)\n    {\n   \
    \     return \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n\
    }\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcodqqos5.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmpcodqqos5.__unittest_L42_C1() [0x4283c7]

    ??:? void tmpcodqqos5.__modtest() [0x428480]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b59e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430641]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b575]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae\
    \ = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n \
    \   int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an\
    \ = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n \
    \   int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw\
    \ = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n \
    \   int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf\
    \ = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n \
    \   int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo\
    \ = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n \
    \   int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx\
    \ = 0;\n    int by = 0;\n    int bz\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpklnrut6y.d(87): Error: semicolon expected, not `unittest`

    /tmp/tmpklnrut6y.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpklnrut6y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even = 0;\n    int odd = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            even++;\n        else\n  \
    \          odd++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \            even++;\n        else\n            odd++;\n    }\n    if(even % 2\
    \ == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3a8sbyck.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmp3a8sbyck.__unittest_L38_C1() [0x4281a9]

    ??:? void tmp3a8sbyck.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    if(evenCount % 2 == 0)\n    {\n        return \"YES\";\n    }\n    else\n\
    \    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqwo4tinu.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpqwo4tinu.__unittest_L50_C1() [0x4281a9]

    ??:? void tmpqwo4tinu.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae\
    \ = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n \
    \   int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an\
    \ = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n \
    \   int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw\
    \ = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n \
    \   int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf\
    \ = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n \
    \   int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo\
    \ = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n \
    \   int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx\
    \ = 0;\n    int by = 0;\n    int bz\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpklnrut6y.d(87): Error: semicolon expected, not `unittest`

    /tmp/tmpklnrut6y.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpklnrut6y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee\
    \ = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n \
    \   int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn\
    \ = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n \
    \   int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww\
    \ = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n\
    \    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int\
    \ fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int\
    \ sss = 0;\n    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\
    \ = 0;\n    int\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpde5bmely.d(85): Error: no identifier for declarator `int`

    /tmp/tmpde5bmely.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde5bmely.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count > 0)\n    {\n        return \"NO\";\n    }\n \
    \   else\n    {\n        return \"YES\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto evens = lst1.filter!(a => a % 2 == 0);\n  \
    \  auto odds = lst2.filter!(a => a % 2 != 0);\n    return evens.length + odds.length\
    \ >= lst1.length ? \"YES\" : \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprkxotjaa.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmprkxotjaa.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprkxotjaa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    bool[] lst1_even = lst1.map!(a => a % 2 == 0);\n\
    \    bool[] lst2_even = lst2.map!(a => a % 2 == 0);\n    if (lst1_even.reduce!((a,\
    \ b) => a && b) || lst2_even.reduce!((a, b) => a && b))\n        return \"YES\"\
    ;\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprxhe8_ci.d(17): Error: no property `map` for type `long[]`

    /tmp/tmprxhe8_ci.d(18): Error: no property `map` for type `long[]`

    /tmp/tmprxhe8_ci.d(19): Error: no property `reduce` for type `bool[]`

    /tmp/tmprxhe8_ci.d(19): Error: no property `reduce` for type `bool[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprxhe8_ci.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    int count1 = 0;\n    int count2 = 0;\n    int count3 = 0;\n    int count4\
    \ = 0;\n    int count5 = 0;\n    int count6 = 0;\n    int count7 = 0;\n    int\
    \ count8 = 0;\n    int count9 = 0;\n    int count10 = 0;\n    int count11 = 0;\n\
    \    int count12 = 0;\n    int count13 = 0;\n    int count14 = 0;\n    int count15\
    \ = 0;\n    int count16 = 0;\n    int count17 = 0;\n    int count18 = 0;\n   \
    \ int count19 = 0;\n    int count20 = 0;\n    int count21 = 0;\n    int count22\
    \ = 0;\n    int count23 = 0;\n    int count24 = 0;\n    int count25 = 0;\n   \
    \ int count26 = 0;\n    int count27 = 0;\n    int count28 = 0;\n    int count29\
    \ = 0;\n    int count30 = 0;\n    int count31 = 0;\n    int count32 = 0;\n   \
    \ int count33 = 0;\n    int count34 = 0;\n    int count35 = 0;\n    int count36\
    \ = 0;\n    int count37 = 0;\n    int count38 = 0;\n    int count39 = 0;\n   \
    \ int count40 = 0;\n    int count41 = 0;\n    int count42 = 0;\n    int count43\
    \ = 0;\n    int count44 = 0;\n    int count45 = 0;\n    int count46 = 0;\n   \
    \ int count47 = 0;\n    int count48 = 0;\n    int count49 = 0;\n    int count50\
    \ = 0;\n    int count51 = 0;\n    int count52 = 0;\n    int count53 = 0;\n   \
    \ int count54 = 0;\n    int count55 = 0;\n    int count56 = 0;\n    int count57\
    \ = 0;\n    int count58 = 0;\n    int count59 = 0;\n    int count60 = 0;\n   \
    \ int count61 = 0;\n\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgj5q1bo.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwgj5q1bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i%2 != 0)\n        {\n            odd1++;\n       \
    \ }\n    }\n    foreach(i; lst2)\n    {\n        if(i%2 != 0)\n        {\n   \
    \         odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpws7lhh21.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpws7lhh21.__unittest_L42_C1() [0x428199]

    ??:? void tmpws7lhh21.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    bool isEven(long[] lst)\n    {\n        foreach(e;\
    \ lst)\n            if(e % 2 != 0)\n                return false;\n        return\
    \ true;\n    }\n    if(isEven(lst1))\n        return \"YES\";\n    else\n    {\n\
    \        foreach(e; lst1)\n        {\n            if(e % 2 != 0)\n           \
    \ {\n                foreach(e2; lst2)\n                {\n                  \
    \  if(e2 % 2 != 0)\n                    {\n                        long[] lst1_\
    \ = lst1.dup;\n                        long[] lst2_ = lst2.dup;\n            \
    \            lst1_[e] = e2;\n                        lst2_[e2] = e;\n        \
    \                if(isEven(lst1_))\n                            return \"YES\"\
    ;\n                    }\n                }\n            }\n        }\n    }\n\
    \    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcsyxt8gi.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x42997d]

    ??:? void tmpcsyxt8gi.__unittest_L49_C1() [0x4282c6]

    ??:? void tmpcsyxt8gi.__modtest() [0x42896c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e55f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x429682]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b2e9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b378]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b275]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429659]

    ??:? runModuleUnitTests [0x42e335]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429e94]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(x; lst1)\n    {\n  \
    \      if(x % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(x; lst2)\n    {\n        if(x % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even_count = 0;\n    int odd_count = 0;\n  \
    \  foreach(l; lst1)\n    {\n        if(l % 2 == 0)\n            even_count++;\n\
    \        else\n            odd_count++;\n    }\n    foreach(l; lst2)\n    {\n\
    \        if(l % 2 == 0)\n            even_count++;\n        else\n           \
    \ odd_count++;\n    }\n    if(even_count == lst1.length + lst2.length)\n     \
    \   return \"YES\";\n    else if(odd_count == lst1.length + lst2.length)\n   \
    \     return \"NO\";\n    else\n        return \"YES\";\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzigh1zc8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428735]

    ??:? void tmpzigh1zc8.__unittest_L40_C1() [0x428061]

    ??:? void tmpzigh1zc8.__modtest() [0x4284b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b9c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430679]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5ad]

    ??:? runModuleUnitTests [0x42c49d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b84]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto evens = lst1.filter!(x => x % 2 == 0);\n  \
    \  auto odds = lst2.filter!(x => x % 2 != 0);\n    if (evens.length > odds.length)\n\
    \        return \"NO\";\n    return \"YES\";\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaennyvvl.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpaennyvvl.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaennyvvl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 != 0)\n            odd1++;\n    }\n    foreach(e;\
    \ lst2)\n    {\n        if(e % 2 != 0)\n            odd2++;\n    }\n    if(odd1\
    \ == odd2)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpinn50ph8.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpinn50ph8.__unittest_L34_C1() [0x428199]

    ??:? void tmpinn50ph8.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int n1 = lst1.length;\n    int n2 = lst2.length;\n\
    \    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < n1 && j < n2)\n\
    \    {\n        if(lst1[i] % 2 == 0)\n        {\n            i++;\n        }\n\
    \        else if(lst2[j] % 2 == 0)\n        {\n            lst1[i] = lst2[j];\n\
    \            i++;\n            j++;\n            count++;\n        }\n       \
    \ else\n        {\n            j++;\n        }\n    }\n    if(count == 0)\n  \
    \  {\n        return \"NO\";\n    }\n    else\n    {\n        return \"YES\";\n\
    \    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpptn8p3vc.d(17): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmpptn8p3vc.d(18): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpptn8p3vc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    bool flag = false;\n\
    \    while(i < lst1.length && j < lst2.length)\n    {\n        if(lst1[i] % 2\
    \ == 0)\n        {\n            i++;\n        }\n        else if(lst2[j] % 2 ==\
    \ 0)\n        {\n            lst1[i] = lst2[j];\n            i++;\n          \
    \  j++;\n            flag = true;\n        }\n        else\n        {\n      \
    \      j++;\n        }\n    }\n    if(flag)\n    {\n        return \"YES\";\n\
    \    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph3ctglq6.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428755]

    ??:? void tmph3ctglq6.__unittest_L47_C1() [0x428081]

    ??:? void tmph3ctglq6.__modtest() [0x4284d8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c75b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b66a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430781]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43070d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b641]

    ??:? runModuleUnitTests [0x42c531]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c18]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(e; lst1)\n    {\n  \
    \      if(e % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even_count = 0;\n    int odd_count = 0;\n  \
    \  foreach(i; lst1)\n    {\n        if(i % 2 == 0)\n            even_count++;\n\
    \        else\n            odd_count++;\n    }\n    foreach(i; lst2)\n    {\n\
    \        if(i % 2 == 0)\n            even_count++;\n        else\n           \
    \ odd_count++;\n    }\n    if(even_count > odd_count)\n        return \"YES\"\
    ;\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo2brfu8h.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpo2brfu8h.__unittest_L38_C1() [0x427f5a]

    ??:? void tmpo2brfu8h.__modtest() [0x42848c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even = 0;\n    int odd = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            even++;\n        else\n  \
    \          odd++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \            even++;\n        else\n            odd++;\n    }\n    if(even % 2\
    \ == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3a8sbyck.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmp3a8sbyck.__unittest_L38_C1() [0x4281a9]

    ??:? void tmp3a8sbyck.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    string result = \"NO\";\n    int even_count = 0;\n\
    \    int odd_count = 0;\n    foreach(num; lst1)\n    {\n        if(num % 2 ==\
    \ 0)\n        {\n            even_count++;\n        }\n        else\n        {\n\
    \            odd_count++;\n        }\n    }\n    if(even_count > 0)\n    {\n \
    \       result = \"YES\";\n    }\n    else\n    {\n        foreach(num; lst2)\n\
    \        {\n            if(num % 2 == 0)\n            {\n                result\
    \ = \"YES\";\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpedia3x2z.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x42872d]

    ??:? void tmpedia3x2z.__unittest_L48_C1() [0x428059]

    ??:? void tmpedia3x2z.__modtest() [0x4284b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306e5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b94]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430671]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5a5]

    ??:? runModuleUnitTests [0x42c495]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b7c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evens = 0;\n    int odds = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            evens++;\n        else\n \
    \           odds++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \            evens++;\n        else\n            odds++;\n    }\n    if(evens\
    \ % 2 == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpab2_s8ry.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpab2_s8ry.__unittest_L38_C1() [0x4281a9]

    ??:? void tmpab2_s8ry.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evens = 0;\n    int odds = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            evens++;\n        else\n \
    \           odds++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \            evens++;\n        else\n            odds++;\n    }\n    if(evens\
    \ % 2 == 0 && odds % 2 == 0)\n        return \"YES\";\n    else\n        return\
    \ \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp50__0o0o.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428725]

    ??:? void tmp50__0o0o.__unittest_L38_C1() [0x4281bd]

    ??:? void tmp50__0o0o.__modtest() [0x4284a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306dd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b8c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430669]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b59d]

    ??:? runModuleUnitTests [0x42c48d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b74]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even = 0;\n    int odd = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            even++;\n        else\n  \
    \          odd++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \            even++;\n        else\n            odd++;\n    }\n    if(even % 2\
    \ == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3a8sbyck.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmp3a8sbyck.__unittest_L38_C1() [0x4281a9]

    ??:? void tmp3a8sbyck.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    int count2 = 0;\n    int count3 = 0;\n    int count4 = 0;\n    int count5\
    \ = 0;\n    int count6 = 0;\n    int count7 = 0;\n    int count8 = 0;\n    int\
    \ count9 = 0;\n    int count10 = 0;\n    int count11 = 0;\n    int count12 = 0;\n\
    \    int count13 = 0;\n    int count14 = 0;\n    int count15 = 0;\n    int count16\
    \ = 0;\n    int count17 = 0;\n    int count18 = 0;\n    int count19 = 0;\n   \
    \ int count20 = 0;\n    int count21 = 0;\n    int count22 = 0;\n    int count23\
    \ = 0;\n    int count24 = 0;\n    int count25 = 0;\n    int count26 = 0;\n   \
    \ int count27 = 0;\n    int count28 = 0;\n    int count29 = 0;\n    int count30\
    \ = 0;\n    int count31 = 0;\n    int count32 = 0;\n    int count33 = 0;\n   \
    \ int count34 = 0;\n    int count35 = 0;\n    int count36 = 0;\n    int count37\
    \ = 0;\n    int count38 = 0;\n    int count39 = 0;\n    int count40 = 0;\n   \
    \ int count41 = 0;\n    int count42 = 0;\n    int count43 = 0;\n    int count44\
    \ = 0;\n    int count45 = 0;\n    int count46 = 0;\n    int count47 = 0;\n   \
    \ int count48 = 0;\n    int count49 = 0;\n    int count50 = 0;\n    int count51\
    \ = 0;\n    int count52 = 0;\n    int count53 = 0;\n    int count54 = 0;\n   \
    \ int count55 = 0;\n    int count56 = 0;\n    int count57 = 0;\n    int count58\
    \ = 0;\n    int count59 = 0;\n    int count60 = 0;\n    int count61 = 0;\n   \
    \ int count62 = 0;\n\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptxesfx1u.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxesfx1u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(j; lst2)\n    {\n        if(j % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even1 = 0;\n    int even2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 0)\n            even1++;\n    }\n    foreach(i;\
    \ lst2)\n    {\n        if(i % 2 == 0)\n            even2++;\n    }\n    if(even1\
    \ == lst1.length || even2 == lst2.length)\n        return \"YES\";\n    else\n\
    \        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n \
    \   assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3f013sfl.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmp3f013sfl.__unittest_L34_C1() [0x427f5e]

    ??:? void tmp3f013sfl.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(x => x % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(x => x % 2 == 0);\n    if (lst1_odd.length\
    \ <= lst2_even.length)\n        return \"YES\";\n    else\n        return \"NO\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplp9bbc2z.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmplp9bbc2z.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplp9bbc2z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee\
    \ = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n \
    \   int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn\
    \ = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n \
    \   int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww\
    \ = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n\
    \    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int\
    \ fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int\
    \ sss = 0;\n    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\
    \ = 0;\n    int\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpde5bmely.d(85): Error: no identifier for declarator `int`

    /tmp/tmpde5bmely.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde5bmely.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae\
    \ = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n \
    \   int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an\
    \ = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n \
    \   int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw\
    \ = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n \
    \   int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf\
    \ = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n \
    \   int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo\
    \ = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n \
    \   int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx\
    \ = 0;\n    int by = 0;\n    int bz\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpklnrut6y.d(87): Error: semicolon expected, not `unittest`

    /tmp/tmpklnrut6y.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpklnrut6y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(num;\
    \ lst1)\n    {\n        if(num % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(num; lst2)\n    {\n        if(num % 2 == 0)\n        {\n        \
    \    evenCount++;\n        }\n        else\n        {\n            oddCount++;\n\
    \        }\n    }\n    if(evenCount % 2 == 0)\n    {\n        return \"YES\";\n\
    \    }\n    else\n    {\n        return \"NO\";\n    }\n}\n/*\n    In this problem,\
    \ you will implement a function that takes a list of numbers,\n    and returns\
    \ a list of numbers where each number is the sum of the corresponding\n    number\
    \ in the input list and the number that follows it in the input list.\n    If\
    \ the input list has an odd number of elements, the last element is not\n    included\
    \ in the sum.\n    For example:\n            It is assumed that the input list\
    \ will be non-empty.\n*/\nlong[] sum_pairs(long[] lst) \n{\n    long[] result\
    \ = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n  \
    \      if(i == lst.length - 1)\n        {\n            result[i] = lst[i];\n \
    \       }\n        else\n        {\n            result[i] = lst[i] + lst[i + 1];\n\
    \        }\n    }\n    return result;\n}\n/*\n    In this problem, you will implement\
    \ a function that takes a list of numbers,\n    and returns a list of numbers\
    \ where each number is the sum of the corresponding\n    number in the input list\
    \ and the number that follows it in the input list.\n    If the input list has\
    \ an odd number of elements, the last element is not\n    included in the sum.\n\
    \    For example:\n            It is assumed that the input list will be non-empty.\n\
    */\nlong[] sum_pairs(long[] lst) \n{\n    long[] result = new long[\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1jrb04tj.d(87): Error: expression expected, not `unittest`

    /tmp/tmp1jrb04tj.d(88): Error: found `{` when expecting `]`

    /tmp/tmp1jrb04tj.d(89): Error: semicolon expected, not `alias`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1jrb04tj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    while (i < lst1.length)\n    {\n        if (lst1[i] % 2 == 0)\n        {\n\
    \            i++;\n        }\n        else\n        {\n            while (j <\
    \ lst2.length)\n            {\n                if (lst2[j] % 2 == 1)\n       \
    \         {\n                    lst1[i] = lst2[j];\n                    lst2[j]\
    \ = 0;\n                    count++;\n                    break;\n           \
    \     }\n                j++;\n            }\n            i++;\n        }\n  \
    \  }\n    if (count == 0)\n    {\n        return \"NO\";\n    }\n    else\n  \
    \  {\n        return \"YES\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpopxgoyqj.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x428785]

    ??:? void tmpopxgoyqj.__unittest_L51_C1() [0x4280ad]

    ??:? void tmpopxgoyqj.__modtest() [0x428504]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c78b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307b1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43073d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b671]

    ??:? runModuleUnitTests [0x42c561]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c48]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(int i; lst1)\n    {\n\
    \        if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n \
    \   foreach(int i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n         \
    \   count--;\n        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\"\
    ;\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L,\
    \ 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp23st32k1.d(18): Error: cannot implicitly convert expression `__r73[__key74]`
    of type `long` to `int`

    /tmp/tmp23st32k1.d(25): Error: cannot implicitly convert expression `__r75[__key76]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23st32k1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1Even = lst1.filter!(x => x % 2 == 0);\n\
    \    long[] lst2Odd = lst2.filter!(x => x % 2 != 0);\n    if (lst1Even.length\
    \ + lst2Odd.length >= lst1.length)\n        return \"YES\";\n    else\n      \
    \  return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7uk1ezdl.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp7uk1ezdl.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7uk1ezdl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even1 = 0;\n    int even2 = 0;\n    foreach(i;lst1)\n\
    \    {\n        if(i%2==0)\n            even1++;\n    }\n    foreach(i;lst2)\n\
    \    {\n        if(i%2==0)\n            even2++;\n    }\n    if(even1==lst1.length)\n\
    \        return \"YES\";\n    else if(even2==lst2.length)\n        return \"YES\"\
    ;\n    else if(even1+even2>=lst1.length)\n        return \"YES\";\n    else\n\
    \        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n \
    \   assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 == 1)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count == 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1h7zlqid.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmp1h7zlqid.__unittest_L41_C1() [0x4283c7]

    ??:? void tmp1h7zlqid.__modtest() [0x428480]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b59e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430641]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b575]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(var i; lst1)\n    {\n\
    \        if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n \
    \   foreach(var j; lst2)\n    {\n        if(j % 2 == 0)\n        {\n         \
    \   count--;\n        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\"\
    ;\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L,\
    \ 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6q8zsd2f.d(18): Error: undefined identifier `var`

    /tmp/tmp6q8zsd2f.d(25): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6q8zsd2f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int lst1_len = lst1.length;\n\
    \    int lst2_len = lst2.length;\n    bool is_even = true;\n    while(i < lst1_len)\n\
    \    {\n        if(lst1[i] % 2 != 0)\n        {\n            is_even = false;\n\
    \            break;\n        }\n        i++;\n    }\n    if(is_even)\n    {\n\
    \        return \"YES\";\n    }\n    while(j < lst2_len)\n    {\n        if(lst2[j]\
    \ % 2 == 0)\n        {\n            return \"YES\";\n        }\n        j++;\n\
    \    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqtjmhy1t.d(19): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmpqtjmhy1t.d(20): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtjmhy1t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 == 1)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 == 1)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count == 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1h7zlqid.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmp1h7zlqid.__unittest_L41_C1() [0x4283c7]

    ??:? void tmp1h7zlqid.__modtest() [0x428480]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b59e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430641]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b575]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long odd_count = 0;\n    foreach(i; lst1)\n    {\n\
    \        if(i % 2 != 0)\n        {\n            odd_count++;\n        }\n    }\n\
    \    long even_count = 0;\n    foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n\
    \        {\n            even_count++;\n        }\n    }\n    if(odd_count == even_count)\n\
    \    {\n        return \"YES\";\n    }\n    else\n    {\n        return \"NO\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgp679j7f.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpgp679j7f.__unittest_L42_C1() [0x4283d7]

    ??:? void tmpgp679j7f.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int lst1_odd_count = 0;\n    int lst2_odd_count\
    \ = 0;\n    foreach(e; lst1)\n    {\n        if(e % 2 != 0)\n        {\n     \
    \       lst1_odd_count++;\n        }\n    }\n    foreach(e; lst2)\n    {\n   \
    \     if(e % 2 != 0)\n        {\n            lst2_odd_count++;\n        }\n  \
    \  }\n    if(lst1_odd_count == lst2_odd_count)\n    {\n        return \"YES\"\
    ;\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L,\
    \ 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpghetdvci.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpghetdvci.__unittest_L42_C1() [0x428199]

    ??:? void tmpghetdvci.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(x => x % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(x => x % 2 == 0);\n    if (lst1_odd.length\
    \ == 0)\n        return \"YES\";\n    if (lst2_even.length == 0)\n        return\
    \ \"NO\";\n    if (lst1_odd.length > lst2_even.length)\n        return \"NO\"\
    ;\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5zq1mno7.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp5zq1mno7.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5zq1mno7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int lst1_odd = 0;\n    int lst2_even = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n            lst1_odd++;\n    }\n    foreach(i;\
    \ lst2)\n    {\n        if(i % 2 == 0)\n            lst2_even++;\n    }\n    if(lst1_odd\
    \ == lst2_even)\n        return \"YES\";\n    else\n        return \"NO\";\n}\n\
    unittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps87xgupu.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmps87xgupu.__unittest_L34_C1() [0x4283cb]

    ??:? void tmps87xgupu.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int n = lst1.length;\n    int m = lst2.length;\n\
    \    int[] lst1_even = new int[n];\n    int[] lst2_even = new int[m];\n    int[]\
    \ lst1_odd = new int[n];\n    int[] lst2_odd = new int[m];\n    int lst1_even_count\
    \ = 0;\n    int lst2_even_count = 0;\n    int lst1_odd_count = 0;\n    int lst2_odd_count\
    \ = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (lst1[i] % 2 == 0)\n\
    \        {\n            lst1_even[lst1_even_count] = lst1[i];\n            lst1_even_count++;\n\
    \        }\n        else\n        {\n            lst1_odd[lst1_odd_count] = lst1[i];\n\
    \            lst1_odd_count++;\n        }\n    }\n    for (int i = 0; i < m; i++)\n\
    \    {\n        if (lst2[i] % 2 == 0)\n        {\n            lst2_even[lst2_even_count]\
    \ = lst2[i];\n            lst2_even_count++;\n        }\n        else\n      \
    \  {\n            lst2_odd[lst2_odd_count] = lst2[i];\n            lst2_odd_count++;\n\
    \        }\n    }\n    if (lst1_even_count >= n)\n    {\n        return \"YES\"\
    ;\n    }\n    else if (lst1_even_count + lst2_odd_count >= n)\n    {\n       \
    \ return \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\n\
    unittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo8xw9_9x.d(17): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmpo8xw9_9x.d(18): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    /tmp/tmpo8xw9_9x.d(31): Error: cannot implicitly convert expression `lst1[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmpo8xw9_9x.d(36): Error: cannot implicitly convert expression `lst1[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmpo8xw9_9x.d(44): Error: cannot implicitly convert expression `lst2[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmpo8xw9_9x.d(49): Error: cannot implicitly convert expression `lst2[cast(ulong)i]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo8xw9_9x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long evenCount = 0;\n    long oddCount = 0;\n  \
    \  foreach(e; lst1)\n    {\n        if(e % 2 == 0)\n            evenCount++;\n\
    \        else\n            oddCount++;\n    }\n    foreach(e; lst2)\n    {\n \
    \       if(e % 2 == 0)\n            evenCount++;\n        else\n            oddCount++;\n\
    \    }\n    if(evenCount % 2 == 0)\n        return \"YES\";\n    else\n      \
    \  return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpngojo_1t.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x42871d]

    ??:? void tmpngojo_1t.__unittest_L38_C1() [0x4281b5]

    ??:? void tmpngojo_1t.__modtest() [0x4284a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5be]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b84]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430661]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b595]

    ??:? runModuleUnitTests [0x42c485]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b6c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(x => x % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(x => x % 2 == 0);\n    if (lst1_odd.length\
    \ <= lst2_even.length)\n        return \"YES\";\n    else\n        return \"NO\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplp9bbc2z.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmplp9bbc2z.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplp9bbc2z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    if(evenCount % 2 == 0)\n    {\n        return \"YES\";\n    }\n    else\n\
    \    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqwo4tinu.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpqwo4tinu.__unittest_L50_C1() [0x4281a9]

    ??:? void tmpqwo4tinu.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    // Write your code here\n    // To print results\
    \ to the standard output you can use Console.WriteLine()\n    // Example: Console.WriteLine(\"\
    Hello world!\");\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(var i in lst1)\n\
    \    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n        }\n  \
    \  }\n    foreach(var i in lst2)\n    {\n        if(i % 2 != 0)\n        {\n \
    \           odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp75u5jf15.d(22): Error: found `in` when expecting `;`

    /tmp/tmp75u5jf15.d(29): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp75u5jf15.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int oddCount = 0;\n    foreach(e; lst1)\n    {\n\
    \        if(e % 2 != 0)\n        {\n            oddCount++;\n        }\n    }\n\
    \    int evenCount = 0;\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \        {\n            evenCount++;\n        }\n    }\n    if(oddCount == evenCount)\n\
    \    {\n        return \"YES\";\n    }\n    else\n    {\n        return \"NO\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp81x1tc4j.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmp81x1tc4j.__unittest_L42_C1() [0x4283cf]

    ??:? void tmp81x1tc4j.__modtest() [0x428488]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    string result = \"NO\";\n    long[] lst1_even =\
    \ lst1.filter!(x => x % 2 == 0);\n    long[] lst1_odd = lst1.filter!(x => x %\
    \ 2 != 0);\n    long[] lst2_even = lst2.filter!(x => x % 2 == 0);\n    long[]\
    \ lst2_odd = lst2.filter!(x => x % 2 != 0);\n    if (lst1_even.length + lst2_even.length\
    \ >= lst1.length)\n    {\n        result = \"YES\";\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzy2du2b7.d(18): Error: no property `filter` for type `long[]`

    /tmp/tmpzy2du2b7.d(19): Error: no property `filter` for type `long[]`

    /tmp/tmpzy2du2b7.d(20): Error: no property `filter` for type `long[]`

    /tmp/tmpzy2du2b7.d(21): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzy2du2b7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    bool isEven(long n)\n    {\n        return n % 2\
    \ == 0;\n    }\n    bool isOdd(long n)\n    {\n        return n % 2 != 0;\n  \
    \  }\n    bool isEvenList(long[] lst)\n    {\n        return all!isEven(lst);\n\
    \    }\n    bool isOddList(long[] lst)\n    {\n        return all!isOdd(lst);\n\
    \    }\n    bool isEvenList1 = isEvenList(lst1);\n    bool isEvenList2 = isEvenList(lst2);\n\
    \    bool isOddList1 = isOddList(lst1);\n    bool isOddList2 = isOddList(lst2);\n\
    \    if(isEvenList1 && isEvenList2)\n    {\n        return \"YES\";\n    }\n \
    \   else if(isEvenList1 && isOddList2)\n    {\n        return \"YES\";\n    }\n\
    \    else if(isOddList1 && isEvenList2)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1hesn_pa.d(27): Error: template instance `all!isEven` template
    `all` is not defined

    /tmp/tmp1hesn_pa.d(31): Error: template instance `all!isOdd` template `all` is
    not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1hesn_pa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even_count = 0;\n    int odd_count = 0;\n  \
    \  foreach(element; lst1)\n    {\n        if(element % 2 == 0)\n        {\n  \
    \          even_count++;\n        }\n        else\n        {\n            odd_count++;\n\
    \        }\n    }\n    foreach(element; lst2)\n    {\n        if(element % 2 ==\
    \ 0)\n        {\n            even_count++;\n        }\n        else\n        {\n\
    \            odd_count++;\n        }\n    }\n    if(even_count % 2 == 0)\n   \
    \ {\n        return \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n\
    \    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8az5sctz.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmp8az5sctz.__unittest_L50_C1() [0x4281a9]

    ??:? void tmp8az5sctz.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int n = lst1.length;\n    int m = lst2.length;\n\
    \    int i = 0;\n    int j = 0;\n    while(i < n && j < m)\n    {\n        if(lst1[i]\
    \ % 2 == 0)\n        {\n            i++;\n        }\n        else if(lst2[j] %\
    \ 2 == 0)\n        {\n            lst1[i] = lst2[j];\n            i++;\n     \
    \       j++;\n        }\n        else\n        {\n            j++;\n        }\n\
    \    }\n    for(int k = 0; k < n; k++)\n    {\n        if(lst1[k] % 2 != 0)\n\
    \        {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n\
    }\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzwk4dx24.d(17): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmpzwk4dx24.d(18): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzwk4dx24.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long evens = 0;\n    long odds = 0;\n    foreach(num;\
    \ lst1)\n    {\n        if(num % 2 == 0)\n            evens++;\n        else\n\
    \            odds++;\n    }\n    foreach(num; lst2)\n    {\n        if(num % 2\
    \ == 0)\n            evens++;\n        else\n            odds++;\n    }\n    if(evens\
    \ > odds)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprz7xqo5b.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmprz7xqo5b.__unittest_L38_C1() [0x427f62]

    ??:? void tmprz7xqo5b.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto even = (long x) => x % 2 == 0;\n    auto odd\
    \ = (long x) => x % 2 != 0;\n    auto isEven = lst1.all!even;\n    auto isOdd\
    \ = lst1.all!odd;\n    if(isEven) return \"YES\";\n    if(isOdd)\n    {\n    \
    \    auto isOdd2 = lst2.all!odd;\n        if(isOdd2) return \"NO\";\n        else\
    \ return \"YES\";\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvpc4l9g8.d(19): Error: no property `all` for type `long[]`

    /tmp/tmpvpc4l9g8.d(20): Error: no property `all` for type `long[]`

    /tmp/tmpvpc4l9g8.d(24): Error: no property `all` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvpc4l9g8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(x => x % 2 == 1);\n\
    \    long[] lst2_even = lst2.filter!(x => x % 2 == 0);\n    if (lst1_odd.length\
    \ == 0)\n        return \"YES\";\n    if (lst2_even.length == 0)\n        return\
    \ \"NO\";\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9zmfgtzs.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp9zmfgtzs.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9zmfgtzs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 != 0)\n            odd1++;\n    }\n    foreach(e;\
    \ lst2)\n    {\n        if(e % 2 != 0)\n            odd2++;\n    }\n    if(odd1\
    \ == odd2)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpinn50ph8.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpinn50ph8.__unittest_L34_C1() [0x428199]

    ??:? void tmpinn50ph8.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd_count = 0;\n    foreach(i; lst1)\n    {\n\
    \        if(i % 2 == 1)\n        {\n            odd_count++;\n        }\n    }\n\
    \    foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            odd_count--;\n\
    \        }\n    }\n    if(odd_count == 0)\n    {\n        return \"YES\";\n  \
    \  }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4_zanmop.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmp4_zanmop.__unittest_L41_C1() [0x4283c7]

    ??:? void tmp4_zanmop.__modtest() [0x428480]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b59e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430641]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b575]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evens = 0;\n    int odds = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 0)\n            evens++;\n        else\n \
    \           odds++;\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n\
    \            evens++;\n        else\n            odds++;\n    }\n    if(evens\
    \ > odds)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzedldb3h.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpzedldb3h.__unittest_L38_C1() [0x427f5a]

    ??:? void tmpzedldb3h.__modtest() [0x42848c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count1 = 0;\n    int count2 = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n        {\n            count1++;\n   \
    \     }\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n        {\n\
    \            count2++;\n        }\n    }\n    if(count1 == lst1.length || count2\
    \ == lst2.length)\n    {\n        return \"YES\";\n    }\n    else\n    {\n  \
    \      return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1to_wety.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmp1to_wety.__unittest_L42_C1() [0x427f5e]

    ??:? void tmp1to_wety.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(a => a % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(a => a % 2 == 0);\n    if (lst1_odd.length\
    \ <= lst2_even.length)\n        return \"YES\";\n    else\n        return \"NO\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe53owttx.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpe53owttx.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe53owttx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto even = lst1.filter!(a => a % 2 == 0);\n   \
    \ auto odd = lst1.filter!(a => a % 2 != 0);\n    auto even2 = lst2.filter!(a =>\
    \ a % 2 == 0);\n    auto odd2 = lst2.filter!(a => a % 2 != 0);\n    if (even.length\
    \ == lst1.length)\n        return \"YES\";\n    if (even2.length >= odd.length)\n\
    \        return \"YES\";\n    return \"NO\";\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsnoagh5g.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpsnoagh5g.d(18): Error: no property `filter` for type `long[]`

    /tmp/tmpsnoagh5g.d(19): Error: no property `filter` for type `long[]`

    /tmp/tmpsnoagh5g.d(20): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsnoagh5g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int lst1_odd_count = 0;\n    int lst2_odd_count\
    \ = 0;\n    foreach(i; lst1)\n    {\n        if(i % 2 != 0)\n        {\n     \
    \       lst1_odd_count++;\n        }\n    }\n    foreach(i; lst2)\n    {\n   \
    \     if(i % 2 != 0)\n        {\n            lst2_odd_count++;\n        }\n  \
    \  }\n    if(lst1_odd_count == lst2_odd_count)\n    {\n        return \"YES\"\
    ;\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L,\
    \ 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpc6w7efez.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpc6w7efez.__unittest_L42_C1() [0x428199]

    ??:? void tmpc6w7efez.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count1 = 0;\n    int count2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 0)\n        {\n            count1++;\n   \
    \     }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n\
    \            count2++;\n        }\n    }\n    if(count1 == lst1.length || count2\
    \ == lst2.length)\n    {\n        return \"YES\";\n    }\n    else\n    {\n  \
    \      return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpb085whgk.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpb085whgk.__unittest_L42_C1() [0x427f5e]

    ??:? void tmpb085whgk.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(x => x % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(x => x % 2 == 0);\n    if (lst1_odd.length\
    \ <= lst2_even.length)\n        return \"YES\";\n    else\n        return \"NO\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplp9bbc2z.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmplp9bbc2z.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplp9bbc2z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(x => x % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(x => x % 2 == 0);\n    if (lst1_odd.length\
    \ <= lst2_even.length)\n        return \"YES\";\n    else\n        return \"NO\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplp9bbc2z.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmplp9bbc2z.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplp9bbc2z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 == 1)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 != 0)\n            odd1++;\n    }\n    foreach(e;\
    \ lst2)\n    {\n        if(e % 2 != 0)\n            odd2++;\n    }\n    if(odd1\
    \ == odd2)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpinn50ph8.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpinn50ph8.__unittest_L34_C1() [0x428199]

    ??:? void tmpinn50ph8.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even1 = 0;\n    int even2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 0)\n            even1++;\n    }\n    foreach(i;\
    \ lst2)\n    {\n        if(i % 2 == 0)\n            even2++;\n    }\n    if(even1\
    \ == lst1.length || even2 == lst2.length)\n        return \"YES\";\n    return\
    \ \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgm1v7zwk.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpgm1v7zwk.__unittest_L33_C1() [0x427f5e]

    ??:? void tmpgm1v7zwk.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(num;\
    \ lst1)\n    {\n        if(num % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(num; lst2)\n    {\n        if(num % 2 == 0)\n        {\n        \
    \    evenCount++;\n        }\n        else\n        {\n            oddCount++;\n\
    \        }\n    }\n    if(evenCount > oddCount)\n    {\n        return \"YES\"\
    ;\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L,\
    \ 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpx9q4mj90.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpx9q4mj90.__unittest_L50_C1() [0x427f5a]

    ??:? void tmpx9q4mj90.__modtest() [0x42848c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int[] evens = lst1.filter!(a => a % 2 == 0);\n \
    \   int[] odds = lst2.filter!(a => a % 2 != 0);\n    if (evens.length == lst1.length)\n\
    \        return \"YES\";\n    if (odds.length == lst2.length)\n        return\
    \ \"NO\";\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0nn23q43.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp0nn23q43.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0nn23q43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    int count2 = 0;\n    int count3 = 0;\n    int count4 = 0;\n    int count5\
    \ = 0;\n    int count6 = 0;\n    int count7 = 0;\n    int count8 = 0;\n    int\
    \ count9 = 0;\n    int count10 = 0;\n    int count11 = 0;\n    int count12 = 0;\n\
    \    int count13 = 0;\n    int count14 = 0;\n    int count15 = 0;\n    int count16\
    \ = 0;\n    int count17 = 0;\n    int count18 = 0;\n    int count19 = 0;\n   \
    \ int count20 = 0;\n    int count21 = 0;\n    int count22 = 0;\n    int count23\
    \ = 0;\n    int count24 = 0;\n    int count25 = 0;\n    int count26 = 0;\n   \
    \ int count27 = 0;\n    int count28 = 0;\n    int count29 = 0;\n    int count30\
    \ = 0;\n    int count31 = 0;\n    int count32 = 0;\n    int count33 = 0;\n   \
    \ int count34 = 0;\n    int count35 = 0;\n    int count36 = 0;\n    int count37\
    \ = 0;\n    int count38 = 0;\n    int count39 = 0;\n    int count40 = 0;\n   \
    \ int count41 = 0;\n    int count42 = 0;\n    int count43 = 0;\n    int count44\
    \ = 0;\n    int count45 = 0;\n    int count46 = 0;\n    int count47 = 0;\n   \
    \ int count48 = 0;\n    int count49 = 0;\n    int count50 = 0;\n    int count51\
    \ = 0;\n    int count52 = 0;\n    int count53 = 0;\n    int count54 = 0;\n   \
    \ int count55 = 0;\n    int count56 = 0;\n    int count57 = 0;\n    int count58\
    \ = 0;\n    int count59 = 0;\n    int count60 = 0;\n    int count61 = 0;\n   \
    \ int count62 = 0;\n\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptxesfx1u.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxesfx1u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(num;\
    \ lst1)\n    {\n        if(num % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(num; lst2)\n    {\n        if(num % 2 == 0)\n        {\n        \
    \    evenCount++;\n        }\n        else\n        {\n            oddCount++;\n\
    \        }\n    }\n    if(evenCount % 2 == 0)\n    {\n        return \"YES\";\n\
    \    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn2ihqhlq.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpn2ihqhlq.__unittest_L50_C1() [0x4281a9]

    ??:? void tmpn2ihqhlq.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even1 = 0;\n    int even2 = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            even1++;\n    }\n    foreach(e;\
    \ lst2)\n    {\n        if(e % 2 == 0)\n            even2++;\n    }\n    if(even1\
    \ == lst1.length || even2 == lst2.length)\n        return \"YES\";\n    else\n\
    \        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n \
    \   assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpht33mex_.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpht33mex_.__unittest_L34_C1() [0x427f5e]

    ??:? void tmpht33mex_.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count1 = 0;\n    int count2 = 0;\n    foreach(num;\
    \ lst1)\n    {\n        if(num % 2 == 0)\n        {\n            count1++;\n \
    \       }\n    }\n    foreach(num; lst2)\n    {\n        if(num % 2 == 0)\n  \
    \      {\n            count2++;\n        }\n    }\n    if(count1 == lst1.length\
    \ || count2 == lst2.length)\n    {\n        return \"YES\";\n    }\n    else\n\
    \    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiz14raqz.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmpiz14raqz.__unittest_L42_C1() [0x427f5e]

    ??:? void tmpiz14raqz.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int oddCount = 0;\n    int evenCount = 0;\n    foreach(num;\
    \ lst1)\n    {\n        if(num % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(num; lst2)\n    {\n        if(num % 2 == 0)\n        {\n        \
    \    evenCount++;\n        }\n        else\n        {\n            oddCount++;\n\
    \        }\n    }\n    if(evenCount > oddCount)\n    {\n        return \"YES\"\
    ;\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L,\
    \ 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppjlztumm.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmppjlztumm.__unittest_L50_C1() [0x427f5a]

    ??:? void tmppjlztumm.__modtest() [0x42848c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count == 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgd9tdwog.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmpgd9tdwog.__unittest_L41_C1() [0x4283c7]

    ??:? void tmpgd9tdwog.__modtest() [0x428480]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b59e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430641]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b575]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_copy = lst1.dup;\n    long[] lst2_copy\
    \ = lst2.dup;\n    long[] lst1_even = lst1.filter!(a => a % 2 == 0);\n    long[]\
    \ lst2_odd = lst2.filter!(a => a % 2 != 0);\n    long[] lst2_even = lst2.filter!(a\
    \ => a % 2 == 0);\n    long[] lst1_odd = lst1.filter!(a => a % 2 != 0);\n    if\
    \ (lst1_odd.length == 0)\n        return \"YES\";\n    if (lst2_odd.length ==\
    \ 0)\n        return \"NO\";\n    if (lst1_odd.length > lst2_odd.length)\n   \
    \     return \"NO\";\n    if (lst1_odd.length == lst2_odd.length)\n    {\n   \
    \     for (int i = 0; i < lst1_odd.length; i++)\n        {\n            lst1_copy[lst1_copy.indexOf(lst1_odd[i])]\
    \ = lst2_odd[i];\n            lst2_copy[lst2_copy.indexOf(lst2_odd[i])] = lst1_odd[i];\n\
    \        }\n        if (lst1_copy.filter!(a => a % 2 != 0).length == 0)\n    \
    \        return \"YES\";\n        else\n            return \"NO\";\n    }\n  \
    \  if (lst1_odd.length < lst2_odd.length)\n    {\n        for (int i = 0; i <\
    \ lst1_odd.length; i++)\n        {\n            lst1_copy[lst1_copy.indexOf(lst1_odd[i])]\
    \ = lst2_odd[i];\n            lst2_copy[lst2_copy.indexOf(lst2_odd[i])] = lst1_odd[i];\n\
    \        }\n        if (lst1_copy.filter!(a => a % 2 != 0).length == 0)\n    \
    \       \nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7xb7_vcl.d(50): Error: found `unittest` instead of statement

    /tmp/tmp7xb7_vcl.d(62): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xb7_vcl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(num;\
    \ lst1)\n    {\n        if(num % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(num; lst2)\n    {\n        if(num % 2 == 0)\n        {\n        \
    \    evenCount++;\n        }\n        else\n        {\n            oddCount++;\n\
    \        }\n    }\n    if(evenCount % 2 == 0)\n    {\n        return \"YES\";\n\
    \    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn2ihqhlq.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpn2ihqhlq.__unittest_L50_C1() [0x4281a9]

    ??:? void tmpn2ihqhlq.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int[] lst1_even = lst1.filter!(a => a % 2 == 0);\n\
    \    int[] lst2_odd = lst2.filter!(a => a % 2 != 0);\n    if (lst1_even.length\
    \ == lst1.length)\n        return \"YES\";\n    else if (lst1_even.length + lst2_odd.length\
    \ >= lst1.length)\n        return \"YES\";\n    else\n        return \"NO\";\n\
    }\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps287_hic.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmps287_hic.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps287_hic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto lst1_even = lst1.filter!(a => a % 2 == 0);\n\
    \    auto lst2_even = lst2.filter!(a => a % 2 == 0);\n    auto lst1_odd = lst1.filter!(a\
    \ => a % 2 != 0);\n    auto lst2_odd = lst2.filter!(a => a % 2 != 0);\n    if\
    \ (lst1_even.length == lst1.length)\n        return \"YES\";\n    else if (lst2_odd.length\
    \ == lst2.length)\n        return \"YES\";\n    else if (lst1_even.length + lst2_even.length\
    \ >= lst1.length)\n        return \"YES\";\n    else if (lst1_odd.length + lst2_odd.length\
    \ >= lst2.length)\n        return \"YES\";\n    else\n        return \"NO\";\n\
    }\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgup85qle.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpgup85qle.d(18): Error: no property `filter` for type `long[]`

    /tmp/tmpgup85qle.d(19): Error: no property `filter` for type `long[]`

    /tmp/tmpgup85qle.d(20): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgup85qle.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            evenCount++;\n        else\n\
    \            oddCount++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2\
    \ == 0)\n            evenCount++;\n        else\n            oddCount++;\n   \
    \ }\n    if(evenCount % 2 == 0)\n        return \"YES\";\n    else\n        return\
    \ \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpii9apk8m.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpii9apk8m.__unittest_L38_C1() [0x4281a9]

    ??:? void tmpii9apk8m.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(a => a % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(a => a % 2 == 0);\n    if (lst1_odd.length\
    \ <= lst2_even.length)\n        return \"YES\";\n    else\n        return \"NO\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe53owttx.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpe53owttx.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe53owttx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int[] evens = lst1.filter!(a => a % 2 == 0);\n \
    \   int[] odds = lst2.filter!(a => a % 2 != 0);\n    if (evens.length + odds.length\
    \ == lst1.length)\n        return \"YES\";\n    else\n        return \"NO\";\n\
    }\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeoz0066w.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpeoz0066w.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeoz0066w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(a => a % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(a => a % 2 == 0);\n    if (lst1_odd.length\
    \ <= lst2_even.length)\n        return \"YES\";\n    else\n        return \"NO\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe53owttx.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpe53owttx.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe53owttx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    if(evenCount % 2 == 0 && oddCount % 2 == 0)\n    {\n        return \"YES\"\
    ;\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L,\
    \ 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpartv_g_q.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x428725]

    ??:? void tmpartv_g_q.__unittest_L50_C1() [0x4281bd]

    ??:? void tmpartv_g_q.__modtest() [0x4284a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306dd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b8c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430669]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b59d]

    ??:? runModuleUnitTests [0x42c48d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b74]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int len1 = lst1.length;\n    int len2 = lst2.length;\n\
    \    int count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < len1; i++)\n\
    \    {\n        if (lst1[i] % 2 == 0)\n        {\n            count1++;\n    \
    \    }\n    }\n    for (int i = 0; i < len2; i++)\n    {\n        if (lst2[i]\
    \ % 2 == 0)\n        {\n            count2++;\n        }\n    }\n    if (count1\
    \ == len1)\n    {\n        return \"YES\";\n    }\n    else if (count2 == len2)\n\
    \    {\n        return \"YES\";\n    }\n    else if (count1 + count2 >= len1)\n\
    \    {\n        return \"YES\";\n    }\n    else\n    {\n        return \"NO\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaus8_uiu.d(17): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmpaus8_uiu.d(18): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaus8_uiu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    int count1 = 0;\n    int count2 = 0;\n    int count3 = 0;\n    int count4\
    \ = 0;\n    int count5 = 0;\n    int count6 = 0;\n    int count7 = 0;\n    int\
    \ count8 = 0;\n    int count9 = 0;\n    int count10 = 0;\n    int count11 = 0;\n\
    \    int count12 = 0;\n    int count13 = 0;\n    int count14 = 0;\n    int count15\
    \ = 0;\n    int count16 = 0;\n    int count17 = 0;\n    int count18 = 0;\n   \
    \ int count19 = 0;\n    int count20 = 0;\n    int count21 = 0;\n    int count22\
    \ = 0;\n    int count23 = 0;\n    int count24 = 0;\n    int count25 = 0;\n   \
    \ int count26 = 0;\n    int count27 = 0;\n    int count28 = 0;\n    int count29\
    \ = 0;\n    int count30 = 0;\n    int count31 = 0;\n    int count32 = 0;\n   \
    \ int count33 = 0;\n    int count34 = 0;\n    int count35 = 0;\n    int count36\
    \ = 0;\n    int count37 = 0;\n    int count38 = 0;\n    int count39 = 0;\n   \
    \ int count40 = 0;\n    int count41 = 0;\n    int count42 = 0;\n    int count43\
    \ = 0;\n    int count44 = 0;\n    int count45 = 0;\n    int count46 = 0;\n   \
    \ int count47 = 0;\n    int count48 = 0;\n    int count49 = 0;\n    int count50\
    \ = 0;\n    int count51 = 0;\n    int count52 = 0;\n    int count53 = 0;\n   \
    \ int count54 = 0;\n    int count55 = 0;\n    int count56 = 0;\n    int count57\
    \ = 0;\n    int count58 = 0;\n    int count59 = 0;\n    int count60 = 0;\n   \
    \ int count61 = 0;\n\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgj5q1bo.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwgj5q1bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    // Write your code here\n    // To print results\
    \ to the standard output you can use Console.WriteLine()\n    // Example: Console.WriteLine(\"\
    Hello world!\");\n    int count1 = 0;\n    int count2 = 0;\n    foreach(var i\
    \ in lst1)\n    {\n        if(i % 2 == 0)\n        {\n            count1++;\n\
    \        }\n    }\n    foreach(var i in lst2)\n    {\n        if(i % 2 == 0)\n\
    \        {\n            count2++;\n        }\n    }\n    if(count1 == lst1.length)\n\
    \    {\n        return \"YES\";\n    }\n    else if(count2 == lst2.length)\n \
    \   {\n        return \"YES\";\n    }\n    else if(count1 + count2 >= lst1.length)\n\
    \    {\n        return \"YES\";\n    }\n    else\n    {\n        return \"NO\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpug8c16jh.d(22): Error: found `in` when expecting `;`

    /tmp/tmpug8c16jh.d(29): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpug8c16jh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even1 = 0;\n    int even2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 0)\n            even1++;\n    }\n    foreach(i;\
    \ lst2)\n    {\n        if(i % 2 == 0)\n            even2++;\n    }\n    if(even1\
    \ == lst1.length)\n        return \"YES\";\n    if(even2 == lst2.length)\n   \
    \     return \"YES\";\n    if(even1 + even2 >= lst1.length)\n        return \"\
    YES\";\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163965
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even1 = 0;\n    int even2 = 0;\n    foreach(int\
    \ i; lst1)\n    {\n        if(i%2 == 0)\n            even1++;\n    }\n    foreach(int\
    \ i; lst2)\n    {\n        if(i%2 == 0)\n            even2++;\n    }\n    if(even1\
    \ == lst1.length || even2 == lst2.length)\n        return \"YES\";\n    else\n\
    \        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n \
    \   assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqx25iaze.d(19): Error: cannot implicitly convert expression `__r73[__key74]`
    of type `long` to `int`

    /tmp/tmpqx25iaze.d(24): Error: cannot implicitly convert expression `__r75[__key76]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqx25iaze.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    // Write your code here\n    long[] lst1_odd = lst1.filter!(a\
    \ => a % 2 != 0);\n    long[] lst2_even = lst2.filter!(a => a % 2 == 0);\n   \
    \ if (lst1_odd.length == 0)\n        return \"YES\";\n    if (lst2_even.length\
    \ == 0)\n        return \"NO\";\n    return \"YES\";\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwws86n5h.d(18): Error: no property `filter` for type `long[]`

    /tmp/tmpwws86n5h.d(19): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwws86n5h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto even = (long x) => x % 2 == 0;\n    auto odd\
    \ = (long x) => x % 2 != 0;\n    auto evens = lst1.filter!even;\n    auto odds\
    \ = lst2.filter!odd;\n    if (evens.length == lst1.length)\n        return \"\
    YES\";\n    if (odds.length == lst2.length)\n        return \"NO\";\n    return\
    \ \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpypo_v3j7.d(19): Error: no property `filter` for type `long[]`

    /tmp/tmpypo_v3j7.d(20): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpypo_v3j7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(a => a % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(a => a % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp21nb24z2.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp21nb24z2.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21nb24z2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int len1 = lst1.length;\n\
    \    int len2 = lst2.length;\n    while(i < len1 && j < len2)\n    {\n       \
    \ if(lst1[i] % 2 == 0)\n        {\n            i++;\n        }\n        else if(lst2[j]\
    \ % 2 == 0)\n        {\n            lst1[i] = lst2[j];\n            i++;\n   \
    \         j++;\n        }\n        else\n        {\n            j++;\n       \
    \ }\n    }\n    for(int k = 0; k < len1; k++)\n    {\n        if(lst1[k] % 2 !=\
    \ 0)\n        {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphlwjvv5b.d(19): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmphlwjvv5b.d(20): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphlwjvv5b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 1)\n            odd1++;\n    }\n    foreach(i;\
    \ lst2)\n    {\n        if(i % 2 == 1)\n            odd2++;\n    }\n    if(odd1\
    \ == odd2)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprxmqt1_x.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmprxmqt1_x.__unittest_L34_C1() [0x428199]

    ??:? void tmprxmqt1_x.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(a => a % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(a => a % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp21nb24z2.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp21nb24z2.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21nb24z2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee\
    \ = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n \
    \   int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn\
    \ = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n \
    \   int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww\
    \ = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n\
    \    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int\
    \ fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int\
    \ sss = 0;\n    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\
    \ = 0;\n    int\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpde5bmely.d(85): Error: no identifier for declarator `int`

    /tmp/tmpde5bmely.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde5bmely.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst3 = lst1.dup;\n    long[] lst4 = lst2.dup;\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb =\
    \ 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n   \
    \ int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk =\
    \ 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n   \
    \ int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt =\
    \ 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n   \
    \ int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n    int bbb = 0;\n    int ccc\
    \ = 0;\n    int ddd = 0;\n    int eee = 0;\n    int fff = 0;\n    int ggg = 0;\n\
    \    int hhh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int\
    \ lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n    int ooo = 0;\n    int ppp\
    \ = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int sss = 0;\n    int t\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbzwqe2jf.d(83): Error: semicolon expected, not `unittest`

    /tmp/tmpbzwqe2jf.d(83): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbzwqe2jf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int lst1_odd_count = 0;\n    int lst2_odd_count\
    \ = 0;\n    foreach(e; lst1)\n    {\n        if(e % 2 != 0)\n        {\n     \
    \       lst1_odd_count++;\n        }\n    }\n    foreach(e; lst2)\n    {\n   \
    \     if(e % 2 != 0)\n        {\n            lst2_odd_count++;\n        }\n  \
    \  }\n    if(lst1_odd_count == lst2_odd_count)\n    {\n        return \"YES\"\
    ;\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L,\
    \ 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpghetdvci.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpghetdvci.__unittest_L42_C1() [0x428199]

    ??:? void tmpghetdvci.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(x => x % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(x => x % 2 == 0);\n    if (lst1_odd.length\
    \ == 0)\n        return \"YES\";\n    if (lst2_even.length == 0)\n        return\
    \ \"NO\";\n    if (lst1_odd.length <= lst2_even.length)\n        return \"YES\"\
    ;\n    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n   \
    \ assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd6r7liz2.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpd6r7liz2.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd6r7liz2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int lst1_len = lst1.length;\n\
    \    int lst2_len = lst2.length;\n    int lst1_even_count = 0;\n    int lst2_odd_count\
    \ = 0;\n    int lst1_odd_count = 0;\n    int lst2_even_count = 0;\n    int lst1_odd_index\
    \ = 0;\n    int lst2_even_index = 0;\n    int lst1_even_index = 0;\n    int lst2_odd_index\
    \ = 0;\n    int[] lst1_odd_index_arr = new int[lst1_len];\n    int[] lst2_even_index_arr\
    \ = new int[lst2_len];\n    int[] lst1_even_index_arr = new int[lst1_len];\n \
    \   int[] lst2_odd_index_arr = new int[lst2_len];\n    for (i = 0; i < lst1_len;\
    \ i++)\n    {\n        if (lst1[i] % 2 == 0)\n        {\n            lst1_even_count++;\n\
    \            lst1_even_index_arr[lst1_even_index] = i;\n            lst1_even_index++;\n\
    \        }\n        else\n        {\n            lst1_odd_count++;\n         \
    \   lst1_odd_index_arr[lst1_odd_index] = i;\n            lst1_odd_index++;\n \
    \       }\n    }\n    for (i = 0; i < lst2_len; i++)\n    {\n        if (lst2[i]\
    \ % 2 == 0)\n        {\n            lst2_even_count++;\n            lst2_even_index_arr[lst2_even_index]\
    \ = i;\n            lst2_even_index++;\n        }\n        else\n        {\n \
    \           lst2_odd_count++;\n            lst2_odd_index_arr[lst2_odd_index]\
    \ = i;\n            lst2_\nunittest\n{\n    alias candidate = exchange;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxfp8bif.d(61): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpaxfp8bif.d(73): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpaxfp8bif.d(73): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpaxfp8bif.d(73): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxfp8bif.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 1)\n            odd1++;\n    }\n    foreach(i;\
    \ lst2)\n    {\n        if(i % 2 == 1)\n            odd2++;\n    }\n    if(odd1\
    \ == odd2)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprxmqt1_x.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmprxmqt1_x.__unittest_L34_C1() [0x428199]

    ??:? void tmprxmqt1_x.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163965
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int cnt = 0;\n    foreach(i; lst1)\n    {\n    \
    \    if(i % 2 != 0)\n            cnt++;\n    }\n    foreach(i; lst2)\n    {\n\
    \        if(i % 2 == 0)\n            cnt--;\n    }\n    if(cnt <= 0)\n       \
    \ return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(a => a % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(a => a % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp21nb24z2.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp21nb24z2.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21nb24z2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    bool isEven(long[] lst)\n    {\n        foreach(e;\
    \ lst)\n            if(e % 2 != 0)\n                return false;\n        return\
    \ true;\n    }\n    if(isEven(lst1))\n        return \"YES\";\n    if(isEven(lst2))\n\
    \        return \"YES\";\n    foreach(e1; lst1)\n        foreach(e2; lst2)\n \
    \           if(e1 % 2 != 0 && e2 % 2 != 0)\n                return \"YES\";\n\
    \    return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq5tsspzt.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x428805]

    ??:? void tmpq5tsspzt.__unittest_L34_C1() [0x42812d]

    ??:? void tmpq5tsspzt.__modtest() [0x428584]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c797]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430749]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b67d]

    ??:? runModuleUnitTests [0x42c56d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i, j;\n    int lst1_len = lst1.length;\n   \
    \ int lst2_len = lst2.length;\n    int count = 0;\n    for (i = 0; i < lst1_len;\
    \ i++) \n    {\n        if (lst1[i] % 2 != 0) \n        {\n            for (j\
    \ = 0; j < lst2_len; j++) \n            {\n                if (lst2[j] % 2 !=\
    \ 0) \n                {\n                    lst1[i] = lst2[j];\n           \
    \         count++;\n                    break;\n                }\n          \
    \  }\n        }\n    }\n    if (count == lst1_len) \n    {\n        return \"\
    YES\";\n    }\n    else \n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpub3aj25t.d(18): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmpub3aj25t.d(19): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpub3aj25t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    bool isEven(long n) { return n % 2 == 0; }\n   \
    \ bool isOdd(long n) { return n % 2 != 0; }\n    bool isEvenList(long[] lst) {\
    \ return all!(isEven)(lst); }\n    bool isOddList(long[] lst) { return all!(isOdd)(lst);\
    \ }\n    bool isEvenOddList(long[] lst) { return all!(isEven)(lst[0 .. $/2]) &&\
    \ all!(isOdd)(lst[$/2 .. $]); }\n    bool isOddEvenList(long[] lst) { return all!(isOdd)(lst[0\
    \ .. $/2]) && all!(isEven)(lst[$/2 .. $]); }\n    bool isEvenOdd(long[] lst1,\
    \ long[] lst2) { return isEvenList(lst1) && isOddList(lst2); }\n    bool isOddEven(long[]\
    \ lst1, long[] lst2) { return isOddList(lst1) && isEvenList(lst2); }\n    bool\
    \ isEvenOddEven(long[] lst1, long[] lst2) { return isEvenOddList(lst1) && isEvenList(lst2);\
    \ }\n    bool isOddEvenOdd(long[] lst1, long[] lst2) { return isOddEvenList(lst1)\
    \ && isOddList(lst2); }\n    bool isEvenEvenOdd(long[] lst1, long[] lst2) { return\
    \ isEvenList(lst1) && isOddEvenList(lst2); }\n    bool isOddOddEven(long[] lst1,\
    \ long[] lst2) { return isOddList(lst1) && isEvenOddList(lst2); }\n    bool isEvenOddEvenOdd(long[]\
    \ lst1, long[] lst2) { return isEvenOddList(lst1) && isOddEvenList(lst2); }\n\
    \    bool isOddEvenOddEven(long[] lst1, long[] l\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4relq1bp.d(31): Error: found `unittest` when expecting `)`

    /tmp/tmp4relq1bp.d(43): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4relq1bp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(a => a % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(a => a % 2 == 0);\n    if (lst1_odd.length\
    \ <= lst2_even.length)\n        return \"YES\";\n    else\n        return \"NO\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe53owttx.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpe53owttx.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe53owttx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    bool isEven(long n) { return n % 2 == 0; }\n   \
    \ bool isOdd(long n) { return n % 2 != 0; }\n    bool isEvenList(long[] lst) {\
    \ return all!(isEven)(lst); }\n    bool isOddList(long[] lst) { return all!(isOdd)(lst);\
    \ }\n    bool isEvenList1 = isEvenList(lst1);\n    bool isEvenList2 = isEvenList(lst2);\n\
    \    bool isOddList1 = isOddList(lst1);\n    bool isOddList2 = isOddList(lst2);\n\
    \    if (isEvenList1 && isEvenList2) return \"YES\";\n    if (isOddList1 && isOddList2)\
    \ return \"YES\";\n    if (isEvenList1 && isOddList2) return \"YES\";\n    if\
    \ (isOddList1 && isEvenList2) return \"YES\";\n    return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppkl2jrer.d(19): Error: template instance `all!isEven` template
    `all` is not defined

    /tmp/tmppkl2jrer.d(20): Error: template instance `all!isOdd` template `all` is
    not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppkl2jrer.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee\
    \ = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n \
    \   int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn\
    \ = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n \
    \   int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww\
    \ = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n\
    \    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int\
    \ fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int\
    \ sss = 0;\n    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\
    \ = 0;\n    int\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpde5bmely.d(85): Error: no identifier for declarator `int`

    /tmp/tmpde5bmely.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde5bmely.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(elem; lst1)\n    {\n\
    \        if(elem % 2 == 1)\n        {\n            count++;\n        }\n    }\n\
    \    foreach(elem; lst2)\n    {\n        if(elem % 2 == 0)\n        {\n      \
    \      count--;\n        }\n    }\n    if(count == 0)\n    {\n        return \"\
    YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n\
    \    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpb427hpq0.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmpb427hpq0.__unittest_L41_C1() [0x4283c7]

    ??:? void tmpb427hpq0.__modtest() [0x428480]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b59e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430641]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b575]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto lst1_even = lst1.filter!(a => a % 2 == 0);\n\
    \    auto lst2_even = lst2.filter!(a => a % 2 == 0);\n    auto lst1_odd = lst1.filter!(a\
    \ => a % 2 != 0);\n    auto lst2_odd = lst2.filter!(a => a % 2 != 0);\n    if\
    \ (lst1_even.length + lst2_even.length >= lst1.length)\n        return \"YES\"\
    ;\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt8817p0z.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpt8817p0z.d(18): Error: no property `filter` for type `long[]`

    /tmp/tmpt8817p0z.d(19): Error: no property `filter` for type `long[]`

    /tmp/tmpt8817p0z.d(20): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt8817p0z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    // Write your code here\n    int count = 0;\n  \
    \  foreach(elem; lst1)\n    {\n        if(elem % 2 != 0)\n        {\n        \
    \    count++;\n        }\n    }\n    foreach(elem; lst2)\n    {\n        if(elem\
    \ % 2 == 0)\n        {\n            count--;\n        }\n    }\n    if(count <=\
    \ 0)\n    {\n        return \"YES\";\n    }\n    else\n    {\n        return \"\
    NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(int\
    \ i; lst1)\n    {\n        if(i % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(int i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n        \
    \    evenCount++;\n        }\n        else\n        {\n            oddCount++;\n\
    \        }\n    }\n    if(evenCount % 2 == 0)\n    {\n        return \"YES\";\n\
    \    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn20w3ewp.d(19): Error: cannot implicitly convert expression `__r73[__key74]`
    of type `long` to `int`

    /tmp/tmpn20w3ewp.d(30): Error: cannot implicitly convert expression `__r75[__key76]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn20w3ewp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1Even = lst1.filter!(a => a % 2 == 0);\n\
    \    long[] lst2Odd = lst2.filter!(a => a % 2 != 0);\n    if (lst1Even.length\
    \ + lst2Odd.length >= lst1.length)\n        return \"YES\";\n    return \"NO\"\
    ;\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0lebxthf.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp0lebxthf.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0lebxthf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst3 = new long[lst1.length];\n    long[]\
    \ lst4 = new long[lst2.length];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    int l = 0;\n    foreach(long x; lst1)\n    {\n        if(x % 2 == 0)\n  \
    \      {\n            lst3[i] = x;\n            i++;\n        }\n        else\n\
    \        {\n            lst4[j] = x;\n            j++;\n        }\n    }\n   \
    \ foreach(long x; lst2)\n    {\n        if(x % 2 == 0)\n        {\n          \
    \  lst3[i] = x;\n            i++;\n        }\n        else\n        {\n      \
    \      lst4[j] = x;\n            j++;\n        }\n    }\n    if(i == lst1.length)\n\
    \    {\n        return \"YES\";\n    }\n    else\n    {\n        return \"NO\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmplrkv_gy3.d(45): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4288de]

    ??:? immutable(char)[] tmplrkv_gy3.exchange(long[], long[]) [0x427f3b]

    ??:? void tmplrkv_gy3.__unittest_L58_C1() [0x42810a]

    ??:? void tmplrkv_gy3.__modtest() [0x4285ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c88f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b79e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4309ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430e5c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430939]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b775]

    ??:? runModuleUnitTests [0x42c665]

    ??:? void rt.dmain2._d_run_main(int, char**, extern ('
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    bool isEven(long n)\n    {\n        return n % 2\
    \ == 0;\n    }\n    bool isOdd(long n)\n    {\n        return n % 2 != 0;\n  \
    \  }\n    bool isEvenList(long[] lst)\n    {\n        return all!(isEven)(lst);\n\
    \    }\n    bool isOddList(long[] lst)\n    {\n        return all!(isOdd)(lst);\n\
    \    }\n    bool isEvenOddList(long[] lst)\n    {\n        return any!(isEven)(lst)\
    \ && any!(isOdd)(lst);\n    }\n    bool isEvenEvenList(long[] lst)\n    {\n  \
    \      return all!(isEven)(lst);\n    }\n    bool isOddOddList(long[] lst)\n \
    \   {\n        return all!(isOdd)(lst);\n    }\n    bool isEvenOddList(long[]\
    \ lst1, long[] lst2)\n    {\n        return isEvenList(lst1) && isOddList(lst2);\n\
    \    }\n    bool isOddEvenList(long[] lst1, long[] lst2)\n    {\n        return\
    \ isOddList(lst1) && isEvenList(lst2);\n    }\n    bool isEvenEvenList(long[]\
    \ lst1, long[] lst2)\n    {\n        return isEvenList(lst1) && isEvenList(lst2);\n\
    \    }\n    bool isOddOddList(long[] lst1, long[] lst2)\n    {\n        return\
    \ isOddList(lst1) && isOddList(lst2);\n    }\n    bool isEvenOddList(long[] lst1,\
    \ long[] lst2, long[] lst3)\n    {\n        return isEvenList(lst1) && isOddList(lst2)\
    \ && isOddList(lst3);\n    }\n    bool isOddEvenList(long[] lst1, long[] lst2,\
    \ long[] lst3)\n    {\n        return isO\nunittest\n{\n    alias candidate =\
    \ exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyjhoovsn.d(68): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpyjhoovsn.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpyjhoovsn.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyjhoovsn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    /*\n    if(lst1.length == 1)\n    {\n        return\
    \ (lst1[0] % 2 == 0) ? \"YES\" : \"NO\";\n    }\n    else\n    {\n        if(lst1[0]\
    \ % 2 == 0)\n        {\n            return exchange(lst1[1..$], lst2);\n     \
    \   }\n        else\n        {\n            if(lst2.length == 1)\n           \
    \ {\n                return \"NO\";\n            }\n            else\n       \
    \     {\n                return exchange(lst1[1..$], lst2[1..$]);\n          \
    \  }\n        }\n    }\n    */\n    if(lst1.length == 1)\n    {\n        return\
    \ (lst1[0] % 2 == 0) ? \"YES\" : \"NO\";\n    }\n    else\n    {\n        if(lst1[0]\
    \ % 2 == 0)\n        {\n            return exchange(lst1[1..$], lst2);\n     \
    \   }\n        else\n        {\n            if(lst2.length == 1)\n           \
    \ {\n                return \"NO\";\n            }\n            else\n       \
    \     {\n                return exchange(lst1[1..$], lst2[1..$]);\n          \
    \  }\n        }\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv3e6eb27.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x42879d]

    ??:? void tmpv3e6eb27.__unittest_L64_C1() [0x4280c5]

    ??:? void tmpv3e6eb27.__modtest() [0x42851c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6b2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430755]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b689]

    ??:? runModuleUnitTests [0x42c579]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c60]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(x => x % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(x => x % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h1c5dic.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp6h1c5dic.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h1c5dic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(x => x % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(x => x % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h1c5dic.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp6h1c5dic.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h1c5dic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int even = 0;\n    int odd = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 0)\n            even++;\n        else\n  \
    \          odd++;\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n\
    \            even++;\n        else\n            odd++;\n    }\n    if(even % 2\
    \ == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv2_5kgb4.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpv2_5kgb4.__unittest_L38_C1() [0x4281a9]

    ??:? void tmpv2_5kgb4.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    bool isEven(long n) { return n % 2 == 0; }\n   \
    \ bool isOdd(long n) { return n % 2 != 0; }\n    bool isEvenList(long[] lst) {\
    \ return all!(isEven)(lst); }\n    bool isOddList(long[] lst) { return all!(isOdd)(lst);\
    \ }\n    bool isEvenOddList(long[] lst) { return isEvenList(lst) || isOddList(lst);\
    \ }\n    bool isEvenOddLists(long[] lst1, long[] lst2) { return isEvenOddList(lst1)\
    \ && isEvenOddList(lst2); }\n    bool isEvenOddLists(long[] lst1, long[] lst2,\
    \ long[] lst3) { return isEvenOddLists(lst1, lst2) && isEvenOddList(lst3); }\n\
    \    bool isEvenOddLists(long[] lst1, long[] lst2, long[] lst3, long[] lst4) {\
    \ return isEvenOddLists(lst1, lst2, lst3) && isEvenOddList(lst4); }\n    bool\
    \ isEvenOddLists(long[] lst1, long[] lst2, long[] lst3, long[] lst4, long[] lst5)\
    \ { return isEvenOddLists(lst1, lst2, lst3, lst4) && isEvenOddList(lst5); }\n\
    \    bool isEvenOddLists(long[] lst1, long[] lst2, long[] lst3, long[] lst4, long[]\
    \ lst5, long[] lst6) { return isEvenOddLists(lst1, lst2, lst3, lst4, lst5) &&\
    \ isEvenOddList(lst6); }\n    bool isEvenOddLists(long[] lst1, long[] lst2, long[]\
    \ lst3, long[] lst4, long[] lst5, long[] lst6, long[] lst7) { return isEven\n\
    unittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnbvbfqk6.d(28): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpnbvbfqk6.d(40): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpnbvbfqk6.d(40): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnbvbfqk6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long lst1_odd = 0;\n    long lst2_even = 0;\n  \
    \  foreach(e; lst1)\n    {\n        if(e % 2 != 0)\n            lst1_odd++;\n\
    \    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n            lst2_even++;\n\
    \    }\n    if(lst1_odd == lst2_even)\n        return \"YES\";\n    else\n   \
    \     return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppw8ztha8.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmppw8ztha8.__unittest_L34_C1() [0x4283cf]

    ??:? void tmppw8ztha8.__modtest() [0x428488]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int oddCount = 0;\n    foreach(e; lst1)\n    {\n\
    \        if(e % 2 == 1)\n            oddCount++;\n    }\n    foreach(e; lst2)\n\
    \    {\n        if(e % 2 == 0)\n            oddCount--;\n    }\n    if(oddCount\
    \ <= 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(num;\
    \ lst1)\n    {\n        if(isEven(num))\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    foreach(num; lst2)\n    {\n        if(isEven(num))\n        {\n         \
    \   evenCount++;\n        }\n        else\n        {\n            oddCount++;\n\
    \        }\n    }\n    if(evenCount > oddCount)\n    {\n        return \"YES\"\
    ;\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n   \
    \ alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L,\
    \ 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7gap_szg.d(21): Error: undefined identifier `isEven`

    /tmp/tmp7gap_szg.d(32): Error: undefined identifier `isEven`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gap_szg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(x => x % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(x => x % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h1c5dic.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp6h1c5dic.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h1c5dic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae\
    \ = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n \
    \   int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an\
    \ = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n \
    \   int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw\
    \ = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n \
    \   int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf\
    \ = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n \
    \   int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo\
    \ = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n \
    \   int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx\
    \ = 0;\n    int by = 0;\n    int bz\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpklnrut6y.d(87): Error: semicolon expected, not `unittest`

    /tmp/tmpklnrut6y.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpklnrut6y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(a => a % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(a => a % 2 == 0);\n    if (lst1_odd.length\
    \ == 0)\n        return \"YES\";\n    if (lst2_even.length == 0)\n        return\
    \ \"NO\";\n    if (lst1_odd.length > lst2_even.length)\n        return \"NO\"\
    ;\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfg8bq2yl.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpfg8bq2yl.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfg8bq2yl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto even = (long x) => x % 2 == 0;\n    auto odd\
    \ = (long x) => x % 2 != 0;\n    auto lst1_even = lst1.filter!even;\n    auto\
    \ lst1_odd = lst1.filter!odd;\n    auto lst2_even = lst2.filter!even;\n    auto\
    \ lst2_odd = lst2.filter!odd;\n    if (lst1_even.length + lst2_even.length ==\
    \ lst1.length)\n        return \"YES\";\n    if (lst1_odd.length + lst2_odd.length\
    \ == lst1.length)\n        return \"YES\";\n    return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzk16d4pl.d(19): Error: no property `filter` for type `long[]`

    /tmp/tmpzk16d4pl.d(20): Error: no property `filter` for type `long[]`

    /tmp/tmpzk16d4pl.d(21): Error: no property `filter` for type `long[]`

    /tmp/tmpzk16d4pl.d(22): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzk16d4pl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count1 = 0;\n    int count2 = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 != 0)\n        {\n            count1++;\n   \
    \     }\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n        {\n\
    \            count2++;\n        }\n    }\n    if(count1 == count2)\n    {\n  \
    \      return \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n\
    }\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmper9wepwl.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmper9wepwl.__unittest_L42_C1() [0x4283cb]

    ??:? void tmper9wepwl.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    for (int i = 0; i < lst1.length;\
    \ i++)\n    {\n        if (lst1[i] % 2 != 0)\n        {\n            count++;\n\
    \        }\n    }\n    for (int i = 0; i < lst2.length; i++)\n    {\n        if\
    \ (lst2[i] % 2 != 0)\n        {\n            count--;\n        }\n    }\n    if\
    \ (count <= 0)\n    {\n        return \"YES\";\n    }\n    else\n    {\n     \
    \   return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4gob79kz.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmp4gob79kz.__unittest_L41_C1() [0x428025]

    ??:? void tmp4gob79kz.__modtest() [0x42847c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c703]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b612]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430729]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430bd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]

    ??:? runModuleUnitTests [0x42c4d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bc0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    auto even = lst1.filter!(a => a % 2 == 0);\n   \
    \ auto odd = lst1.filter!(a => a % 2 != 0);\n    auto even2 = lst2.filter!(a =>\
    \ a % 2 == 0);\n    auto odd2 = lst2.filter!(a => a % 2 != 0);\n    if (even.length\
    \ == lst1.length)\n        return \"YES\";\n    if (even2.length >= odd.length)\n\
    \        return \"YES\";\n    return \"NO\";\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsnoagh5g.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpsnoagh5g.d(18): Error: no property `filter` for type `long[]`

    /tmp/tmpsnoagh5g.d(19): Error: no property `filter` for type `long[]`

    /tmp/tmpsnoagh5g.d(20): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsnoagh5g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    // Write your code here\n    int i = 0;\n    int\
    \ j = 0;\n    int count = 0;\n    while(i < lst1.length && j < lst2.length)\n\
    \    {\n        if(lst1[i] % 2 == 0)\n        {\n            i++;\n        }\n\
    \        else if(lst2[j] % 2 == 0)\n        {\n            j++;\n        }\n \
    \       else\n        {\n            count++;\n            i++;\n            j++;\n\
    \        }\n    }\n    if(count == 0)\n    {\n        return \"NO\";\n    }\n\
    \    else\n    {\n        return \"YES\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppxbninba.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmppxbninba.__unittest_L47_C1() [0x428031]

    ??:? void tmppxbninba.__modtest() [0x428488]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c70b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b61a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430731]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430be0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]

    ??:? runModuleUnitTests [0x42c4e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bc8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long evens = 0;\n    long odds = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            evens++;\n        else\n \
    \           odds++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \            evens++;\n        else\n            odds++;\n    }\n    if(evens\
    \ % 2 == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg3alrklu.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x42871d]

    ??:? void tmpg3alrklu.__unittest_L38_C1() [0x4281b5]

    ??:? void tmpg3alrklu.__modtest() [0x4284a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5be]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b84]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430661]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b595]

    ??:? runModuleUnitTests [0x42c485]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b6c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(l; lst1)\n    {\n  \
    \      if(l % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(l; lst2)\n    {\n        if(l % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count == 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7zskv73m.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmp7zskv73m.__unittest_L41_C1() [0x4283c7]

    ??:? void tmp7zskv73m.__modtest() [0x428480]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b59e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430641]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b575]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b4c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(a => a % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(a => a % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp21nb24z2.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp21nb24z2.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21nb24z2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee\
    \ = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n \
    \   int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn\
    \ = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n \
    \   int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww\
    \ = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n\
    \    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int\
    \ fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int\
    \ sss = 0;\n    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\
    \ = 0;\n    int\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpde5bmely.d(85): Error: no identifier for declarator `int`

    /tmp/tmpde5bmely.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde5bmely.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163963
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(a => a % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(a => a % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp21nb24z2.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp21nb24z2.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21nb24z2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163965
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 != 0)\n        {\n            odd1++;\n     \
    \   }\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 != 0)\n        {\n\
    \            odd2++;\n        }\n    }\n    if(odd1 == odd2)\n    {\n        return\
    \ \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0799hk7.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpt0799hk7.__unittest_L42_C1() [0x428199]

    ??:? void tmpt0799hk7.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(int i; lst1)\n    {\n\
    \        if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n \
    \   if(count == 0)\n    {\n        return \"YES\";\n    }\n    else\n    {\n \
    \       foreach(int i; lst1)\n        {\n            if(i % 2 != 0)\n        \
    \    {\n                foreach(int j; lst2)\n                {\n            \
    \        if(j % 2 == 0)\n                    {\n                        count--;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n        if(count == 0)\n        {\n            return\
    \ \"YES\";\n        }\n        else\n        {\n            return \"NO\";\n \
    \       }\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplithy79l.d(18): Error: cannot implicitly convert expression `__r73[__key74]`
    of type `long` to `int`

    /tmp/tmplithy79l.d(31): Error: cannot implicitly convert expression `__r75[__key76]`
    of type `long` to `int`

    /tmp/tmplithy79l.d(35): Error: cannot implicitly convert expression `__r77[__key78]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplithy79l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int n = lst1.length;\n    int m = lst2.length;\n\
    \    int[] a = new int[n];\n    int[] b = new int[m];\n    for (int i = 0; i <\
    \ n; i++) \n    {\n        a[i] = lst1[i] % 2;\n    }\n    for (int i = 0; i <\
    \ m; i++) \n    {\n        b[i] = lst2[i] % 2;\n    }\n    int suma = 0;\n   \
    \ int sumb = 0;\n    for (int i = 0; i < n; i++) \n    {\n        suma += a[i];\n\
    \    }\n    for (int i = 0; i < m; i++) \n    {\n        sumb += b[i];\n    }\n\
    \    if (suma == 0) \n    {\n        return \"YES\";\n    }\n    if (suma == n)\
    \ \n    {\n        return \"NO\";\n    }\n    if (suma == sumb) \n    {\n    \
    \    return \"YES\";\n    }\n    return \"NO\";\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzxtd3lcr.d(17): Error: cannot implicitly convert expression `lst1.length`
    of type `ulong` to `int`

    /tmp/tmpzxtd3lcr.d(18): Error: cannot implicitly convert expression `lst2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzxtd3lcr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(x => x % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(x => x % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h1c5dic.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp6h1c5dic.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h1c5dic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(l;\
    \ lst1)\n    {\n        if(l % 2 == 0)\n            evenCount++;\n        else\n\
    \            oddCount++;\n    }\n    foreach(l; lst2)\n    {\n        if(l % 2\
    \ == 0)\n            evenCount++;\n        else\n            oddCount++;\n   \
    \ }\n    if(evenCount % 2 == 0)\n        return \"YES\";\n    else\n        return\
    \ \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7xzve2hs.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmp7xzve2hs.__unittest_L38_C1() [0x4281a9]

    ??:? void tmp7xzve2hs.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long even = 0;\n    long odd = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            even++;\n        else\n  \
    \          odd++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \            even++;\n        else\n            odd++;\n    }\n    if(even % 2\
    \ == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplc7shky8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x42871d]

    ??:? void tmplc7shky8.__unittest_L38_C1() [0x4281b5]

    ??:? void tmplc7shky8.__modtest() [0x4284a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5be]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b84]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430661]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b595]

    ??:? runModuleUnitTests [0x42c485]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b6c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(x => x % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(x => x % 2 != 0);\n    if (lst1_even.length\
    \ + lst2_odd.length >= lst1.length)\n        return \"YES\";\n    else\n     \
    \   return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h1c5dic.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp6h1c5dic.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h1c5dic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_copy = lst1.dup;\n    long[] lst2_copy\
    \ = lst2.dup;\n    long[] lst1_even = lst1.filter!(a => a % 2 == 0);\n    long[]\
    \ lst2_odd = lst2.filter!(a => a % 2 != 0);\n    long[] lst2_even = lst2.filter!(a\
    \ => a % 2 == 0);\n    long[] lst1_odd = lst1.filter!(a => a % 2 != 0);\n    if\
    \ (lst1_odd.length == 0)\n        return \"YES\";\n    if (lst2_odd.length ==\
    \ 0)\n        return \"NO\";\n    if (lst1_odd.length == lst2_odd.length)\n  \
    \      return \"YES\";\n    if (lst1_odd.length > lst2_odd.length)\n        return\
    \ \"NO\";\n    if (lst1_odd.length < lst2_odd.length)\n    {\n        if (lst1_even.length\
    \ + lst1_odd.length < lst2_even.length + lst2_odd.length)\n            return\
    \ \"NO\";\n        else\n            return \"YES\";\n    }\n}\nunittest\n{\n\
    \    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp799g8di_.d(19): Error: no property `filter` for type `long[]`

    /tmp/tmp799g8di_.d(20): Error: no property `filter` for type `long[]`

    /tmp/tmp799g8di_.d(21): Error: no property `filter` for type `long[]`

    /tmp/tmp799g8di_.d(22): Error: no property `filter` for type `long[]`

    /tmp/tmp799g8di_.d(15): Error: function `tmp799g8di_.exchange` no `return exp;`
    or `assert(0);` at end of function

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp799g8di_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evens = 0;\n    int odds = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e%2 == 0)\n            evens++;\n        else\n   \
    \         odds++;\n    }\n    foreach(e; lst2)\n    {\n        if(e%2 == 0)\n\
    \            evens++;\n        else\n            odds++;\n    }\n    if(evens\
    \ > odds)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6an115fq.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmp6an115fq.__unittest_L38_C1() [0x427f5a]

    ??:? void tmp6an115fq.__modtest() [0x42848c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int odd1 = 0;\n    int odd2 = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 != 0)\n            odd1++;\n    }\n    foreach(e;\
    \ lst2)\n    {\n        if(e % 2 != 0)\n            odd2++;\n    }\n    if(odd1\
    \ == odd2)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpinn50ph8.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428705]

    ??:? void tmpinn50ph8.__unittest_L34_C1() [0x428199]

    ??:? void tmpinn50ph8.__modtest() [0x428484]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430649]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b57d]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    // Write your code here\n    int lst1_even = 0;\n\
    \    int lst2_even = 0;\n    foreach(num; lst1)\n    {\n        if(num % 2 ==\
    \ 0)\n        {\n            lst1_even++;\n        }\n    }\n    foreach(num;\
    \ lst2)\n    {\n        if(num % 2 == 0)\n        {\n            lst2_even++;\n\
    \        }\n    }\n    if(lst1_even == lst1.length || lst2_even == lst2.length)\n\
    \    {\n        return \"YES\";\n    }\n    else\n    {\n        return \"NO\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_g64o6ej.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x42870d]

    ??:? void tmp_g64o6ej.__unittest_L43_C1() [0x427f5e]

    ??:? void tmp_g64o6ej.__modtest() [0x428490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b585]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    bool isEven(long n) { return n % 2 == 0; }\n   \
    \ long[] lst1Even = lst1.filter!isEven;\n    long[] lst2Odd = lst2.filter!(n =>\
    \ !isEven(n));\n    if (lst1Even.length == lst1.length) return \"YES\";\n    if\
    \ (lst2Odd.length == 0) return \"NO\";\n    return lst1Even.length < lst1.length\
    \ ? \"YES\" : \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n   \
    \ assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjjel7h1r.d(18): Error: no property `filter` for type `long[]`

    /tmp/tmpjjel7h1r.d(19): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjjel7h1r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163966
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int count = 0;\n    foreach(i; lst1)\n    {\n  \
    \      if(i % 2 != 0)\n        {\n            count++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count <= 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odds = lst1.filter!(x => x % 2 != 0);\n\
    \    long[] lst2_evens = lst2.filter!(x => x % 2 == 0);\n    if (lst1_odds.length\
    \ <= lst2_evens.length)\n        return \"YES\";\n    else\n        return \"\
    NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpocyt9kpb.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmpocyt9kpb.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocyt9kpb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    int count2 = 0;\n    int count3 = 0;\n    int count4 = 0;\n    int count5\
    \ = 0;\n    int count6 = 0;\n    int count7 = 0;\n    int count8 = 0;\n    int\
    \ count9 = 0;\n    int count10 = 0;\n    int count11 = 0;\n    int count12 = 0;\n\
    \    int count13 = 0;\n    int count14 = 0;\n    int count15 = 0;\n    int count16\
    \ = 0;\n    int count17 = 0;\n    int count18 = 0;\n    int count19 = 0;\n   \
    \ int count20 = 0;\n    int count21 = 0;\n    int count22 = 0;\n    int count23\
    \ = 0;\n    int count24 = 0;\n    int count25 = 0;\n    int count26 = 0;\n   \
    \ int count27 = 0;\n    int count28 = 0;\n    int count29 = 0;\n    int count30\
    \ = 0;\n    int count31 = 0;\n    int count32 = 0;\n    int count33 = 0;\n   \
    \ int count34 = 0;\n    int count35 = 0;\n    int count36 = 0;\n    int count37\
    \ = 0;\n    int count38 = 0;\n    int count39 = 0;\n    int count40 = 0;\n   \
    \ int count41 = 0;\n    int count42 = 0;\n    int count43 = 0;\n    int count44\
    \ = 0;\n    int count45 = 0;\n    int count46 = 0;\n    int count47 = 0;\n   \
    \ int count48 = 0;\n    int count49 = 0;\n    int count50 = 0;\n    int count51\
    \ = 0;\n    int count52 = 0;\n    int count53 = 0;\n    int count54 = 0;\n   \
    \ int count55 = 0;\n    int count56 = 0;\n    int count57 = 0;\n    int count58\
    \ = 0;\n    int count59 = 0;\n    int count60 = 0;\n    int count61 = 0;\n   \
    \ int count62 = 0;\n\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptxesfx1u.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxesfx1u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evens = 0;\n    int odds = 0;\n    foreach(i;\
    \ lst1)\n    {\n        if(i % 2 == 0)\n            evens++;\n        else\n \
    \           odds++;\n    }\n    foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n\
    \            evens++;\n        else\n            odds++;\n    }\n    if(evens\
    \ % 2 == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpidu75amw.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpidu75amw.__unittest_L38_C1() [0x4281a9]

    ??:? void tmpidu75amw.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_even = lst1.filter!(a => a % 2 == 0);\n\
    \    long[] lst2_odd = lst2.filter!(a => a % 2 != 0);\n    return lst1_even.length\
    \ + lst2_odd.length >= lst1.length ? \"YES\" : \"NO\";\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp311cy81x.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp311cy81x.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp311cy81x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    // Write your code here\n    int count = 0;\n  \
    \  for(int i = 0; i < lst1.length; i++)\n    {\n        if(lst1[i] % 2 != 0)\n\
    \        {\n            count++;\n        }\n    }\n    for(int i = 0; i < lst2.length;\
    \ i++)\n    {\n        if(lst2[i] % 2 != 0)\n        {\n            count--;\n\
    \        }\n    }\n    if(count == 0)\n    {\n        return \"YES\";\n    }\n\
    \    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"\
    YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L,\
    \ 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L])\
    \ == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn5d15fls.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x4286fd]

    ??:? void tmpn5d15fls.__unittest_L42_C1() [0x428191]

    ??:? void tmpn5d15fls.__modtest() [0x42847c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c703]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b612]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430729]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430bd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]

    ??:? runModuleUnitTests [0x42c4d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bc0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163966
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    int evens = 0;\n    int odds = 0;\n    foreach(e;\
    \ lst1)\n    {\n        if(e % 2 == 0)\n            evens++;\n        else\n \
    \           odds++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n\
    \            evens++;\n        else\n            odds++;\n    }\n    if(evens\
    \ % 2 == 0)\n        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpab2_s8ry.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428715]

    ??:? void tmpab2_s8ry.__unittest_L38_C1() [0x4281a9]

    ??:? void tmpab2_s8ry.__modtest() [0x428494]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430659]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b58d]

    ??:? runModuleUnitTests [0x42c47d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b64]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163964
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n         \
    \   It is assumed that the input lists will be non-empty.\n    \n*/\nstring exchange(long[]\
    \ lst1, long[] lst2) \n{\n    long[] lst1_odd = lst1.filter!(x => x % 2 != 0);\n\
    \    long[] lst2_even = lst2.filter!(x => x % 2 == 0);\n    if (lst1_odd.length\
    \ == 0)\n        return \"YES\";\n    if (lst2_even.length == 0)\n        return\
    \ \"NO\";\n    if (lst1_odd.length > lst2_even.length)\n        return \"NO\"\
    ;\n    return \"YES\";\n}\nunittest\n{\n    alias candidate = exchange;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5zq1mno7.d(17): Error: no property `filter` for type `long[]`

    /tmp/tmp5zq1mno7.d(18): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5zq1mno7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163964
