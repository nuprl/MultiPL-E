language: d
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11smd35c.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11smd35c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    long row = 0;\n    foreach(row_; lst)\n  \
    \  {\n        long col = 0;\n        foreach(col_; row_)\n        {\n        \
    \    if(col_ == x)\n            {\n                res ~= tuple(row, col);\n \
    \           }\n            col++;\n        }\n        row++;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn9jtz7u6.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a51d]

    ??:? void tmpn9jtz7u6.__unittest_L36_C1() [0x428710]

    ??:? void tmpn9jtz7u6.__modtest() [0x429470]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f823]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c765]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1d1]

    ??:? runModuleUnitTests [0x42f5f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a96c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ val; row)\n        {\n            if(val == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    res.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n    return res;\n}\n/*\n\
    \    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) ==\n    [(1, 1)]\n    \n  \
    \  get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 6) ==\n    [(1, 2)]\n    \n    get_row([[1,\
    \ 2, 3], [4, 5, 6], [7, 8, 9]], 7) ==\n    [(2, 0)]\n    \n    get_row([[1, 2,\
    \ 3], [4, 5, 6], [7, 8, 9]], 8) ==\n    [(2, 1)]\n    \n    get_row([[1, 2, 3],\
    \ [4, 5, 6], [7, 8, 9]], 9) ==\n    [(2, 2)]\n    \n    get_row([[1, 2, 3], [4,\
    \ 5, 6], [7, 8, 9]], 10) ==\n    []\n    \n    get_row([[1, 2, 3], [4, 5, 6],\
    \ [7, 8, 9]], 1) ==\n    [(0, 0)]\n    \n    get_row([[1, 2, 3], [4, 5, 6], [7,\
    \ 8, 9]], 2) ==\n    [(0, 1)]\n    \n    get_row([[1, 2, 3], [4, 5, 6], [7, 8,\
    \ 9]], 3) ==\n    [(0, 2)]\n    \n    get_row([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\
    \ 4\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplq9hlsao.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplq9hlsao.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst) \n    {\n        foreach(j,\
    \ col; row) \n        {\n            if(col == x) \n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5pnjuarj.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pnjuarj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    for (long i = 0; i < lst.length;\
    \ i++) \n    {\n        for (long j = 0; j < lst[i].length; j++) \n        {\n\
    \            if (lst[i][j] == x) \n            {\n                result ~= tuple(i,\
    \ j);\n            }\n        }\n    }\n    return result.sort!((a, b) => a[0]\
    \ < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tvw0490.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tvw0490.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdkfi1l5.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdkfi1l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = [];\n    foreach(i, row; lst)\n    {\n        auto cols = row.indexOf(x);\n\
    \        if(cols != -1)\n        {\n            res ~= tuple(i, cols);\n     \
    \   }\n    }\n    return res.sort!((a, b) => a[0] < b[0] || (a[0] == b[0] && a[1]\
    \ > b[1]));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprn01y3xg.d(22): Error: no property `indexOf` for type `long[]`

    /tmp/tmprn01y3xg.d(28): Error: no property `sort` for type `void[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprn01y3xg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = [];\n    foreach(i, row; lst)\n    {\n        foreach(j, elem;\
    \ row)\n        {\n            if(elem == x)\n            {\n                res\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcbap3dn5.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `void[]`

    /tmp/tmpcbap3dn5.d(30): Error: cannot implicitly convert expression `res` of type
    `void[]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcbap3dn5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ val; row)\n        {\n            if(val == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmff1a14a.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmff1a14a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, e; row)\n        {\n            if(e == x)\n            {\n\
    \                res ~= tuple(i, j);\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvla1jrj4.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvla1jrj4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result.sort!((a, b) => a[0] < b[0] || (a[0]\
    \ == b[0] && a[1] > b[1]));\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpda3dkvp6.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    /tmp/tmpda3dkvp6.d(30): Error: no property `sort` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpda3dkvp6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(long row, long[] cols; lst)\n \
    \   {\n        foreach(long col; cols)\n        {\n            if(col == x)\n\
    \            {\n                result ~= tuple(row, col);\n            }\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp36pust_g.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a505]

    ??:? void tmp36pust_g.__unittest_L32_C1() [0x4286f8]

    ??:? void tmp36pust_g.__modtest() [0x429458]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f80b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c74d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7dc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6d9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1b9]

    ??:? runModuleUnitTests [0x42f5e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a954]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst) \n    {\n        foreach(j,\
    \ item; row) \n        {\n            if (item == x) \n            {\n       \
    \         result ~= tuple(i, j);\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpynnzu6w0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpynnzu6w0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdkfi1l5.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdkfi1l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = [];\n    foreach(i, row; lst)\n    {\n        auto pos = row.find(x);\n\
    \        if(pos != -1)\n        {\n            res ~= tuple(i, pos);\n       \
    \ }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa3gprrre.d(22): Error: no property `find` for type `long[]`

    /tmp/tmpa3gprrre.d(28): Error: cannot implicitly convert expression `res` of type
    `void[]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa3gprrre.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto ret = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                ret ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu1vf6qfc.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu1vf6qfc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] row = new long[];\n    Tuple!(long, long)[] result = new Tuple!(long,\
    \ long)[];\n    foreach(i, row; lst)\n    {\n        foreach(j, item; row)\n \
    \       {\n            if(item == x)\n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnswu_vzr.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpnswu_vzr.d(20): Error: new can only create structs, dynamic arrays or
    class objects, not `Tuple!(long, long)[]`''s

    /tmp/tmpnswu_vzr.d(21): Error: variable `row` is shadowing variable `tmpnswu_vzr.get_row.row`

    /tmp/tmpnswu_vzr.d(27): Error: cannot append type `Tuple!(ulong, ulong)` to type
    `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnswu_vzr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result.sort!((a, b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppx4382bf.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppx4382bf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, item; row)\n        {\n            if(item == x)\n       \
    \     {\n                result ~= tuple(i, j);\n            }\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp532vlya_.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp532vlya_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, val; row)\n        {\n            if(val == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzyvw9umv.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzyvw9umv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, item; row)\n        {\n            if(item == x)\n       \
    \     {\n                result ~= tuple(i, j);\n            }\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp532vlya_.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp532vlya_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdkfi1l5.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdkfi1l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, e; row)\n        {\n            if(e == x)\n            {\n\
    \                result ~= tuple(i, j);\n            }\n        }\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplqkjb6k6.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplqkjb6k6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, elem; row)\n        {\n            if(elem == x)\n       \
    \     {\n                result ~= tuple(i, j);\n            }\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgdu94nrk.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgdu94nrk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdkfi1l5.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdkfi1l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, item; row)\n        {\n            if(item == x)\n        \
    \    {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgsrwxhfj.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgsrwxhfj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    long row = 0;\n    foreach(row_; lst)\n\
    \    {\n        long col = 0;\n        foreach(col_; row_)\n        {\n      \
    \      if(col_ == x)\n            {\n                result ~= tuple(row, col);\n\
    \            }\n            col++;\n        }\n        row++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt0fskyfy.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a51d]

    ??:? void tmpt0fskyfy.__unittest_L36_C1() [0x428710]

    ??:? void tmpt0fskyfy.__modtest() [0x429470]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f823]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c765]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1d1]

    ??:? runModuleUnitTests [0x42f5f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a96c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, el; row)\n        {\n            if(el == x)\n            {\n\
    \                res ~= tuple(i, j);\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp456tlwew.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp456tlwew.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst) \n    {\n        foreach(j,\
    \ col; row) \n        {\n            if(col == x) \n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5pnjuarj.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pnjuarj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    res.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5tbnzqr_.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    /tmp/tmp5tbnzqr_.d(30): Error: no property `sort` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5tbnzqr_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, e; row)\n        {\n            if(e == x)\n            {\n\
    \                res ~= tuple(i, j);\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvla1jrj4.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvla1jrj4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = [];\n    foreach(i, row; lst)\n    {\n        foreach(j, element;\
    \ row)\n        {\n            if(element == x)\n            {\n             \
    \   result ~= tuple(i, j);\n            }\n        }\n    }\n    return result.sort!((a,\
    \ b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9rstqy9s.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `void[]`

    /tmp/tmp9rstqy9s.d(30): Error: no property `sort` for type `void[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9rstqy9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = [];\n    foreach(i, row; lst)\n    {\n        foreach(j, col;\
    \ row)\n        {\n            if(col == x)\n            {\n                res\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return res.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphgrs2613.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `void[]`

    /tmp/tmphgrs2613.d(30): Error: no property `sort` for type `void[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphgrs2613.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    for (long i = 0; i < lst.length;\
    \ i++) \n    {\n        for (long j = 0; j < lst[i].length; j++) \n        {\n\
    \            if (lst[i][j] == x) \n            {\n                result ~= tuple(i,\
    \ j);\n            }\n        }\n    }\n    return result.sort!((a, b) => a[0]\
    \ < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tvw0490.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tvw0490.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(row; 0..lst.length)\n\
    \    {\n        foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf1dz72zd.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf1dz72zd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdkfi1l5.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdkfi1l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(long i, long[] row; lst)\n    {\n\
    \        foreach(long j, long val; row)\n        {\n            if(val == x)\n\
    \            {\n                result ~= tuple(i, j);\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiyi0bruw.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a50d]

    ??:? void tmpiyi0bruw.__unittest_L32_C1() [0x428700]

    ??:? void tmpiyi0bruw.__modtest() [0x429460]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f813]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c755]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1c1]

    ??:? runModuleUnitTests [0x42f5e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a95c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result.sort!((a, b) => a[0] < b[0] || (a[0]\
    \ == b[0] && a[1] > b[1]));\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpda3dkvp6.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    /tmp/tmpda3dkvp6.d(30): Error: no property `sort` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpda3dkvp6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(long i, row; lst)\n    {\n    \
    \    foreach(long j, elem; row)\n        {\n            if(elem == x)\n      \
    \      {\n                result ~= tuple(i, j);\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmutfmild.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a50d]

    ??:? void tmpmutfmild.__unittest_L32_C1() [0x428700]

    ??:? void tmpmutfmild.__modtest() [0x429460]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f813]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c755]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1c1]

    ??:? runModuleUnitTests [0x42f5e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a95c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(long i, row; lst)\n    {\n    \
    \    foreach(long j, val; row)\n        {\n            if(val == x)\n        \
    \    {\n                result ~= tuple(i, j);\n            }\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw0jfusqa.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a50d]

    ??:? void tmpw0jfusqa.__unittest_L32_C1() [0x428700]

    ??:? void tmpw0jfusqa.__modtest() [0x429460]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f813]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c755]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1c1]

    ??:? runModuleUnitTests [0x42f5e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a95c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] result;\n    foreach(i, row; lst)\n    {\n        foreach(j, col;\
    \ row)\n        {\n            if(col == x)\n            {\n                result\
    \ ~= [i, j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuq21ew03.d(30): Error: cannot implicitly convert expression `result`
    of type `long[][]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuq21ew03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ el; row)\n        {\n            if(el == x)\n            {\n              \
    \  result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl1xezz_u.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl1xezz_u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] result = [];\n    foreach(i, row; lst)\n    {\n        long[] tmp\
    \ = [];\n        foreach(j, col; row)\n        {\n            if(col == x)\n \
    \           {\n                tmp ~= j;\n            }\n        }\n        if(tmp.length\
    \ > 0)\n        {\n            result ~= tmp;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp36rin98_.d(35): Error: cannot implicitly convert expression `result`
    of type `long[][]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp36rin98_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = [];\n    foreach(i, row; lst)\n    {\n        foreach(j, col;\
    \ row)\n        {\n            if(col == x)\n            {\n                res\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_9v2ofco.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `void[]`

    /tmp/tmp_9v2ofco.d(30): Error: cannot implicitly convert expression `res` of type
    `void[]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_9v2ofco.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    res.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5tbnzqr_.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    /tmp/tmp5tbnzqr_.d(30): Error: no property `sort` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5tbnzqr_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, elem; row)\n        {\n            if(elem == x)\n       \
    \     {\n                result ~= tuple(i, j);\n            }\n        }\n  \
    \  }\n    return result.sort!((a, b) => a[0] < b[0] || (a[0] == b[0] && a[1] >\
    \ b[1]));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9kjk6t6h.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9kjk6t6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = [];\n    foreach(i, row; lst)\n    {\n        foreach(j, col;\
    \ row)\n        {\n            if(col == x)\n            {\n                res\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_9v2ofco.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `void[]`

    /tmp/tmp_9v2ofco.d(30): Error: cannot implicitly convert expression `res` of type
    `void[]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_9v2ofco.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = [];\n    foreach(i, row; lst)\n    {\n        foreach(j, col;\
    \ row)\n        {\n            if(col == x)\n            {\n                result\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return result.sort!((a,\
    \ b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi68ahyz1.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `void[]`

    /tmp/tmpi68ahyz1.d(30): Error: no property `sort` for type `void[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi68ahyz1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11smd35c.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11smd35c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; lst)\n    {\n        foreach(column;\
    \ row)\n        {\n            if(column == x)\n            {\n              \
    \  result ~= tuple(lst.indexOf(row), row.indexOf(column));\n            }\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf77sd4vi.d(26): Error: no property `indexOf` for type `long[][]`

    /tmp/tmpf77sd4vi.d(26): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf77sd4vi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, elem; row)\n        {\n            if(elem == x)\n       \
    \     {\n                result ~= tuple(i, j);\n            }\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgdu94nrk.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgdu94nrk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11smd35c.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11smd35c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ val; row)\n        {\n            if(val == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    res.sort!((a, b)\
    \ => a[0] < b[0] || a[0] == b[0] && a[1] > b[1]);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfft7ro6p.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    /tmp/tmpfft7ro6p.d(30): Error: no property `sort` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfft7ro6p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11smd35c.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11smd35c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] res = [];\n    foreach(i, row; lst)\n    {\n        long[] tmp =\
    \ [];\n        foreach(j, col; row)\n        {\n            if(col == x)\n   \
    \         {\n                tmp ~= j;\n            }\n        }\n        if(tmp.length)\n\
    \        {\n            res ~= [i, tmp];\n        }\n    }\n    res.sort!(\"a[0]\
    \ < b[0]\");\n    foreach(i, row; res)\n    {\n        row[1].sort!(\"a > b\"\
    );\n    }\n    Tuple!(long, long)[] res2 = [];\n    foreach(i, row; res)\n   \
    \ {\n        foreach(j, col; row[1])\n        {\n            res2 ~= tuple(row[0],\
    \ col);\n        }\n    }\n    return res2;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpges3jhm5.d(32): Error: incompatible types for `(i) : (tmp)`: `ulong`
    and `long[]`

    /tmp/tmpges3jhm5.d(35): Error: no property `sort` for type `long[][]`

    /tmp/tmpges3jhm5.d(38): Error: no property `sort` for type `long`

    /tmp/tmpges3jhm5.d(43): Error: invalid `foreach` aggregate `row[1]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpges3jhm5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdkfi1l5.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdkfi1l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = [];\n    foreach(i, row; lst)\n    {\n        foreach(j, col;\
    \ row)\n        {\n            if(col == x)\n            {\n                res\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return res.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphgrs2613.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `void[]`

    /tmp/tmphgrs2613.d(30): Error: no property `sort` for type `void[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphgrs2613.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdkfi1l5.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdkfi1l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(long i, long[] row; lst)\n    {\n\
    \        foreach(long j, long elem; row)\n        {\n            if(elem == x)\n\
    \            {\n                result ~= tuple(i, j);\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnxrgdd9h.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a50d]

    ??:? void tmpnxrgdd9h.__unittest_L32_C1() [0x428700]

    ??:? void tmpnxrgdd9h.__modtest() [0x429460]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f813]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c755]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1c1]

    ??:? runModuleUnitTests [0x42f5e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a95c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] rows = [];\n    foreach(i, row; lst)\n    {\n        foreach(j, col;\
    \ row)\n        {\n            if(col == x)\n            {\n                rows\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return rows.sort!((a,\
    \ b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo18cwz5g.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `long[]`

    /tmp/tmpo18cwz5g.d(30): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo18cwz5g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11smd35c.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11smd35c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ e; row)\n        {\n            if(e == x)\n            {\n                result\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1hkbw5b6.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1hkbw5b6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto ret = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                ret ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu1vf6qfc.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu1vf6qfc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11smd35c.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11smd35c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11smd35c.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11smd35c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ el; row)\n        {\n            if(el == x)\n            {\n              \
    \  res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo30lgdng.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo30lgdng.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst) \n    {\n\
    \        foreach(j, col; row) \n        {\n            if(col == x) \n       \
    \     {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz_fif72r.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_fif72r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, value; row)\n        {\n            if(value == x)\n     \
    \       {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkyhzntdv.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkyhzntdv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst) \n    {\n        foreach(j,\
    \ col; row) \n        {\n            if(col == x) \n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5pnjuarj.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pnjuarj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(row; 0..lst.length)\n    {\n  \
    \      foreach(col; 0..lst[row].length)\n        {\n            if(lst[row][col]\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzdkfi1l5.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdkfi1l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst) \n    {\n        foreach(j,\
    \ col; row) \n        {\n            if(col == x) \n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5pnjuarj.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pnjuarj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ val; row)\n        {\n            if(val == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbgjkw7_b.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbgjkw7_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, val; row)\n        {\n            if(val == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzyvw9umv.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzyvw9umv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst) \n    {\n        foreach(j,\
    \ col; row) \n        {\n            if(col == x) \n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5pnjuarj.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pnjuarj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(long i, row; lst)\n    {\n    \
    \    foreach(long j, col; row)\n        {\n            if(col == x)\n        \
    \    {\n                result ~= tuple(i, j);\n            }\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpexw3iu9v.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a50d]

    ??:? void tmpexw3iu9v.__unittest_L32_C1() [0x428700]

    ??:? void tmpexw3iu9v.__modtest() [0x429460]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f813]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c755]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1c1]

    ??:? runModuleUnitTests [0x42f5e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a95c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, item; row)\n        {\n            if(item == x)\n       \
    \     {\n                result ~= tuple(i, j);\n            }\n        }\n  \
    \  }\n    return result.sort!((a, b) => a[0] < b[0] || (a[0] == b[0] && a[1] >\
    \ b[1]));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5uq7fu3g.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5uq7fu3g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(long i, long[] row; lst)\n    {\n\
    \        foreach(long j, long val; row)\n        {\n            if(val == x)\n\
    \            {\n                result ~= tuple(i, j);\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiyi0bruw.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a50d]

    ??:? void tmpiyi0bruw.__unittest_L32_C1() [0x428700]

    ??:? void tmpiyi0bruw.__modtest() [0x429460]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f813]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c755]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1c1]

    ??:? runModuleUnitTests [0x42f5e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a95c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ e; row)\n        {\n            if(e == x)\n            {\n                result\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1hkbw5b6.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1hkbw5b6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] result;\n    long row = 0;\n    foreach(row_; lst)\n    {\n    \
    \    long col = 0;\n        foreach(col_; row_)\n        {\n            if(col_\
    \ == x)\n            {\n                result ~= tuple(row, col);\n         \
    \   }\n            col++;\n        }\n        row++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplaqa1lx8.d(28): Error: cannot append type `Tuple!(long, long)`
    to type `long[][]`

    /tmp/tmplaqa1lx8.d(34): Error: cannot implicitly convert expression `result` of
    type `long[][]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplaqa1lx8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqa1p0td8.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqa1p0td8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                res ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpn5kdei.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpn5kdei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    res.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5tbnzqr_.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    /tmp/tmp5tbnzqr_.d(30): Error: no property `sort` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5tbnzqr_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    res ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh917aj0.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh917aj0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ca9iaxb.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ca9iaxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11smd35c.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11smd35c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto res = [];\n    foreach(i, row; lst)\n    {\n        foreach(j, col;\
    \ row)\n        {\n            if(col == x)\n            {\n                res\
    \ ~= tuple(i, j);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_9v2ofco.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `void[]`

    /tmp/tmp_9v2ofco.d(30): Error: cannot implicitly convert expression `res` of type
    `void[]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_9v2ofco.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ val; row)\n        {\n            if(val == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbgjkw7_b.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbgjkw7_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ elem; row)\n        {\n            if(elem == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp11smd35c.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11smd35c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    auto ret = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n \
    \       foreach(j, col; row)\n        {\n            if(col == x)\n          \
    \  {\n                ret ~= tuple(i, j);\n            }\n        }\n    }\n \
    \   return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu1vf6qfc.d(19): Error: new can only create structs, dynamic arrays
    or class objects, not `Tuple!(long, long)[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu1vf6qfc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7239kx2w.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7239kx2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v3lklcw.d(26): Error: cannot append type `Tuple!(ulong, ulong)`
    to type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v3lklcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164468
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result;\n    foreach(long i, row; lst)\n    {\n    \
    \    foreach(long j, item; row)\n        {\n            if(item == x)\n      \
    \      {\n                result ~= tuple(i, j);\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkt4ugko7.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x42a50d]

    ??:? void tmpkt4ugko7.__unittest_L32_C1() [0x428700]

    ??:? void tmpkt4ugko7.__modtest() [0x429460]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42f813]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a1ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c755]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c7e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c6e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a1c1]

    ??:? runModuleUnitTests [0x42f5e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a95c]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42a8e3]

    ??:? _d_run_main [0x42a84e]

    ??:? main [0x429473]

    ??:? __libc_start_main [0xcc515554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164469
