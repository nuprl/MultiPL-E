language: d
name: HumanEval_58_common
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n \
    \   {\n        result ~= e;\n    }\n    foreach (e; l2)\n    {\n        result\
    \ ~= e;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] intersection(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ difference(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (!(e in l2))\n        {\n            result ~= e;\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] symmetricDifference(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (!(e in\
    \ l2))\n        {\n            result ~= e;\n        }\n    }\n    foreach (e;\
    \ l2)\n    {\n        if (!(e in l1))\n        {\n            result ~= e;\n \
    \       }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] symmetricDifference(long[]\
    \ l1, long[] l2) \n{\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0k7fckwe.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmp0k7fckwe.d(25): Error: { } expected following `union` declaration

    /tmp/tmp0k7fckwe.d(25): Error: declaration expected, not `(`

    /tmp/tmp0k7fckwe.d(28): Error: declaration expected, not `foreach`

    /tmp/tmp0k7fckwe.d(28): Error: no identifier for declarator `l1`

    /tmp/tmp0k7fckwe.d(28): Error: declaration expected, not `)`

    /tmp/tmp0k7fckwe.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0k7fckwe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto l = new long[](l1.length);\n    long i = 0;\n    foreach (e1;\
    \ l1)\n    {\n        foreach (e2; l2)\n        {\n            if (e1 == e2)\n\
    \            {\n                l[i] = e1;\n                i++;\n           \
    \ }\n        }\n    }\n    l.length = i;\n    l.sort;\n    return l;\n}\n/*\n\
    Return sorted unique elements for two lists.\n        \n    \n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    auto l = new long[](l1.length + l2.length);\n    long\
    \ i = 0;\n    foreach (e1; l1)\n    {\n        l[i] = e1;\n        i++;\n    }\n\
    \    foreach (e2; l2)\n    {\n        l[i] = e2;\n        i++;\n    }\n    l.length\
    \ = i;\n    l.sort;\n    return l;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[] l2, long[] l3) \n\
    {\n    auto l = new long[](l1.length + l2.length + l3.length);\n    long i = 0;\n\
    \    foreach (e1; l1)\n    {\n        l[i] = e1;\n        i++;\n    }\n    foreach\
    \ (e2; l2)\n    {\n        l[i] = e2;\n        i++;\n    }\n    foreach (e3; l3)\n\
    \    {\n        l[i] = e3;\n        i++;\n    }\n    l.length = i;\n    l.sort;\n\
    \    return l;\n}\n/*\nReturn sorted unique elements for two lists.\n        \n\
    \    \n*/\nlong[] unique(long[] l1, long[] l2, long[] l3, long[] l4) \n{\n   \
    \ auto l = new long[](l1.length + l2.length + l3.length + l4.length);\n\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ico1wfd.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ico1wfd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (long x; l1)\n    {\n\
    \        if (x in l2)\n            result ~= x;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n   \
    \ foreach (long x; l1)\n    {\n        if (x in l2)\n            result ~= x;\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[];\n    foreach (long x; l1)\n    {\n        if\
    \ (x in l2)\n            result ~= x;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n   \
    \ foreach (long x; l1)\n    {\n        if (x in l2)\n            result ~= x;\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[];\n    foreach (long x; l1)\n    {\n        if\
    \ (x in l2)\n            result ~= x;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n   \
    \ foreach (long x; l1)\n    {\n        if (x in l2)\n            result ~= x;\n\
    \    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu7jlj1c6.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpu7jlj1c6.d(13): Error: incompatible types for `(x) in (l2)`: `long` and
    `long[]`

    /tmp/tmpu7jlj1c6.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpu7jlj1c6.d(25): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmpu7jlj1c6.d(28): Error: incompatible types for `(x) in (l2)`: `long` and
    `long[]`

    /tmp/tmpu7jlj1c6.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmpu7jlj1c6.d(40): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmpu7jlj1c6.d(43): Error: incompatible types for `(x) in (l2)`: `long` and
    `long[]`

    /tmp/tmpu7jlj1c6.d(46): Error: no property `sort` for type `long[]`

    /tmp/tmpu7jlj1c6.d(55): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmpu7jlj1c6.d(58): Error: incompatible types for `(x) in (l2)`: `long` and
    `long[]`

    /tmp/tmpu7jlj1c6.d(61): Error: n'
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto result = new long[];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3)\
    \ \n{\n    return common(common(l1, l2), l3);\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2, long[] l3, long[] l4) \n{\n    return common(common(l1, l2), common(l3,\
    \ l4));\n}\n/*\nReturn sorted unique common elements for two lists.\n        \n\
    \    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3, long[] l4, long[] l5)\
    \ \n{\n    return common(common(l1, l2), common(l3, l4, l5));\n}\n/*\nReturn sorted\
    \ unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2, long[] l3, long[] l4, long[] l5, long[] l6) \n{\n    return common(common(l1,\
    \ l2), common(l3, l4, l5, l6));\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3,\
    \ long[] l4, long[] l5, long[] l6, long[] l7) \n{\n    return common(common(l1,\
    \ l2), common(l3, l4, l5, l6, l7));\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[]\
    \ l3, long[] l4, long[] l5, long[] l6, long[] l7, long[] l8) \n\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1usnj1zf.d(72): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1usnj1zf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1) \n    {\n        if (elem in l2) \n        {\n       \
    \     result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem; l1)\
    \ \n    {\n        if (elem in l2) \n        {\n            result ~= elem;\n\
    \        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1,\
    \ long[] l2) \n{\n    long[] result;\n    foreach (elem; l1) \n    {\n       \
    \ if (elem in l2) \n        {\n            result ~= elem;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] result;\n    foreach (elem; l1) \n    {\n        if (elem in l2) \n\
    \        {\n            result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem;\
    \ l1) \n    {\n        if (\nunittest\n{\n    alias candidate = common;\n\n  \
    \  assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjz76czdx.d(99): Error: expression expected, not `unittest`

    /tmp/tmpjz76czdx.d(100): Error: found `{` when expecting `)`

    /tmp/tmpjz76czdx.d(108): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjz76czdx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    long[] result = new long[]; \n    foreach (e1; l1) \n    { \n\
    \        foreach (e2; l2) \n        { \n            if (e1 == e2) \n         \
    \   { \n                result ~= e1; \n                break; \n            }\
    \ \n        } \n    } \n    return result; \n} \nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu8a4uabq.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8a4uabq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res;\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                res\
    \ ~= e1;\n            }\n        }\n    }\n    return res.sort().unique;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdl69u_wt.d(21): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdl69u_wt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().unique;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjfyplcbf.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpjfyplcbf.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfyplcbf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted = l1.dup;\n\
    \    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n  \
    \  foreach(long i; l1_sorted)\n    {\n        if(l2_sorted.find(i) != -1)\n  \
    \      {\n            result ~= i;\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted =\
    \ l1.dup;\n    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n\
    \    foreach(long i; l1_sorted)\n    {\n        if(l2_sorted.find(i) == -1)\n\
    \        {\n            result ~= i;\n        }\n    }\n    foreach(long i; l2_sorted)\n\
    \    {\n        if(l1_sorted.find(i) == -1)\n        {\n            result ~=\
    \ i;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[] l2, long[]\
    \ l3) \n{\n    long[] result = new long[0];\n    long[] l1_sorted = l1.dup;\n\
    \    long[] l2_sorted = l2.dup;\n    long[] l3_sorted = l3.dup;\n    l1_sorted.sort;\n\
    \    l2_sorted.sort;\n    l3_sorted.sort;\n    foreach(long i; l1_sorted)\n  \
    \  {\n        if(l2_sorted.find(i) == -1 && l3_sorted.find(i) == -1)\n       \
    \ {\n\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphdhxe2g0.d(71): Error: found `unittest` instead of statement

    /tmp/tmphdhxe2g0.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmphdhxe2g0.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphdhxe2g0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_copy = l1.dup;\n    long[] l2_copy\
    \ = l2.dup;\n    l1_copy.sort;\n    l2_copy.sort;\n    result = l1_copy.intersect(l2_copy);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp56385n2a.d(13): Error: no property `sort` for type `long[]`

    /tmp/tmp56385n2a.d(14): Error: no property `sort` for type `long[]`

    /tmp/tmp56385n2a.d(15): Error: no property `intersect` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp56385n2a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8q1t56ep.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmp8q1t56ep.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8q1t56ep.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81vr2a_b.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp81vr2a_b.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81vr2a_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \       \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1) \n    {\n        result ~= elem;\n    }\n    foreach (elem;\
    \ l2) \n    {\n        result ~= elem;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersection(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem;\
    \ l1) \n    {\n        if (elem in l2) \n        {\n            result ~= elem;\n\
    \        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1) \n    {\n        if (!(elem\
    \ in l2)) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \       \n    \n*/\nlong[] symmetric_difference(long[] l1, long[] l2) \n{\n  \
    \  long[] result;\n    foreach (elem; l1) \n    {\n        if (!(elem in l2))\
    \ \n        {\n            result ~= elem;\n        }\n    }\n    foreach (elem;\
    \ l2) \n    {\n        if (!(elem in l1)) \n        {\n            result ~= elem;\n\
    \        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4kjaf2v6.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmp4kjaf2v6.d(25): Error: { } expected following `union` declaration

    /tmp/tmp4kjaf2v6.d(25): Error: declaration expected, not `(`

    /tmp/tmp4kjaf2v6.d(28): Error: declaration expected, not `foreach`

    /tmp/tmp4kjaf2v6.d(28): Error: no identifier for declarator `l1`

    /tmp/tmp4kjaf2v6.d(28): Error: declaration expected, not `)`

    /tmp/tmp4kjaf2v6.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4kjaf2v6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_unique = l1.unique;\n    long[] l2_unique\
    \ = l2.unique;\n    foreach(long i; l1_unique)\n    {\n        foreach(long j;\
    \ l2_unique)\n        {\n            if(i == j)\n            {\n             \
    \   result ~= i;\n            }\n        }\n    }\n    return result.sort;\n}\n\
    /*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{\n    long[] result;\n    long[] l1_unique = l1.unique;\n\
    \    long[] l2_unique = l2.unique;\n    foreach(long i; l1_unique)\n    {\n  \
    \      result ~= i;\n    }\n    foreach(long j; l2_unique)\n    {\n        result\
    \ ~= j;\n    }\n    return result.sort;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_unique = l1.unique;\n    long[] l2_unique\
    \ = l2.unique;\n    foreach(long i; l1_unique)\n    {\n        bool found = false;\n\
    \        foreach(long j; l2_unique)\n        {\n            if(i == j)\n     \
    \       {\n                found = true;\n            }\n        }\n        if(!found)\n\
    \        {\n            result ~= i;\n        }\n    }\n    return result.sort;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ symmetric_difference(long[] l1, long[] l2) \n{\n    long[] result;\n    long[]\
    \ l1_unique = l1.unique;\n    long[] l2_unique = l2.unique;\n    foreach(long\
    \ i; l1_unique)\n    {\n        bool found = false;\n        foreach(long j; l2_unique)\n\
    \        {\n            if\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb4r5ne9_.d(30): Error: no identifier for declarator `long[]`

    /tmp/tmpb4r5ne9_.d(30): Error: { } expected following `union` declaration

    /tmp/tmpb4r5ne9_.d(30): Error: declaration expected, not `(`

    /tmp/tmpb4r5ne9_.d(35): Error: declaration expected, not `foreach`

    /tmp/tmpb4r5ne9_.d(35): Error: no identifier for declarator `l1_unique`

    /tmp/tmpb4r5ne9_.d(35): Error: declaration expected, not `)`

    /tmp/tmpb4r5ne9_.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb4r5ne9_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n     \
    \       {\n                result ~= l;\n            }\n        }\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7_wyfqpc.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp7_wyfqpc.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmp7_wyfqpc.d(15): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7_wyfqpc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret = new long[0];\n    foreach (long i; l1) {\n       \
    \ if (l2.canFind(i)) {\n            ret ~= i;\n        }\n    }\n    ret.sort();\n\
    \    ret = ret.dup;\n    return ret;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n   \
    \ long[] ret = new long[0];\n    foreach (long i; l1) {\n        ret ~= i;\n \
    \   }\n    foreach (long i; l2) {\n        ret ~= i;\n    }\n    ret.sort();\n\
    \    ret = ret.dup;\n    return ret;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] intersection(long[] l1, long[] l2) \n\
    {\n    long[] ret = new long[0];\n    foreach (long i; l1) {\n        if (l2.canFind(i))\
    \ {\n            ret ~= i;\n        }\n    }\n    ret.sort();\n    ret = ret.dup;\n\
    \    return ret;\n}\n/*\nReturn sorted unique elements for two lists.\n      \
    \  \n    \n*/\nlong[] difference(long[] l1, long[] l2) \n{\n    long[] ret = new\
    \ long[0];\n    foreach (long i; l1) {\n        if (!l2.canFind(i)) {\n      \
    \      ret ~= i;\n        }\n    }\n    ret.sort();\n    ret = ret.dup;\n    return\
    \ ret;\n}\n/*\nReturn sorted unique elements for two lists.\n        \n    \n\
    */\nlong[] symmetric_difference(long[] l1, long[] l2) \n{\n    long[] ret = new\
    \ long[0];\n    foreach (long i; l1) {\n        if (!l2.canFind(i)) {\n      \
    \      ret ~= i;\n        }\n    }\n    foreach (long i; l2) {\n        if (!l1.canFind(i))\
    \ {\n           \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6idnrf_b.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmp6idnrf_b.d(25): Error: { } expected following `union` declaration

    /tmp/tmp6idnrf_b.d(25): Error: declaration expected, not `(`

    /tmp/tmp6idnrf_b.d(28): Error: declaration expected, not `foreach`

    /tmp/tmp6idnrf_b.d(28): Error: no identifier for declarator `l1`

    /tmp/tmp6idnrf_b.d(28): Error: declaration expected, not `)`

    /tmp/tmp6idnrf_b.d(30): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6idnrf_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().unique;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9h0rw33r.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmp9h0rw33r.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9h0rw33r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().unique;\n}\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0xshp6c7.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp0xshp6c7.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0xshp6c7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkvqp5j62.d(104): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpkvqp5j62.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkvqp5j62.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkvqp5j62.d(104): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpkvqp5j62.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkvqp5j62.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1,\
    \ long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted\
    \ unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8bz1d0o6.d(92): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8bz1d0o6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret = new long[0];\n    long[] l1s = l1.dup;\n    long[]\
    \ l2s = l2.dup;\n    l1s.sort;\n    l2s.sort;\n    long i1 = 0;\n    long i2 =\
    \ 0;\n    while (i1 < l1s.length && i2 < l2s.length)\n    {\n        if (l1s[i1]\
    \ == l2s[i2])\n        {\n            ret ~= l1s[i1];\n            i1++;\n   \
    \         i2++;\n        }\n        else if (l1s[i1] < l2s[i2])\n        {\n \
    \           i1++;\n        }\n        else\n        {\n            i2++;\n   \
    \     }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4w5afw6a.d(13): Error: no property `sort` for type `long[]`

    /tmp/tmp4w5afw6a.d(14): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4w5afw6a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto result = new long[];\n    foreach (e1; l1)\n    {\n      \
    \  foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n   \
    \             result ~= e1;\n                break;\n            }\n        }\n\
    \    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpestt0hwm.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpestt0hwm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1) {\n        if\
    \ (l2.canFind(l)) {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach\
    \ (l; l1) {\n        result ~= l;\n    }\n    foreach (l; l2) {\n        result\
    \ ~= l;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) {\n        if (!l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ symmetricDifference(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n\
    \    foreach (l; l1) {\n        if (!l2.canFind(l)) {\n            result ~= l;\n\
    \        }\n    }\n    foreach (l; l2) {\n        if (!l1.canFind(l)) {\n    \
    \        result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2, long[] l3) \n{\n    long[] result = new long[];\n\
    \    foreach (l; l1) {\n        if (l2.canFind(l) && l3.canFind(l)) {\n      \
    \      result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\n\
    Return sorted unique elements for two lists.\n        \n    \nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzpldx60f.d(23): Error: no identifier for declarator `long[]`

    /tmp/tmpzpldx60f.d(23): Error: { } expected following `union` declaration

    /tmp/tmpzpldx60f.d(23): Error: declaration expected, not `(`

    /tmp/tmpzpldx60f.d(26): Error: declaration expected, not `foreach`

    /tmp/tmpzpldx60f.d(26): Error: no identifier for declarator `l1`

    /tmp/tmpzpldx60f.d(26): Error: declaration expected, not `)`

    /tmp/tmpzpldx60f.d(28): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzpldx60f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1) \n    {\n        if (e in l2)\
    \ \n        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2w14ljjc.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmp2w14ljjc.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2w14ljjc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements in l1 that\
    \ are not in l2.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (!l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\n/*\nReturn sorted unique elements in l1 that\
    \ are not in l2.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (!l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\n/*\nReturn sorted unique elements in l1 that\
    \ are not in l2.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (!l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\n/*\nReturn sorted unique elements in l1 that\
    \ are not in l2.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (!l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\n/*\nReturn sorted unique elements in l1 that\
    \ are not in l2.\n        \n    \n*/\nlong[] difference(long[] l\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo2tu4efh.d(94): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo2tu4efh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    if (l1.length < l2.length) \n    {\n      \
    \  result = l1.dup;\n        foreach (e; l2) \n        {\n            if (e in\
    \ result) \n            {\n                result ~= e;\n            }\n     \
    \   }\n    } \n    else \n    {\n        result = l2.dup;\n        foreach (e;\
    \ l1) \n        {\n            if (e in result) \n            {\n            \
    \    result ~= e;\n            }\n        }\n    }\n    return result.sort.uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqsuvramo.d(16): Error: incompatible types for `(e) in (result)`:
    `long` and `long[]`

    /tmp/tmpqsuvramo.d(27): Error: incompatible types for `(e) in (result)`: `long`
    and `long[]`

    /tmp/tmpqsuvramo.d(33): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsuvramo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n\
    \        if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n\
    \    }\n    return result.sort().dup.unique;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiel7r7nc.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmpiel7r7nc.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiel7r7nc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted = l1.dup;\n\
    \    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n  \
    \  int l1_i = 0;\n    int l2_i = 0;\n    while (l1_i < l1_sorted.length && l2_i\
    \ < l2_sorted.length) {\n        if (l1_sorted[l1_i] == l2_sorted[l2_i]) {\n \
    \           result ~= l1_sorted[l1_i];\n            l1_i++;\n            l2_i++;\n\
    \        } else if (l1_sorted[l1_i] < l2_sorted[l2_i]) {\n            l1_i++;\n\
    \        } else {\n            l2_i++;\n        }\n    }\n    return result;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ unique(long[] l1, long[] l2) \n{\n    long[] result = new long[0];\n    long[]\
    \ l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n \
    \   l2_sorted.sort;\n    int l1_i = 0;\n    int l2_i = 0;\n    while (l1_i < l1_sorted.length\
    \ && l2_i < l2_sorted.length) {\n        if (l1_sorted[l1_i] == l2_sorted[l2_i])\
    \ {\n            l1_i++;\n            l2_i++;\n        } else if (l1_sorted[l1_i]\
    \ < l2_sorted[l2_i]) {\n            result ~= l1_sorted[l1_i];\n            l1_i++;\n\
    \        } else {\n            result ~= l2_sorted[l2_i];\n            l2_i++;\n\
    \        }\n\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwn16y7pe.d(56): Error: found `unittest` instead of statement

    /tmp/tmpwn16y7pe.d(65): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwn16y7pe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    long[] result = new long[]; \n    foreach (e; l1) \n    { \n \
    \       if (e in l2) \n            result ~= e; \n    } \n    return result.sort().uniq;\
    \ \n} \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmaoil4um.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpmaoil4um.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpmaoil4um.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmaoil4um.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto r = new long[];\n    foreach (i; l1)\n    {\n        if (l2.canFind(i))\n\
    \            r ~= i;\n    }\n    return r.sort().uniq;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4v04pypb.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp4v04pypb.d(13): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4v04pypb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurqpj89s.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpurqpj89s.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurqpj89s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (e1; l1)\n    {\n       \
    \ foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n    \
    \            res ~= e1;\n                break;\n            }\n        }\n  \
    \  }\n    return res.sort().uniq;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[]\
    \ res = new long[];\n    foreach (e1; l1)\n    {\n        res ~= e1;\n    }\n\
    \    foreach (e2; l2)\n    {\n        res ~= e2;\n    }\n    return res.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ diff(long[] l1, long[] l2) \n{\n    long[] res = new long[];\n    foreach (e1;\
    \ l1)\n    {\n        bool found = false;\n        foreach (e2; l2)\n        {\n\
    \            if (e1 == e2)\n            {\n                found = true;\n   \
    \             break;\n            }\n        }\n        if (!found)\n        {\n\
    \            res ~= e1;\n        }\n    }\n    return res.sort().uniq;\n}\n/*\n\
    Return sorted unique elements for two lists.\n        \n    \n*/\nlong[] symdiff(long[]\
    \ l1, long[] l2) \n{\n    long[] res = new long[];\n    foreach (e1; l1)\n   \
    \ {\n        bool found = false;\n        foreach (e2; l2)\n        {\n      \
    \      if (e1 == e2)\n            {\n                found = true;\n         \
    \       break;\n            }\n        }\n        if (!found)\n        {\n   \
    \         res ~= e1;\n        }\n    }\n    foreach (e2; l2)\n    {\n        bool\
    \ found = false;\n        foreach (e1; l1)\n        {\n            if (e1 ==\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxoq2tnqy.d(29): Error: no identifier for declarator `long[]`

    /tmp/tmpxoq2tnqy.d(29): Error: { } expected following `union` declaration

    /tmp/tmpxoq2tnqy.d(29): Error: declaration expected, not `(`

    /tmp/tmpxoq2tnqy.d(32): Error: declaration expected, not `foreach`

    /tmp/tmpxoq2tnqy.d(32): Error: no identifier for declarator `l1`

    /tmp/tmpxoq2tnqy.d(32): Error: declaration expected, not `)`

    /tmp/tmpxoq2tnqy.d(35): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxoq2tnqy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            if (e in result)\n                continue;\n\
    \            result ~= e;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4_5wnmbc.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp4_5wnmbc.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmp4_5wnmbc.d(15): Error: incompatible types for `(e) in (result)`: `long`
    and `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4_5wnmbc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements in l1 that\
    \ are not in l2.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        bool\
    \ found = false;\n        foreach (e2; l2)\n        {\n            if (e1 == e2)\n\
    \            {\n                found = true;\n                break;\n      \
    \      }\n        }\n        if (!found)\n        {\n            result ~= e1;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements in\
    \ l1 that are not in l2.\n        \n    \n*/\nlong[] difference(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    bool found = false;\n        foreach (e2; l2)\n        {\n            if\
    \ (e1 == e2)\n            {\n                found = true;\n                break;\n\
    \            }\n        }\n        if (!found)\n        {\n            result\
    \ ~= e1;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ in l1 that are not in l2.\n        \n    \n*/\nlong[] difference(long[] l1,\
    \ long[] l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n\
    \        bool found = false;\n        foreach (e2; l2)\n        {\n          \
    \  if (e1 == e2)\n            {\n                found = true;\n             \
    \   break;\n            }\n        }\n        if (!found)\n        {\n       \
    \     result ~= e1;\n        }\n    }\n    return\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr20zio1e.d(101): Error: expression expected, not `unittest`

    /tmp/tmpr20zio1e.d(102): Error: found `{` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr20zio1e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long[] l1_unique =\
    \ l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    foreach(long\
    \ i; l1_unique)\n    {\n        if(l2_unique.canFind(i))\n        {\n        \
    \    result ~= i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ug3tk8k.d(13): Error: no property `sort` for type `long[]`

    /tmp/tmp7ug3tk8k.d(14): Error: no property `sort` for type `long[]`

    /tmp/tmp7ug3tk8k.d(15): Error: no property `unique` for type `long[]`

    /tmp/tmp7ug3tk8k.d(16): Error: no property `unique` for type `long[]`

    /tmp/tmp7ug3tk8k.d(19): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ug3tk8k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[]\
    \ result = new long[];\n    foreach (l; l1)\n    {\n        result ~= l;\n   \
    \ }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersect(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] diff(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (!l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \        \n    \n*/\nlong[] symdiff(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (l; l1)\n    {\n        if (!l2.canFind(l))\n   \
    \     {\n            result ~= l;\n        }\n    }\n    foreach (l; l2)\n   \
    \ {\n        if (!l1.canFind(l))\n        {\n            result ~= l;\n      \
    \  }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjtq4piyo.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpjtq4piyo.d(25): Error: { } expected following `union` declaration

    /tmp/tmpjtq4piyo.d(25): Error: declaration expected, not `(`

    /tmp/tmpjtq4piyo.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpjtq4piyo.d(28): Error: no identifier for declarator `l1`

    /tmp/tmpjtq4piyo.d(28): Error: declaration expected, not `)`

    /tmp/tmpjtq4piyo.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjtq4piyo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \            ret ~= l;\n    }\n    ret.sort;\n    ret = ret.dup;\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuum_ksds.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpuum_ksds.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmpuum_ksds.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuum_ksds.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] l3 = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            l3 ~= l;\n        }\n    }\n    return l3.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] l3 = new long[];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n        {\n            l3 ~= l;\n   \
    \     }\n    }\n    return l3.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] l3 = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            l3 ~= l;\n        }\n    }\n    return l3.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] l3 = new long[];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n        {\n            l3 ~= l;\n   \
    \     }\n    }\n    return l3.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] l3 = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            l3 ~= l;\n        }\n    }\n    return l3.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpycyozgjj.d(95): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpycyozgjj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().unique;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjfyplcbf.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpjfyplcbf.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfyplcbf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprqhgq2fb.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmprqhgq2fb.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmprqhgq2fb.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqhgq2fb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1)\n    {\n        if (elem in l2)\n        {\n         \
    \   result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem; l1)\n\
    \    {\n        if (elem in l2)\n        {\n            result ~= elem;\n    \
    \    }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1)\n    {\n        if (elem in l2)\n        {\n         \
    \   result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem; l1)\n\
    \    {\n        if (elem in l2)\n        {\n           \nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpid4lwom8.d(101): Error: found `unittest` instead of statement

    /tmp/tmpid4lwom8.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpid4lwom8.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpid4lwom8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    foreach(long i; l1_sorted)\n\
    \    {\n        if (l2_sorted.canFind(i))\n        {\n            result ~= i;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n   \
    \ long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n\
    \    l1_sorted.sort;\n    l2_sorted.sort;\n    foreach(long i; l1_sorted)\n  \
    \  {\n        if (!result.canFind(i))\n        {\n            result ~= i;\n \
    \       }\n    }\n    foreach(long i; l2_sorted)\n    {\n        if (!result.canFind(i))\n\
    \        {\n            result ~= i;\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[] difference(long[]\
    \ l1, long[] l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n   \
    \ long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    foreach(long\
    \ i; l1_sorted)\n    {\n        if (!l2_sorted.canFind(i))\n        {\n      \
    \      result ~= i;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted\
    \ unique elements for two lists.\n        \n    \n*/\nlong[] symmetric_difference(long[]\
    \ l1, long[] l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0nyyt4s1.d(29): Error: no identifier for declarator `long[]`

    /tmp/tmp0nyyt4s1.d(29): Error: { } expected following `union` declaration

    /tmp/tmp0nyyt4s1.d(29): Error: declaration expected, not `(`

    /tmp/tmp0nyyt4s1.d(34): Error: no identifier for declarator `l1_sorted.sort`

    /tmp/tmp0nyyt4s1.d(35): Error: no identifier for declarator `l2_sorted.sort`

    /tmp/tmp0nyyt4s1.d(36): Error: declaration expected, not `foreach`

    /tmp/tmp0nyyt4s1.d(36): Error: no identifier for declarator `l1_sorted`

    /tmp/tmp0nyyt4s1.d(36): Error: declaration expected, not `)`

    /tmp/tmp0nyyt4s1.d(41): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0nyyt4s1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5yxgt1by.d(21): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5yxgt1by.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5gyg25gx.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp5gyg25gx.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmp5gyg25gx.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5gyg25gx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1) {\n        if\
    \ (e in l2) {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7v37xh6x.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp7v37xh6x.d(12): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmp7v37xh6x.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7v37xh6x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long l1_len = l1_sorted.length;\n\
    \    long l2_len = l2_sorted.length;\n    long i = 0;\n    long j = 0;\n    while\
    \ (i < l1_len && j < l2_len) \n    {\n        if (l1_sorted[i] < l2_sorted[j])\
    \ \n        {\n            i++;\n        }\n        else if (l1_sorted[i] > l2_sorted[j])\
    \ \n        {\n            j++;\n        }\n        else \n        {\n       \
    \     ret ~= l1_sorted[i];\n            i++;\n            j++;\n        }\n  \
    \  }\n    return ret;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \       \n    \n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[] ret;\n\
    \    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n\
    \    l2_sorted.sort;\n    long l1_len = l1_sorted.length;\n    long l2_len = l2_sorted.length;\n\
    \    long i = 0;\n    long j = 0;\n    while (i < l1_len && j < l2_len) \n   \
    \ {\n        if (l1_sorted[i] < l2_sorted[j]) \n        {\n            ret ~=\
    \ l1_sorted[i];\n            i++;\n        }\n        else if (l1_sorted[i] >\
    \ l2_sorted[j]) \n        {\n            ret ~= l2_sorted[j];\n            j++;\n\
    \        }\n        else \n        {\n            ret ~= l1_sorted[i];\n     \
    \       i++;\n           \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwr1fqj14.d(71): Error: found `unittest` instead of statement

    /tmp/tmpwr1fqj14.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpwr1fqj14.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwr1fqj14.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1)\n    {\n        if (elem in l2)\n        {\n         \
    \   result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem; l1)\n\
    \    {\n        if (elem in l2)\n        {\n            result ~= elem;\n    \
    \    }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1)\n    {\n        if (elem in l2)\n        {\n         \
    \   result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem; l1)\n\
    \    {\n        if (elem in l2)\n        {\n           \nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpid4lwom8.d(101): Error: found `unittest` instead of statement

    /tmp/tmpid4lwom8.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpid4lwom8.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpid4lwom8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprfdb3kru.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmprfdb3kru.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprfdb3kru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().unique;\n}\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpah8daiuh.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpah8daiuh.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpah8daiuh.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpah8daiuh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n    \
    \    if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().unique;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa27ad90i.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmpa27ad90i.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa27ad90i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \       \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (e; l1)\n    {\n        result ~= e;\n    }\n   \
    \ foreach (e; l2)\n    {\n        result ~= e;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersection(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n  \
    \  foreach (e; l1)\n    {\n        if (e in l2)\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted\
    \ unique elements for two lists.\n        \n    \n*/\nlong[] difference(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n \
    \   {\n        if (!(e in l2))\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] symmetricDifference(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (!(e in l2))\n        {\n            result ~= e;\n        }\n    }\n \
    \   foreach (e; l2)\n    {\n        if (!(e in l1))\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted\
    \ unique elements for two lists.\n        \n    \n*/\n\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgmd43f3i.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpgmd43f3i.d(25): Error: { } expected following `union` declaration

    /tmp/tmpgmd43f3i.d(25): Error: declaration expected, not `(`

    /tmp/tmpgmd43f3i.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpgmd43f3i.d(28): Error: no identifier for declarator `l1`

    /tmp/tmpgmd43f3i.d(28): Error: declaration expected, not `)`

    /tmp/tmpgmd43f3i.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgmd43f3i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().unique;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n \
    \   {\n        result ~= e;\n    }\n    foreach (e; l2)\n    {\n        result\
    \ ~= e;\n    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (!(e in\
    \ l2))\n        {\n            result ~= e;\n        }\n    }\n    return result.sort().unique;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ symmetric_difference(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach\
    \ (e; l1)\n    {\n        if (!(e in l2))\n        {\n            result ~= e;\n\
    \        }\n    }\n    foreach (e; l2)\n    {\n        if (!(e in l1))\n     \
    \   {\n            result ~= e;\n        }\n    }\n    return result.sort().unique;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersection(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e;\
    \ l1)\n    {\n        if (e in l2)\n        {\n            result ~= e;\n    \
    \    }\n    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] symmetric_intersection(long[] l1,\
    \ long[] l2) \n{\n    long\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpon1fqsc5.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpon1fqsc5.d(25): Error: { } expected following `union` declaration

    /tmp/tmpon1fqsc5.d(25): Error: declaration expected, not `(`

    /tmp/tmpon1fqsc5.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpon1fqsc5.d(28): Error: no identifier for declarator `l1`

    /tmp/tmpon1fqsc5.d(28): Error: declaration expected, not `)`

    /tmp/tmpon1fqsc5.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpon1fqsc5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1,\
    \ long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted\
    \ unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    return l1\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbikqlo50.d(95): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpbikqlo50.d(104): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbikqlo50.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph37a11w.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpph37a11w.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpph37a11w.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpph37a11w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort.uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfhab0agd.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmpfhab0agd.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfhab0agd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    auto l1_sorted = l1.dup.sort;\n    auto l2_sorted\
    \ = l2.dup.sort;\n    auto l1_len = l1_sorted.length;\n    auto l2_len = l2_sorted.length;\n\
    \    auto l1_idx = 0;\n    auto l2_idx = 0;\n    while (l1_idx < l1_len && l2_idx\
    \ < l2_len) {\n        if (l1_sorted[l1_idx] == l2_sorted[l2_idx]) {\n       \
    \     result ~= l1_sorted[l1_idx];\n            l1_idx++;\n            l2_idx++;\n\
    \        } else if (l1_sorted[l1_idx] < l2_sorted[l2_idx]) {\n            l1_idx++;\n\
    \        } else {\n            l2_idx++;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt__lhb15.d(11): Error: no property `sort` for type `long[]`

    /tmp/tmpt__lhb15.d(12): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt__lhb15.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \            ret ~= l;\n    }\n    return ret.sort().uniq;\n}\nunittest\n{\n \
    \   alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6sefkle4.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp6sefkle4.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmp6sefkle4.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6sefkle4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph37a11w.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpph37a11w.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpph37a11w.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpph37a11w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2) \n{\n    return (l1 ~ l2).sort().uniq;\n}\n/*\n\
    Return sorted unique elements for two lists.\n        \n    \n*/\nlong[] difference(long[]\
    \ l1, long[] l2) \n{\n    long[] res = new long[];\n    foreach (e; l1)\n    {\n\
    \        if (!(e in l2))\n        {\n            res ~= e;\n        }\n    }\n\
    \    return res.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \        \n    \n*/\nlong[] symmetricDifference(long[] l1, long[] l2) \n{\n  \
    \  return (l1 ~ l2).sort().uniq;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n        \n    \n*/\nlong[] intersection(long[] l1, long[] l2) \n{\n\
    \    long[] res = new long[];\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ disjoint(long[] l1, long[] l2) \n{\n    long[] res = new long[];\n    foreach\
    \ (e; l1)\n    {\n        if (!(e in l2))\n        {\n            res ~= e;\n\
    \        }\n    }\n    return res.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] exclusiveOr(long[] l1, long[] l2)\
    \ \n{\n    return (l1 ~ l2).sort().uniq;\n}\n\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpecwuz76z.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpecwuz76z.d(25): Error: { } expected following `union` declaration

    /tmp/tmpecwuz76z.d(25): Error: declaration expected, not `(`

    /tmp/tmpecwuz76z.d(28): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpecwuz76z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto result = new long[];\n    foreach (e; l1)\n    {\n       \
    \ if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2xksvp0_.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp2xksvp0_.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2xksvp0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81vr2a_b.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp81vr2a_b.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81vr2a_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto result = new long[](l1.length);\n    auto result_length =\
    \ 0;\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n    \
    \        result[result_length] = l;\n            result_length++;\n        }\n\
    \    }\n    return result[0 .. result_length];\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n\
    \    auto result = new long[](l1.length + l2.length);\n    auto result_length\
    \ = 0;\n    foreach (l; l1)\n    {\n        if (!result.canFind(l))\n        {\n\
    \            result[result_length] = l;\n            result_length++;\n      \
    \  }\n    }\n    foreach (l; l2)\n    {\n        if (!result.canFind(l))\n   \
    \     {\n            result[result_length] = l;\n            result_length++;\n\
    \        }\n    }\n    return result[0 .. result_length];\n}\n/*\nReturn sorted\
    \ unique elements for two lists.\n        \n    \n*/\nlong[] intersection(long[]\
    \ l1, long[] l2) \n{\n    auto result = new long[](l1.length);\n    auto result_length\
    \ = 0;\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n  \
    \          result[result_length] = l;\n            result_length++;\n        }\n\
    \    }\n    return result[0 .. result_length];\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    auto result = new long[](l1.length);\n    auto result_length = 0;\n\
    \    foreach (l; l1)\n    {\n        if (!l2.canFind(l))\n        {\n        \
    \    result[result_length] = l;\n            result_length++;\n        }\n   \
    \ }\n    return result[0 .. result_length];\n}\n/*\n\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbkqh2ne_.d(27): Error: no identifier for declarator `long[]`

    /tmp/tmpbkqh2ne_.d(27): Error: { } expected following `union` declaration

    /tmp/tmpbkqh2ne_.d(27): Error: declaration expected, not `(`

    /tmp/tmpbkqh2ne_.d(31): Error: declaration expected, not `foreach`

    /tmp/tmpbkqh2ne_.d(31): Error: no identifier for declarator `l1`

    /tmp/tmpbkqh2ne_.d(31): Error: declaration expected, not `)`

    /tmp/tmpbkqh2ne_.d(36): Error: no identifier for declarator `result_length`

    /tmp/tmpbkqh2ne_.d(36): Error: declaration expected, not `++`

    /tmp/tmpbkqh2ne_.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbkqh2ne_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long[] l1_unique =\
    \ l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    foreach(long\
    \ l1_u; l1_unique)\n    {\n        foreach(long l2_u; l2_unique)\n        {\n\
    \            if(l1_u == l2_u)\n            {\n                result ~= l1_u;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long[] l1_unique =\
    \ l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    foreach(long\
    \ l1_u; l1_unique)\n    {\n        result ~= l1_u;\n    }\n    foreach(long l2_u;\
    \ l2_unique)\n    {\n        result ~= l2_u;\n    }\n    return result.unique;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ unique(long[] l1, long[] l2, long[] l3) \n{\n    long[] result;\n    long[]\
    \ l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n    long[] l3_sorted =\
    \ l3.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    l3_sorted.sort;\n   \
    \ long[] l1_unique = l1_s\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmjhctxq6.d(68): Error: semicolon expected, not `unittest`

    /tmp/tmpmjhctxq6.d(68): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmjhctxq6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81vr2a_b.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp81vr2a_b.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81vr2a_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_unique;\n    long[] l2_unique;\n\
    \    long[] l1_sorted;\n    long[] l2_sorted;\n    long[] l1_sorted_unique;\n\
    \    long[] l2_sorted_unique;\n    long[] l1_sorted_unique_common;\n    long[]\
    \ l2_sorted_unique_common;\n    long[] l1_sorted_unique_common_sorted;\n    long[]\
    \ l2_sorted_unique_common_sorted;\n    long[] l1_sorted_unique_common_sorted_unique;\n\
    \    long[] l2_sorted_unique_common_sorted_unique;\n    long[] l1_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common;\n    long[] l1_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted;\n    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique;\n    long[]\
    \ l1_sorted_unique_common_sorted_unique_common_sorted_unique_common;\n    long[]\
    \ l2_sorted_unique_common_sorted_unique_common_sorted_unique_common;\n    long[]\
    \ l1_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted_unique;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted_unique;\n\
    \    long[] l1_sorted_unique_common_sorted\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnolu54ht.d(36): Error: semicolon expected, not `unittest`

    /tmp/tmpnolu54ht.d(36): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnolu54ht.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprqhgq2fb.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmprqhgq2fb.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmprqhgq2fb.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqhgq2fb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \            ret ~= l;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb1xybuxe.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpb1xybuxe.d(13): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb1xybuxe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long[] l1_unique =\
    \ l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    long[] l1_unique_sorted\
    \ = l1_unique.dup;\n    long[] l2_unique_sorted = l2_unique.dup;\n    l1_unique_sorted.sort;\n\
    \    l2_unique_sorted.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.unique;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.unique;\n    long[] l1_unique_sorted_set_sorted\
    \ = l1_unique_sorted_set.dup;\n    long[] l2_unique_sorted_set_sorted = l2_unique_sorted_set.dup;\n\
    \    l1_unique_sorted_set_sorted.sort;\n    l2_unique_sorted_set_sorted.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_set = l1_unique_sorted_set_sorted.unique;\n\
    \    long[] l2_unique_sorted_set_sorted_set = l2_unique_sorted_set_sorted.unique;\n\
    \    long[] l1_unique_sorted_set_sorted_set_sorted = l1_unique_sorted_set_sorted_set.dup;\n\
    \    long[] l2_unique_sorted_set_sorted_set_sorted = l2_unique_sorted_set_sorted_set.dup;\n\
    \    l1_unique_sorted_set_sorted_set_sorted.sort;\n    l2_unique_sorted_set_sorted_set_sorted.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_set_s\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph_0ao2oc.d(34): Error: semicolon expected, not `unittest`

    /tmp/tmph_0ao2oc.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph_0ao2oc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        result\
    \ ~= e1;\n    }\n    foreach (e2; l2)\n    {\n        result ~= e2;\n    }\n \
    \   return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \        \n    \n*/\nlong[] difference(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (e1; l1)\n    {\n        bool found = false;\n  \
    \      foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        if (!found)\n        {\n            result ~= e1;\n        }\n \
    \   }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] symmetricDifference(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    bool found = false;\n        foreach (e2; l2)\n        {\n            if\
    \ (e1 == e2)\n            {\n                found = true;\n                break;\n\
    \            }\n        }\n        if (!found)\n        {\n            result\
    \ ~= e1;\n        }\n    }\n    foreach (e2; l2)\n    {\n        bool found =\
    \ false;\n        foreach (e1; l1)\n        {\n            if (e\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcg56e6m9.d(29): Error: no identifier for declarator `long[]`

    /tmp/tmpcg56e6m9.d(29): Error: { } expected following `union` declaration

    /tmp/tmpcg56e6m9.d(29): Error: declaration expected, not `(`

    /tmp/tmpcg56e6m9.d(32): Error: declaration expected, not `foreach`

    /tmp/tmpcg56e6m9.d(32): Error: no identifier for declarator `l1`

    /tmp/tmpcg56e6m9.d(32): Error: declaration expected, not `)`

    /tmp/tmpcg56e6m9.d(35): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcg56e6m9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprqhgq2fb.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmprqhgq2fb.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmprqhgq2fb.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqhgq2fb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long i = 0;\n    long\
    \ j = 0;\n    while (i < l1_sorted.length && j < l2_sorted.length) \n    {\n \
    \       if (l1_sorted[i] < l2_sorted[j]) \n        {\n            i++;\n     \
    \   }\n        else if (l1_sorted[i] > l2_sorted[j]) \n        {\n           \
    \ j++;\n        }\n        else \n        {\n            result ~= l1_sorted[i];\n\
    \            i++;\n            j++;\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n   \
    \ long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long\
    \ i = 0;\n    long j = 0;\n    while (i < l1_sorted.length && j < l2_sorted.length)\
    \ \n    {\n        if (l1_sorted[i] < l2_sorted[j]) \n        {\n            result\
    \ ~= l1_sorted[i];\n            i++;\n        }\n        else if (l1_sorted[i]\
    \ > l2_sorted[j]) \n        {\n            result ~= l2_sorted[j];\n         \
    \   j++;\n        }\n        else \n        {\n            result ~= l1_sorted[i];\n\
    \            i++;\n            j++;\n        }\n    }\n    while (i < l1_sorted.length)\
    \ \n    {\n        result ~= l1_sorted[i];\n        i++;\n    }\n    while (j\
    \ <\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcnbhsibv.d(75): Error: expression expected, not `unittest`

    /tmp/tmpcnbhsibv.d(76): Error: found `{` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcnbhsibv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    long[] result; \n    foreach (e; l1) \n    { \n        if (e in\
    \ l2) \n            result ~= e; \n    } \n    return result.sort().uniq; \n}\
    \ \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp9hqpzxf.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpp9hqpzxf.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp9hqpzxf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (e1; l1)\n    {\n        result ~= e1;\n    }\n \
    \   foreach (e2; l2)\n    {\n        bool found = false;\n        foreach (e1;\
    \ l1)\n        {\n            if (e1 == e2)\n            {\n                found\
    \ = true;\n                break;\n            }\n        }\n        if (!found)\n\
    \        {\n            result ~= e2;\n        }\n    }\n    return result;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersect(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach\
    \ (e1; l1)\n    {\n        foreach (e2; l2)\n        {\n            if (e1 ==\
    \ e2)\n            {\n                result ~= e1;\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    bool found = false;\n        foreach (e2; l2)\n        {\n            if\
    \ (e1 == e2)\n            {\n                found = true;\n                break;\n\
    \            }\n        }\n        if (!found)\n        {\n            result\
    \ ~= e1;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n\nunittest\n{\n    alias candidate = common;\n\n \
    \   assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpypf64zk3.d(29): Error: no identifier for declarator `long[]`

    /tmp/tmpypf64zk3.d(29): Error: { } expected following `union` declaration

    /tmp/tmpypf64zk3.d(29): Error: declaration expected, not `(`

    /tmp/tmpypf64zk3.d(32): Error: declaration expected, not `foreach`

    /tmp/tmpypf64zk3.d(32): Error: no identifier for declarator `l1`

    /tmp/tmpypf64zk3.d(32): Error: declaration expected, not `)`

    /tmp/tmpypf64zk3.d(35): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpypf64zk3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa6pm3wmx.d(98): Error: no identifier for declarator `e`

    /tmp/tmpa6pm3wmx.d(98): Error: found `unittest` when expecting `;`

    /tmp/tmpa6pm3wmx.d(107): Error: found `void` when expecting `)`

    /tmp/tmpa6pm3wmx.d(107): Error: found `{` when expecting `;` following statement

    /tmp/tmpa6pm3wmx.d(107): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa6pm3wmx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto l3 = l1.dup;\n    l3 ~= l2;\n    l3.sort;\n    l3.unique;\n\
    \    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq0qsqtd1.d(12): Error: no property `sort` for type `long[]`

    /tmp/tmpq0qsqtd1.d(13): Error: no property `unique` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq0qsqtd1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7wehvvwj.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7wehvvwj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    long[] result = new long[]; \n    foreach (e1; l1) \n    { \n\
    \        foreach (e2; l2) \n        { \n            if (e1 == e2) \n         \
    \   { \n                result ~= e1; \n                break; \n            }\
    \ \n        } \n    } \n    return result.sort().uniq; \n} \nunittest\n{\n   \
    \ alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51vsed8e.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp51vsed8e.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51vsed8e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    if (l1.length > l2.length) \n    {\n      \
    \  result = l1.dup;\n        foreach (e; l2) \n        {\n            if (e in\
    \ result) \n            {\n                result ~= e;\n            }\n     \
    \   }\n    } \n    else \n    {\n        result = l2.dup;\n        foreach (e;\
    \ l1) \n        {\n            if (e in result) \n            {\n            \
    \    result ~= e;\n            }\n        }\n    }\n    return result.sort.uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2) \n{\n    return (l1 ~ l2).sort.uniq;\n}\n/*\nReturn\
    \ sorted unique elements for two lists.\n        \n    \n*/\nlong[] intersection(long[]\
    \ l1, long[] l2) \n{\n    long[] result;\n    if (l1.length > l2.length) \n  \
    \  {\n        result = l1.dup;\n        foreach (e; l2) \n        {\n        \
    \    if (e in result) \n            {\n                result ~= e;\n        \
    \    }\n        }\n    } \n    else \n    {\n        result = l2.dup;\n      \
    \  foreach (e; l1) \n        {\n            if (e in result) \n            {\n\
    \                result ~= e;\n            }\n        }\n    }\n    return result.sort.uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ difference(long[] l1, long[] l2) \n{\n    long[] result;\n    if (l1.length\
    \ > l2.length) \n    {\n        result = l1.dup;\n        foreach (e; l2) \n \
    \       {\n            if (e in result) \n            {\n                result\
    \ ~= e;\n            }\n        }\n    } \n    else \n    {\n        result =\
    \ l2.du\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h7kwwcd.d(40): Error: no identifier for declarator `long[]`

    /tmp/tmp6h7kwwcd.d(40): Error: { } expected following `union` declaration

    /tmp/tmp6h7kwwcd.d(40): Error: declaration expected, not `(`

    /tmp/tmp6h7kwwcd.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h7kwwcd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[]\
    \ result = new long[];\n    foreach (l; l1)\n    {\n        result ~= l;\n   \
    \ }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ difference(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach\
    \ (l; l1)\n    {\n        if (!l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] symmetricDifference(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (!l2.canFind(l))\n        {\n            result ~= l;\n    \
    \    }\n    }\n    foreach (l; l2)\n    {\n        if (!l1.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersection(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n  \
    \  foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn\
    \ sorted unique\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9cxin5vt.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmp9cxin5vt.d(25): Error: { } expected following `union` declaration

    /tmp/tmp9cxin5vt.d(25): Error: declaration expected, not `(`

    /tmp/tmp9cxin5vt.d(28): Error: declaration expected, not `foreach`

    /tmp/tmp9cxin5vt.d(28): Error: no identifier for declarator `l1`

    /tmp/tmp9cxin5vt.d(28): Error: declaration expected, not `)`

    /tmp/tmp9cxin5vt.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9cxin5vt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \       \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (e; l1)\n    {\n        result ~= e;\n    }\n   \
    \ foreach (e; l2)\n    {\n        result ~= e;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersect(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach\
    \ (e; l1)\n    {\n        if (e in l2)\n        {\n            result ~= e;\n\
    \        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (!(e in l2))\n        {\n            result ~= e;\n        }\n    }\n \
    \   return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \        \n    \n*/\nlong[] symmetric_difference(long[] l1, long[] l2) \n{\n \
    \   long[] result = new long[];\n    foreach (e; l1)\n    {\n        if (!(e in\
    \ l2))\n        {\n            result ~= e;\n        }\n    }\n    foreach (e;\
    \ l2)\n    {\n        if (!(e in l1))\n        {\n            result ~= e;\n \
    \       }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmmzw6q12.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpmmzw6q12.d(25): Error: { } expected following `union` declaration

    /tmp/tmpmmzw6q12.d(25): Error: declaration expected, not `(`

    /tmp/tmpmmzw6q12.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpmmzw6q12.d(28): Error: no identifier for declarator `l1`

    /tmp/tmpmmzw6q12.d(28): Error: declaration expected, not `)`

    /tmp/tmpmmzw6q12.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmmzw6q12.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (l; l1)\n \
    \   {\n        result ~= l;\n    }\n    foreach (l; l2)\n    {\n        result\
    \ ~= l;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] intersection(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ difference(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (l; l1)\n\
    \    {\n        if (!l2.canFind(l))\n        {\n            result ~= l;\n   \
    \     }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] symmetric_difference(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (l; l1)\n    {\n        if (!l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    foreach (l; l2)\n\
    \    {\n        if (!l1.canFind(l))\n        {\n            result ~= l;\n   \
    \     }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] isdisjoint(\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7xv_183g.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmp7xv_183g.d(25): Error: { } expected following `union` declaration

    /tmp/tmp7xv_183g.d(25): Error: declaration expected, not `(`

    /tmp/tmp7xv_183g.d(28): Error: declaration expected, not `foreach`

    /tmp/tmp7xv_183g.d(28): Error: no identifier for declarator `l1`

    /tmp/tmp7xv_183g.d(28): Error: declaration expected, not `)`

    /tmp/tmp7xv_183g.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xv_183g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph37a11w.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpph37a11w.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpph37a11w.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpph37a11w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result;\n}\n/*\nReturn sorted unique elements for two lists.\n   \
    \     \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[] result =\
    \ new long[];\n    foreach (l; l1)\n    {\n        result ~= l;\n    }\n    foreach\
    \ (l; l2)\n    {\n        if (!result.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (!l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result;\n}\n/*\nReturn sorted unique elements for two lists.\n     \
    \   \n    \n*/\nlong[] symmetricDifference(long[] l1, long[] l2) \n{\n    long[]\
    \ result = new long[];\n    foreach (l; l1)\n    {\n        if (!l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    foreach (l; l2)\n\
    \    {\n        if (!l1.canFind(l))\n        {\n            result ~= l;\n   \
    \     }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n        \n    \n*/\nlong[] intersection(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique elements for two lists.\n        \n\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3b6cvyl4.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmp3b6cvyl4.d(25): Error: { } expected following `union` declaration

    /tmp/tmp3b6cvyl4.d(25): Error: declaration expected, not `(`

    /tmp/tmp3b6cvyl4.d(28): Error: declaration expected, not `foreach`

    /tmp/tmp3b6cvyl4.d(28): Error: no identifier for declarator `l1`

    /tmp/tmp3b6cvyl4.d(28): Error: declaration expected, not `)`

    /tmp/tmp3b6cvyl4.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3b6cvyl4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto result = new long[](0);\n    auto l1s = l1.sort();\n    auto\
    \ l2s = l2.sort();\n    auto l1i = 0;\n    auto l2i = 0;\n    while (l1i < l1s.length\
    \ && l2i < l2s.length) {\n        if (l1s[l1i] == l2s[l2i]) {\n            result\
    \ ~= l1s[l1i];\n            l1i++;\n            l2i++;\n        } else if (l1s[l1i]\
    \ < l2s[l2i]) {\n            l1i++;\n        } else {\n            l2i++;\n  \
    \      }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n   \
    \ auto result = new long[](0);\n    auto l1s = l1.sort();\n    auto l2s = l2.sort();\n\
    \    auto l1i = 0;\n    auto l2i = 0;\n    while (l1i < l1s.length || l2i < l2s.length)\
    \ {\n        if (l1i < l1s.length && l2i < l2s.length) {\n            if (l1s[l1i]\
    \ == l2s[l2i]) {\n                result ~= l1s[l1i];\n                l1i++;\n\
    \                l2i++;\n            } else if (l1s[l1i] < l2s[l2i]) {\n     \
    \           result ~= l1s[l1i];\n                l1i++;\n            } else {\n\
    \                result ~= l2s[l2i];\n                l2i++;\n            }\n\
    \        } else if (l1i < l1s.length) {\n            result ~= l1s[l1i];\n   \
    \         l1i++;\n        } else {\n            result ~= l2s[l2i];\n        \
    \    l2i++;\n        }\n    }\n    return result;\n}\n/*\n\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpploevwpi.d(33): Error: no identifier for declarator `long[]`

    /tmp/tmpploevwpi.d(33): Error: { } expected following `union` declaration

    /tmp/tmpploevwpi.d(33): Error: declaration expected, not `(`

    /tmp/tmpploevwpi.d(40): Error: declaration expected, not `while`

    /tmp/tmpploevwpi.d(44): Error: no identifier for declarator `l1i`

    /tmp/tmpploevwpi.d(44): Error: declaration expected, not `++`

    /tmp/tmpploevwpi.d(45): Error: no identifier for declarator `l2i`

    /tmp/tmpploevwpi.d(45): Error: declaration expected, not `++`

    /tmp/tmpploevwpi.d(46): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpploevwpi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    long[] result;\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3qxc34nf.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x42858d]

    ??:? void tmp3qxc34nf.__unittest_L23_C1() [0x428012]

    ??:? void tmp3qxc34nf.__modtest() [0x42830c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cf63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bdf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cf8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4307d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bdcd]

    ??:? runModuleUnitTests [0x42cd39]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = [];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1,\
    \ long[] l2) \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n      \
    \  if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = [];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1,\
    \ long[] l2) \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n      \
    \  if (l2.canFind(\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1mwgi01d.d(99): Error: expression expected, not `unittest`

    /tmp/tmp1mwgi01d.d(100): Error: found `{` when expecting `,`

    /tmp/tmp1mwgi01d.d(101): Error: expression expected, not `alias`

    /tmp/tmp1mwgi01d.d(101): Error: found `candidate` when expecting `,`

    /tmp/tmp1mwgi01d.d(101): Error: expression expected, not `=`

    /tmp/tmp1mwgi01d.d(101): Error: found `common` when expecting `,`

    /tmp/tmp1mwgi01d.d(101): Error: expression expected, not `;`

    /tmp/tmp1mwgi01d.d(103): Error: found `assert` when expecting `,`

    /tmp/tmp1mwgi01d.d(103): Error: found `;` when expecting `,`

    /tmp/tmp1mwgi01d.d(104): Error: found `;` when expecting `,`

    /tmp/tmp1mwgi01d.d(105): Error: found `;` when expecting `,`

    /tmp/tmp1mwgi01d.d(106): Error: found `;` when expecting `,`

    /tmp/tmp1mwgi01d.d(107): Error: expression expected, not `}`

    /tmp/tmp1mwgi01d.d(108): Error: found `void` when expecting `,`

    /tmp/tmp1mwgi01d.d(108): Error: found `{` when expecting `,`

    /tmp/tmp1mwgi01d.d(108): Error: expression expected, not `}`

    /tmp/tmp1mwgi01d.'
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    int l1_index = 0;\n\
    \    int l2_index = 0;\n    while (l1_index < l1_sorted.length && l2_index < l2_sorted.length)\n\
    \    {\n        if (l1_sorted[l1_index] < l2_sorted[l2_index])\n        {\n  \
    \          l1_index++;\n        }\n        else if (l1_sorted[l1_index] > l2_sorted[l2_index])\n\
    \        {\n            l2_index++;\n        }\n        else\n        {\n    \
    \        result ~= l1_sorted[l1_index];\n            l1_index++;\n           \
    \ l2_index++;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    int l1_index = 0;\n\
    \    int l2_index = 0;\n    while (l1_index < l1_sorted.length && l2_index < l2_sorted.length)\n\
    \    {\n        if (l1_sorted[l1_index] < l2_sorted[l2_index])\n        {\n  \
    \          result ~= l1_sorted[l1_index];\n            l1_index++;\n        }\n\
    \        else if (l1_sorted[l1_index] > l2_sorted[l2_index])\n        {\n    \
    \        result ~= l2_sorted[l2_index];\n            l2_index++;\n        }\n\
    \        else\n        {\n            result ~\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfo2rxynk.d(65): Error: expression expected, not `unittest`

    /tmp/tmpfo2rxynk.d(66): Error: found `{` when expecting `;` following statement

    /tmp/tmpfo2rxynk.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpfo2rxynk.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfo2rxynk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    auto result = new long[]; \n    foreach (a; l1) \n    { \n   \
    \     if (a in l2) \n            result ~= a; \n    } \n    return result.sort().uniq;\
    \ \n} \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4b4bxl9q.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp4b4bxl9q.d(13): Error: incompatible types for `(a) in (l2)`: `long` and
    `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4b4bxl9q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    int l1_i = 0;\n   \
    \ int l2_i = 0;\n    while (l1_i < l1_sorted.length && l2_i < l2_sorted.length)\n\
    \    {\n        if (l1_sorted[l1_i] == l2_sorted[l2_i])\n        {\n         \
    \   result ~= l1_sorted[l1_i];\n            l1_i++;\n            l2_i++;\n   \
    \     }\n        else if (l1_sorted[l1_i] < l2_sorted[l2_i])\n        {\n    \
    \        l1_i++;\n        }\n        else\n        {\n            l2_i++;\n  \
    \      }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[] l2) \n{\n  \
    \  long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n\
    \    l1_sorted.sort;\n    l2_sorted.sort;\n    int l1_i = 0;\n    int l2_i = 0;\n\
    \    while (l1_i < l1_sorted.length && l2_i < l2_sorted.length)\n    {\n     \
    \   if (l1_sorted[l1_i] == l2_sorted[l2_i])\n        {\n            l1_i++;\n\
    \            l2_i++;\n        }\n        else if (l1_sorted[l1_i] < l2_sorted[l2_i])\n\
    \        {\n            result ~= l1_sorted[l1_i];\n            l1_i++;\n    \
    \    }\n        else\n        {\n            result ~= l2_sorted[l2\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptxw9fr2x.d(65): Error: found `unittest` when expecting `,`

    /tmp/tmptxw9fr2x.d(74): Error: found `void` when expecting `,`

    /tmp/tmptxw9fr2x.d(74): Error: found `{` when expecting `,`

    /tmp/tmptxw9fr2x.d(74): Error: expression expected, not `}`

    /tmp/tmptxw9fr2x.d(74): Error: found `End of File` when expecting `,`

    /tmp/tmptxw9fr2x.d(74): Error: found `End of File` when expecting `]`

    /tmp/tmptxw9fr2x.d(74): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmptxw9fr2x.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmptxw9fr2x.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmptxw9fr2x.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxw9fr2x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[]\
    \ result = new long[];\n    foreach (l; l1)\n    {\n        result ~= l;\n   \
    \ }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ difference(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach\
    \ (l; l1)\n    {\n        if (!l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] symmetricDifference(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (!l2.canFind(l))\n        {\n            result ~= l;\n    \
    \    }\n    }\n    foreach (l; l2)\n    {\n        if (!l1.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersection(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n  \
    \  foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn\
    \ sorted unique\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9cxin5vt.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmp9cxin5vt.d(25): Error: { } expected following `union` declaration

    /tmp/tmp9cxin5vt.d(25): Error: declaration expected, not `(`

    /tmp/tmp9cxin5vt.d(28): Error: declaration expected, not `foreach`

    /tmp/tmp9cxin5vt.d(28): Error: no identifier for declarator `l1`

    /tmp/tmp9cxin5vt.d(28): Error: declaration expected, not `)`

    /tmp/tmp9cxin5vt.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9cxin5vt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph37a11w.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpph37a11w.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpph37a11w.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpph37a11w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurqpj89s.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpurqpj89s.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurqpj89s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \       \n    \n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (e; l1)\n    {\n        result ~= e;\n    }\n   \
    \ foreach (e; l2)\n    {\n        result ~= e;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ unique(long[] l1, long[] l2, long[] l3) \n{\n    long[] result = new long[];\n\
    \    foreach (e; l1)\n    {\n        result ~= e;\n    }\n    foreach (e; l2)\n\
    \    {\n        result ~= e;\n    }\n    foreach (e; l3)\n    {\n        result\
    \ ~= e;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[] l2, long[]\
    \ l3, long[] l4) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n \
    \   {\n        result ~= e;\n    }\n    foreach (e; l2)\n    {\n        result\
    \ ~= e;\n    }\n    foreach (e; l3)\n    {\n        result ~= e;\n    }\n    foreach\
    \ (e; l4)\n    {\n        result ~= e;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ unique(long[] l1, long[] l2, long[] l3, long[] l4, long[] l5) \n{\n    long[]\
    \ result = new\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkff67_ms.d(94): Error: basic type expected, not `unittest`

    /tmp/tmpkff67_ms.d(94): Error: semicolon expected, not `unittest`

    /tmp/tmpkff67_ms.d(94): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkff67_ms.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7wehvvwj.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7wehvvwj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    foreach (e1; l1)\n    {\n   \
    \     foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n\
    \                result ~= e1;\n            }\n        }\n    }\n    return result.sort().unique;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[0];\n  \
    \  foreach (e1; l1)\n    {\n        foreach (e2; l2)\n        {\n            if\
    \ (e1 == e2)\n            {\n                result ~= e1;\n            }\n  \
    \      }\n    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1,\
    \ long[] l2) \n{\n    long[] result = new long[0];\n    foreach (e1; l1)\n   \
    \ {\n        foreach (e2; l2)\n        {\n            if (e1 == e2)\n        \
    \    {\n                result ~= e1;\n            }\n        }\n    }\n    return\
    \ result.sort().unique;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach (e1; l1)\n    {\n        foreach (e2; l2)\n    \
    \    {\n            if (e1 == e2)\n            {\n                result ~= e1;\n\
    \            }\n        }\n    }\n    return result.sort().unique;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[0];\n    foreach (e1; l1)\n\
    \    {\n        foreach (e2; l2)\n        {\n            if (e1 ==\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph89l7i09.d(96): Error: expression expected, not `unittest`

    /tmp/tmph89l7i09.d(97): Error: found `{` when expecting `)`

    /tmp/tmph89l7i09.d(105): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmph89l7i09.d(105): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph89l7i09.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurqpj89s.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpurqpj89s.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurqpj89s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.count(l) > 0)\n        {\n            result ~= l;\n        }\n   \
    \ }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7mrz6bbh.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp7mrz6bbh.d(13): Error: no property `count` for type `long[]`

    /tmp/tmp7mrz6bbh.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7mrz6bbh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n\
    \        if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n\
    \    }\n    return result.sort().dup.unique;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n        result\
    \ ~= i;\n    }\n    foreach (long i; l2)\n    {\n        result ~= i;\n    }\n\
    \    return result.sort().dup.unique;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] intersection(long[] l1, long[] l2) \n\
    {\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n       \
    \ if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n    }\n\
    \    return result.sort().dup.unique;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n        if\
    \ (!l2.canFind(i))\n        {\n            result ~= i;\n        }\n    }\n  \
    \  return result.sort().dup.unique;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] symmetric_difference(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n\
    \        if (!l2.canFind(i))\n        {\n            result ~= i;\n        }\n\
    \    }\n    foreach (long i; l2)\n    {\n        if (!l1.canFind(i))\n       \
    \ {\n            result ~= i;\n        }\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdm00eeq9.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpdm00eeq9.d(25): Error: { } expected following `union` declaration

    /tmp/tmpdm00eeq9.d(25): Error: declaration expected, not `(`

    /tmp/tmpdm00eeq9.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpdm00eeq9.d(28): Error: no identifier for declarator `l1`

    /tmp/tmpdm00eeq9.d(28): Error: declaration expected, not `)`

    /tmp/tmpdm00eeq9.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdm00eeq9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    auto l = new long[]; \n    foreach (e; l1) \n    { \n        if\
    \ (e in l2) \n            l ~= e; \n    } \n    return l.sort().uniq; \n} \nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdkhn33jt.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpdkhn33jt.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdkhn33jt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long[] l1_unique =\
    \ l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    foreach(long\
    \ l1_u; l1_unique)\n    {\n        foreach(long l2_u; l2_unique)\n        {\n\
    \            if(l1_u == l2_u)\n            {\n                result ~= l1_u;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long[] l1_unique =\
    \ l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    foreach(long\
    \ l1_u; l1_unique)\n    {\n        result ~= l1_u;\n    }\n    foreach(long l2_u;\
    \ l2_unique)\n    {\n        result ~= l2_u;\n    }\n    return result.unique;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ unique(long[] l1, long[] l2, long[] l3) \n{\n    long[] result;\n    long[]\
    \ l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n    long[] l3_sorted =\
    \ l3.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    l3_sorted.sort;\n   \
    \ long[] l1_unique = l1_s\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmjhctxq6.d(68): Error: semicolon expected, not `unittest`

    /tmp/tmpmjhctxq6.d(68): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmjhctxq6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] r;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long[] l1_unique =\
    \ l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    long[] l1_unique_sorted\
    \ = l1_unique.dup;\n    long[] l2_unique_sorted = l2_unique.dup;\n    l1_unique_sorted.sort;\n\
    \    l2_unique_sorted.sort;\n    long[] l1_unique_sorted_unique = l1_unique_sorted.unique;\n\
    \    long[] l2_unique_sorted_unique = l2_unique_sorted.unique;\n    long[] l1_unique_sorted_unique_sorted\
    \ = l1_unique_sorted_unique.dup;\n    long[] l2_unique_sorted_unique_sorted =\
    \ l2_unique_sorted_unique.dup;\n    l1_unique_sorted_unique_sorted.sort;\n   \
    \ l2_unique_sorted_unique_sorted.sort;\n    long[] l1_unique_sorted_unique_sorted_unique\
    \ = l1_unique_sorted_unique_sorted.unique;\n    long[] l2_unique_sorted_unique_sorted_unique\
    \ = l2_unique_sorted_unique_sorted.unique;\n    long[] l1_unique_sorted_unique_sorted_unique_sorted\
    \ = l1_unique_sorted_unique_sorted_unique.dup;\n    long[] l2_unique_sorted_unique_sorted_unique_sorted\
    \ = l2_unique_sorted_unique_sorted_unique.dup;\n    l1_unique_sorted_unique_sorted_unique_sorted.sort;\n\
    \    l2_unique_sorted_unique_sorted_unique_sorted.sort;\n    long[] l1_unique_sorted_unique_sorted_unique_s\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp53psfvqt.d(34): Error: semicolon expected, not `unittest`

    /tmp/tmp53psfvqt.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp53psfvqt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    foreach(long i; l1_sorted)\n\
    \    {\n        if(l2_sorted.canFind(i))\n        {\n            result ~= i;\n\
    \        }\n    }\n    return result.dup.sort.uniq;\n}\n/*\nReturn sorted unique\
    \ elements in l1 that are not in l2.\n        \n    \n*/\nlong[] difference(long[]\
    \ l1, long[] l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n   \
    \ long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    foreach(long\
    \ i; l1_sorted)\n    {\n        if(!l2_sorted.canFind(i))\n        {\n       \
    \     result ~= i;\n        }\n    }\n    return result.dup.sort.uniq;\n}\n/*\n\
    Return sorted unique elements in l1 that are not in l2.\n        \n    \n*/\n\
    long[] difference(long[] l1, long[] l2) \n{\n    long[] result;\n    long[] l1_sorted\
    \ = l1.dup;\n    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n\
    \    foreach(long i; l1_sorted)\n    {\n        if(!l2_sorted.canFind(i))\n  \
    \      {\n            result ~= i;\n        }\n    }\n    return result.dup.sort.uniq;\n\
    }\n/*\nReturn sorted unique elements in l1 that are not in l2.\n        \n   \
    \ \n*/\nlong[] difference(long[] l1, long[] l2) \n{\n    long[] result;\n    long[]\
    \ l1_sorted = l1.dup;\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl0qsbbjl.d(75): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0qsbbjl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (e1; l1)\n    {\n       \
    \ foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n    \
    \            res ~= e1;\n                break;\n            }\n        }\n  \
    \  }\n    return res.sort().unique;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplo32_wg7.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmplo32_wg7.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplo32_wg7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    long[] res = new long[l1.length]; \n    int i = 0; \n    int j\
    \ = 0; \n    int k = 0; \n    while (i < l1.length && j < l2.length) \n    { \n\
    \        if (l1[i] < l2[j]) \n            i++; \n        else if (l2[j] < l1[i])\
    \ \n            j++; \n        else \n        { \n            res[k] = l1[i];\
    \ \n            i++; \n            j++; \n            k++; \n        } \n    }\
    \ \n    return res[0..k]; \n} \n/*\nReturn sorted unique elements for two lists.\n\
    \        \n    \n*/\nlong[] unique(long[] l1, long[] l2) \n{ \n    long[] res\
    \ = new long[l1.length + l2.length]; \n    int i = 0; \n    int j = 0; \n    int\
    \ k = 0; \n    while (i < l1.length && j < l2.length) \n    { \n        if (l1[i]\
    \ < l2[j]) \n            res[k++] = l1[i++]; \n        else if (l2[j] < l1[i])\
    \ \n            res[k++] = l2[j++]; \n        else \n        { \n            res[k++]\
    \ = l1[i++]; \n            j++; \n        } \n    } \n    while (i < l1.length)\
    \ \n        res[k++] = l1[i++]; \n    while (j < l2.length) \n        res[k++]\
    \ = l2[j++]; \n    return res[0..k]; \n} \n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[] l2) \n{ \n \
    \   long[] res = new long[l1.length + l2.length]; \n    int i = 0; \n    int j\
    \ = 0; \n    int k = 0\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4zjriaaq.d(70): Error: semicolon expected, not `unittest`

    /tmp/tmp4zjriaaq.d(70): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4zjriaaq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph37a11w.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpph37a11w.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpph37a11w.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpph37a11w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5gyg25gx.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp5gyg25gx.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmp5gyg25gx.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5gyg25gx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto result = new long[];\n    foreach (a; l1)\n    {\n       \
    \ if (a in l2)\n        {\n            result ~= a;\n        }\n    }\n    return\
    \ result.sort().unique;\n}\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyrsnh1jj.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpyrsnh1jj.d(13): Error: incompatible types for `(a) in (l2)`: `long` and
    `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyrsnh1jj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \        \n    \n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (e1; l1)\n    {\n        bool found = false;\n  \
    \      foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        if (!found)\n        {\n            result ~= e1;\n        }\n \
    \   }\n    foreach (e2; l2)\n    {\n        bool found = false;\n        foreach\
    \ (e1; l1)\n        {\n            if (e1 == e2)\n            {\n            \
    \    found = true;\n                break;\n            }\n        }\n       \
    \ if (!found)\n        {\n            result ~= e2;\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements for two lists.\n        \n   \
    \ \n*/\nlong[] unique(long[] l1, long[] l2, long[] l3) \n{\n    long[] result\
    \ = new long[];\n    foreach (e1; l1)\n    {\n        bool found = false;\n  \
    \      foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        if (!found)\n        {\n            foreach (e3; l3)\n         \
    \   {\n                if (e1 == e3)\n                {\n                    found\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n        if (!found)\n        {\n            result ~= e1;\n        }\n\
    \    }\n    foreach (e2; l2)\n   \nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5_kzlotn.d(103): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_kzlotn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    int i, j;\n    i = 0;\n    j = 0;\n    while\
    \ (i < l1.length && j < l2.length)\n    {\n        if (l1[i] == l2[j])\n     \
    \   {\n            result ~= l1[i];\n            i++;\n            j++;\n    \
    \    }\n        else if (l1[i] < l2[j])\n        {\n            i++;\n       \
    \ }\n        else\n        {\n            j++;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz6ajg_jp.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x42860d]

    ??:? void tmpz6ajg_jp.__unittest_L33_C1() [0x428096]

    ??:? void tmpz6ajg_jp.__modtest() [0x428390]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d057]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42beea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43093d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430dec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4308c9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bec1]

    ??:? runModuleUnitTests [0x42ce2d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ad0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().unique;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjfyplcbf.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpjfyplcbf.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfyplcbf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set & l2_set;\n    return common_set.array;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[]\
    \ l2) \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set | l2_set;\n    return common_set.array;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[]\
    \ l2, long[] l3) \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n\
    \    auto l3_set = set(l3);\n    auto common_set = l1_set | l2_set | l3_set;\n\
    \    return common_set.array;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \        \n    \n*/\nlong[] unique(long[] l1, long[] l2, long[] l3, long[] l4)\
    \ \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto l3_set\
    \ = set(l3);\n    auto l4_set = set(l4);\n    auto common_set = l1_set | l2_set\
    \ | l3_set | l4_set;\n    return common_set.array;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[]\
    \ l2, long[] l3, long[] l4, long[] l5) \n{\n    auto l1_set = set(l1);\n    auto\
    \ l2_set = set(l2);\n    auto l3_set = set(l3);\n    auto l4_set = set(l4);\n\
    \    auto l5_set = set(l5);\n    auto common_\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpouyiz1gp.d(67): Error: no identifier for declarator `common_`

    /tmp/tmpouyiz1gp.d(67): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpouyiz1gp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph37a11w.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpph37a11w.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpph37a11w.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpph37a11w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81vr2a_b.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp81vr2a_b.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81vr2a_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \            ret ~= l;\n    }\n    return ret.sort().uniq;\n}\nunittest\n{\n \
    \   alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6sefkle4.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp6sefkle4.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmp6sefkle4.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6sefkle4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n   \
    \ foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted\
    \ unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (l2.canFind(l))\n        {\n            result ~= l;\n     \
    \   }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] result = new long[];\n    foreach (\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcsfazoa1.d(97): Error: basic type expected, not `unittest`

    /tmp/tmpcsfazoa1.d(97): Error: no identifier for declarator `_error_`

    /tmp/tmpcsfazoa1.d(97): Error: found `unittest` when expecting `;`

    /tmp/tmpcsfazoa1.d(106): Error: found `void` when expecting `)`

    /tmp/tmpcsfazoa1.d(106): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcsfazoa1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n   \
    \ foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted\
    \ unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (l2.canFind(l))\n        {\n            result ~= l;\n     \
    \   }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] result = new long[];\n    foreach (\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcsfazoa1.d(97): Error: basic type expected, not `unittest`

    /tmp/tmpcsfazoa1.d(97): Error: no identifier for declarator `_error_`

    /tmp/tmpcsfazoa1.d(97): Error: found `unittest` when expecting `;`

    /tmp/tmpcsfazoa1.d(106): Error: found `void` when expecting `)`

    /tmp/tmpcsfazoa1.d(106): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcsfazoa1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[]\
    \ result = new long[];\n    foreach (l; l1)\n    {\n        result ~= l;\n   \
    \ }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersection(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n  \
    \  foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn\
    \ sorted unique elements for two lists.\n        \n    \n*/\nlong[] difference(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (!l2.canFind(l))\n        {\n            result ~= l;\n    \
    \    }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] symmetric_difference(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (!l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    foreach (l; l2)\n    {\n        if (!l1.canFind(l))\n        {\n        \
    \    result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn\
    \ sorted\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe9c5arai.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpe9c5arai.d(25): Error: { } expected following `union` declaration

    /tmp/tmpe9c5arai.d(25): Error: declaration expected, not `(`

    /tmp/tmpe9c5arai.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpe9c5arai.d(28): Error: no identifier for declarator `l1`

    /tmp/tmpe9c5arai.d(28): Error: declaration expected, not `)`

    /tmp/tmpe9c5arai.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe9c5arai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7wehvvwj.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7wehvvwj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (l2.canFind(e))\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplqh7zcm3.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmplqh7zcm3.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplqh7zcm3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto result = new long[](0);\n    foreach (elem; l1)\n    {\n \
    \       if (elem in l2)\n        {\n            result ~= elem;\n        }\n \
    \   }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjszwl1a7.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmpjszwl1a7.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjszwl1a7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurqpj89s.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpurqpj89s.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurqpj89s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1) {\n        foreach\
    \ (e2; l2) {\n            if (e1 == e2) {\n                result ~= e1;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7uj07cqt.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp7uj07cqt.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7uj07cqt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted = l1.dup;\n\
    \    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n  \
    \  long[] l1_unique = l1_sorted.uniq;\n    long[] l2_unique = l2_sorted.uniq;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements of l1 that are not in l2.\n        \n    \n*/\nlong[] uncommon(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted =\
    \ l1.dup;\n    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n\
    \    long[] l1_unique = l1_sorted.uniq;\n    long[] l2_unique = l2_sorted.uniq;\n\
    \    foreach(long i; l1_unique)\n    {\n        bool found = false;\n        foreach(long\
    \ j; l2_unique)\n        {\n            if(i == j)\n            {\n          \
    \      found = true;\n            }\n        }\n        if(!found)\n        {\n\
    \            result ~= i;\n        }\n    }\n    return result;\n}\n/*\nReturn\
    \ sorted unique elements of l1 that are not in l2.\n        \n    \n*/\nlong[]\
    \ uncommon(long[] l1, long[] l2) \n{\n    long[] result = new long[0];\n    long[]\
    \ l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n \
    \   l2_sorted.sort;\n    long[] l1_unique =\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpndgdqwtl.d(73): Error: expression expected, not `unittest`

    /tmp/tmpndgdqwtl.d(74): Error: semicolon expected, not `{`

    /tmp/tmpndgdqwtl.d(82): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpndgdqwtl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] res;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            res ~= e;\n        }\n  \
    \  }\n    return res.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] res;\n    foreach (e; l1)\n    {\n        if (e in l2)\n        {\n\
    \            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] res;\n    foreach (e; l1)\n   \
    \ {\n        if (e in l2)\n        {\n            res ~= e;\n        }\n    }\n\
    \    return res.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] res;\n    foreach (e; l1)\n    {\n        if (e in l2)\n        {\n\
    \            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] res;\n    foreach (e; l1)\n   \
    \ {\n        if (e in l2)\n        {\n            res ~= e;\n        }\n    }\n\
    \    return res.sort\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2b7vmlkl.d(104): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmp2b7vmlkl.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2b7vmlkl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \       \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (e; l1)\n    {\n        result ~= e;\n    }\n   \
    \ foreach (e; l2)\n    {\n        result ~= e;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersection(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n  \
    \  foreach (e; l1)\n    {\n        if (e in l2)\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted\
    \ unique elements for two lists.\n        \n    \n*/\nlong[] difference(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n \
    \   {\n        if (!(e in l2))\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] symmetricDifference(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (!(e in l2))\n        {\n            result ~= e;\n        }\n    }\n \
    \   foreach (e; l2)\n    {\n        if (!(e in l1))\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted\
    \ unique elements for two lists.\n        \n    \n*/\n\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgmd43f3i.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpgmd43f3i.d(25): Error: { } expected following `union` declaration

    /tmp/tmpgmd43f3i.d(25): Error: declaration expected, not `(`

    /tmp/tmpgmd43f3i.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpgmd43f3i.d(28): Error: no identifier for declarator `l1`

    /tmp/tmpgmd43f3i.d(28): Error: declaration expected, not `)`

    /tmp/tmpgmd43f3i.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgmd43f3i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81vr2a_b.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp81vr2a_b.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81vr2a_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret;\n    ret = new long[l1.length];\n    int i = 0;\n \
    \   foreach(e; l1)\n    {\n        if (e in l2)\n        {\n            ret[i]\
    \ = e;\n            i++;\n        }\n    }\n    ret = ret[0..i];\n    ret.sort;\n\
    \    ret = ret.uniq;\n    return ret;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iippdaw.d(15): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmp1iippdaw.d(22): Error: no property `sort` for type `long[]`

    /tmp/tmp1iippdaw.d(23): Error: no property `uniq` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iippdaw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurqpj89s.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpurqpj89s.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurqpj89s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurqpj89s.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpurqpj89s.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurqpj89s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9mfrh3km.d(98): Error: found `unittest` when expecting `)`

    /tmp/tmp9mfrh3km.d(107): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp9mfrh3km.d(107): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9mfrh3km.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkvqp5j62.d(104): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpkvqp5j62.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkvqp5j62.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (long i; l1) {\n     \
    \   if (l2.canFind(i)) {\n            result ~= i;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (long i; l1) {\n        if (l2.canFind(i)) {\n  \
    \          result ~= i;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    /*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n   \
    \ foreach (long i; l1) {\n        if (l2.canFind(i)) {\n            result ~=\
    \ i;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1,\
    \ long[] l2) \n{\n    long[] result = new long[];\n    foreach (long i; l1) {\n\
    \        if (l2.canFind(i)) {\n            result ~= i;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] result = new long[];\n    foreach (long i; l1) {\n        if (l2.canFind(i))\
    \ {\n            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n   \
    \ foreach (long i; l1) {\n        if (l2.can\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmponh6mon4.d(88): Error: found `unittest` when expecting `)`

    /tmp/tmponh6mon4.d(97): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmponh6mon4.d(97): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmponh6mon4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1) {\n        foreach\
    \ (e2; l2) {\n            if (e1 == e2) {\n                result ~= e1;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7uj07cqt.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp7uj07cqt.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7uj07cqt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurqpj89s.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpurqpj89s.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurqpj89s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph37a11w.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpph37a11w.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpph37a11w.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpph37a11w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    int i = 0;\n    int\
    \ j = 0;\n    while (i < l1_sorted.length && j < l2_sorted.length) \n    {\n \
    \       if (l1_sorted[i] == l2_sorted[j]) \n        {\n            result ~= l1_sorted[i];\n\
    \            i++;\n            j++;\n        }\n        else if (l1_sorted[i]\
    \ < l2_sorted[j]) \n        {\n            i++;\n        }\n        else \n  \
    \      {\n            j++;\n        }\n    }\n    return result;\n}\n/*\nReturn\
    \ sorted unique elements of l1 that are not in l2.\n        \n    \n*/\nlong[]\
    \ difference(long[] l1, long[] l2) \n{\n    long[] result;\n    long[] l1_sorted\
    \ = l1.dup;\n    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n\
    \    int i = 0;\n    int j = 0;\n    while (i < l1_sorted.length && j < l2_sorted.length)\
    \ \n    {\n        if (l1_sorted[i] == l2_sorted[j]) \n        {\n           \
    \ i++;\n            j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j])\
    \ \n        {\n            result ~= l1_sorted[i];\n            i++;\n       \
    \ }\n        else \n        {\n            j++;\n        }\n    }\n    while (i\
    \ < l1_sorted.length) \n    {\n        result ~= l1_sorted[i];\n        i++;\n\
    \    }\n    return result;\n}\n/*\nReturn sorted unique elements of l1 that are\
    \ not in l2.\n        \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpck02etq6.d(74): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpck02etq6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (e; l1) {\n        if (e\
    \ in l2) {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] res = new long[];\n    foreach\
    \ (e; l1) {\n        if (e in l2) {\n            res ~= e;\n        }\n    }\n\
    \    return res.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] res = new long[];\n    foreach (e; l1) {\n        if (e in l2) {\n \
    \           res ~= e;\n        }\n    }\n    return res.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] res = new long[];\n    foreach\
    \ (e; l1) {\n        if (e in l2) {\n            res ~= e;\n        }\n    }\n\
    \    return res.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n  \
    \  long[] res = new long[];\n    foreach (e; l1) {\n        if (e in l2) {\n \
    \           res ~= e;\n        }\n    }\n    return res.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] res = new long[];\n    foreach\
    \ (e; l1) {\n        if (e in l2) {\n            res ~= e;\n        }\n    }\n\
    \    return res.sort\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplwqr0g1j.d(92): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmplwqr0g1j.d(101): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplwqr0g1j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto l = new long[];\n    foreach (e1; l1) {\n        foreach (e2;\
    \ l2) {\n            if (e1 == e2) {\n                l ~= e1;\n             \
    \   break;\n            }\n        }\n    }\n    return l.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpztt8wm4u.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztt8wm4u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81vr2a_b.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp81vr2a_b.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81vr2a_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81vr2a_b.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp81vr2a_b.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81vr2a_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    long[] l1_sorted = l1.dup;\n \
    \   long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n   \
    \ long i1 = 0;\n    long i2 = 0;\n    while (i1 < l1_sorted.length && i2 < l2_sorted.length)\
    \ \n    {\n        if (l1_sorted[i1] == l2_sorted[i2]) \n        {\n         \
    \   result ~= l1_sorted[i1];\n            i1++;\n            i2++;\n        }\n\
    \        else if (l1_sorted[i1] < l2_sorted[i2]) \n        {\n            i1++;\n\
    \        }\n        else \n        {\n            i2++;\n        }\n    }\n  \
    \  return result;\n}\n/*\nReturn sorted unique elements for two lists.\n     \
    \   \n    \n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[] result = new\
    \ long[];\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n  \
    \  l1_sorted.sort;\n    l2_sorted.sort;\n    long i1 = 0;\n    long i2 = 0;\n\
    \    while (i1 < l1_sorted.length && i2 < l2_sorted.length) \n    {\n        if\
    \ (l1_sorted[i1] == l2_sorted[i2]) \n        {\n            result ~= l1_sorted[i1];\n\
    \            i1++;\n            i2++;\n        }\n        else if (l1_sorted[i1]\
    \ < l2_sorted[i2]) \n        {\n            result ~= l1_sorted[i1];\n       \
    \     i1++;\n        }\n        else \n        {\n            result ~= l2_sorted[i2];\n\
    \            i2++;\n        }\n    }\n    while (i1 < l\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmweh_bqp.d(70): Error: found `unittest` when expecting `)`

    /tmp/tmpmweh_bqp.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmweh_bqp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81vr2a_b.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp81vr2a_b.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81vr2a_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted = l1.dup;\n\
    \    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n  \
    \  long i = 0;\n    long j = 0;\n    while (i < l1_sorted.length && j < l2_sorted.length)\
    \ \n    {\n        if (l1_sorted[i] == l2_sorted[j]) \n        {\n           \
    \ result ~= l1_sorted[i];\n            i++;\n            j++;\n        }\n   \
    \     else if (l1_sorted[i] < l2_sorted[j]) \n        {\n            i++;\n  \
    \      }\n        else \n        {\n            j++;\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements for two lists.\n        \n   \
    \ \n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[] result = new long[0];\n\
    \    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n\
    \    l2_sorted.sort;\n    long i = 0;\n    long j = 0;\n    while (i < l1_sorted.length\
    \ && j < l2_sorted.length) \n    {\n        if (l1_sorted[i] == l2_sorted[j])\
    \ \n        {\n            i++;\n            j++;\n        }\n        else if\
    \ (l1_sorted[i] < l2_sorted[j]) \n        {\n            result ~= l1_sorted[i];\n\
    \            i++;\n        }\n        else \n        {\n            result ~=\
    \ l2_sorted[j];\n            j++;\n        }\n    }\n    while (i < l1_sorted.length)\
    \ \n    {\n        result ~= l1_sorted[i];\n        i++;\n    }\n    while (j\
    \ < l2_\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdja05ocr.d(74): Error: found `unittest` when expecting `)`

    /tmp/tmpdja05ocr.d(83): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdja05ocr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurqpj89s.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpurqpj89s.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurqpj89s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    if (l1.length > l2.length) \n    {\n      \
    \  result = common(l2, l1);\n    }\n    else \n    {\n        result = new long[l1.length];\n\
    \        size_t j = 0;\n        foreach (i, e; l1) \n        {\n            if\
    \ (e in l2) \n            {\n                result[j++] = e;\n            }\n\
    \        }\n        result = result[0 .. j];\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    if (l1.length\
    \ > l2.length) \n    {\n        result = common(l2, l1);\n    }\n    else \n \
    \   {\n        result = new long[l1.length];\n        size_t j = 0;\n        foreach\
    \ (i, e; l1) \n        {\n            if (e in l2) \n            {\n         \
    \       result[j++] = e;\n            }\n        }\n        result = result[0\
    \ .. j];\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    if (l1.length > l2.length) \n    {\n      \
    \  result = common(l2, l1);\n    }\n    else \n    {\n        result = new long[l1.length];\n\
    \        size_t j = 0;\n        foreach (i, e; l1) \n        {\n            if\
    \ (e in l2) \n            {\n                result[j++] = e;\n            }\n\
    \        }\n        result = result[0 .. j];\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7il9q8t9.d(90): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7il9q8t9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().unique;\n}\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0xshp6c7.d(13): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmp0xshp6c7.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0xshp6c7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph37a11w.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpph37a11w.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpph37a11w.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpph37a11w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurqpj89s.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpurqpj89s.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurqpj89s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().unique;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().unique;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().unique;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().unique;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3yqq55h8.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmp3yqq55h8.d(18): Error: no property `sort` for type `long[]`

    /tmp/tmp3yqq55h8.d(30): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmp3yqq55h8.d(35): Error: no property `sort` for type `long[]`

    /tmp/tmp3yqq55h8.d(47): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmp3yqq55h8.d(52): Error: no property `sort` for type `long[]`

    /tmp/tmp3yqq55h8.d(64): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmp3yqq55h8.d(69): Error: no property `sort` for type `long[]`

    /tmp/tmp3yqq55h8.d(81): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmp3yqq55h8.d(86): Error: no property `sort` for type `long[]`

    /tmp/tmp3yqq55h8.d(98): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmp3yqq55h8.d(103): Error: no property `sort` for type `long[]`

    /tmp/tmp3yqq55h8.d(109): Error: `tmp3yqq55h8.common` called with argument types
    `'
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto l1_sorted = l1.dup.sort;\n    auto l2_sorted = l2.dup.sort;\n\
    \    auto l1_unique = l1_sorted.unique;\n    auto l2_unique = l2_sorted.unique;\n\
    \    auto l1_set = l1_unique.toSet;\n    auto l2_set = l2_unique.toSet;\n    auto\
    \ l1_l2_intersection = l1_set.intersection(l2_set);\n    auto l1_l2_intersection_sorted\
    \ = l1_l2_intersection.toArray.sort;\n    return l1_l2_intersection_sorted;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    return l1.dup.sort.unique.toSet.intersection(l2.dup.sort.unique.toSet).toArray.sort;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    return l1.dup.sort.unique.toSet.intersection(l2.dup.sort.unique.toSet).toArray.sort;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    return l1.dup.sort.unique.toSet.intersection(l2.dup.sort.unique.toSet).toArray.sort;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    return l1.dup.sort.unique.toSet.intersection(l2.dup.sort.unique.toSet).toArray.sort;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    return l1\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqdtf2_d.d(64): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpvqdtf2_d.d(73): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqdtf2_d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeau27zij.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpeau27zij.d(13): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeau27zij.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted = l1.dup;\n\
    \    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuf6ue4qa.d(13): Error: no property `sort` for type `long[]`

    /tmp/tmpuf6ue4qa.d(14): Error: no property `sort` for type `long[]`

    /tmp/tmpuf6ue4qa.d(15): Error: no property `unique` for type `long[]`

    /tmp/tmpuf6ue4qa.d(16): Error: no property `unique` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuf6ue4qa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto l = new long[](l1.length);\n    auto i = 0;\n    foreach (e;\
    \ l1)\n    {\n        if (e in l2)\n        {\n            l[i] = e;\n       \
    \     i++;\n        }\n    }\n    l.length = i;\n    return l;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7pnlqd36.d(14): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7pnlqd36.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (e1; l1)\n    {\n       \
    \ foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n    \
    \            res ~= e1;\n                break;\n            }\n        }\n  \
    \  }\n    return res.sort.uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpasrhojoa.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpasrhojoa.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasrhojoa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \            ret ~= l;\n    }\n    return ret.sort().uniq;\n}\n/*\nReturn sorted\
    \ unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    long[] ret = new long[];\n    foreach(l; l1)\n    {\n\
    \        if(l2.canFind(l))\n            ret ~= l;\n    }\n    return ret.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] ret = new long[];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n            ret ~= l;\n    }\n    return\
    \ ret.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] ret =\
    \ new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        \
    \    ret ~= l;\n    }\n    return ret.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1,\
    \ long[] l2) \n{\n    long[] ret = new long[];\n    foreach(l; l1)\n    {\n  \
    \      if(l2.canFind(l))\n            ret ~= l;\n    }\n    return ret.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] ret = new long[];\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n            ret ~= l;\n    }\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuejz3rd4.d(91): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuejz3rd4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (e; l1)\n    {\n        if (e in l2)\n        {\n\
    \            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n   \
    \ foreach (e; l1)\n    {\n        if (e in l2)\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted\
    \ unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n \
    \   {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[];\n    foreach (e; l1)\n    {\n        if (e in\
    \ l2)\n        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n   \
    \ foreach (e; l1)\n    {\n        if (e in l\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb603csso.d(99): Error: found `unittest` when expecting `)`

    /tmp/tmpb603csso.d(108): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpb603csso.d(108): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb603csso.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        result\
    \ ~= e1;\n    }\n    foreach (e2; l2)\n    {\n        result ~= e2;\n    }\n \
    \   return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \        \n    \n*/\nlong[] union(long[] l1, long[] l2, long[] l3) \n{\n    long[]\
    \ result = new long[];\n    foreach (e1; l1)\n    {\n        result ~= e1;\n \
    \   }\n    foreach (e2; l2)\n    {\n        result ~= e2;\n    }\n    foreach\
    \ (e3; l3)\n    {\n        result ~= e3;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2, long[] l3, long[] l4) \n{\n    long[] result = new\
    \ long[];\n    foreach (e1; l1)\n    {\n        result ~= e1;\n    }\n    foreach\
    \ (e2; l2)\n    {\n        result ~= e2;\n    }\n    foreach (e3; l3)\n    {\n\
    \        result ~= e3;\n    }\n    foreach (e4; l4)\n    {\n        result ~=\
    \ e4;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp1zr92u5.d(29): Error: no identifier for declarator `long[]`

    /tmp/tmpp1zr92u5.d(29): Error: { } expected following `union` declaration

    /tmp/tmpp1zr92u5.d(29): Error: declaration expected, not `(`

    /tmp/tmpp1zr92u5.d(32): Error: declaration expected, not `foreach`

    /tmp/tmpp1zr92u5.d(32): Error: no identifier for declarator `l1`

    /tmp/tmpp1zr92u5.d(32): Error: declaration expected, not `)`

    /tmp/tmpp1zr92u5.d(35): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp1zr92u5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().unique;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1)\n    {\n        if (elem in l2)\n        {\n         \
    \   result ~= elem;\n        }\n    }\n    return result.sort().unique;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem; l1)\n\
    \    {\n        if (elem in l2)\n        {\n            result ~= elem;\n    \
    \    }\n    }\n    return result.sort().unique;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().unique;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1)\n    {\n        if (elem in l2)\n        {\n         \
    \   result ~= elem;\n        }\n    }\n    return result.sort().unique;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem; l1)\n\
    \    {\n        if (elem in l2)\n        {\n            result ~= elem\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprpk_6azz.d(101): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmprpk_6azz.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmprpk_6azz.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmprpk_6azz.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprpk_6azz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    foreach (i; l1)\n    {\n    \
    \    if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n    }\n\
    \    return result.sort().unique;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppf9h1hmh.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmppf9h1hmh.d(18): Error: no property `sort` for type `long[]`

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] tmp;\n    long[] tmp2;\n    long[] tmp3;\n\
    \    long[] tmp4;\n    long[] tmp5;\n    long[] tmp6;\n    long[] tmp7;\n    long[]\
    \ tmp8;\n    long[] tmp9;\n    long[] tmp10;\n    long[] tmp11;\n    long[] tmp12;\n\
    \    long[] tmp13;\n    long[] tmp14;\n    long[] tmp15;\n    long[] tmp16;\n\
    \    long[] tmp17;\n    long[] tmp18;\n    long[] tmp19;\n    long[] tmp20;\n\
    \    long[] tmp21;\n    long[] tmp22;\n    long[] tmp23;\n    long[] tmp24;\n\
    \    long[] tmp25;\n    long[] tmp26;\n    long[] tmp27;\n    long[] tmp28;\n\
    \    long[] tmp29;\n    long[] tmp30;\n    long[] tmp31;\n    long[] tmp32;\n\
    \    long[] tmp33;\n    long[] tmp34;\n    long[] tmp35;\n    long[] tmp36;\n\
    \    long[] tmp37;\n    long[] tmp38;\n    long[] tmp39;\n    long[] tmp40;\n\
    \    long[] tmp41;\n    long[] tmp42;\n    long[] tmp43;\n    long[] tmp44;\n\
    \    long[] tmp45;\n    long[] tmp46;\n    long[] tmp47;\n    long[] tmp48;\n\
    \    long[] tmp49;\n    long[] tmp50;\n    long[] tmp51;\n    long[] tmp52;\n\
    \    long[] tmp53;\n    long[] tmp54;\n    long[] tmp55;\n    long[] tmp56;\n\
    \    long[] tmp57;\n    long[] tmp58;\n    long[] tmp59;\n    long[] tmp60;\n\
    \    long[] tmp61;\n    long[] tmp62;\n    long[] tmp63;\n    long[] tmp64;\n\
    \    long[] tmp65;\n    long[] tmp66;\n    long[] tmp67;\n    long[] tmp68;\n\
    \    long[] tmp69;\n    long[] tmp70;\n    long[] tmp71;\n    long[] tmp72;\n\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9nqd_lg.d(84): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9nqd_lg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto result = new long[](l1.length);\n    size_t i = 0;\n    foreach\
    \ (a; l1)\n    {\n        foreach (b; l2)\n        {\n            if (a == b)\n\
    \            {\n                result[i] = a;\n                i++;\n       \
    \     }\n        }\n    }\n    return result[0..i];\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8rplt672.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285bd]

    ??:? void tmp8rplt672.__unittest_L25_C1() [0x428042]

    ??:? void tmp8rplt672.__modtest() [0x42833c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c677]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b50a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430795]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c44]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430721]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4e1]

    ??:? runModuleUnitTests [0x42c44d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a80]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    result = l1_sorted.intersect(l2_sorted);\n\
    \    return result;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3) \n{\n    long[]\
    \ result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n  \
    \  long[] l3_sorted = l3.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    l3_sorted.sort;\n\
    \    result = l1_sorted.intersect(l2_sorted).intersect(l3_sorted);\n    return\
    \ result;\n}\n/*\nReturn sorted unique common elements for two lists.\n      \
    \  \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3, long[] l4) \n{\n\
    \    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n\
    \    long[] l3_sorted = l3.dup;\n    long[] l4_sorted = l4.dup;\n    l1_sorted.sort;\n\
    \    l2_sorted.sort;\n    l3_sorted.sort;\n    l4_sorted.sort;\n    result = l1_sorted.intersect(l2_sorted).intersect(l3_sorted).intersect(l4_sorted);\n\
    \    return result;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3, long[] l4,\
    \ long[] l5) \n{\n    long[] result;\n    long[] l1_sorted\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_u5ezroi.d(63): Error: semicolon expected, not `unittest`

    /tmp/tmp_u5ezroi.d(63): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_u5ezroi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkvqp5j62.d(104): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpkvqp5j62.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkvqp5j62.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1) \n    {\n        if (e in l2)\
    \ \n        {\n            result ~= e;\n        }\n    }\n    return result.sort().unique;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfjs2qvg2.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpfjs2qvg2.d(18): Error: no property `sort` for type `long[]`

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    long[] l1_unique =\
    \ l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    foreach(long\
    \ i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n        {\n      \
    \      if(i == j)\n            {\n                result ~= i;\n            }\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[] l2) \n{\n  \
    \  long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n\
    \    l1_sorted.sort;\n    l2_sorted.sort;\n    long[] l1_unique = l1_sorted.unique;\n\
    \    long[] l2_unique = l2_sorted.unique;\n    foreach(long i; l1_unique)\n  \
    \  {\n        result ~= i;\n    }\n    foreach(long j; l2_unique)\n    {\n   \
    \     result ~= j;\n    }\n    return result.unique;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] unique(long[] l1, long[]\
    \ l2, long[] l3) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n   \
    \ long[] l2_sorted = l2.dup;\n    long[] l3_sorted = l3.dup;\n    l1_sorted.sort;\n\
    \    l2_sorted.sort;\n    l3_sorted.sort;\n    long[] l1_unique = l1_sorted.unique;\n\
    \    long[] l2_unique = l2_sorted.unique;\n    long[] l3\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0hfnpjle.d(70): Error: semicolon expected, not `unittest`

    /tmp/tmp0hfnpjle.d(70): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hfnpjle.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res;\n    foreach (long i; l1)\n    {\n        if (l2.canFind(i))\n\
    \            res ~= i;\n    }\n    res.sort();\n    return res.dup.unique;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8pw1wztb.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmp8pw1wztb.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmp8pw1wztb.d(17): Error: no property `unique` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8pw1wztb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1) {\n        foreach\
    \ (e2; l2) {\n            if (e1 == e2) {\n                result ~= e1;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7uj07cqt.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp7uj07cqt.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7uj07cqt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (long i; l1)\n    {\n\
    \        if (l2.canFind(i))\n            result ~= i;\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2lcr7iwg.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp2lcr7iwg.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmp2lcr7iwg.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2lcr7iwg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n \
    \   {\n        result ~= e;\n    }\n    foreach (e; l2)\n    {\n        result\
    \ ~= e;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (!(e in l2))\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ symmetric_difference(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach\
    \ (e; l1)\n    {\n        if (!(e in l2))\n        {\n            result ~= e;\n\
    \        }\n    }\n    foreach (e; l2)\n    {\n        if (!(e in l1))\n     \
    \   {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ intersection(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e;\
    \ l1)\n    {\n        if (e in l2)\n        {\n            result ~= e;\n    \
    \    }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] intersection_update(long[] l1, long[]\
    \ l2) \n{\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph9o5jtc3.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmph9o5jtc3.d(25): Error: { } expected following `union` declaration

    /tmp/tmph9o5jtc3.d(25): Error: declaration expected, not `(`

    /tmp/tmph9o5jtc3.d(28): Error: declaration expected, not `foreach`

    /tmp/tmph9o5jtc3.d(28): Error: no identifier for declarator `l1`

    /tmp/tmph9o5jtc3.d(28): Error: declaration expected, not `)`

    /tmp/tmph9o5jtc3.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9o5jtc3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto result = new long[](0);\n    foreach (i; l1)\n    {\n    \
    \    if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3)\
    \ \n{\n    return common(common(l1, l2), l3);\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2, long[] l3, long[] l4) \n{\n    return common(common(l1, l2), common(l3,\
    \ l4));\n}\n/*\nReturn sorted unique common elements for two lists.\n        \n\
    \    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3, long[] l4, long[] l5)\
    \ \n{\n    return common(common(l1, l2), common(l3, l4, l5));\n}\n/*\nReturn sorted\
    \ unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2, long[] l3, long[] l4, long[] l5, long[] l6) \n{\n    return common(common(l1,\
    \ l2), common(l3, l4, l5, l6));\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3,\
    \ long[] l4, long[] l5, long[] l6, long[] l7) \n{\n    return common(common(l1,\
    \ l2), common(l3, l4, l5, l6, l7));\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[]\
    \ l3, long[] l4, long[] l5, long[] l6, long[] l7, long[] l8)\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv2twokeq.d(71): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv2twokeq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{ \n    long[] result; \n    foreach (e; l1) \n    { \n        if (e in\
    \ l2) \n            result ~= e; \n    } \n    return result.sort().uniq; \n}\
    \ \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp9hqpzxf.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpp9hqpzxf.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp9hqpzxf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] ret = new long[];\n    foreach(long i; l1)\n    {\n    \
    \    if(l2.canFind(i))\n            ret ~= i;\n    }\n    ret.sort;\n    ret =\
    \ ret.dup;\n    return ret;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr7mb6m61.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpr7mb6m61.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmpr7mb6m61.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr7mb6m61.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2) \n{\n    long[] result = [];\n    foreach (l; l1)\n\
    \    {\n        result ~= l;\n    }\n    foreach (l; l2)\n    {\n        result\
    \ ~= l;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] intersection(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ difference(long[] l1, long[] l2) \n{\n    long[] result = [];\n    foreach (l;\
    \ l1)\n    {\n        if (!l2.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n        \n    \n*/\nlong[] symmetric_difference(long[]\
    \ l1, long[] l2) \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n  \
    \      if (!l2.canFind(l))\n        {\n            result ~= l;\n        }\n \
    \   }\n    foreach (l; l2)\n    {\n        if (!l1.canFind(l))\n        {\n  \
    \          result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    /*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvuwrk9y4.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpvuwrk9y4.d(25): Error: { } expected following `union` declaration

    /tmp/tmpvuwrk9y4.d(25): Error: declaration expected, not `(`

    /tmp/tmpvuwrk9y4.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpvuwrk9y4.d(28): Error: no identifier for declarator `l1`

    /tmp/tmpvuwrk9y4.d(28): Error: declaration expected, not `)`

    /tmp/tmpvuwrk9y4.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvuwrk9y4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted\
    \ = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    result = l1_sorted.intersect(l2_sorted);\n\
    \    return result;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3) \n{\n    long[]\
    \ result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n  \
    \  long[] l3_sorted = l3.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n    l3_sorted.sort;\n\
    \    result = l1_sorted.intersect(l2_sorted).intersect(l3_sorted);\n    return\
    \ result;\n}\n/*\nReturn sorted unique common elements for two lists.\n      \
    \  \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3, long[] l4) \n{\n\
    \    long[] result;\n    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n\
    \    long[] l3_sorted = l3.dup;\n    long[] l4_sorted = l4.dup;\n    l1_sorted.sort;\n\
    \    l2_sorted.sort;\n    l3_sorted.sort;\n    l4_sorted.sort;\n    result = l1_sorted.intersect(l2_sorted).intersect(l3_sorted).intersect(l4_sorted);\n\
    \    return result;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3, long[] l4,\
    \ long[] l5) \n{\n    long[] result;\n    long[] l1_sorted\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_u5ezroi.d(63): Error: semicolon expected, not `unittest`

    /tmp/tmp_u5ezroi.d(63): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_u5ezroi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7wehvvwj.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7wehvvwj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] r;\n    foreach (e; l1)\n    {\n        if (e in l2)\n \
    \           r ~= e;\n    }\n    return r.sort().uniq;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph5_zd9i7.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmph5_zd9i7.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph5_zd9i7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            if (e in res)\n                continue;\n\
    \            res ~= e;\n        }\n    }\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9yt3ii4n.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp9yt3ii4n.d(13): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmp9yt3ii4n.d(15): Error: incompatible types for `(e) in (res)`: `long` and
    `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9yt3ii4n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1)\n    {\n        if (elem in l2)\n        {\n         \
    \   result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem; l1)\n\
    \    {\n        if (elem in l2)\n        {\n            result ~= elem;\n    \
    \    }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (elem; l1)\n    {\n        if (elem\
    \ in l2)\n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach (elem; l1)\n    {\n        if (elem in l2)\n        {\n         \
    \   result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n        \n    \n*/\nlong[]\
    \ common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (elem; l1)\n\
    \    {\n        if (elem in l2)\n        {\n           \nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpid4lwom8.d(101): Error: found `unittest` instead of statement

    /tmp/tmpid4lwom8.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpid4lwom8.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpid4lwom8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5gyg25gx.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp5gyg25gx.d(13): Error: no property `canFind` for type `long[]`

    /tmp/tmp5gyg25gx.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5gyg25gx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2)\n        {\n            if (e in result)\n                continue;\n\
    \            result ~= e;\n        }\n    }\n    return result;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n        \n    \n*/\nlong[] common(long[]\
    \ l1, long[] l2, long[] l3) \n{\n    long[] result = new long[];\n    foreach\
    \ (e; l1)\n    {\n        if (e in l2 && e in l3)\n        {\n            if (e\
    \ in result)\n                continue;\n            result ~= e;\n        }\n\
    \    }\n    return result;\n}\n/*\nReturn sorted unique common elements for two\
    \ lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3, long[]\
    \ l4) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2 && e in l3 && e in l4)\n        {\n            if (e in result)\n\
    \                continue;\n            result ~= e;\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique common elements for two lists.\n      \
    \  \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3, long[] l4, long[]\
    \ l5) \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n     \
    \   if (e in l2 && e in l3 && e in l4 && e in l5)\n        {\n            if (e\
    \ in result)\n                continue;\n            result ~= e;\n        }\n\
    \    }\n    return result;\n}\n/*\nReturn sorted unique common elements for two\
    \ lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2, long[] l3, long[]\
    \ l4, long[] l5, long[] l6) \n{\n    long[] result = new long[];\n    foreach\
    \ (e; l\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6kb2ai6m.d(88): Error: found `unittest` when expecting `)`

    /tmp/tmp6kb2ai6m.d(97): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6kb2ai6m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n    \
    \    foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n \
    \               result ~= e1;\n                break;\n            }\n       \
    \ }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dsdk4o0.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0dsdk4o0.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dsdk4o0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n\
    \        if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n\
    \    }\n    return result.sort().dup.unique;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n        result\
    \ ~= i;\n    }\n    foreach (long i; l2)\n    {\n        result ~= i;\n    }\n\
    \    return result.sort().dup.unique;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] intersection(long[] l1, long[] l2) \n\
    {\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n       \
    \ if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n    }\n\
    \    return result.sort().dup.unique;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] difference(long[] l1, long[] l2) \n{\n\
    \    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n        if\
    \ (!l2.canFind(i))\n        {\n            result ~= i;\n        }\n    }\n  \
    \  return result.sort().dup.unique;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n        \n    \n*/\nlong[] symmetric_difference(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n\
    \        if (!l2.canFind(i))\n        {\n            result ~= i;\n        }\n\
    \    }\n    foreach (long i; l2)\n    {\n        if (!l1.canFind(i))\n       \
    \ {\n            result ~= i;\n        }\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdm00eeq9.d(25): Error: no identifier for declarator `long[]`

    /tmp/tmpdm00eeq9.d(25): Error: { } expected following `union` declaration

    /tmp/tmpdm00eeq9.d(25): Error: declaration expected, not `(`

    /tmp/tmpdm00eeq9.d(28): Error: declaration expected, not `foreach`

    /tmp/tmpdm00eeq9.d(28): Error: no identifier for declarator `l1`

    /tmp/tmpdm00eeq9.d(28): Error: declaration expected, not `)`

    /tmp/tmpdm00eeq9.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdm00eeq9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort.uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq7aqpdnm.d(13): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpq7aqpdnm.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq7aqpdnm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted = l1.dup;\n\
    \    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n    l2_sorted.sort;\n  \
    \  int i = 0;\n    int j = 0;\n    while (i < l1_sorted.length && j < l2_sorted.length)\
    \ \n    {\n        if (l1_sorted[i] == l2_sorted[j]) \n        {\n           \
    \ result ~= l1_sorted[i];\n            i++;\n            j++;\n        }\n   \
    \     else if (l1_sorted[i] < l2_sorted[j]) \n        {\n            i++;\n  \
    \      }\n        else \n        {\n            j++;\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements for two lists.\n        \n   \
    \ \n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[] result = new long[0];\n\
    \    long[] l1_sorted = l1.dup;\n    long[] l2_sorted = l2.dup;\n    l1_sorted.sort;\n\
    \    l2_sorted.sort;\n    int i = 0;\n    int j = 0;\n    while (i < l1_sorted.length\
    \ && j < l2_sorted.length) \n    {\n        if (l1_sorted[i] == l2_sorted[j])\
    \ \n        {\n            i++;\n            j++;\n        }\n        else if\
    \ (l1_sorted[i] < l2_sorted[j]) \n        {\n            result ~= l1_sorted[i];\n\
    \            i++;\n        }\n        else \n        {\n            result ~=\
    \ l2_sorted[j];\n            j++;\n        }\n    }\n    while (i < l1_sorted.length)\
    \ \n    {\n        result ~= l1_sorted[i];\n        i++;\n    }\n    while (j\
    \ < l2_\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkt55uoc8.d(74): Error: found `unittest` when expecting `)`

    /tmp/tmpkt55uoc8.d(83): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkt55uoc8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] res = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n            res ~= l;\n    }\n    return res.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2) \n{\n    long[] res = new long[];\n    foreach (l;\
    \ l1)\n    {\n        res ~= l;\n    }\n    foreach (l; l2)\n    {\n        res\
    \ ~= l;\n    }\n    return res.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n        \n    \n*/\nlong[] union(long[] l1, long[] l2, long[]\
    \ l3) \n{\n    long[] res = new long[];\n    foreach (l; l1)\n    {\n        res\
    \ ~= l;\n    }\n    foreach (l; l2)\n    {\n        res ~= l;\n    }\n    foreach\
    \ (l; l3)\n    {\n        res ~= l;\n    }\n    return res.sort().uniq;\n}\n/*\n\
    Return sorted unique elements for two lists.\n        \n    \n*/\nlong[] union(long[]\
    \ l1, long[] l2, long[] l3, long[] l4) \n{\n    long[] res = new long[];\n   \
    \ foreach (l; l1)\n    {\n        res ~= l;\n    }\n    foreach (l; l2)\n    {\n\
    \        res ~= l;\n    }\n    foreach (l; l3)\n    {\n        res ~= l;\n   \
    \ }\n    foreach (l; l4)\n    {\n        res ~= l;\n    }\n    return res.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n        \n    \n*/\nlong[]\
    \ union(long[] l1, long[] l2, long[] l3, long[] l4, long[] l5) \n{\n    long[]\
    \ res = new long[];\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph7y351ab.d(23): Error: no identifier for declarator `long[]`

    /tmp/tmph7y351ab.d(23): Error: { } expected following `union` declaration

    /tmp/tmph7y351ab.d(23): Error: declaration expected, not `(`

    /tmp/tmph7y351ab.d(26): Error: declaration expected, not `foreach`

    /tmp/tmph7y351ab.d(26): Error: no identifier for declarator `l1`

    /tmp/tmph7y351ab.d(26): Error: declaration expected, not `)`

    /tmp/tmph7y351ab.d(29): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph7y351ab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    auto l = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    l ~= e1;\n                break;\n            }\n        }\n    }\n    return\
    \ l.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphl7dsbd1.d(10): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphl7dsbd1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163920
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[]\
    \ l2) \n{\n    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements\
    \ for two lists.\n        \n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n\
    \    long[] result;\n    foreach (e; l1)\n    {\n        if (e in l2)\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique common elements for two lists.\n        \n    \n*/\n\
    long[] common(long[] l1, long[] l2) \n{\n    long[] result;\n    foreach (e; l1)\n\
    \    {\n        if (e in l2)\n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkvqp5j62.d(104): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpkvqp5j62.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkvqp5j62.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163919
