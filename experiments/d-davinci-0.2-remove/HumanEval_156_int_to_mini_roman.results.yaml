language: d
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [ \"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\" ];\n  \
    \  static string[10] roman10 = [ \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\",\
    \ \"lx\", \"lxx\", \"lxxx\", \"xc\" ];\n    static string[10] roman100 = [ \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\" ];\n\
    \    static string[4] roman1000 = [ \"\", \"m\", \"mm\", \"mmm\" ];\n    string\
    \ result;\n    result ~= roman1000[number / 1000];\n    number %= 1000;\n    result\
    \ ~= roman100[number / 100];\n    number %= 100;\n    result ~= roman10[number\
    \ / 10];\n    number %= 10;\n    result ~= roman[number];\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] places = [\"\
    \", \"hundred\", \"thousand\", \"million\"];\n    static string[4] place_values\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] place_values = [\"\", \"\"\
    , \"\", \"\"];\n    static string[4] place_values = [\"\", \"\", \"\", \"\"];\n\
    \    static string[4] place_values = [\"\", \"\", \"\", \"\"];\n    static string[4]\
    \ place_values = [\"\", \"\", \"\", \"\"];\n    static string[4] place_values\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] place_values = [\"\", \"\"\
    , \"\", \"\"];\n    static string[4] place_values = [\"\", \"\", \"\", \"\"];\n\
    \    static string[4] place_values = [\"\", \"\", \"\", \"\"];\n    static string[4]\
    \ place_values = [\"\", \"\", \"\", \"\"];\n    static string[4] place_values\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] place_values = [\"\", \"\"\
    , \"\", \"\"];\n    static string[4] place_values = [\"\", \"\", \"\", \"\"];\n\
    \    static string[4] place_values = [\"\", \"\", \"\", \"\"];\n    static string[4]\
    \ place_values = [\"\", \"\", \"\", \"\"];\n    static string[4] place_values\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] place_values = [\"\", \"\"\
    , \"\", \"\"]\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4jn5c8aa.d(36): Error: semicolon expected, not `unittest`

    /tmp/tmp4jn5c8aa.d(36): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4jn5c8aa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\n      \
    \  \"\",\n        \"i\",\n        \"ii\",\n        \"iii\",\n        \"iv\",\n\
    \        \"v\",\n        \"vi\",\n        \"vii\",\n        \"viii\",\n      \
    \  \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\",\n     \
    \   \"x\",\n        \"xx\",\n        \"xxx\",\n        \"xl\",\n        \"l\"\
    ,\n        \"lx\",\n        \"lxx\",\n        \"lxxx\",\n        \"xc\"\n    ];\n\
    \    static string[10] roman_hundreds = [\n        \"\",\n        \"c\",\n   \
    \     \"cc\",\n        \"ccc\",\n        \"cd\",\n        \"d\",\n        \"dc\"\
    ,\n        \"dcc\",\n        \"dccc\",\n        \"cm\"\n    ];\n    static string[4]\
    \ roman_thousands = [\n        \"\",\n        \"m\",\n        \"mm\",\n      \
    \  \"mmm\"\n    ];\n    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static const string roman_numerals =\
    \ \"ivxlcdm\";\n    static const long[] values = [1, 5, 10, 50, 100, 500, 1000];\n\
    \    static const long[] subtractors = [1, 10, 100];\n    static const long[]\
    \ multipliers = [1, 10, 100];\n    static const long[] divisors = [1, 2, 2, 5,\
    \ 2, 2, 5, 4, 1];\n    static const long[] subtractor_indexes = [0, 2, 4];\n \
    \   static const long[] multiplier_indexes = [0, 2, 4];\n    static const long[]\
    \ divisor_indexes = [0, 1, 1, 2, 1, 1, 2, 3, 0];\n    static const long[] divisor_multipliers\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const long[] divisor_subtractors\
    \ = [1, 10, 100];\n    static const long[] divisor_multiplier_indexes = [0, 2,\
    \ 4];\n    static const long[] divisor_subtractor_indexes = [0, 2, 4];\n    static\
    \ const long[] divisor_multiplier_powers = [0, 1, 2, 2, 3, 3, 4, 4, 5];\n    static\
    \ const long[] divisor_subtractor_powers = [0, 1, 2, 2, 3, 3, 4, 4, 5];\n    static\
    \ const long[] divisor_multiplier_powers_indexes = [0, 1, 2, 2, 3, 3, 4, 4, 5];\n\
    \    static const long[] divisor_subtractor_powers_indexes = [0, 1, 2, 2, 3, 3,\
    \ 4, 4, 5];\n    static const long[] divisor_multiplier_powers_indexes_indexes\
    \ = [0, 1, 2, 2, 3, 3, 4, 4, 5];\n    static const long[] divisor_subtractor_powers_indexes_indexes\
    \ = [0, 1, 2, 2, 3, 3, 4, 4, 5];\n    static const long[] divisor_multiplier_powers_index\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplim1u2k5.d(33): Error: semicolon expected, not `unittest`

    /tmp/tmplim1u2k5.d(33): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplim1u2k5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [ \"\
    m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\"\
    , \"iv\", \"i\" ];\n    static long[] numbers = [ 1000, 900, 500, 400, 100, 90,\
    \ 50, 40, 10, 9, 5, 4, 1 ];\n    string result = \"\";\n    foreach(i, num; numbers)\n\
    \    {\n        while(number >= num)\n        {\n            result ~= roman_numerals[i];\n\
    \            number -= num;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    string result = \"\";\n   \
    \ if (number >= 1000)\n    {\n        result ~= thousands[number / 1000];\n  \
    \      number %= 1000;\n    }\n    if (number >= 100)\n    {\n        result ~=\
    \ hundreds[number / 100];\n        number %= 100;\n    }\n    if (number >= 10)\n\
    \    {\n        result ~= tens[number / 10];\n        number %= 10;\n    }\n \
    \   if (number >= 1)\n    {\n        result ~= ones[number];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6il2pwwv.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmp6il2pwwv.int_to_mini_roman(long) [0x427af2]

    ??:? void tmp6il2pwwv.__unittest_L17_C1() [0x427b29]

    ??:? void tmp6il2pwwv.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] decimal_numerals = [\n  \
    \      1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string\
    \ result = \"\";\n    foreach(i, numeral; zip(decimal_numerals, roman_numerals))\
    \ {\n        while(number >= numeral[0]) {\n            result ~= numeral[1];\n\
    \            number -= numeral[0];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppvluw_e_.d(21): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppvluw_e_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] decimal_numerals = [\n  \
    \      1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string\
    \ result = \"\";\n    foreach(i, roman; roman_numerals)\n    {\n        while(number\
    \ >= decimal_numerals[i])\n        {\n            result ~= roman;\n         \
    \   number -= decimal_numerals[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[10] roman_tenthousands\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundredthousands = [\n   \
    \     \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\",\
    \ \"cm\"\n    ];\n    static string[10] roman_millions = [\n        \"\", \"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\n    ];\n\
    \    static string[10] roman_tenmillions = [\n        \"\", \"x\", \"xx\", \"\
    xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static string[10]\
    \ roman_hundredmillions = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[10] roman_billions\
    \ = [\n        \"\", \"b\", \"bb\", \"bbb\", \"bbv\", \"bv\", \"bvv\", \"bvvv\"\
    , \"bvvvv\", \"bxb\"\n    ];\n    static\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2msrdfm2.d(45): Error: basic type expected, not `unittest`

    /tmp/tmp2msrdfm2.d(45): Error: no identifier for declarator `_error_`

    /tmp/tmp2msrdfm2.d(45): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2msrdfm2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[4] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[4] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\"];\n    return thousands[number / 1000] ~ hundreds[(number / 100)\
    \ % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpna1p7k90.d(14): Error: array initializer has 10 elements, but array
    length is 4

    /tmp/tmpna1p7k90.d(15): Error: array initializer has 10 elements, but array length
    is 4

    /tmp/tmpna1p7k90.d(16): Error: array initializer has 10 elements, but array length
    is 4

    /tmp/tmpna1p7k90.d(17): Error: array initializer has 10 elements, but array length
    is 4

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpna1p7k90.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [ \"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\" ];\n  \
    \  return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpe0vwl__t.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpe0vwl__t.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpe0vwl__t.__unittest_L17_C1() [0x427b29]

    ??:? void tmpe0vwl__t.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    static int[4] decimal_values = [1, 5, 10, 50];\n\
    \    string result = \"\";\n    int i = 0;\n    while (number > 0) \n    {\n \
    \       int digit = number % 10;\n        if (digit == 9) \n        {\n      \
    \      result = roman_numerals[i] ~ roman_numerals[i + 2] ~ result;\n        }\
    \ \n        else if (digit == 4) \n        {\n            result = roman_numerals[i]\
    \ ~ roman_numerals[i + 1] ~ result;\n        } \n        else \n        {\n  \
    \          if (digit >= 5) \n            {\n                result = roman_numerals[i\
    \ + 1] ~ result;\n                digit -= 5;\n            }\n            result\
    \ = repeat(roman_numerals[i], digit) ~ result;\n        }\n        number /= 10;\n\
    \        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0z5uf9rl.d(36): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0z5uf9rl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    string result = \"\";\n    int i = 0;\n    while\
    \ (number > 0)\n    {\n        int digit = number % 10;\n        if (digit ==\
    \ 9)\n        {\n            result = roman_numerals[i] ~ roman_numerals[i + 2]\
    \ ~ result;\n        }\n        else if (digit == 4)\n        {\n            result\
    \ = roman_numerals[i] ~ roman_numerals[i + 1] ~ result;\n        }\n        else\n\
    \        {\n            if (digit >= 5)\n            {\n                result\
    \ = roman_numerals[i + 1] ~ result;\n                digit -= 5;\n           \
    \ }\n            result = repeat(roman_numerals[i], digit) ~ result;\n       \
    \ }\n        number /= 10;\n        i += 2;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr46ln2fb.d(35): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr46ln2fb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    static string[10]\
    \ roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\"\
    , \"dccc\", \"cm\"];\n    static string[10] roman_thousands = [\"\", \"m\", \"\
    mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"];\n    static\
    \ string[10] roman_tenthousands = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\"\
    , \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] roman_hundredthousands\
    \ = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"];\n    static string[10] roman_millions = [\"\", \"m\", \"mm\", \"mmm\",\
    \ \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"];\n    static string[10] roman_tenmillions\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman_hundredmillions = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[10]\
    \ roman_billions = [\"\", \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\"\
    , \"vmmm\", \"mx\"];\n    static string[10] roman_tenbillions = [\"\", \"x\",\
    \ \"xx\", \"xxx\", \"xl\", \"l\", \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz6l_6g2q.d(25): Error: unterminated string constant starting at
    /tmp/tmpz6l_6g2q.d(43)

    /tmp/tmpz6l_6g2q.d(30): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpz6l_6g2q.d(30): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpz6l_6g2q.d(31): Error: found `lii` when expecting `;` following statement

    /tmp/tmpz6l_6g2q.d(32): Error: found `cli` when expecting `;` following statement

    /tmp/tmpz6l_6g2q.d(33): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpz6l_6g2q.d(34): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpz6l_6g2q.d(35): Error: found `i` when expecting `;` following statement

    /tmp/tmpz6l_6g2q.d(36): Error: found `iv` when expecting `;` following statement

    /tmp/tmpz6l_6g2q.d(37): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpz6l_6g2q.d(38): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164588
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\
    \ \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\
    \ ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpedmsjzyg.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpedmsjzyg.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpedmsjzyg.__unittest_L17_C1() [0x427b29]

    ??:? void tmpedmsjzyg.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    return\
    \ roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp_eyz19z4.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428296]

    ??:? immutable(char)[] tmp_eyz19z4.int_to_mini_roman(long) [0x427b09]

    ??:? void tmp_eyz19z4.__unittest_L17_C1() [0x427b31]

    ??:? void tmp_eyz19z4.__modtest() [0x427f64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bf03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae12]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42feb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade9]

    ??:? runModuleUnitTests [0x42bcd9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    assert(1 <= number &&\
    \ number <= 1000);\n    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman_numerals[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\"\
    m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\"\
    , \"iv\", \"i\"];\n    static long[] decimal_numerals = [1000, 900, 500, 400,\
    \ 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n    foreach(i,\
    \ numeral; roman_numerals)\n    {\n        while(number >= decimal_numerals[i])\n\
    \        {\n            result ~= numeral;\n            number -= decimal_numerals[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"m\", \"cm\"\
    , \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"\
    i\"];\n    static int[] decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1];\n    string result = \"\";\n    int i = 0;\n    while (number > 0)\
    \ \n    {\n        while (number / decimal[i] > 0) \n        {\n            result\
    \ ~= roman[i];\n            number -= decimal[i];\n        }\n        i++;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] digits = [ \"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\" ];\n  \
    \  static string[10] tens = [ \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\" ];\n    static string[10] hundreds = [ \"\", \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\" ];\n  \
    \  static string[4] thousands = [ \"\", \"m\", \"mm\", \"mmm\" ];\n    return\
    \ thousands[number / 1000] ~ hundreds[(number / 100) % 10] ~ tens[(number / 10)\
    \ % 10] ~ digits[number % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[] roman_tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\",\
    \ \"lxx\", \"lxxx\", \"xc\"];\n    static string[] roman_hundreds = [\"\", \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n   \
    \ static string[] roman_thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return\
    \ roman_thousands[number / 1000] ~ roman_hundreds[(number % 1000) / 100] ~ roman_tens[(number\
    \ % 100) / 10] ~ roman[number % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] romans = [\n     \
    \   \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\"\n    ];\n    return romans[number];\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpnpo09vu4.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpnpo09vu4.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpnpo09vu4.__unittest_L19_C1() [0x427b29]

    ??:? void tmpnpo09vu4.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [ \"i\", \"\
    v\", \"x\", \"l\" ];\n    string result = \"\";\n    int i = 0;\n    while (number\
    \ > 0) \n    {\n        int digit = number % 10;\n        if (digit < 4) \n  \
    \      {\n            result = repeat(roman[i], digit) ~ result;\n        } \n\
    \        else if (digit == 4) \n        {\n            result = roman[i] ~ roman[i\
    \ + 1] ~ result;\n        } \n        else if (digit == 5) \n        {\n     \
    \       result = roman[i + 1] ~ result;\n        } \n        else if (digit <\
    \ 9) \n        {\n            result = roman[i + 1] ~ repeat(roman[i], digit -\
    \ 5) ~ result;\n        } \n        else \n        {\n            result = roman[i]\
    \ ~ roman[i + 2] ~ result;\n        }\n        number /= 10;\n        i += 2;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqyhl9yki.d(22): Error: undefined identifier `repeat`

    /tmp/tmpqyhl9yki.d(34): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqyhl9yki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(1 <= number && number\
    \ <= 1000);\n    return thousands[number / 1000] ~ hundreds[(number / 100) % 10]\
    \ ~ tens[(number / 10) % 10] ~ ones[number % 10];\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    static int[4] values = [1, 5, 10, 50];\n    string\
    \ result = \"\";\n    int i = 0;\n    while (number > 0) \n    {\n        int\
    \ digit = number % 10;\n        if (digit == 4) \n        {\n            result\
    \ = roman_numerals[i] ~ roman_numerals[i + 1] ~ result;\n        } \n        else\
    \ if (digit == 9) \n        {\n            result = roman_numerals[i] ~ roman_numerals[i\
    \ + 2] ~ result;\n        } \n        else \n        {\n            if (digit\
    \ >= 5) \n            {\n                result = roman_numerals[i + 1] ~ result;\n\
    \                digit -= 5;\n            }\n            result = repeat(roman_numerals[i],\
    \ digit) ~ result;\n        }\n        number /= 10;\n        i += 2;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr17ifj24.d(36): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr17ifj24.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static const string[] roman_numerals\
    \ = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"\
    x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static const long[] values = [\n\
    \        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string\
    \ result = \"\";\n    foreach(i, v; zip(roman_numerals, values))\n    {\n    \
    \    while(number >= v)\n        {\n            result ~= roman_numerals[i];\n\
    \            number -= v;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8nfo27wx.d(21): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8nfo27wx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6il2pwwv.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmp6il2pwwv.int_to_mini_roman(long) [0x427af2]

    ??:? void tmp6il2pwwv.__unittest_L17_C1() [0x427b29]

    ??:? void tmp6il2pwwv.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\
    \ \"i\", \"v\", \"x\", \"l\" ];\n    string result = \"\";\n    int i = 0;\n \
    \   while (number > 0) \n    {\n        int digit = number % 10;\n        if (digit\
    \ == 4) \n        {\n            result = roman_numerals[i] ~ roman_numerals[i\
    \ + 1] ~ result;\n        } \n        else if (digit == 9) \n        {\n     \
    \       result = roman_numerals[i] ~ roman_numerals[i + 2] ~ result;\n       \
    \ } \n        else \n        {\n            if (digit >= 5) \n            {\n\
    \                result = roman_numerals[i + 1] ~ result;\n                digit\
    \ -= 5;\n            }\n            result = repeat(roman_numerals[i], digit)\
    \ ~ result;\n        }\n        number /= 10;\n        i += 2;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphiqfv6in.d(35): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphiqfv6in.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] numbers = [\n        1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string result =\
    \ \"\";\n    foreach(i, roman; roman_numerals) {\n        while(number >= numbers[i])\
    \ {\n            result ~= roman;\n            number -= numbers[i];\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    auto result = \"\";\n    auto numeral\
    \ = [](long n, string one, string five, string ten) {\n        if (n == 0) return\
    \ \"\";\n        if (n <= 3) return one.repeat(n);\n        if (n == 4) return\
    \ one ~ five;\n        if (n <= 8) return five ~ one.repeat(n - 5);\n        return\
    \ one ~ ten;\n    };\n    result ~= numeral(number / 100, \"c\", \"d\", \"m\"\
    );\n    number %= 100;\n    result ~= numeral(number / 10, \"x\", \"l\", \"c\"\
    );\n    number %= 10;\n    result ~= numeral(number, \"i\", \"v\", \"x\");\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgiu4x7q5.d(15): Error: found `n` when expecting `.` following long

    /tmp/tmpgiu4x7q5.d(15): Error: found `,` when expecting identifier following `long`.

    /tmp/tmpgiu4x7q5.d(15): Error: found `string` when expecting `,`

    /tmp/tmpgiu4x7q5.d(15): Error: found `five` when expecting `,`

    /tmp/tmpgiu4x7q5.d(15): Error: expression expected, not `,`

    /tmp/tmpgiu4x7q5.d(15): Error: found `string` when expecting `,`

    /tmp/tmpgiu4x7q5.d(15): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpgiu4x7q5.d(21): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgiu4x7q5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"m\", \"cm\"\
    , \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"\
    i\"];\n    static int[] arabic = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1];\n    string result = \"\";\n    foreach(i, romanDigit; roman)\n  \
    \  {\n        while(number >= arabic[i])\n        {\n            number -= arabic[i];\n\
    \            result ~= romanDigit;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    static long[4] roman_numerals_values = [1, 5,\
    \ 10, 50];\n    static long[4] roman_numerals_values_max = [3, 1, 3, 1];\n   \
    \ static long[4] roman_numerals_values_next = [0, 2, 4, 0];\n    static long[4]\
    \ roman_numerals_values_next_next = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next_next_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next_next_next_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_next_next_next_next_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0pceyosz.d(29): Error: semicolon expected, not `unittest`

    /tmp/tmp0pceyosz.d(29): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0pceyosz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    if (number < 1 || number\
    \ > 1000)\n        return \"\";\n    return roman_thousands[number / 1000] ~\n\
    \           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n\
    \    static string[10] roman_tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] roman_hundreds\
    \ = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"];\n    static string[4] roman_thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n\
    \    static string[4] roman_tenthousands = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n\
    \    static string[4] roman_hundredthousands = [\"\", \"cm\", \"ccm\", \"cccm\"\
    ];\n    static string[4] roman_millions = [\"\", \"m\", \"mm\", \"mmm\"];\n  \
    \  static string[4] roman_tenmillions = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n \
    \   static string[4] roman_hundredmillions = [\"\", \"cm\", \"ccm\", \"cccm\"\
    ];\n    static string[4] roman_billions = [\"\", \"m\", \"mm\", \"mmm\"];\n  \
    \  static string[4] roman_tenbillions = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n \
    \   static string[4] roman_hundredbillions = [\"\", \"cm\", \"ccm\", \"cccm\"\
    ];\n    static string[4] roman_trillions = [\"\", \"m\", \"mm\", \"mmm\"];\n \
    \   static string[4] roman_tentrillions = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n\
    \    static string[4] roman_hundredtrillions = [\"\", \"cm\", \"ccm\", \"cccm\"\
    ];\n    static string[4] roman_quadrillions = [\"\", \"m\", \"mm\", \"mmm\"];\n\
    \    static string[4] roman_ten\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn16vfczb.d(31): Error: semicolon expected, not `unittest`

    /tmp/tmpn16vfczb.d(31): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn16vfczb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] values = [\n        1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string result =\
    \ \"\";\n    foreach(i, roman; roman_numerals) {\n        while(number >= values[i])\
    \ {\n            result ~= roman;\n            number -= values[i];\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"i\", \"\
    v\", \"x\", \"l\"];\n    string result = \"\";\n    int i = 0;\n    while (number\
    \ > 0) {\n        int digit = number % 10;\n        if (digit == 9) {\n      \
    \      result = roman[i] ~ roman[i + 2] ~ result;\n        } else if (digit ==\
    \ 4) {\n            result = roman[i] ~ roman[i + 1] ~ result;\n        } else\
    \ {\n            if (digit >= 5) {\n                result = roman[i + 1] ~ result;\n\
    \                digit -= 5;\n            }\n            result = repeat(roman[i],\
    \ digit) ~ result;\n        }\n        number /= 10;\n        i += 2;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpav3xjlmk.d(28): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpav3xjlmk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [ \"i\", \"\
    v\", \"x\", \"l\", \"c\", \"d\", \"m\" ];\n    static int[] values = [ 1, 5, 10,\
    \ 50, 100, 500, 1000 ];\n    string result = \"\";\n    int i = 6;\n    while\
    \ (number > 0) \n    {\n        int power = (int)pow(10, i);\n        int digit\
    \ = number / power;\n        number %= power;\n        if (digit != 0) \n    \
    \    {\n            if (digit <= 3) \n            {\n                result ~=\
    \ roman[2 * i];\n                for (int j = 1; j < digit; j++) \n          \
    \      {\n                    result ~= roman[2 * i];\n                }\n   \
    \         } \n            else if (digit == 4) \n            {\n             \
    \   result ~= roman[2 * i] ~ roman[2 * i + 1];\n            } \n            else\
    \ if (digit == 5) \n            {\n                result ~= roman[2 * i + 1];\n\
    \            } \n            else if (digit <= 8) \n            {\n          \
    \      result ~= roman[2 * i + 1];\n                for (int j = 6; j <= digit;\
    \ j++) \n                {\n                    result ~= roman[2 * i];\n    \
    \            }\n            } \n            else \n            {\n           \
    \     result ~= roman[2 * i] ~ roman[2 * i + 2];\n            }\n        }\n \
    \       i--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppsqmdmkb.d(20): Error: C style cast illegal, use `cast(int)pow(10,
    i)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppsqmdmkb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] bigs = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    \n    string result = \"\";\n    int i = 0;\n\
    \    while (number > 0)\n    {\n        result = ones[number % 10] ~ result;\n\
    \        number /= 10;\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6wle33zx.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283ad]

    ??:? void tmp6wle33zx.__unittest_L30_C1() [0x427d30]

    ??:? void tmp6wle33zx.__modtest() [0x42812c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c213]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b122]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4300f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4305a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43007d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0f9]

    ??:? runModuleUnitTests [0x42bfe9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428870]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] decimal_numerals = [\n  \
    \      1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string\
    \ result = \"\";\n    foreach(i, roman_numeral; roman_numerals) {\n        while(number\
    \ >= decimal_numerals[i]) {\n            result ~= roman_numeral;\n          \
    \  number -= decimal_numerals[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    string result = \"\";\n    int i = 0;\n    while\
    \ (number > 0) \n    {\n        int digit = number % 10;\n        if (digit <\
    \ 4) \n        {\n            result = repeat(roman_numerals[i], digit) ~ result;\n\
    \        } \n        else if (digit == 4) \n        {\n            result = roman_numerals[i]\
    \ ~ roman_numerals[i + 1] ~ result;\n        } \n        else if (digit == 5)\
    \ \n        {\n            result = roman_numerals[i + 1] ~ result;\n        }\
    \ \n        else if (digit < 9) \n        {\n            result = roman_numerals[i\
    \ + 1] ~ repeat(roman_numerals[i], digit - 5) ~ result;\n        } \n        else\
    \ \n        {\n            result = roman_numerals[i] ~ roman_numerals[i + 2]\
    \ ~ result;\n        }\n        number /= 10;\n        i += 2;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgl6cs_mu.d(22): Error: undefined identifier `repeat`

    /tmp/tmpgl6cs_mu.d(34): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgl6cs_mu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string roman;\n    static string[10]\
    \ roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\"\
    , \"dccc\", \"cm\"];\n    static string[4] roman_thousands = [\"\", \"m\", \"\
    mm\", \"mmm\"];\n    roman ~= roman_thousands[number / 1000];\n    roman ~= roman_hundreds[(number\
    \ % 1000) / 100];\n    roman ~= roman_tens[(number % 100) / 10];\n    roman ~=\
    \ roman_numerals[number % 10];\n    return roman;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static const string roman_numerals =\
    \ \"ivxlcdm\";\n    static const int[] numeral_values = [1, 5, 10, 50, 100, 500,\
    \ 1000];\n    static const int[] numeral_indices = [0, 1, 1, 2, 2, 2, 3, 3, 4,\
    \ 4, 4, 5, 5, 5, 6];\n    static const int[] numeral_counts = [0, 1, 2, 3, 1,\
    \ 0, 1, 2, 3, 1, 0, 1, 2, 3, 1];\n    static const int[] numeral_offsets = [0,\
    \ 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3];\n    static const int[] numeral_multipliers\
    \ = [1, 10, 100, 1000];\n    static const int[] numeral_divisors = [1, 10, 100,\
    \ 1000];\n    static const int[] numeral_modulos = [1, 10, 100, 1000];\n    static\
    \ const int[] numeral_quotients = [1, 10, 100, 1000];\n    static const int[]\
    \ numeral_remainders = [1, 10, 100, 1000];\n    static const int[] numeral_subtractors\
    \ = [1, 10, 100, 1000];\n    static const int[] numeral_subtractors_index = [1,\
    \ 10, 100, 1000];\n    static const int[] numeral_subtractors_count = [1, 10,\
    \ 100, 1000];\n    static const int[] numeral_subtractors_offset = [1, 10, 100,\
    \ 1000];\n    static const int[] numeral_subtractors_multiplier = [1, 10, 100,\
    \ 1000];\n    static const int[] numeral_subtractors_divisor = [1, 10, 100, 1000];\n\
    \    static const int[] numeral_subtractors_modulo = [1, 10, 100, 1000];\n   \
    \ static const int[] numeral_subtractors_quotient = [1, 10, 100, 1000];\n    static\
    \ const int[] numeral_subtractors_remainder = [1, 10\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi4ozl80e.d(33): Error: comma expected separating array initializers,
    not `unittest`

    /tmp/tmpi4ozl80e.d(34): Error: semicolon expected, not `{`

    /tmp/tmpi4ozl80e.d(52): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi4ozl80e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] values = [\n        1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string result =\
    \ \"\";\n    foreach(i, roman_numeral; roman_numerals) {\n        while(number\
    \ >= values[i]) {\n            result ~= roman_numeral;\n            number -=\
    \ values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n\
    \    return roman_numerals[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwd6_0lml.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpwd6_0lml.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpwd6_0lml.__unittest_L17_C1() [0x427b29]

    ??:? void tmpwd6_0lml.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n\
    \    return roman_numerals[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwd6_0lml.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpwd6_0lml.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpwd6_0lml.__unittest_L17_C1() [0x427b29]

    ??:? void tmpwd6_0lml.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    static long[4] roman_values = [1, 5, 10, 50];\n\
    \    static long[4] roman_values_next = [5, 10, 50, 100];\n    string result =\
    \ \"\";\n    for (int i = 3; i >= 0; i--)\n    {\n        long value = roman_values[i];\n\
    \        long value_next = roman_values_next[i];\n        long value_next_next\
    \ = roman_values_next[i - 1];\n        long quotient = number / value;\n     \
    \   long remainder = number % value;\n        if (quotient == 4)\n        {\n\
    \            result ~= roman_numerals[i] ~ roman_numerals[i + 1];\n        }\n\
    \        else if (quotient == 9)\n        {\n            result ~= roman_numerals[i]\
    \ ~ roman_numerals[i + 2];\n        }\n        else\n        {\n            if\
    \ (quotient >= 5)\n            {\n                result ~= roman_numerals[i +\
    \ 1];\n                quotient -= 5;\n            }\n            result ~= roman_numerals[i].repeat(quotient);\n\
    \        }\n        number = remainder;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk9i1zocu.d(40): Error: no property `repeat` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk9i1zocu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    return\
    \ roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp_eyz19z4.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428296]

    ??:? immutable(char)[] tmp_eyz19z4.int_to_mini_roman(long) [0x427b09]

    ??:? void tmp_eyz19z4.__unittest_L17_C1() [0x427b31]

    ??:? void tmp_eyz19z4.__modtest() [0x427f64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bf03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae12]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42feb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade9]

    ??:? runModuleUnitTests [0x42bcd9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6il2pwwv.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmp6il2pwwv.int_to_mini_roman(long) [0x427af2]

    ??:? void tmp6il2pwwv.__unittest_L17_C1() [0x427b29]

    ??:? void tmp6il2pwwv.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6il2pwwv.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmp6il2pwwv.int_to_mini_roman(long) [0x427af2]

    ??:? void tmp6il2pwwv.__unittest_L17_C1() [0x427b29]

    ??:? void tmp6il2pwwv.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    return roman_thousands[number\
    \ / 1000] ~\n        roman_hundreds[(number / 100) % 10] ~\n        roman_tens[(number\
    \ / 10) % 10] ~\n        roman_numerals[number % 10];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\
    \ \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\
    \ ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpedmsjzyg.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpedmsjzyg.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpedmsjzyg.__unittest_L17_C1() [0x427b29]

    ??:? void tmpedmsjzyg.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n\
    \    return roman_numerals[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwd6_0lml.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpwd6_0lml.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpwd6_0lml.__unittest_L17_C1() [0x427b29]

    ??:? void tmpwd6_0lml.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    string result = \"\";\n   \
    \ result ~= thousands[number / 1000];\n    result ~= hundreds[(number % 1000)\
    \ / 100];\n    result ~= tens[(number % 100) / 10];\n    result ~= ones[number\
    \ % 10];\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"m\", \"cm\"\
    , \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"\
    i\"];\n    static long[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1];\n    string result = \"\";\n    foreach(i, r; roman)\n    {\n    \
    \    while(number >= values[i])\n        {\n            number -= values[i];\n\
    \            result ~= r;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    int[] roman = [1,\
    \ 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n    string[] roman_str\
    \ = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\"\
    , \"d\", \"cm\", \"m\"];\n    int i = roman.length - 1;\n    while (number > 0)\
    \ \n    {\n        int div = number / roman[i];\n        number %= roman[i];\n\
    \        while (div-- > 0) \n        {\n            result ~= roman_str[i];\n\
    \        }\n        i--;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp9m86gcz.d(17): Error: cannot implicitly convert expression `roman.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpp9m86gcz.d(20): Error: cannot implicitly convert expression `number /
    cast(long)roman[cast(ulong)i]` of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp9m86gcz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6il2pwwv.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmp6il2pwwv.int_to_mini_roman(long) [0x427af2]

    ??:? void tmp6il2pwwv.__unittest_L17_C1() [0x427b29]

    ??:? void tmp6il2pwwv.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    if (number == 0)\n\
    \        return \"\";\n    if (number >= 1000)\n    {\n        result ~= \"m\"\
    ;\n        number -= 1000;\n    }\n    if (number >= 900)\n    {\n        result\
    \ ~= \"cm\";\n        number -= 900;\n    }\n    if (number >= 500)\n    {\n \
    \       result ~= \"d\";\n        number -= 500;\n    }\n    if (number >= 400)\n\
    \    {\n        result ~= \"cd\";\n        number -= 400;\n    }\n    if (number\
    \ >= 100)\n    {\n        result ~= \"c\";\n        number -= 100;\n    }\n  \
    \  if (number >= 90)\n    {\n        result ~= \"xc\";\n        number -= 90;\n\
    \    }\n    if (number >= 50)\n    {\n        result ~= \"l\";\n        number\
    \ -= 50;\n    }\n    if (number >= 40)\n    {\n        result ~= \"xl\";\n   \
    \     number -= 40;\n    }\n    if (number >= 10)\n    {\n        result ~= \"\
    x\";\n        number -= 10;\n    }\n    if (number >= 9)\n    {\n        result\
    \ ~= \"ix\";\n        number -= 9;\n    }\n    if (number >= 5)\n    {\n     \
    \   result ~= \"v\";\n        number -= 5;\n    }\n    if (number >= 4)\n    {\n\
    \        result ~= \"iv\";\n        number -= 4;\n    }\n    if (number >= 1)\n\
    \    {\n        result ~= \"i\";\n        number -= 1;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqf7enwfn.d(89): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283a5]

    ??:? void tmpqf7enwfn.__unittest_L84_C1() [0x427d69]

    ??:? void tmpqf7enwfn.__modtest() [0x428124]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42caeb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b9fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430321]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4307d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4302ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d1]

    ??:? runModuleUnitTests [0x42c8c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    enum roman_numerals = [\n        \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n\
    \    return roman_numerals[number - 1];\n}\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp5e_4peia.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428e66]

    ??:? immutable(char)[] tmp5e_4peia.int_to_mini_roman(long) [0x427bc0]

    ??:? void tmp5e_4peia.__unittest_L19_C1() [0x427be9]

    ??:? void tmp5e_4peia.__modtest() [0x42801c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d703]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428b0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a5b1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a640]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a53d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ae5]

    ??:? runModuleUnitTests [0x42d4d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    assert(number > 0 &&\
    \ number <= 1000);\n    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman_numerals[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\
    \ \"i\", \"v\", \"x\", \"l\" ];\n    static int[4] values = [ 1, 5, 10, 50 ];\n\
    \    static int[4] digits = [ 0, 0, 0, 0 ];\n    static string result = \"\";\n\
    \    static int i = 0;\n    static int j = 0;\n    static int k = 0;\n    static\
    \ int l = 0;\n    static int m = 0;\n    static int n = 0;\n    static int p =\
    \ 0;\n    static int q = 0;\n    static int r = 0;\n    static int s = 0;\n  \
    \  static int t = 0;\n    static int u = 0;\n    static int v = 0;\n    static\
    \ int w = 0;\n    static int x = 0;\n    static int y = 0;\n    static int z =\
    \ 0;\n    static int aa = 0;\n    static int bb = 0;\n    static int cc = 0;\n\
    \    static int dd = 0;\n    static int ee = 0;\n    static int ff = 0;\n    static\
    \ int gg = 0;\n    static int hh = 0;\n    static int ii = 0;\n    static int\
    \ jj = 0;\n    static int kk = 0;\n    static int ll = 0;\n    static int mm =\
    \ 0;\n    static int nn = 0;\n    static int oo = 0;\n    static int pp = 0;\n\
    \    static int qq = 0;\n    static int rr = 0;\n    static int ss = 0;\n    static\
    \ int tt = 0;\n    static int uu = 0;\n    static int vv = 0;\n    static int\
    \ ww = 0;\n    static int xx = 0;\n    static int yy = 0;\n    static int zz =\
    \ 0;\n    static int aaa = 0;\n    static int bbb = 0;\n    static int ccc = 0;\n\
    \    static int ddd = 0;\n    static int eee = 0;\n    static int fff = 0;\n \
    \   static int ggg = 0;\n    static int hhh = 0;\n    static int iii\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbswckzef.d(70): Error: semicolon expected, not `unittest`

    /tmp/tmpbswckzef.d(70): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbswckzef.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_numerals_tens = [\n        \"\"\
    , \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n \
    \   ];\n    static string[10] roman_numerals_hundreds = [\n        \"\", \"c\"\
    , \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n\
    \    static string[4] roman_numerals_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    return roman_numerals_thousands[number / 1000] ~\n    \
    \       roman_numerals_hundreds[(number / 100) % 10] ~\n           roman_numerals_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    const string roman_numerals = \"ivxlcdm\"\
    ;\n    string result;\n    int i = 0;\n    while (number > 0) \n    {\n      \
    \  int digit = number % 10;\n        if (digit < 4) \n        {\n            result\
    \ = repeat(roman_numerals[i], digit) ~ result;\n        } \n        else if (digit\
    \ == 4) \n        {\n            result = roman_numerals[i] ~ roman_numerals[i\
    \ + 1] ~ result;\n        } \n        else if (digit == 5) \n        {\n     \
    \       result = roman_numerals[i + 1] ~ result;\n        } \n        else if\
    \ (digit < 9) \n        {\n            result = roman_numerals[i + 1] ~ repeat(roman_numerals[i],\
    \ digit - 5) ~ result;\n        } \n        else \n        {\n            result\
    \ = roman_numerals[i] ~ roman_numerals[i + 2] ~ result;\n        }\n        number\
    \ /= 10;\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxuud113l.d(22): Error: undefined identifier `repeat`

    /tmp/tmpxuud113l.d(26): Error: incompatible types for `(cast(int)roman_numerals[cast(ulong)i])
    ~ (cast(int)roman_numerals[cast(ulong)(i + 1)])`: both operands are of type `int`

    /tmp/tmpxuud113l.d(34): Error: undefined identifier `repeat`

    /tmp/tmpxuud113l.d(38): Error: incompatible types for `(cast(int)roman_numerals[cast(ulong)i])
    ~ (cast(int)roman_numerals[cast(ulong)(i + 2)])`: both operands are of type `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxuud113l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"i\", \"v\"\
    , \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static int[] values = [1, 5, 10, 50,\
    \ 100, 500, 1000];\n    static int[] divisors = [1, 10, 100, 1000];\n    string\
    \ result = \"\";\n    int i = 0;\n    foreach(divisor; divisors)\n    {\n    \
    \    int digit = (number / divisor) % 10;\n        if (digit == 0)\n        {\n\
    \            i += 2;\n            continue;\n        }\n        if (digit < 4)\n\
    \        {\n            result ~= roman[i] * digit;\n        }\n        else if\
    \ (digit == 4)\n        {\n            result ~= roman[i] ~ roman[i + 1];\n  \
    \      }\n        else if (digit == 5)\n        {\n            result ~= roman[i\
    \ + 1];\n        }\n        else if (digit < 9)\n        {\n            result\
    \ ~= roman[i + 1] ~ roman[i] * (digit - 5);\n        }\n        else\n       \
    \ {\n            result ~= roman[i] ~ roman[i + 2];\n        }\n        i += 2;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcdc9qxz0.d(29): Error: incompatible types for `(roman[cast(ulong)i])
    * (digit)`: `string` and `int`

    /tmp/tmpcdc9qxz0.d(41): Error: incompatible types for `(roman[cast(ulong)i]) *
    (digit - 5)`: `string` and `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcdc9qxz0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    int[] digits = [1,\
    \ 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n    string[] romans = [\"\
    i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\"\
    , \"cm\", \"m\"];\n    int i = digits.length - 1;\n    while (number > 0) \n \
    \   {\n        while (number >= digits[i]) \n        {\n            result ~=\
    \ romans[i];\n            number -= digits[i];\n        }\n        i--;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj_vj7cce.d(17): Error: cannot implicitly convert expression `digits.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj_vj7cce.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string roman_numerals = \"ivxlcdm\"\
    ;\n    static int[] roman_values = [1, 5, 10, 50, 100, 500, 1000];\n    static\
    \ int[] roman_subtractors = [1, 10, 100];\n    static int[] roman_subtractors_values\
    \ = [1, 10, 100];\n    static string[] roman_subtractors_strings = [\"i\", \"\
    x\", \"c\"];\n    static string[] roman_subtractors_strings_5 = [\"v\", \"l\"\
    , \"d\"];\n    static string[] roman_subtractors_strings_10 = [\"x\", \"c\", \"\
    m\"];\n    static string[] roman_subtractors_strings_5_10 = [\"v\", \"l\", \"\
    d\"];\n    static string[] roman_subtractors_strings_10_10 = [\"x\", \"c\", \"\
    m\"];\n    static string[] roman_subtractors_strings_5_5 = [\"v\", \"l\", \"d\"\
    ];\n    static string[] roman_subtractors_strings_10_5 = [\"x\", \"c\", \"m\"\
    ];\n    static string[] roman_subtractors_strings_5_1 = [\"v\", \"l\", \"d\"];\n\
    \    static string[] roman_subtractors_strings_10_1 = [\"x\", \"c\", \"m\"];\n\
    \    static string[] roman_subtractors_strings_5_5_1 = [\"v\", \"l\", \"d\"];\n\
    \    static string[] roman_subtractors_strings_10_5_1 = [\"x\", \"c\", \"m\"];\n\
    \    static string[] roman_subtractors_strings_5_10_1 = [\"v\", \"l\", \"d\"];\n\
    \    static string[] roman_subtractors_strings_10_10_1 = [\"x\", \"c\", \"m\"\
    ];\n    static string[] roman_subtractors_strings_5_10_10 = [\"v\", \"l\", \"\
    d\"];\n    static string[] roman_subtractors_strings_10_\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4r7sfs_9.d(33): Error: semicolon expected, not `unittest`

    /tmp/tmp4r7sfs_9.d(33): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4r7sfs_9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"i\", \"\
    v\", \"x\", \"l\"];\n    string result = \"\";\n    int digit = 0;\n    while\
    \ (number > 0) \n    {\n        int remainder = number % 10;\n        if (remainder\
    \ == 9) \n        {\n            result = roman[digit] ~ roman[digit + 2] ~ result;\n\
    \        } \n        else if (remainder >= 5) \n        {\n            result\
    \ = roman[digit + 1] ~ roman[digit].repeat(remainder - 5) ~ result;\n        }\
    \ \n        else if (remainder == 4) \n        {\n            result = roman[digit]\
    \ ~ roman[digit + 1] ~ result;\n        } \n        else \n        {\n       \
    \     result = roman[digit].repeat(remainder) ~ result;\n        }\n        number\
    \ /= 10;\n        digit += 2;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzla36aiw.d(26): Error: no property `repeat` for type `string`

    /tmp/tmpzla36aiw.d(34): Error: no property `repeat` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzla36aiw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    assert(number >= 1 &&\
    \ number <= 1000);\n    return roman_thousands[number / 1000] ~ \n           roman_hundreds[(number\
    \ / 100) % 10] ~ \n           roman_tens[(number / 10) % 10] ~ \n           roman_numerals[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    int[] values = [1,\
    \ 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n    string[] numerals =\
    \ [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\",\
    \ \"d\", \"cm\", \"m\"];\n    int i = values.length - 1;\n    while (number >\
    \ 0) \n    {\n        int val = values[i];\n        if (number >= val) \n    \
    \    {\n            result ~= numerals[i];\n            number -= val;\n     \
    \   } \n        else \n        {\n            i--;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp10aubbbw.d(17): Error: cannot implicitly convert expression `values.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp10aubbbw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"m\", \"cm\"\
    , \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"\
    i\"];\n    static long[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1];\n    string result = \"\";\n    foreach(i, r; roman)\n    {\n    \
    \    while(number >= values[i])\n        {\n            number -= values[i];\n\
    \            result ~= r;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    static long[4] decimal_numerals = [1, 5, 10, 50];\n\
    \    string result = \"\";\n    long i = 0;\n    while (number > 0) {\n      \
    \  long current_numeral = decimal_numerals[i];\n        long next_numeral = decimal_numerals[i\
    \ + 1];\n        long next_next_numeral = decimal_numerals[i + 2];\n        long\
    \ current_digit = number % 10;\n        if (current_digit == 9) {\n          \
    \  result = roman_numerals[i] ~ roman_numerals[i + 2] ~ result;\n            number\
    \ -= 9 * current_numeral;\n        } else if (current_digit == 4) {\n        \
    \    result = roman_numerals[i] ~ roman_numerals[i + 1] ~ result;\n          \
    \  number -= 4 * current_numeral;\n        } else {\n            result = roman_numerals[i]\
    \ ~ result;\n            number -= current_numeral;\n        }\n        i += 2;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpz6u_pfig.d(21): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42865e]

    ??:? immutable(char)[] tmpz6u_pfig.int_to_mini_roman(long) [0x427c1a]

    ??:? void tmpz6u_pfig.__unittest_L37_C1() [0x427efd]

    ??:? void tmpz6u_pfig.__modtest() [0x428330]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c413]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b322]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4302f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4307a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43027d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2f9]

    ??:? runModuleUnitTests [0x42c1e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    int[] values = [1,\
    \ 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n    string[] numerals =\
    \ [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\",\
    \ \"d\", \"cm\", \"m\"];\n    while (number > 0) \n    {\n        foreach (i,\
    \ v; zip(values, numerals)) \n        {\n            if (v[0] <= number) \n  \
    \          {\n                result ~= v[1];\n                number -= v[0];\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\n/*\n    Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3tdpj4ty.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3tdpj4ty.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    string result = \"\";\n \
    \   int index = 0;\n    while (number > 0) \n    {\n        int digit = number\
    \ % 10;\n        if (digit == 0) \n        {\n            number /= 10;\n    \
    \        index += 2;\n            continue;\n        }\n        if (digit <= 3)\
    \ \n        {\n            result = repeat(roman_numerals[index], digit) ~ result;\n\
    \        } \n        else if (digit == 4) \n        {\n            result = roman_numerals[index]\
    \ ~ roman_numerals[index + 1] ~ result;\n        } \n        else if (digit ==\
    \ 5) \n        {\n            result = roman_numerals[index + 1] ~ result;\n \
    \       } \n        else if (digit <= 8) \n        {\n            result = roman_numerals[index\
    \ + 1] ~ repeat(roman_numerals[index], digit - 5) ~ result;\n        } \n    \
    \    else \n        {\n            result = roman_numerals[index] ~ roman_numerals[index\
    \ + 2] ~ result;\n        }\n        number /= 10;\n        index += 2;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfx3tlo3m.d(28): Error: undefined identifier `repeat`

    /tmp/tmpfx3tlo3m.d(40): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfx3tlo3m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] digits = [\n     \
    \   \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\"\n    ];\n    static string[10] tens = [\n        \"\", \"x\", \"xx\", \"\
    xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static string[10]\
    \ hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] thousands = [\n        \"\
    \", \"m\", \"mm\", \"mmm\"\n    ];\n    string result = \"\";\n    result ~= thousands[number\
    \ / 1000];\n    result ~= hundreds[(number / 100) % 10];\n    result ~= tens[(number\
    \ / 10) % 10];\n    result ~= digits[number % 10];\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    static int[4] values = [1, 5, 10, 50];\n    string\
    \ result = \"\";\n    int i = 0;\n    while (number > 0) {\n        int digit\
    \ = number % 10;\n        if (digit == 9) {\n            result = roman_numerals[i]\
    \ ~ roman_numerals[i + 2] ~ result;\n        } else if (digit == 4) {\n      \
    \      result = roman_numerals[i] ~ roman_numerals[i + 1] ~ result;\n        }\
    \ else {\n            if (digit >= 5) {\n                result = roman_numerals[i\
    \ + 1] ~ result;\n                digit -= 5;\n            }\n            result\
    \ = repeat(roman_numerals[i], digit) ~ result;\n        }\n        number /= 10;\n\
    \        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6zbl1iir.d(29): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6zbl1iir.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6il2pwwv.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmp6il2pwwv.int_to_mini_roman(long) [0x427af2]

    ??:? void tmp6il2pwwv.__unittest_L17_C1() [0x427b29]

    ??:? void tmp6il2pwwv.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\
    \ \"i\", \"v\", \"x\", \"l\" ];\n    static long[4] decimal_values = [ 1, 5, 10,\
    \ 50 ];\n    static long[4] decimal_values_max = [ 4, 9, 40, 90 ];\n    static\
    \ string[4] roman_numerals_max = [ \"iv\", \"ix\", \"xl\", \"xc\" ];\n    static\
    \ long[4] decimal_values_max_2 = [ 9, 40, 90, 400 ];\n    static string[4] roman_numerals_max_2\
    \ = [ \"ix\", \"xl\", \"xc\", \"cd\" ];\n    static long[4] decimal_values_max_3\
    \ = [ 40, 90, 400, 900 ];\n    static string[4] roman_numerals_max_3 = [ \"xl\"\
    , \"xc\", \"cd\", \"cm\" ];\n    static long[4] decimal_values_max_4 = [ 90, 400,\
    \ 900, 1000 ];\n    static string[4] roman_numerals_max_4 = [ \"xc\", \"cd\",\
    \ \"cm\", \"m\" ];\n    static long[4] decimal_values_max_5 = [ 400, 900, 1000,\
    \ 0 ];\n    static string[4] roman_numerals_max_5 = [ \"cd\", \"cm\", \"m\", \"\
    \" ];\n    static long[4] decimal_values_max_6 = [ 900, 1000, 0, 0 ];\n    static\
    \ string[4] roman_numerals_max_6 = [ \"cm\", \"m\", \"\", \"\" ];\n    static\
    \ long[4] decimal_values_max_7 = [ 1000, 0, 0, 0 ];\n    static string[4] roman_numerals_max_7\
    \ = [ \"m\", \"\", \"\", \"\" ];\n    static long[4] decimal_values_max_8 = [\
    \ 0, 0, 0, 0 ];\n    static string[4] roman_numerals_max_8 = [ \"\", \"\", \"\"\
    , \"\" ];\n    static long[4] decimal_values_max_9 = [ 0, 0, 0, 0 ];\n    static\
    \ string[\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9dsk9rck.d(34): Error: expression expected, not `unittest`

    /tmp/tmp9dsk9rck.d(35): Error: found `{` when expecting `]`

    /tmp/tmp9dsk9rck.d(36): Error: no identifier for declarator `string[0]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9dsk9rck.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"i\", \"\
    v\", \"x\", \"l\"];\n    static string[4] roman_5 = [\"\", \"v\", \"x\", \"l\"\
    ];\n    static string[4] roman_10 = [\"\", \"\", \"x\", \"l\"];\n    static string[4]\
    \ roman_50 = [\"\", \"\", \"\", \"l\"];\n    static string[4] roman_100 = [\"\"\
    , \"\", \"\", \"\"];\n    static string[4] roman_500 = [\"\", \"\", \"\", \"\"\
    ];\n    static string[4] roman_1000 = [\"\", \"\", \"\", \"\"];\n    static string[4]\
    \ roman_5000 = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_10000 = [\"\
    \", \"\", \"\", \"\"];\n    static string[4] roman_50000 = [\"\", \"\", \"\",\
    \ \"\"];\n    static string[4] roman_100000 = [\"\", \"\", \"\", \"\"];\n    static\
    \ string[4] roman_500000 = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_1000000\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_5000000 = [\"\", \"\"\
    , \"\", \"\"];\n    static string[4] roman_10000000 = [\"\", \"\", \"\", \"\"\
    ];\n    static string[4] roman_50000000 = [\"\", \"\", \"\", \"\"];\n    static\
    \ string[4] roman_100000000 = [\"\", \"\", \"\", \"\"];\n    static string[4]\
    \ roman_500000000 = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_1000000000\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_5000000000 = [\"\",\
    \ \"\", \"\", \"\"];\n    static string[4] roman_10000000000 = [\"\", \"\", \"\
    \", \"\"];\n    static string[4] roman_50000000000 = [\"\", \"\", \"\", \"\"];\n\
    \    static string[4] roman_100000000000 = [\"\", \"\", \"\", \"\"];\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx_j9uku7.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_j9uku7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[4] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[4] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\"];\n    \n    return thousands[number / 1000] ~ hundreds[(number\
    \ / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjjow22i3.d(14): Error: array initializer has 10 elements, but array
    length is 4

    /tmp/tmpjjow22i3.d(15): Error: array initializer has 10 elements, but array length
    is 4

    /tmp/tmpjjow22i3.d(16): Error: array initializer has 10 elements, but array length
    is 4

    /tmp/tmpjjow22i3.d(17): Error: array initializer has 10 elements, but array length
    is 4

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjjow22i3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] separators\
    \ = [\"\", \" \", \" \", \" \"];\n    return thousands[number / 1000] ~ separators[number\
    \ / 1000] ~ hundreds[(number / 100) % 10] ~ separators[number / 100] ~ tens[(number\
    \ / 10) % 10] ~ separators[number / 10] ~ ones[number % 10];\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph4owy8zg.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285b5]

    ??:? void tmph4owy8zg.__unittest_L21_C1() [0x427f3c]

    ??:? void tmph4owy8zg.__modtest() [0x428338]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c2d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4302f9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4307a8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430285]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1b9]

    ??:? runModuleUnitTests [0x42c0a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a78]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    \n    assert(number > 0 &&\
    \ number <= 1000);\n    \n    return thousands[number / 1000] ~ hundreds[(number\
    \ / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [ \"i\", \"\
    iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\"\
    , \"m\" ];\n    static long[] decimal = [ 1, 4, 5, 9, 10, 40, 50, 90, 100, 400,\
    \ 500, 900, 1000 ];\n    string result = \"\";\n    for (long i = roman.length\
    \ - 1; i >= 0; i--)\n    {\n        while (number >= decimal[i])\n        {\n\
    \            number -= decimal[i];\n            result ~= roman[i];\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    return\
    \ roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp_eyz19z4.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428296]

    ??:? immutable(char)[] tmp_eyz19z4.int_to_mini_roman(long) [0x427b09]

    ??:? void tmp_eyz19z4.__unittest_L17_C1() [0x427b31]

    ??:? void tmp_eyz19z4.__modtest() [0x427f64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bf03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae12]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42feb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade9]

    ??:? runModuleUnitTests [0x42bcd9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n\
    \    return roman_numerals[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwd6_0lml.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpwd6_0lml.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpwd6_0lml.__unittest_L17_C1() [0x427b29]

    ??:? void tmpwd6_0lml.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    m\", \"c\", \"x\", \"i\"];\n    static int[4] decimal_numerals = [1000, 100, 10,\
    \ 1];\n    static int[4] repeat_limit = [3, 3, 3, 3];\n    static string[4] five_symbols\
    \ = [\"\", \"d\", \"l\", \"v\"];\n    static string[4] nine_symbols = [\"\", \"\
    cm\", \"xc\", \"ix\"];\n    string result = \"\";\n    foreach (index, numeral;\
    \ roman_numerals)\n    {\n        int repeat_count = number / decimal_numerals[index];\n\
    \        if (repeat_count == 4)\n        {\n            result ~= roman_numerals[index]\
    \ ~ five_symbols[index];\n        }\n        else if (repeat_count == 9)\n   \
    \     {\n            result ~= roman_numerals[index] ~ nine_symbols[index];\n\
    \        }\n        else\n        {\n            result ~= repeat(roman_numerals[index],\
    \ repeat_count);\n        }\n        number %= decimal_numerals[index];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0_16rke5.d(22): Error: cannot implicitly convert expression `number
    / cast(long)decimal_numerals[index]` of type `long` to `int`

    /tmp/tmp0_16rke5.d(33): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0_16rke5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    import std.conv;\n    import std.string;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.array;\n   \
    \ import std.typecons;\n    import std.math;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.traits;\n    import\
    \ std.meta;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.type\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprncetdh2.d(83): Error: `;` expected

    /tmp/tmprncetdh2.d(102): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprncetdh2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\"\n    ];\n    assert(1 <= number && number <= 1000);\n    string result =\
    \ \"\";\n    if (number >= 100) {\n        result ~= roman_numerals[(number /\
    \ 100) - 1];\n        number %= 100;\n    }\n    if (number >= 10) {\n       \
    \ result ~= roman_numerals[(number / 10) - 1];\n        number %= 10;\n    }\n\
    \    if (number > 0) {\n        result ~= roman_numerals[number - 1];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk9wpmz6l.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x428451]

    ??:? void tmpk9wpmz6l.__unittest_L32_C1() [0x427d24]

    ??:? void tmpk9wpmz6l.__modtest() [0x428120]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cc0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bb1a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430441]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42baf1]

    ??:? runModuleUnitTests [0x42c9e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428914]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] romans = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ string result = \"\";\n    while (number > 0) \n    {\n        result ~= romans[number\
    \ % 10];\n        number /= 10;\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpax80zdqw.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x42823d]

    ??:? void tmpax80zdqw.__unittest_L23_C1() [0x427bc4]

    ??:? void tmpax80zdqw.__modtest() [0x427fc0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9f7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b906]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43022d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4306dc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4301b9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8dd]

    ??:? runModuleUnitTests [0x42c7cd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428700]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[int] roman_numerals =\
    \ [\n        1: \"i\",\n        4: \"iv\",\n        5: \"v\",\n        9: \"ix\"\
    ,\n        10: \"x\",\n        40: \"xl\",\n        50: \"l\",\n        90: \"\
    xc\",\n        100: \"c\",\n        400: \"cd\",\n        500: \"d\",\n      \
    \  900: \"cm\",\n        1000: \"m\"\n    ];\n    static int[] roman_numerals_keys\
    \ = roman_numerals.keys;\n    static int[] roman_numerals_values = roman_numerals.values;\n\
    \    static int[] roman_numerals_keys_sorted = roman_numerals_keys.sort;\n   \
    \ static int[] roman_numerals_values_sorted = roman_numerals_values.sort;\n  \
    \  static int[] roman_numerals_keys_sorted_reversed = roman_numerals_keys_sorted.reverse;\n\
    \    static int[] roman_numerals_values_sorted_reversed = roman_numerals_values_sorted.reverse;\n\
    \    static int[] roman_numerals_keys_sorted_reversed_unique = roman_numerals_keys_sorted_reversed.uniq;\n\
    \    static int[] roman_numerals_values_sorted_reversed_unique = roman_numerals_values_sorted_reversed.uniq;\n\
    \    static int[] roman_numerals_keys_sorted_reversed_unique_sorted = roman_numerals_keys_sorted_reversed_unique.sort;\n\
    \    static int[] roman_numerals_values_sorted_reversed_unique_sorted = roman_numerals_values_sorted_reversed_unique.sort;\n\
    \    static int[] roman_numerals_keys_sorted_reversed_unique_sorted_reversed =\
    \ roman_numerals_keys_sorted_reversed_unique_sorted.reverse\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2n_jh4qx.d(40): Error: semicolon expected, not `unittest`

    /tmp/tmp2n_jh4qx.d(40): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2n_jh4qx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"m\", \"\
    c\", \"x\", \"i\"];\n    static long[4] decimal = [1000, 100, 10, 1];\n    string\
    \ result = \"\";\n    foreach (i, r; roman) \n    {\n        long count = number\
    \ / decimal[i];\n        number %= decimal[i];\n        if (count == 9) \n   \
    \     {\n            result ~= r ~ roman[i - 1];\n        } \n        else if\
    \ (count >= 5) \n        {\n            result ~= roman[i - 1];\n            result\
    \ ~= r ~ repeat(r, count - 5);\n        } \n        else if (count == 4) \n  \
    \      {\n            result ~= r ~ roman[i - 1];\n        } \n        else \n\
    \        {\n            result ~= repeat(r, count);\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfz277fb3.d(28): Error: undefined identifier `repeat`

    /tmp/tmpfz277fb3.d(36): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfz277fb3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    foreach(i; iota(0,\
    \ 4))\n    {\n        auto digit = number % 10;\n        number /= 10;\n     \
    \   if (digit == 0) continue;\n        if (digit <= 3)\n            result ~=\
    \ \"I\" * digit;\n        else if (digit == 4)\n            result ~= \"IV\";\n\
    \        else if (digit <= 8)\n            result ~= \"V\" ~ \"I\" * (digit -\
    \ 5);\n        else\n            result ~= \"IX\";\n    }\n    return result.idup.reverse;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8wb6d_iw.d(15): Error: undefined identifier `iota`

    /tmp/tmp8wb6d_iw.d(29): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(string)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wb6d_iw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [ \"\
    i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\" ];\n    static int[] values = [\
    \ 1, 5, 10, 50, 100, 500, 1000 ];\n    static int[] digits = [ 0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9 ];\n    static string[] roman_digits = [ \"\", \"c\", \"cc\",\
    \ \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\" ];\n    static string[]\
    \ roman_tens = [ \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\" ];\n    static string[] roman_hundreds = [ \"\", \"i\", \"\
    ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\" ];\n    static\
    \ string[] roman_thousands = [ \"\", \"m\", \"mm\", \"mmm\" ];\n    static string[]\
    \ roman_tenthousands = [ \"\", \"xm\", \"xxm\", \"xxxm\", \"xlm\", \"lm\", \"\
    lxm\", \"lxxm\", \"lxxxm\", \"xcm\" ];\n    static string[] roman_hundredthousands\
    \ = [ \"\", \"im\", \"iim\", \"iiim\", \"ivm\", \"vm\", \"vim\", \"viim\", \"\
    viiim\", \"ixm\" ];\n    static string[] roman_millions = [ \"\", \"mm\", \"mmm\"\
    \ ];\n    static string[] roman_tenmillions = [ \"\", \"xmm\", \"xxmm\", \"xxxmm\"\
    , \"xlmm\", \"lmm\", \"lxmm\", \"lxxmm\", \"lxxxmm\", \"xcmm\" ];\n    static\
    \ string[] roman_hundredmillions = [ \"\", \"imm\", \"iimm\", \"iiimm\", \"ivmm\"\
    , \"vmm\", \"vimm\", \"viimm\", \"viiimm\", \"ixmm\" ];\n    static string[] roman_billions\
    \ = [ \"\", \"mmm\" ];\n    static string[] roman_tenbill\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6xngpphm.d(28): Error: semicolon expected, not `unittest`

    /tmp/tmp6xngpphm.d(28): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6xngpphm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_thousands\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred_millions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_billions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_trillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpedkr5oqc.d(57): Error: expression expected, not `unittest`

    /tmp/tmpedkr5oqc.d(58): Error: found `{` when expecting `]`

    /tmp/tmpedkr5oqc.d(59): Error: no identifier for declarator `string[0]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedkr5oqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number >= 1 && number\
    \ <= 1000);\n    return thousands[number / 1000] ~ hundreds[(number / 100) % 10]\
    \ ~ tens[(number / 10) % 10] ~ ones[number % 10];\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [ \"i\", \"\
    v\", \"x\", \"l\", \"c\", \"d\", \"m\" ];\n    string result = \"\";\n    int\
    \ i = 0;\n    while (number > 0) \n    {\n        int digit = number % 10;\n \
    \       if (digit == 9) \n        {\n            result = roman[i] ~ roman[i +\
    \ 2] ~ result;\n        } \n        else if (digit == 4) \n        {\n       \
    \     result = roman[i] ~ roman[i + 1] ~ result;\n        } \n        else \n\
    \        {\n            if (digit >= 5) \n            {\n                result\
    \ = roman[i + 1] ~ result;\n                digit -= 5;\n            }\n     \
    \       result = repeat(roman[i], digit) ~ result;\n        }\n        number\
    \ /= 10;\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwwr4lwsu.d(35): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwwr4lwsu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n\
    \    return roman_numerals[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwd6_0lml.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpwd6_0lml.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpwd6_0lml.__unittest_L17_C1() [0x427b29]

    ??:? void tmpwd6_0lml.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] numbers = [\n        1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string result =\
    \ \"\";\n    foreach(i, roman_numeral; roman_numerals) {\n        while(number\
    \ >= numbers[i]) {\n            result ~= roman_numeral;\n            number -=\
    \ numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] separators\
    \ = [\"\", \" \", \" \", \" \"];\n    static string[4] separators2 = [\"\", \"\
    \ \", \" \", \" \"];\n    static string[4] separators3 = [\"\", \" \", \" \",\
    \ \" \"];\n    static string[4] separators4 = [\"\", \" \", \" \", \" \"];\n \
    \   static string[4] separators5 = [\"\", \" \", \" \", \" \"];\n    static string[4]\
    \ separators6 = [\"\", \" \", \" \", \" \"];\n    static string[4] separators7\
    \ = [\"\", \" \", \" \", \" \"];\n    static string[4] separators8 = [\"\", \"\
    \ \", \" \", \" \"];\n    static string[4] separators9 = [\"\", \" \", \" \",\
    \ \" \"];\n    static string[4] separators10 = [\"\", \" \", \" \", \" \"];\n\
    \    static string[4] separators11 = [\"\", \" \", \" \", \" \"];\n    static\
    \ string[4] separators12 = [\"\", \" \", \" \", \" \"];\n    static string[4]\
    \ separators13 = [\"\", \" \", \" \", \" \"];\n    static string[4] separators14\
    \ = [\"\", \" \", \" \", \" \"];\n    static string[4] separators15 = [\"\", \"\
    \ \", \" \", \" \"];\n    static string[4] separators16 = [\"\", \" \", \" \"\
    , \" \"];\n    static string[4] separators17 = [\"\", \" \", \" \", \" \"];\n\
    \    static string[4] separators18 = [\"\", \" \", \" \", \" \"];\n    static\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa8at4p_k.d(37): Error: basic type expected, not `unittest`

    /tmp/tmpa8at4p_k.d(37): Error: no identifier for declarator `_error_`

    /tmp/tmpa8at4p_k.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa8at4p_k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    foreach(i; 0 ..\
    \ 4)\n    {\n        auto digit = number % 10;\n        number /= 10;\n      \
    \  switch(i)\n        {\n            case 0:\n                result ~= repeat(\"\
    I\", digit);\n                break;\n            case 1:\n                result\
    \ ~= repeat(digit == 4 ? \"IV\" : \"V\", digit / 5);\n                result ~=\
    \ repeat(\"I\", digit % 5);\n                break;\n            case 2:\n   \
    \             result ~= repeat(digit == 4 ? \"XL\" : \"L\", digit / 5);\n    \
    \            result ~= repeat(\"X\", digit % 5);\n                break;\n   \
    \         case 3:\n                result ~= repeat(digit == 4 ? \"CD\" : \"D\"\
    , digit / 5);\n                result ~= repeat(\"C\", digit % 5);\n         \
    \       break;\n            case 4:\n                result ~= repeat(\"M\", digit);\n\
    \                break;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh_wbs8o.d(22): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(25): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(26): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(29): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(30): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(33): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(34): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(37): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh_wbs8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [ \"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\" ];\n  \
    \  return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpe0vwl__t.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpe0vwl__t.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpe0vwl__t.__unittest_L17_C1() [0x427b29]

    ??:? void tmpe0vwl__t.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    string result = \"\";\n   \
    \ if (number >= 1000) \n    {\n        result ~= thousands[number / 1000];\n \
    \       number %= 1000;\n    }\n    if (number >= 100) \n    {\n        result\
    \ ~= hundreds[number / 100];\n        number %= 100;\n    }\n    if (number >=\
    \ 10) \n    {\n        result ~= tens[number / 10];\n        number %= 10;\n \
    \   }\n    if (number >= 1) \n    {\n        result ~= ones[number];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static const string roman_numerals =\
    \ \"ivxlcdm\";\n    static const long[] roman_values = [1, 5, 10, 50, 100, 500,\
    \ 1000];\n    static const long[] roman_values_max = [3, 1, 1, 1, 3, 1, 3];\n\
    \    static const long[] roman_values_min = [1, 0, 0, 0, 1, 0, 1];\n    static\
    \ const long[] roman_values_mid = [1, 1, 1, 1, 1, 1, 1];\n    static const long[]\
    \ roman_values_next = [5, 10, 50, 100, 500, 1000, 0];\n    static const long[]\
    \ roman_values_prev = [0, 1, 5, 10, 50, 100, 500];\n    static const long[] roman_values_prev_prev\
    \ = [0, 0, 1, 5, 10, 50, 100];\n    static const long[] roman_values_next_next\
    \ = [10, 50, 100, 500, 1000, 0, 0];\n    static const long[] roman_values_next_next_next\
    \ = [50, 100, 500, 1000, 0, 0, 0];\n    static const long[] roman_values_prev_prev_prev\
    \ = [0, 0, 0, 1, 5, 10, 50];\n    static const long[] roman_values_prev_prev_prev_prev\
    \ = [0, 0, 0, 0, 1, 5, 10];\n    static const long[] roman_values_next_next_next_next\
    \ = [100, 500, 1000, 0, 0, 0, 0];\n    static const long[] roman_values_next_next_next_next_next\
    \ = [500, 1000, 0, 0, 0, 0, 0];\n    static const long[] roman_values_next_next_next_next_next_next\
    \ = [1000, 0, 0, 0, 0, 0, 0];\n    static const long[] roman_values_prev_prev_prev_prev_prev\
    \ = [0, 0, 0, 0, 0, 1, 5];\n    static const long[] roman_values_prev_prev_prev_prev_prev_prev\
    \ =\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcjroldqm.d(31): Error: expression expected, not `unittest`

    /tmp/tmpcjroldqm.d(32): Error: semicolon expected, not `{`

    /tmp/tmpcjroldqm.d(50): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcjroldqm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    static long[4] decimal_numerals = [1, 5, 10, 50];\n\
    \    static long[4] decimal_numerals_max = [3, 1, 3, 1];\n    static long[4] decimal_numerals_next\
    \ = [0, 2, 4, 0];\n    static long[4] decimal_numerals_next_next = [0, 0, 0, 0];\n\
    \    static long[4] decimal_numerals_next_next_next = [0, 0, 0, 0];\n    static\
    \ long[4] decimal_numerals_next_next_next_next = [0, 0, 0, 0];\n    static long[4]\
    \ decimal_numerals_next_next_next_next_next = [0, 0, 0, 0];\n    static long[4]\
    \ decimal_numerals_next_next_next_next_next_next = [0, 0, 0, 0];\n    static long[4]\
    \ decimal_numerals_next_next_next_next_next_next_next = [0, 0, 0, 0];\n    static\
    \ long[4] decimal_numerals_next_next_next_next_next_next_next_next = [0, 0, 0,\
    \ 0];\n    static long[4] decimal_numerals_next_next_next_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] decimal_numerals_next_next_next_next_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] decimal_numerals_next_next_next_next_next_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] decimal_numerals_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = [0, 0, 0, 0];\n    static long[4] decimal_numerals_next_next_\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6y1oo52f.d(30): Error: semicolon expected, not `unittest`

    /tmp/tmp6y1oo52f.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6y1oo52f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\n      \
    \  \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\"\n    ];\n    static string[10] roman10 = [\n        \"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman100 = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman1000 =\
    \ [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    string result;\n    if\
    \ (number < 10) {\n        result = roman[number];\n    } else if (number < 100)\
    \ {\n        result = roman10[number / 10] ~ roman[number % 10];\n    } else if\
    \ (number < 1000) {\n        result = roman100[number / 100] ~ roman10[(number\
    \ / 10) % 10] ~ roman[number % 10];\n    } else {\n        result = roman1000[number\
    \ / 1000] ~ roman100[(number / 100) % 10] ~ roman10[(number / 10) % 10] ~ roman[number\
    \ % 10];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] values = [\n        1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string result =\
    \ \"\";\n    foreach(i, roman_numeral; roman_numerals) {\n        while(number\
    \ >= values[i]) {\n            result ~= roman_numeral;\n            number -=\
    \ values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    assert(number > 0 &&\
    \ number <= 1000);\n    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman_numerals[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    const string roman\
    \ = \"ivxlcdm\";\n    int i = 0;\n    while (number > 0) \n    {\n        int\
    \ digit = number % 10;\n        if (digit == 9) \n        {\n            result\
    \ = roman[i] ~ roman[i + 2] ~ result;\n        } \n        else if (digit == 4)\
    \ \n        {\n            result = roman[i] ~ roman[i + 1] ~ result;\n      \
    \  } \n        else \n        {\n            if (digit >= 5) \n            {\n\
    \                result = roman[i + 1] ~ result;\n                digit -= 5;\n\
    \            }\n            result = repeat(roman[i], digit) ~ result;\n     \
    \   }\n        number /= 10;\n        i += 2;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpijtvjyxv.d(22): Error: incompatible types for `(cast(int)roman[cast(ulong)i])
    ~ (cast(int)roman[cast(ulong)(i + 2)])`: both operands are of type `int`

    /tmp/tmpijtvjyxv.d(26): Error: incompatible types for `(cast(int)roman[cast(ulong)i])
    ~ (cast(int)roman[cast(ulong)(i + 1)])`: both operands are of type `int`

    /tmp/tmpijtvjyxv.d(35): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpijtvjyxv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_thousands\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred_millions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_billions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_trillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpedkr5oqc.d(57): Error: expression expected, not `unittest`

    /tmp/tmpedkr5oqc.d(58): Error: found `{` when expecting `]`

    /tmp/tmpedkr5oqc.d(59): Error: no identifier for declarator `string[0]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedkr5oqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\n        \"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n\
    \    ];\n    return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpfizzhl09.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428296]

    ??:? immutable(char)[] tmpfizzhl09.int_to_mini_roman(long) [0x427b09]

    ??:? void tmpfizzhl09.__unittest_L19_C1() [0x427b31]

    ??:? void tmpfizzhl09.__modtest() [0x427f64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bf03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae12]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42feb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade9]

    ??:? runModuleUnitTests [0x42bcd9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"m\", \"\
    c\", \"x\", \"i\"];\n    static long[4] decimal = [1000, 100, 10, 1];\n    string\
    \ result = \"\";\n    foreach (i, r; roman) \n    {\n        long count = number\
    \ / decimal[i];\n        number %= decimal[i];\n        if (count == 9) \n   \
    \     {\n            result ~= r ~ roman[i - 1];\n        } \n        else if\
    \ (count >= 5) \n        {\n            result ~= roman[i - 1];\n            result\
    \ ~= r ~ repeat(r, count - 5);\n        } \n        else if (count == 4) \n  \
    \      {\n            result ~= r ~ roman[i - 1];\n        } \n        else \n\
    \        {\n            result ~= repeat(r, count);\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfz277fb3.d(28): Error: undefined identifier `repeat`

    /tmp/tmpfz277fb3.d(36): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfz277fb3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[4] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[4] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\"];\n    return thousands[number / 1000] ~ hundreds[(number / 100)\
    \ % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpna1p7k90.d(14): Error: array initializer has 10 elements, but array
    length is 4

    /tmp/tmpna1p7k90.d(15): Error: array initializer has 10 elements, but array length
    is 4

    /tmp/tmpna1p7k90.d(16): Error: array initializer has 10 elements, but array length
    is 4

    /tmp/tmpna1p7k90.d(17): Error: array initializer has 10 elements, but array length
    is 4

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpna1p7k90.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164588
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    int i;\n    int[]\
    \ numeral = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n    string[]\
    \ roman = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\",\
    \ \"cd\", \"d\", \"cm\", \"m\"];\n    for (i = numeral.length - 1; i >= 0; i--)\
    \ \n    {\n        while (number >= numeral[i]) \n        {\n            result\
    \ ~= roman[i];\n            number -= numeral[i];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb4g8q59y.d(18): Error: cannot implicitly convert expression `numeral.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb4g8q59y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [ \"i\", \"\
    v\", \"x\", \"l\" ];\n    static int[4]    value = [  1,   5,  10,  50 ];\n  \
    \  string result;\n    foreach (i; 0 .. 4)\n    {\n        int v = value[i];\n\
    \        if (number >= v)\n        {\n            int count = number / v;\n  \
    \          number %= v;\n            result ~= roman[i] * count;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnu_fb0xi.d(22): Error: cannot implicitly convert expression `number
    / cast(long)v` of type `long` to `int`

    /tmp/tmpnu_fb0xi.d(24): Error: incompatible types for `(roman[cast(ulong)i]) *
    (count)`: `string` and `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnu_fb0xi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    assert(number >= 1 &&\
    \ number <= 1000);\n    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman_numerals[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    int[] digits = [1,\
    \ 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n    string[] roman = [\"\
    i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\"\
    , \"cm\", \"m\"];\n    foreach(i; 0 .. digits.length)\n    {\n        while(number\
    \ >= digits[i])\n        {\n            result ~= roman[i];\n            number\
    \ -= digits[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpe84kgo4m.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x42921d]

    ??:? void tmpe84kgo4m.__unittest_L27_C1() [0x42808c]

    ??:? void tmpe84kgo4m.__modtest() [0x428488]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e7eb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b4b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b544]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b441]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f4d]

    ??:? runModuleUnitTests [0x42e5c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\
    \ \"i\", \"v\", \"x\", \"l\" ];\n    static long[4]   roman_values   = [ 1, 5,\
    \ 10, 50 ];\n    static long[4]   roman_limits   = [ 3, 1, 3, 1 ];\n    static\
    \ string[4] roman_subtract = [ \"i\", \"x\", \"c\", \"m\" ];\n    static long[4]\
    \   roman_subvals  = [ 1, 10, 100, 1000 ];\n    static long[4]   roman_sublims\
    \  = [ 1, 1, 1, 1 ];\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviidfv7o.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviidfv7o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] romans = [\n       \
    \ \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n \
    \   ];\n    assert(0 < number && number <= 1000);\n    return romans[number -\
    \ 1];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpycgnqkli.d(18): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4283aa]

    ??:? immutable(char)[] tmpycgnqkli.int_to_mini_roman(long) [0x427b65]

    ??:? void tmpycgnqkli.__unittest_L20_C1() [0x427b95]

    ??:? void tmpycgnqkli.__modtest() [0x427fc8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c017]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42af26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43003d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4304ec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ffc9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aefd]

    ??:? runModuleUnitTests [0x42bded]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] ones = [\"i\", \"x\"\
    , \"c\", \"m\"];\n    static string[4] fives = [\"v\", \"l\", \"d\", \"\"];\n\
    \    static string[4] tens = [\"x\", \"c\", \"m\", \"\"];\n    static string[4]\
    \ fifties = [\"l\", \"d\", \"\", \"\"];\n    static string[4] hundreds = [\"c\"\
    , \"m\", \"\", \"\"];\n    static string[4] five_hundreds = [\"d\", \"\", \"\"\
    , \"\"];\n    static string[4] thousands = [\"m\", \"\", \"\", \"\"];\n    static\
    \ string[4] five_thousands = [\"\", \"\", \"\", \"\"];\n    \n    string result\
    \ = \"\";\n    int i = 0;\n    while (number > 0) {\n        int digit = number\
    \ % 10;\n        if (digit == 4) {\n            result = ones[i] ~ fives[i] ~\
    \ result;\n        } else if (digit == 9) {\n            result = ones[i] ~ tens[i]\
    \ ~ result;\n        } else {\n            if (digit >= 5) {\n               \
    \ result = fives[i] ~ result;\n                digit -= 5;\n            }\n  \
    \          for (int j = 0; j < digit; j++) {\n                result = ones[i]\
    \ ~ result;\n            }\n        }\n        number /= 10;\n        i++;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzpw23ex0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428785]

    ??:? void tmpzpw23ex0.__unittest_L45_C1() [0x4281cf]

    ??:? void tmpzpw23ex0.__modtest() [0x428508]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5eb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430978]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430455]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4d1]

    ??:? runModuleUnitTests [0x42c3c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c48]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\n      \
    \  \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\"\n    ];\n    static string[10] roman10 = [\n        \"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman100 = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman1000 =\
    \ [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    return roman1000[number\
    \ / 1000] ~\n           roman100[(number % 1000) / 100] ~\n           roman10[(number\
    \ % 100) / 10] ~\n           roman[number % 10];\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    enum roman_numerals = [\n        \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n\
    \    return roman_numerals[number - 1];\n}\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp5e_4peia.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428e66]

    ??:? immutable(char)[] tmp5e_4peia.int_to_mini_roman(long) [0x427bc0]

    ??:? void tmp5e_4peia.__unittest_L19_C1() [0x427be9]

    ??:? void tmp5e_4peia.__modtest() [0x42801c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d703]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428b0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a5b1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a640]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a53d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ae5]

    ??:? runModuleUnitTests [0x42d4d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [ \"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\" ];\n  \
    \  return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpe0vwl__t.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpe0vwl__t.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpe0vwl__t.__unittest_L17_C1() [0x427b29]

    ??:? void tmpe0vwl__t.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] digits = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ static string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\"\
    , \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\",\
    \ \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static\
    \ string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number\
    \ / 1000] ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ digits[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"m\", \"\
    c\", \"x\", \"i\"];\n    static long[4] decimal = [1000, 100, 10, 1];\n    string\
    \ result = \"\";\n    foreach (i, r; roman) \n    {\n        long count = number\
    \ / decimal[i];\n        number %= decimal[i];\n        if (count < 4) \n    \
    \    {\n            result ~= repeat(r, count);\n        } \n        else if (count\
    \ == 4) \n        {\n            result ~= r ~ roman[i - 1];\n        } \n   \
    \     else if (count > 4 && count < 9) \n        {\n            result ~= roman[i\
    \ - 1] ~ repeat(r, count - 5);\n        } \n        else if (count == 9) \n  \
    \      {\n            result ~= r ~ roman[i - 2];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkg1kv_et.d(23): Error: undefined identifier `repeat`

    /tmp/tmpkg1kv_et.d(31): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkg1kv_et.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n\
    \    return roman_numerals[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwd6_0lml.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpwd6_0lml.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpwd6_0lml.__unittest_L17_C1() [0x427b29]

    ??:? void tmpwd6_0lml.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    static long[4] roman_numerals_values = [1, 5,\
    \ 10, 50];\n    static long[4] roman_numerals_values_next = [5, 10, 50, 100];\n\
    \    static long[4] roman_numerals_values_prev = [0, 1, 5, 10];\n    static long[4]\
    \ roman_numerals_values_prev_prev = [0, 0, 1, 5];\n    static long[4] roman_numerals_values_prev_prev_prev\
    \ = [0, 0, 0, 1];\n    static long[4] roman_numerals_values_prev_prev_prev_prev\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_prev_prev_prev_prev_prev\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_prev_prev_prev_prev_prev_prev\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_prev_prev_prev_prev_prev_prev_prev\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = [0, 0, 0, 0];\n    static long[4] roman_numerals_values_prev_prev_prev_prev_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzhiem2nd.d(29): Error: semicolon expected, not `unittest`

    /tmp/tmpzhiem2nd.d(29): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzhiem2nd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"m\", \"cm\"\
    , \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"\
    i\"];\n    static long[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1];\n    string result = \"\";\n    foreach(i, r; roman)\n    {\n    \
    \    while(number >= values[i])\n        {\n            number -= values[i];\n\
    \            result ~= r;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    string result = \"\"\
    ;\n    if (number < 1 || number > 1000)\n        return result;\n    result ~=\
    \ roman_thousands[number / 1000];\n    number %= 1000;\n    result ~= roman_hundreds[number\
    \ / 100];\n    number %= 100;\n    result ~= roman_tens[number / 10];\n    number\
    \ %= 10;\n    result ~= roman_numerals[number];\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    i\", \"v\", \"x\", \"l\"];\n    string result = \"\";\n    int i = 0;\n    while\
    \ (number > 0) \n    {\n        int digit = number % 10;\n        if (digit <\
    \ 4) \n        {\n            result = repeat(roman_numerals[i], digit) ~ result;\n\
    \        } \n        else if (digit == 4) \n        {\n            result = roman_numerals[i]\
    \ ~ roman_numerals[i + 1] ~ result;\n        } \n        else if (digit < 9) \n\
    \        {\n            result = roman_numerals[i + 1] ~ repeat(roman_numerals[i],\
    \ digit - 5) ~ result;\n        } \n        else \n        {\n            result\
    \ = roman_numerals[i] ~ roman_numerals[i + 2] ~ result;\n        }\n        number\
    \ /= 10;\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5d34ymqb.d(22): Error: undefined identifier `repeat`

    /tmp/tmp5d34ymqb.d(30): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5d34ymqb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\
    \ \"m\", \"c\", \"x\", \"i\" ];\n    static int[4] decimal_values = [ 1000, 100,\
    \ 10, 1 ];\n    static int[4] repeat_values = [ 3, 3, 3, 3 ];\n    static int[4]\
    \ subtractive_values = [ 900, 90, 9, 4 ];\n    static string[4] subtractive_symbols\
    \ = [ \"cm\", \"xc\", \"ix\", \"iv\" ];\n    string result = \"\";\n    int i\
    \ = 0;\n    while (number > 0) \n    {\n        int repeats = number / decimal_values[i];\n\
    \        if (repeats < 4) \n        {\n            result ~= roman_numerals[i]\
    \ * repeats;\n        }\n        else if (repeats == 4) \n        {\n        \
    \    result ~= subtractive_symbols[i];\n        }\n        else if (repeats <\
    \ 9) \n        {\n            result ~= roman_numerals[i] * (repeats - 5) ~ subtractive_symbols[i][0..1];\n\
    \        }\n        else \n        {\n            result ~= roman_numerals[i];\n\
    \        }\n        number %= decimal_values[i];\n        i++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpexn6so3c.d(23): Error: cannot implicitly convert expression `number
    / cast(long)decimal_values[cast(ulong)i]` of type `long` to `int`

    /tmp/tmpexn6so3c.d(26): Error: incompatible types for `(roman_numerals[cast(ulong)i])
    * (repeats)`: `string` and `int`

    /tmp/tmpexn6so3c.d(34): Error: incompatible types for `(roman_numerals[cast(ulong)i])
    * (repeats - 5)`: `string` and `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpexn6so3c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    static string[10]\
    \ roman = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"];\n    if (number > 0 && number < 10)\n        result = roman[number];\n\
    \    else if (number >= 10 && number < 100)\n    {\n        result = roman[number\
    \ / 10];\n        result ~= roman[number % 10];\n    }\n    else if (number >=\
    \ 100 && number < 1000)\n    {\n        result = roman[number / 100];\n      \
    \  result ~= roman[(number % 100) / 10];\n        result ~= roman[number % 10];\n\
    \    }\n    else if (number == 1000)\n        result = \"m\";\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpil90v91a.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428425]

    ??:? void tmpil90v91a.__unittest_L33_C1() [0x427dac]

    ??:? void tmpil90v91a.__modtest() [0x4281a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cbdf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42baee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430415]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308c4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303a1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bac5]

    ??:? runModuleUnitTests [0x42c9b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    string result = \"\"\
    ;\n    auto thousands = number / 1000;\n    auto hundreds = (number % 1000) /\
    \ 100;\n    auto tens = (number % 100) / 10;\n    auto ones = number % 10;\n \
    \   result ~= roman_thousands[thousands];\n    result ~= roman_hundreds[hundreds];\n\
    \    result ~= roman_tens[tens];\n    result ~= roman_numerals[ones];\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"m\", \"cm\"\
    , \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"\
    i\"];\n    static long[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1];\n    string result = \"\";\n    foreach(i, r; roman)\n    {\n    \
    \    while(number >= values[i])\n        {\n            number -= values[i];\n\
    \            result ~= r;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"m\", \"\
    c\", \"x\", \"i\"];\n    static long[4] decimal = [1000, 100, 10, 1];\n    string\
    \ result = \"\";\n    foreach (i, r; roman) \n    {\n        long count = number\
    \ / decimal[i];\n        number %= decimal[i];\n        if (count == 9) \n   \
    \     {\n            result ~= r ~ roman[i - 1];\n        } \n        else if\
    \ (count >= 5) \n        {\n            result ~= roman[i - 1];\n            result\
    \ ~= r ~ repeat(r, count - 5);\n        } \n        else if (count == 4) \n  \
    \      {\n            result ~= r ~ roman[i - 1];\n        } \n        else \n\
    \        {\n            result ~= repeat(r, count);\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfz277fb3.d(28): Error: undefined identifier `repeat`

    /tmp/tmpfz277fb3.d(36): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfz277fb3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\"\
    m\", \"c\", \"x\", \"i\"];\n    static long[4] values = [1000, 100, 10, 1];\n\
    \    static long[4] subtractive_values = [900, 90, 9, 4];\n    static string[4]\
    \ subtractive_numerals = [\"cm\", \"xc\", \"ix\", \"iv\"];\n    string result\
    \ = \"\";\n    foreach (i, val; values)\n    {\n        long number_of_letters\
    \ = number / val;\n        if (number_of_letters == 4)\n        {\n          \
    \  result ~= subtractive_numerals[i];\n            number -= subtractive_values[i];\n\
    \        }\n        else\n        {\n            result ~= roman_numerals[i] *\
    \ number_of_letters;\n            number -= number_of_letters * val;\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1trnsi42.d(29): Error: incompatible types for `(roman_numerals[i])
    * (number_of_letters)`: `string` and `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1trnsi42.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[4] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[4] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\"];\n    static string[4] ten_thousands = [\"\", \"x\", \"xx\", \"\
    xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[4]\
    \ hundred_thousands = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\"];\n    static string[4] millions = [\"\", \"m\", \"mm\"\
    , \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"];\n    static string[4]\
    \ ten_millions = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[4] hundred_millions = [\"\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static\
    \ string[4] billions = [\"\", \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"\
    vmm\", \"vmmm\", \"mx\"];\n    static string[4] ten_billions = [\"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static\
    \ string[4] hundred_billions = [\"\", \"c\", \"cc\", \"ccc\", \"cd\",\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu9ghe_4x.d(26): Error: expression expected, not `unittest`

    /tmp/tmpu9ghe_4x.d(27): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpu9ghe_4x.d(45): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpu9ghe_4x.d(45): Error: semicolon expected, not `main`

    /tmp/tmpu9ghe_4x.d(45): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu9ghe_4x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    auto ones = number %\
    \ 10;\n    auto tens = (number / 10) % 10;\n    auto hundreds = (number / 100)\
    \ % 10;\n    auto thousands = (number / 1000) % 10;\n    return format(\"%s%s%s%s\"\
    ,\n        roman_thousands[thousands],\n        roman_hundreds[hundreds],\n  \
    \      roman_tens[tens],\n        roman_numerals[ones]\n    );\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptow37gwd.d(30): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptow37gwd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman_numerals = [\
    \ \"i\", \"v\", \"x\", \"l\" ];\n    static long[4] divisors = [ 1, 5, 10, 50\
    \ ];\n    static long[4] multipliers = [ 1, 10, 100, 1000 ];\n    static long[4]\
    \ subtractors = [ 1, 10, 100, 1000 ];\n    static long[4] limits = [ 3, 1, 3,\
    \ 1 ];\n    static long[4] exceptions = [ 4, 9, 40, 90 ];\n    static long[4]\
    \ exception_values = [ 1, 1, 10, 10 ];\n    static long[4] exception_subtractors\
    \ = [ 1, 1, 10, 10 ];\n    static long[4] exception_multipliers = [ 1, 1, 10,\
    \ 10 ];\n    static long[4] exception_divisors = [ 1, 1, 10, 10 ];\n    static\
    \ long[4] exception_limits = [ 1, 1, 1, 1 ];\n    static long[4] exception_exceptions\
    \ = [ 0, 0, 0, 0 ];\n    static long[4] exception_exception_values = [ 0, 0, 0,\
    \ 0 ];\n    static long[4] exception_exception_subtractors = [ 0, 0, 0, 0 ];\n\
    \    static long[4] exception_exception_multipliers = [ 0, 0, 0, 0 ];\n    static\
    \ long[4] exception_exception_divisors = [ 0, 0, 0, 0 ];\n    static long[4] exception_exception_limits\
    \ = [ 0, 0, 0, 0 ];\n    static long[4] exception_exception_exceptions = [ 0,\
    \ 0, 0, 0 ];\n    static long[4] exception_exception_exception_values = [ 0, 0,\
    \ 0, 0 ];\n    static long[4] exception_exception_exception_subtractors = [ 0,\
    \ 0, 0, 0 ];\n    static long[4] exception_exception_exception_multipliers = [\
    \ 0, 0, 0, 0 ];\n    static long[4] exception_exception_exception_divisors = [\
    \ 0, 0, 0, 0 ];\n    static long[4\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6mlek49u.d(37): Error: found `unittest` when expecting `]`

    /tmp/tmp6mlek49u.d(38): Error: no identifier for declarator `long[4]`

    /tmp/tmp6mlek49u.d(56): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6mlek49u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    if (number >= 1000)\
    \ \n    {\n        result ~= 'm';\n        number -= 1000;\n    }\n    if (number\
    \ >= 900) \n    {\n        result ~= \"cm\";\n        number -= 900;\n    }\n\
    \    if (number >= 500) \n    {\n        result ~= 'd';\n        number -= 500;\n\
    \    }\n    if (number >= 400) \n    {\n        result ~= \"cd\";\n        number\
    \ -= 400;\n    }\n    while (number >= 100) \n    {\n        result ~= 'c';\n\
    \        number -= 100;\n    }\n    if (number >= 90) \n    {\n        result\
    \ ~= \"xc\";\n        number -= 90;\n    }\n    if (number >= 50) \n    {\n  \
    \      result ~= 'l';\n        number -= 50;\n    }\n    if (number >= 40) \n\
    \    {\n        result ~= \"xl\";\n        number -= 40;\n    }\n    while (number\
    \ >= 10) \n    {\n        result ~= 'x';\n        number -= 10;\n    }\n    if\
    \ (number >= 9) \n    {\n        result ~= \"ix\";\n        number -= 9;\n   \
    \ }\n    if (number >= 5) \n    {\n        result ~= 'v';\n        number -= 5;\n\
    \    }\n    if (number >= 4) \n    {\n        result ~= \"iv\";\n        number\
    \ -= 4;\n    }\n    while (number >= 1) \n    {\n        result ~= 'i';\n    \
    \    number -= 1;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"m\", \"\
    c\", \"x\", \"i\"];\n    static long[4] decimal = [1000, 100, 10, 1];\n    string\
    \ result = \"\";\n    foreach (i, r; roman) \n    {\n        long count = number\
    \ / decimal[i];\n        number %= decimal[i];\n        if (count == 9) \n   \
    \     {\n            result ~= r ~ roman[i - 1];\n        } \n        else if\
    \ (count >= 5) \n        {\n            result ~= roman[i - 1];\n            result\
    \ ~= r ~ repeat(r, count - 5);\n        } \n        else if (count == 4) \n  \
    \      {\n            result ~= r ~ roman[i - 1];\n        } \n        else \n\
    \        {\n            result ~= repeat(r, count);\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfz277fb3.d(28): Error: undefined identifier `repeat`

    /tmp/tmpfz277fb3.d(36): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfz277fb3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"m\", \"\
    c\", \"x\", \"i\"];\n    static string[4] five = [\"\", \"d\", \"l\", \"v\"];\n\
    \    static string[4] nine = [\"\", \"cm\", \"xc\", \"ix\"];\n    static int[4]\
    \ values = [1000, 100, 10, 1];\n    string result = \"\";\n    foreach(i, val;\
    \ values)\n    {\n        auto n = number / val;\n        number %= val;\n   \
    \     if (n == 9)\n        {\n            result ~= nine[i];\n        }\n    \
    \    else if (n >= 5)\n        {\n            result ~= five[i];\n           \
    \ result ~= roman[i] ~ roman[i] ~ roman[i] ~ roman[i];\n        }\n        else\
    \ if (n == 4)\n        {\n            result ~= nine[i];\n        }\n        else\n\
    \        {\n            result ~= roman[i] ~ roman[i] ~ roman[i] ~ roman[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8h7pb11g.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428785]

    ??:? void tmp8h7pb11g.__unittest_L43_C1() [0x428108]

    ??:? void tmp8h7pb11g.__modtest() [0x428504]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cf3f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42be4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430775]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430701]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be25]

    ??:? runModuleUnitTests [0x42cd15]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c48]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6il2pwwv.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmp6il2pwwv.int_to_mini_roman(long) [0x427af2]

    ??:? void tmp6il2pwwv.__unittest_L17_C1() [0x427b29]

    ??:? void tmp6il2pwwv.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    string result = \"\"\
    ;\n    result ~= roman_thousands[number / 1000];\n    number %= 1000;\n    result\
    \ ~= roman_hundreds[number / 100];\n    number %= 100;\n    result ~= roman_tens[number\
    \ / 10];\n    number %= 10;\n    result ~= roman_numerals[number];\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6il2pwwv.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmp6il2pwwv.int_to_mini_roman(long) [0x427af2]

    ??:? void tmp6il2pwwv.__unittest_L17_C1() [0x427b29]

    ??:? void tmp6il2pwwv.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_thousands\
    \ = [\n        \"\", \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_millions\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_billions\
    \ = [\n        \"\", \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_trillions\
    \ = [\n        \"\", \"xm\", \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp5fayc2_.d(53): Error: unterminated string constant starting at
    /tmp/tmpp5fayc2_.d(72)

    /tmp/tmpp5fayc2_.d(59): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpp5fayc2_.d(59): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpp5fayc2_.d(60): Error: found `lii` when expecting `;` following statement

    /tmp/tmpp5fayc2_.d(61): Error: found `cli` when expecting `;` following statement

    /tmp/tmpp5fayc2_.d(62): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpp5fayc2_.d(63): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpp5fayc2_.d(64): Error: found `i` when expecting `;` following statement

    /tmp/tmpp5fayc2_.d(65): Error: found `iv` when expecting `;` following statement

    /tmp/tmpp5fayc2_.d(66): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpp5fayc2_.d(67): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\"\
    \", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n\
    \    return roman_numerals[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpo4k2mejc.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428296]

    ??:? immutable(char)[] tmpo4k2mejc.int_to_mini_roman(long) [0x427b09]

    ??:? void tmpo4k2mejc.__unittest_L17_C1() [0x427b31]

    ??:? void tmpo4k2mejc.__modtest() [0x427f64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bf03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae12]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42feb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade9]

    ??:? runModuleUnitTests [0x42bcd9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman = [\"\", \"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman[number];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6il2pwwv.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmp6il2pwwv.int_to_mini_roman(long) [0x427af2]

    ??:? void tmp6il2pwwv.__unittest_L17_C1() [0x427b29]

    ??:? void tmp6il2pwwv.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    \n    assert(number > 0 &&\
    \ number <= 1000);\n    \n    return thousands[number / 1000] ~ hundreds[(number\
    \ / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] values = [\n        1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string result =\
    \ \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= values[i])\n        {\n            result ~= roman_numeral;\n           \
    \ number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\
    \ \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\
    \ ];\n    static string[10] roman_tens = [ \"\", \"x\", \"xx\", \"xxx\", \"xl\"\
    , \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\" ];\n    static string[10] roman_hundreds\
    \ = [ \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\",\
    \ \"cm\" ];\n    static string[4] roman_thousands = [ \"\", \"m\", \"mm\", \"\
    mmm\" ];\n    static string[4] roman_ten_thousands = [ \"\", \"xm\", \"xmm\",\
    \ \"xmmm\" ];\n    static string[4] roman_hundred_thousands = [ \"\", \"cm\",\
    \ \"cmm\", \"cmmm\" ];\n    static string[4] roman_millions = [ \"\", \"mm\",\
    \ \"mmm\", \"mmmm\" ];\n    static string[4] roman_ten_millions = [ \"\", \"xmm\"\
    , \"xmmm\", \"xmmmm\" ];\n    static string[4] roman_hundred_millions = [ \"\"\
    , \"cmm\", \"cmmm\", \"cmmmm\" ];\n    static string[4] roman_billions = [ \"\"\
    , \"mm\", \"mmm\", \"mmmm\" ];\n    static string[4] roman_ten_billions = [ \"\
    \", \"xmm\", \"xmmm\", \"xmmmm\" ];\n    static string[4] roman_hundred_billions\
    \ = [ \"\", \"cmm\", \"cmmm\", \"cmmmm\" ];\n    static string[4] roman_trillions\
    \ = [ \"\", \"mm\", \"mmm\", \"mmmm\" ];\n    static string[4] roman_ten_trillions\
    \ = [ \"\", \"xmm\", \"xmmm\", \"xmmmm\" ];\n    static string[4] roman_hundred_trillions\
    \ = [ \"\", \"cmm\", \"cmmm\", \"cmmmm\" ];\n    static string[4] roman_quadr\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb1sdjafr.d(30): Error: semicolon expected, not `unittest`

    /tmp/tmpb1sdjafr.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb1sdjafr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    assert(number > 0 &&\
    \ number <= 1000);\n    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman_numerals[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ return roman_numerals[number - 1];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpsgv4ijoi.d(15): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42829e]

    ??:? immutable(char)[] tmpsgv4ijoi.int_to_mini_roman(long) [0x427b13]

    ??:? void tmpsgv4ijoi.__unittest_L17_C1() [0x427b39]

    ??:? void tmpsgv4ijoi.__modtest() [0x427f6c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bf0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae1a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42febd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42adf1]

    ??:? runModuleUnitTests [0x42bce1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [\"i\", \"\
    v\", \"x\", \"l\"];\n    static string[4] roman_5 = [\"\", \"v\", \"x\", \"l\"\
    ];\n    static string[4] roman_10 = [\"\", \"\", \"x\", \"l\"];\n    static string[4]\
    \ roman_50 = [\"\", \"\", \"\", \"l\"];\n    static string[4] roman_100 = [\"\"\
    , \"\", \"\", \"\"];\n    static string[4] roman_500 = [\"\", \"\", \"\", \"\"\
    ];\n    static string[4] roman_1000 = [\"\", \"\", \"\", \"\"];\n    static string[4]\
    \ roman_5000 = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_10000 = [\"\
    \", \"\", \"\", \"\"];\n    static string[4] roman_50000 = [\"\", \"\", \"\",\
    \ \"\"];\n    static string[4] roman_100000 = [\"\", \"\", \"\", \"\"];\n    static\
    \ string[4] roman_500000 = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_1000000\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_5000000 = [\"\", \"\"\
    , \"\", \"\"];\n    static string[4] roman_10000000 = [\"\", \"\", \"\", \"\"\
    ];\n    static string[4] roman_50000000 = [\"\", \"\", \"\", \"\"];\n    static\
    \ string[4] roman_100000000 = [\"\", \"\", \"\", \"\"];\n    static string[4]\
    \ roman_500000000 = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_1000000000\
    \ = [\"\", \"\", \"\", \"\"];\n    static string[4] roman_5000000000 = [\"\",\
    \ \"\", \"\", \"\"];\n    static string[4] roman_10000000000 = [\"\", \"\", \"\
    \", \"\"];\n    static string[4] roman_50000000000 = [\"\", \"\", \"\", \"\"];\n\
    \    static string[4] roman_100000000000 = [\"\", \"\", \"\", \"\"];\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx_j9uku7.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_j9uku7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    foreach(i; 0 ..\
    \ 4)\n    {\n        auto digit = number % 10;\n        number /= 10;\n      \
    \  switch(i)\n        {\n            case 0:\n                result ~= repeat(\"\
    I\", digit);\n                break;\n            case 1:\n                result\
    \ ~= repeat(digit == 4 ? \"IV\" : \"V\", digit / 5);\n                result ~=\
    \ repeat(\"I\", digit % 5);\n                break;\n            case 2:\n   \
    \             result ~= repeat(digit == 4 ? \"XL\" : \"L\", digit / 5);\n    \
    \            result ~= repeat(\"X\", digit % 5);\n                break;\n   \
    \         case 3:\n                result ~= repeat(digit == 4 ? \"CD\" : \"D\"\
    , digit / 5);\n                result ~= repeat(\"C\", digit % 5);\n         \
    \       break;\n            case 4:\n                result ~= repeat(\"M\", digit);\n\
    \                break;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh_wbs8o.d(22): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(25): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(26): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(29): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(30): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(33): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(34): Error: undefined identifier `repeat`

    /tmp/tmpdh_wbs8o.d(37): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdh_wbs8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    return roman_numerals[number];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpvayelx5_.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42828e]

    ??:? immutable(char)[] tmpvayelx5_.int_to_mini_roman(long) [0x427af2]

    ??:? void tmpvayelx5_.__unittest_L19_C1() [0x427b29]

    ??:? void tmpvayelx5_.__modtest() [0x427f5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42befb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ae0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ff21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4303d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fead]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ade1]

    ??:? runModuleUnitTests [0x42bcd1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman_numerals = [\n\
    \        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"\
    ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[] decimal_values = [\n    \
    \    1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n    string\
    \ result = \"\";\n    foreach(i, roman_numeral; roman_numerals) {\n        while(number\
    \ >= decimal_values[i]) {\n            number -= decimal_values[i];\n        \
    \    result ~= roman_numeral;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    static string roman_numerals\
    \ = \"ivxlcdm\";\n    static int[] values = [1, 5, 10, 50, 100, 500, 1000];\n\
    \    int i = 0;\n    while (number > 0) {\n        int digit = number % 10;\n\
    \        if (digit == 9) {\n            result = roman_numerals[i] ~ roman_numerals[i\
    \ + 2] ~ result;\n        } else if (digit >= 5) {\n            result = roman_numerals[i\
    \ + 1] ~ repeat(roman_numerals[i], digit - 5) ~ result;\n        } else if (digit\
    \ == 4) {\n            result = roman_numerals[i] ~ roman_numerals[i + 1] ~ result;\n\
    \        } else {\n            result = repeat(roman_numerals[i], digit) ~ result;\n\
    \        }\n        number /= 10;\n        i += 2;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdpz88gf8.d(21): Error: incompatible types for `(cast(int)roman_numerals[cast(ulong)i])
    ~ (cast(int)roman_numerals[cast(ulong)(i + 2)])`: both operands are of type `int`

    /tmp/tmpdpz88gf8.d(23): Error: undefined identifier `repeat`

    /tmp/tmpdpz88gf8.d(25): Error: incompatible types for `(cast(int)roman_numerals[cast(ulong)i])
    ~ (cast(int)roman_numerals[cast(ulong)(i + 1)])`: both operands are of type `int`

    /tmp/tmpdpz88gf8.d(27): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdpz88gf8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[4] roman = [ \"i\", \"\
    v\", \"x\", \"l\" ];\n    string result = \"\";\n    int i = 0;\n    while (number\
    \ > 0) \n    {\n        int digit = number % 10;\n        result = to!string(digit)\
    \ ~ result;\n        number /= 10;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpygwple3f.d(20): Error: template instance `to!string` template `to`
    is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpygwple3f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] ones = [\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static\
    \ string[10] tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\"];\n    static string[10] hundreds = [\"\", \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4]\
    \ thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [\"m\", \"cm\"\
    , \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"\
    i\"];\n    static int[] arabic = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1];\n    string result = \"\";\n    foreach(i, r; roman)\n    {\n    \
    \    while(number >= arabic[i])\n        {\n            number -= arabic[i];\n\
    \            result ~= r;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    string result;\n    static string[10]\
    \ roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens = [\n\
    \        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\", \"c\"\
    , \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n\
    \    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\", \"mmm\"\
    \n    ];\n    if (number > 0 && number <= 1000) {\n        result = roman_thousands[number\
    \ / 1000] ~\n                 roman_hundreds[(number % 1000) / 100] ~\n      \
    \           roman_tens[(number % 100) / 10] ~\n                 roman_numerals[number\
    \ % 10];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164590
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[10] roman_numerals = [\n\
    \        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"\n    ];\n    static string[10] roman_tens = [\n        \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static\
    \ string[10] roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164589
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static const string roman_numerals =\
    \ \"ivxlcdm\";\n    static const long[] values = [1, 5, 10, 50, 100, 500, 1000];\n\
    \    static const long[] divisors = [1, 10, 100, 1000];\n    static const long[]\
    \ multipliers = [1, 10, 100, 1000];\n    static const long[] subtractors = [1,\
    \ 2, 2, 4];\n    static const long[] subtractor_values = [1, 10, 100, 1000];\n\
    \    static const long[] subtractor_multipliers = [1, 10, 100, 1000];\n    static\
    \ const long[] subtractor_divisors = [1, 10, 100, 1000];\n    static const long[]\
    \ subtractor_indexes = [0, 0, 1, 1];\n    static const long[] subtractor_multiplier_indexes\
    \ = [0, 0, 0, 1];\n    static const long[] subtractor_divisor_indexes = [0, 0,\
    \ 0, 0];\n    static const long[] subtractor_subtractor_indexes = [0, 0, 0, 0];\n\
    \    static const long[] subtractor_subtractor_value_indexes = [0, 0, 0, 0];\n\
    \    static const long[] subtractor_subtractor_multiplier_indexes = [0, 0, 0,\
    \ 0];\n    static const long[] subtractor_subtractor_divisor_indexes = [0, 0,\
    \ 0, 0];\n    static const long[] subtractor_subtractor_subtractor_indexes = [0,\
    \ 0, 0, 0];\n    static const long[] subtractor_subtractor_subtractor_value_indexes\
    \ = [0, 0, 0, 0];\n    static const long[] subtractor_subtractor_subtractor_multiplier_indexes\
    \ = [0, 0, 0, 0];\n    static const long[] subtractor_subtractor_subtractor_divisor_indexes\
    \ = [0, 0, 0, 0];\n    static const long[] subtractor_subtractor_subtractor_subtractor_indexes\
    \ = [0, 0, 0, 0];\n    static const long[] subtractor_subtractor_\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpswqhirnq.d(35): Error: semicolon expected, not `unittest`

    /tmp/tmpswqhirnq.d(35): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpswqhirnq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n                \n*/\nstring\
    \ int_to_mini_roman(long number) \n{\n    static string[] roman = [ \"m\", \"\
    cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\"\
    , \"i\" ];\n    static int[] values = [ 1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1 ];\n    string result = \"\";\n    foreach (i, v; zip(roman,\
    \ values))\n    {\n        while (number >= v)\n        {\n            result\
    \ ~= roman[i];\n            number -= v;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpidgxrw42.d(17): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpidgxrw42.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164590
