{
  "language": "d",
  "name": "HumanEval_128_prod_signs",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i < 0) \n        {\n            prod *= -1;\n        }\n        else if (i == 0) \n        {\n            return null;\n        }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeecyfouj.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpeecyfouj.d(29): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpeecyfouj.d(33): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeecyfouj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpauia19rd.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpauia19rd.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpauia19rd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n            sum += i;\n        }\n        else if (i < 0) \n        {\n            prod *= -1;\n            sum += abs(i);\n        }\n        else \n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp33dex52l.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp33dex52l.d(36): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp33dex52l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp98prv8u3.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp98prv8u3.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp98prv8u3.d(23): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp98prv8u3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    else \n    {\n        long sum = 0;\n        long prod = 1;\n        foreach (i; arr) \n        {\n            sum += abs(i);\n            prod *= sign(i);\n        }\n        return sum * prod;\n    }\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpk61jrlk7.d(26): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpk61jrlk7.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpk61jrlk7.d(28): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk61jrlk7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i == 0) \n        {\n            prod *= 0;\n            continue;\n        }\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuyckjc7g.d(26): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpuyckjc7g.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuyckjc7g.d(28): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuyckjc7g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i == 0) \n        {\n            continue;\n        }\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpphjma1un.d(28): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpphjma1un.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpphjma1un.d(30): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpphjma1un.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplp7xejm0.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmplp7xejm0.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmplp7xejm0.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplp7xejm0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *= i > 0 ? 1 : -1;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkix_1h4w.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpkix_1h4w.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkix_1h4w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4pixn8es.d(23): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp4pixn8es.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp4pixn8es.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4pixn8es.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5z17tgyw.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp5z17tgyw.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp5z17tgyw.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5z17tgyw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5z17tgyw.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp5z17tgyw.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp5z17tgyw.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5z17tgyw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv4t7g8nh.d(23): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpv4t7g8nh.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv4t7g8nh.d(26): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv4t7g8nh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiwd4k59h.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpiwd4k59h.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiwd4k59h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp63xms5zy.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp63xms5zy.d(29): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63xms5zy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n        {\n            prod *= 1;\n            sum += i;\n        }\n        else if (i < 0)\n        {\n            prod *= -1;\n            sum += abs(i);\n        }\n        else\n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2wqbn8be.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp2wqbn8be.d(35): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2wqbn8be.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return Nullable!(long)();\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i != 0)\n        {\n            sum += abs(i);\n            prod *= sign(i);\n        }\n    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8gkrwckz.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gkrwckz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n        {\n            prod *= 1;\n            sum += i;\n        }\n        else if (i < 0)\n        {\n            prod *= -1;\n            sum += abs(i);\n        }\n        else\n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2wqbn8be.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp2wqbn8be.d(35): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2wqbn8be.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i == 0) continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyexvj2po.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpyexvj2po.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpyexvj2po.d(24): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyexvj2po.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (elem; arr)\n    {\n        if (elem > 0)\n            prod *= 1;\n        else if (elem < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(elem);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpimyhacu_.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpimyhacu_.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpimyhacu_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i != 0) \n        {\n            prod *= sign(i);\n            sum += abs(i);\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuru60tk6.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpuru60tk6.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuru60tk6.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuru60tk6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4u7ov8r_.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp4u7ov8r_.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp4u7ov8r_.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4u7ov8r_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n        } \n        else if (i < 0) \n        {\n            prod *= -1;\n        } \n        else \n        {\n            prod *= 0;\n        }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpym3t8oeg.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpym3t8oeg.d(37): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpym3t8oeg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprfqb3ags.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmprfqb3ags.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprfqb3ags.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprfqb3ags.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv4t7g8nh.d(23): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpv4t7g8nh.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv4t7g8nh.d(26): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv4t7g8nh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (elem; arr) \n    {\n        if (elem > 0)\n            prod *= 1;\n        else if (elem < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(elem);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_z54j0ts.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp_z54j0ts.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_z54j0ts.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpauia19rd.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpauia19rd.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpauia19rd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptlo2a6ax.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmptlo2a6ax.d(29): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptlo2a6ax.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    long sum = 0;\n    long prod = 1;\n    foreach(i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return prod == 0 ? null : sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvbv2vpc1.d(20): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpvbv2vpc1.d(22): Error: incompatible types for `(null) : (sum * prod)`: `typeof(null)` and `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvbv2vpc1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return Nullable!(long)();\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpimp7r0_y.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpimp7r0_y.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppij3556v.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmppij3556v.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppij3556v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4u7ov8r_.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp4u7ov8r_.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp4u7ov8r_.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4u7ov8r_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i < 0) \n        {\n            prod *= -1;\n        }\n        else if (i == 0) \n        {\n            return null;\n        }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeecyfouj.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpeecyfouj.d(29): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpeecyfouj.d(33): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeecyfouj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp63xms5zy.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp63xms5zy.d(29): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63xms5zy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            sum += i;\n        else if (i < 0)\n        {\n            sum += -i;\n            prod *= -1;\n        }\n        else\n            prod = 0;\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8t6yi0_7.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp8t6yi0_7.d(31): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8t6yi0_7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4fxqmaxx.d(23): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp4fxqmaxx.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp4fxqmaxx.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4fxqmaxx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpauia19rd.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpauia19rd.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpauia19rd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppij3556v.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmppij3556v.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppij3556v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i != 0) \n        {\n            prod *= i < 0 ? -1 : 1;\n            sum += abs(i);\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzwuf8asv.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpzwuf8asv.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzwuf8asv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            sum += i;\n            prod *= 1;\n        }\n        else if (i < 0) \n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n        else \n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwase2ekd.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpwase2ekd.d(36): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwase2ekd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4bznxp09.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp4bznxp09.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp4bznxp09.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4bznxp09.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return Nullable!(long)();\n    }\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            sum += i;\n        }\n        else if (i < 0) \n        {\n            sum += -i;\n            prod *= -1;\n        }\n        else \n        {\n            prod = 0;\n        }\n    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164046
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i == 0) continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplpvug_du.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmplpvug_du.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmplpvug_du.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplpvug_du.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprfqb3ags.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmprfqb3ags.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprfqb3ags.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprfqb3ags.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppij3556v.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmppij3556v.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppij3556v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i < 0)\n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n        else if (i > 0)\n        {\n            sum += abs(i);\n            prod *= 1;\n        }\n        else\n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_q94_tlo.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp_q94_tlo.d(36): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_q94_tlo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i == 0) \n        {\n            sum += 0;\n            prod *= 1;\n        }\n        else if (i > 0) \n        {\n            sum += i;\n            prod *= 1;\n        }\n        else \n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfzvc2mry.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpfzvc2mry.d(37): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfzvc2mry.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpauia19rd.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpauia19rd.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpauia19rd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4bznxp09.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp4bznxp09.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp4bznxp09.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4bznxp09.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5z17tgyw.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp5z17tgyw.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp5z17tgyw.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5z17tgyw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (elem; arr)\n    {\n        if (elem > 0)\n            prod *= 1;\n        else if (elem < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(elem);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn8zc6h8d.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpn8zc6h8d.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn8zc6h8d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpauia19rd.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpauia19rd.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpauia19rd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp63xms5zy.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp63xms5zy.d(29): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63xms5zy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp63xms5zy.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp63xms5zy.d(29): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63xms5zy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiwd4k59h.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpiwd4k59h.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiwd4k59h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6iqi9zl9.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp6iqi9zl9.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6iqi9zl9.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6iqi9zl9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i == 0)\n            continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpff0kl71i.d(23): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpff0kl71i.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpff0kl71i.d(26): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpff0kl71i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            sum += i;\n        else if (i < 0)\n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7ozf0yx8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp7ozf0yx8.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ozf0yx8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp63xms5zy.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp63xms5zy.d(29): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63xms5zy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    foreach (i; arr)\n        sum += abs(i) * product(arr.map!(x => sign(x)));\n    return sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph7edty58.d(19): Error: undefined identifier `product`\n/tmp/tmph7edty58.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmph7edty58.d(20): Error: cannot implicitly convert expression `sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph7edty58.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4u7ov8r_.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp4u7ov8r_.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp4u7ov8r_.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4u7ov8r_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n            sum += i;\n        }\n        else if (i < 0) \n        {\n            prod *= -1;\n            sum += abs(i);\n        }\n        else \n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp33dex52l.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp33dex52l.d(36): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp33dex52l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppo29muuh.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmppo29muuh.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmppo29muuh.d(24): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppo29muuh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n        {\n            prod *= 1;\n            sum += i;\n        }\n        else if (i < 0)\n        {\n            prod *= -1;\n            sum += abs(i);\n        }\n        else\n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2wqbn8be.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp2wqbn8be.d(35): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2wqbn8be.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0pfvoim9.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp0pfvoim9.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp0pfvoim9.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0pfvoim9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        if (i < 0)\n            prod *= -1;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6ghz98zg.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6ghz98zg.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ghz98zg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpauia19rd.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpauia19rd.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpauia19rd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (elem; arr)\n    {\n        if (elem > 0)\n        {\n            sum += elem;\n            prod *= 1;\n        }\n        else if (elem < 0)\n        {\n            sum += abs(elem);\n            prod *= -1;\n        }\n        else\n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9j9wy9hp.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp9j9wy9hp.d(35): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9j9wy9hp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (elem; arr) \n    {\n        sum += abs(elem);\n        prod *= sign(elem);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpk8babwh2.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpk8babwh2.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpk8babwh2.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk8babwh2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i == 0) \n        {\n            prod *= 0;\n            continue;\n        }\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuyckjc7g.d(26): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpuyckjc7g.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpuyckjc7g.d(28): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuyckjc7g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n            sum += i;\n        }\n        else if (i < 0) \n        {\n            prod *= -1;\n            sum += abs(i);\n        }\n        else \n        {\n            prod *= 0;\n        }\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpysny7l9u.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpysny7l9u.d(35): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpysny7l9u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164046
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return Nullable!(long)();\n    \n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164047
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (elem; arr)\n    {\n        if (elem > 0)\n            prod *= 1;\n        else if (elem < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(elem);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpimyhacu_.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpimyhacu_.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpimyhacu_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (elem; arr)\n    {\n        if (elem > 0)\n            prod *= 1;\n        else if (elem < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(elem);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpimyhacu_.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpimyhacu_.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpimyhacu_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbaif_9iu.d(20): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpbaif_9iu.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpbaif_9iu.d(23): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbaif_9iu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i == 0) continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyexvj2po.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpyexvj2po.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpyexvj2po.d(24): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyexvj2po.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return Nullable!(long)();\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        sum += abs(i);\n    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1r_6h7py.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x455ba9]\n??:? void tmp1r_6h7py.__unittest_L27_C1() [0x4418ed]\n??:? void tmp1r_6h7py.__modtest() [0x4536b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x45ebab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x4551d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x45a3ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x45a47c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x45a379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4551ad]\n??:? runModuleUnitTests [0x45e981]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x456b34]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164047
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i < 0) \n        {\n            prod *= -1;\n        }\n        else if (i == 0) \n        {\n            prod = 0;\n            break;\n        }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9oo9p5d3.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp9oo9p5d3.d(34): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9oo9p5d3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    foreach (i; arr)\n        sum += abs(i) * product(arr.map!(x => sign(x)));\n    return sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph7edty58.d(19): Error: undefined identifier `product`\n/tmp/tmph7edty58.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmph7edty58.d(20): Error: cannot implicitly convert expression `sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph7edty58.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            sum += i;\n        else if (i < 0)\n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplopyfjn9.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmplopyfjn9.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplopyfjn9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i == 0) \n        {\n            continue;\n        }\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpphjma1un.d(28): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpphjma1un.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpphjma1un.d(30): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpphjma1un.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv4t7g8nh.d(23): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpv4t7g8nh.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv4t7g8nh.d(26): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv4t7g8nh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *= i > 0 ? 1 : -1;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkix_1h4w.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpkix_1h4w.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkix_1h4w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    Nullable!(long) result = 0;\n    if (arr.length == 0)\n        return null;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        result = result.get + abs(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjsh388go.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjsh388go.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164046
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiwd4k59h.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpiwd4k59h.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiwd4k59h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    auto prod = 1;\n    auto sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeis19tem.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpeis19tem.d(29): Error: cannot implicitly convert expression `sum * prod` of type `int` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeis19tem.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i == 0) continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvz13mdc5.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpvz13mdc5.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpvz13mdc5.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvz13mdc5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4bznxp09.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp4bznxp09.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp4bznxp09.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4bznxp09.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n            sum += i;\n        }\n        else if (i < 0) \n        {\n            prod *= -1;\n            sum += abs(i);\n        }\n        else \n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp33dex52l.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp33dex52l.d(36): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp33dex52l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptlo2a6ax.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmptlo2a6ax.d(29): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptlo2a6ax.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp98prv8u3.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp98prv8u3.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp98prv8u3.d(23): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp98prv8u3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4bznxp09.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp4bznxp09.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp4bznxp09.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4bznxp09.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n            sum += i;\n        } \n        else if (i < 0) \n        {\n            prod *= -1;\n            sum += abs(i);\n        } \n        else \n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn8gqoya6.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpn8gqoya6.d(35): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn8gqoya6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp98prv8u3.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp98prv8u3.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp98prv8u3.d(23): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp98prv8u3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp718u1lqt.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp718u1lqt.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp718u1lqt.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp718u1lqt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n        {\n            prod *= 1;\n            sum += i;\n        }\n        else if (i < 0)\n        {\n            prod *= -1;\n            sum += abs(i);\n        }\n        else\n        {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2wqbn8be.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp2wqbn8be.d(35): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2wqbn8be.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplp7xejm0.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmplp7xejm0.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmplp7xejm0.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplp7xejm0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplp7xejm0.d(24): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmplp7xejm0.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmplp7xejm0.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplp7xejm0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return Nullable!(long)();\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            sum += i;\n        else if (i < 0)\n        {\n            sum += -i;\n            prod *= -1;\n        }\n        else\n            prod = 0;\n    }\n    return Nullable!(long)(sum * prod);\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164047
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5z17tgyw.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp5z17tgyw.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp5z17tgyw.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5z17tgyw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n            sum += i;\n        } \n        else if (i < 0) \n        {\n            prod *= -1;\n            sum += -i;\n        } \n        else \n        {\n            prod *= 0;\n        }\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxkss5h41.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpxkss5h41.d(36): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxkss5h41.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164046
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i == 0) continue;\n        prod *= i > 0 ? 1 : -1;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7e4tf5bm.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp7e4tf5bm.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7e4tf5bm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp98prv8u3.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp98prv8u3.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp98prv8u3.d(23): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp98prv8u3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            sum += i;\n        }\n        else if (i < 0) \n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n        else \n        {\n            prod = 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptd0wgpf1.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmptd0wgpf1.d(37): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptd0wgpf1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp63xms5zy.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp63xms5zy.d(29): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63xms5zy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiwd4k59h.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpiwd4k59h.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiwd4k59h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            sum += i;\n        else if (i < 0)\n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7ozf0yx8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp7ozf0yx8.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ozf0yx8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n            sum += i;\n        }\n        else if (i < 0) \n        {\n            prod *= -1;\n            sum += abs(i);\n        }\n        else \n        {\n            prod *= 0;\n        }\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpysny7l9u.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpysny7l9u.d(35): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpysny7l9u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164046
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            sum += i;\n        else if (i < 0)\n        {\n            sum += -i;\n            prod *= -1;\n        }\n        else\n            prod = 0;\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8t6yi0_7.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp8t6yi0_7.d(31): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8t6yi0_7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp63xms5zy.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp63xms5zy.d(29): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp63xms5zy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpauia19rd.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpauia19rd.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpauia19rd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp98prv8u3.d(21): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmp98prv8u3.d(15): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp98prv8u3.d(23): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp98prv8u3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpauia19rd.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpauia19rd.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpauia19rd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *= i > 0 ? 1 : -1;\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpaimyswx_.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpaimyswx_.d(26): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaimyswx_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppij3556v.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmppij3556v.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppij3556v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n        } \n        else if (i < 0) \n        {\n            prod *= -1;\n        } \n        else \n        {\n            prod *= 0;\n        }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpym3t8oeg.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpym3t8oeg.d(37): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpym3t8oeg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv4t7g8nh.d(23): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpv4t7g8nh.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv4t7g8nh.d(26): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv4t7g8nh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        sum += abs(i);\n        prod *= signbit(i) ? -1 : 1;\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(271): Error: no property `epsilon` for type `long`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(272): Error: no property `mant_dig` for type `long`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(292): Error: no property `mant_dig` for type `long`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(335): Error: no property `mant_dig` for type `long`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(353): Error: no property `mant_dig` for type `long`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(371): Error: no property `mant_dig` for type `long`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/math.d(6254): Error: template instance `std.math.floatTraits!long` error instantiating\n/tmp/tmp652bbk2r.d(24):        instantiated from here: `signbit!long`\n/tmp/tmp652bbk2r.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp652bbk2r.d(26): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp652bbk2r.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164046
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            sum += i;\n        }\n        else if (i < 0) \n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n        else \n        {\n            prod = 0;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptd0wgpf1.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmptd0wgpf1.d(37): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptd0wgpf1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            sum += i;\n        else if (i < 0)\n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplopyfjn9.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmplopyfjn9.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplopyfjn9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (elem; arr)\n    {\n        if (elem < 0)\n            prod *= -1;\n        else if (elem == 0)\n            prod = 0;\n        sum += abs(elem);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_s_6trwx.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp_s_6trwx.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_s_6trwx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164046
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp43rg2__n.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp43rg2__n.d(27): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43rg2__n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i == 0)\n            continue;\n        prod *= sign(i);\n        sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv4t7g8nh.d(23): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpv4t7g8nh.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpv4t7g8nh.d(26): Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv4t7g8nh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            sum += i;\n        else if (i < 0)\n        {\n            sum += abs(i);\n            prod *= -1;\n        }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplopyfjn9.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmplopyfjn9.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplopyfjn9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164045
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoez66oh8.d(22): Error: undefined identifier `sign`, did you mean template `sgn(F)(F x)`?\n/tmp/tmpoez66oh8.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpoez66oh8.d(24): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoez66oh8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjomt6kec.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpjomt6kec.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjomt6kec.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i < 0) \n        {\n            prod *= -1;\n        }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeovom405.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpeovom405.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeovom405.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164047
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtoxb5tl.d(16): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmprtoxb5tl.d(29): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtoxb5tl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164043
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n                \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length == 0) \n    {\n        return null;\n    }\n    long prod = 1;\n    long sum = 0;\n    foreach (i; arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1;\n        } \n        else if (i < 0) \n        {\n            prod *= -1;\n        } \n        else \n        {\n            prod *= 0;\n        }\n        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpym3t8oeg.d(17): Error: cannot implicitly convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpym3t8oeg.d(37): Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpym3t8oeg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164044
    }
  ]
}