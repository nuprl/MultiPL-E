name: HumanEval_47_median
language: d
prompt: "import std.math;\n/*\nReturn median of elements in the list l.\n        \
  \    \n*/\nfloat median(long[] l) \n"
tests: "unittest\n{\n    alias candidate = median;\n\n    assert(candidate([3L, 1L,\
  \ 2L, 4L, 5L]) == 3L);\n    assert(candidate([-10L, 4L, 6L, 1000L, 10L, 20L]) ==\
  \ 8.0);\n    assert(candidate([5L]) == 5L);\n    assert(candidate([6L, 5L]) == 5.5);\n\
  \    assert(candidate([8L, 1L, 3L, 9L, 9L, 2L, 7L]) == 7L);\n}\nvoid main(){}"
completions: ["{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] s = l.dup;\n    s.sort;\n    if (s.length & 1)\n \
    \       return s[s.length / 2];\n    else\n        return (s[s.length / 2 - 1]\
    \ + s[s.length / 2]) / 2.0;\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n\
    \    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n \
    \   sorted.sort;\n    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    if (sorted.length\
    \ % 2 == 0)\n    {\n        return (sorted[sorted.length / 2 - 1] + sorted[sorted.length\
    \ / 2]) / 2.0;\n    }\n    else\n    {\n        return sorted[sorted.length /\
    \ 2];\n    }\n}", "{\n    long[] ll = l.dup;\n    ll.sort;\n    return ll[ll.length/2];\n\
    }", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length/2];\n}",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    std.algorithm.sort(sorted);\n\
    \    return sorted[sorted.length / 2];\n}", "{\n    long[] m = l.dup;\n    m.sort;\n\
    \    return m[m.length / 2];\n}", "{\n    long[] l2 = l[0..$];\n    std.algorithm.sort(l2);\n\
    \    return l2[$/2];\n}", "{\n    long[] l2 = l[0..$];\n    std.algorithm.sort(l2);\n\
    \    return l2[l2.length / 2];\n}", "{\n    long[] temp = l.dup;\n    temp.sort;\n\
    \    return temp[temp.length/2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n\
    \    return sorted[sorted.length/2];\n}", "{\n    long[] sorted = l.dup;\n   \
    \ sorted.sort;\n    return sorted[sorted.length / 2];\n}", "{\n    float[] a =\
    \ l.dup;\n    a.sort;\n    return a[a.length / 2];\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}\n/*\nReturn the mean of elements in the list l.\n            \n*/\n\
    float mean(long[] l) \n{\n    long sum = 0;\n    foreach (long i; l) \n    {\n\
    \        sum += i;\n    }\n    return float(sum) / l.length;\n}\n/*\nReturn the\
    \ standard deviation of elements in the list l.\n            \n*/\nfloat stddev(long[]\
    \ l) \n{\n    float m = mean(l);\n    float sum = 0;\n    foreach (long i; l)\
    \ \n    {\n        sum += (i - m) * (i - m);\n    }\n    return sqrt(sum / l.length);\n\
    }\n/*\nReturn the number of elements in the list l that are greater than or equal\
    \ to\nmin and less than or equal to max.\n            \n*/\nlong range(long[]\
    \ l, long min, long max) \n{\n    long count = 0;\n    foreach (long i; l) \n\
    \    {\n        if (i >= min && i <= max) \n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\nReturn the number of elements in\
    \ the list l that are greater than or equal to\nmin and less than or equal to\
    \ max.\n            \n*/\nlong range(float[] l, float min, float max) \n{\n  \
    \  long count = 0;\n    foreach (float i; l) \n    {\n        if (i >= min &&\
    \ i <= max) \n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\nReturn the number of elements in the list l that are greater than or equal\
    \ to\nmin and less than or equal to max.\n            \n*/\nlong range(double[]\
    \ l, double min, double max) \n{\n    long count = 0;\n    foreach (double i;\
    \ l) \n    {\n        if (i >= min && i <= max) \n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n", "{\n    long[] sorted = l.dup;\n \
    \   sorted.sort;\n    return sorted[sorted.length/2];\n}", "{\n    long[] ll =\
    \ l.dup;\n    ll.sort;\n    if (ll.length % 2 == 0) \n    {\n        return (ll[ll.length\
    \ / 2 - 1] + ll[ll.length / 2]) / 2.0;\n    } \n    else \n    {\n        return\
    \ ll[ll.length / 2];\n    }\n}", "{\n    if (l.length == 0)\n        return 0;\n\
    \    l.sort;\n    if (l.length % 2 == 0)\n        return (l[l.length / 2 - 1]\
    \ + l[l.length / 2]) / 2;\n    else\n        return l[l.length / 2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l[0..$];\n    l2.sort();\n    return l2[l2.length\
    \ / 2];\n}", "{\n    long[] a = l.dup;\n    a.sort;\n    return a[a.length / 2];\n\
    }", "{\n    float median;\n    long[] sorted = l.dup;\n    sorted.sort;\n    if\
    \ (sorted.length % 2 == 0)\n    {\n        median = (sorted[sorted.length / 2\
    \ - 1] + sorted[sorted.length / 2]) / 2.0;\n    }\n    else\n    {\n        median\
    \ = sorted[sorted.length / 2];\n    }\n    return median;\n}", "{\n    long[]\
    \ sorted = l.dup;\n    sort(sorted);\n    if (sorted.length % 2 == 0)\n    {\n\
    \        return (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) /\
    \ 2.0;\n    }\n    else\n    {\n        return sorted[sorted.length / 2];\n  \
    \  }\n}", "{\n    long[] l2 = l[0..$];\n    std.algorithm.sort(l2);\n    if (l2.length\
    \ % 2 == 0) \n    {\n        return (l2[l2.length / 2 - 1] + l2[l2.length / 2])\
    \ / 2.0;\n    }\n    else \n    {\n        return l2[l2.length / 2];\n    }\n}",
  "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length/2];\n\
    }", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length/2];\n}",
  "{\n    long[] tmp = l.dup;\n    tmp.sort;\n    return tmp[tmp.length / 2];\n}",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l[0..$];\n    sort(l2);\n    return (l2[$/2]\
    \ + l2[$/2-1])/2.0;\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n  \
    \  return sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n   \
    \ sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] m = l.dup;\n    m.sort;\n    if (m.length % 2 == 0)\n\
    \    {\n        return (m[m.length / 2 - 1] + m[m.length / 2]) / 2.0;\n    }\n\
    \    else\n    {\n        return m[m.length / 2];\n    }\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sort(sorted);\n    return sorted[sorted.length/2];\n}", "{\n \
    \   if (l.length == 0) \n        return 0;\n    else \n    {\n        long[] sorted\
    \ = l.dup;\n        std.algorithm.sort(sorted);\n        if (sorted.length % 2\
    \ == 0) \n            return (sorted[sorted.length / 2 - 1] + sorted[sorted.length\
    \ / 2]) / 2.0;\n        else \n            return sorted[sorted.length / 2];\n\
    \    }\n}", "{\n    long[] l2 = l[0..$];\n    std.algorithm.sort(l2);\n    if\
    \ (l2.length % 2 == 0)\n    {\n        return (l2[l2.length / 2 - 1] + l2[l2.length\
    \ / 2]) / 2.0;\n    }\n    else\n    {\n        return l2[l2.length / 2];\n  \
    \  }\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l[0..$];\n    l2.sort();\n    return l2[l2.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] temp = l.dup;\n    temp.sort;\n    if (temp.length\
    \ % 2 == 0)\n        return (temp[temp.length / 2 - 1] + temp[temp.length / 2])\
    \ / 2.0;\n    else\n        return temp[temp.length / 2];\n}", "{\n    long[]\
    \ sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length / 2];\n}",
  "{\n    long[] s = l.dup;\n    s.sort;\n    return s[s.length / 2];\n}", "{\n  \
    \  long[] ll = l.dup;\n    ll.sort;\n    return ll[ll.length/2];\n}", "{\n   \
    \ long[] temp = l[];\n    sort(temp);\n    return temp[temp.length / 2];\n}",
  "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length / 2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}\n/*\nReturn the mean of elements in the list l.\n*/\nfloat mean(long[]\
    \ l) \n{\n    long sum = 0;\n    foreach (long i; l) \n    {\n        sum += i;\n\
    \    }\n    return float(sum) / l.length;\n}\n/*\nReturn the variance of elements\
    \ in the list l.\n*/\nfloat variance(long[] l) \n{\n    float m = mean(l);\n \
    \   float sum = 0;\n    foreach (long i; l) \n    {\n        sum += (i - m) *\
    \ (i - m);\n    }\n    return sum / l.length;\n}\n/*\nReturn the standard deviation\
    \ of elements in the list l.\n*/\nfloat stddev(long[] l) \n{\n    return sqrt(variance(l));\n\
    }\n/*\nReturn the standard error of elements in the list l.\n*/\nfloat stderr(long[]\
    \ l) \n{\n    return stddev(l) / sqrt(l.length);\n}\n/*\nReturn the coefficient\
    \ of variation of elements in the list l.\n*/\nfloat coeffvar(long[] l) \n{\n\
    \    return stddev(l) / mean(l);\n}\n/*\nReturn the skewness of elements in the\
    \ list l.\n*/\nfloat skewness(long[] l) \n{\n    float m = mean(l);\n    float\
    \ sum = 0;\n    foreach (long i; l) \n    {\n        sum += (i - m) * (i - m)\
    \ * (i - m);\n    }\n    return sum / (l.length * stddev(l) * stddev(l) * stddev(l));\n\
    }\n/*\nReturn the kurtosis of elements in the list l.\n*/\nfloat kurtosis(long[]\
    \ l) \n{\n    float m = mean(l);\n    float sum = 0;\n    foreach (long i; l)\
    \ \n    {\n        sum += (i - m) * (i", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n\
    \    return sorted[l.length / 2];\n}", "{\n    float[] a = l.dup;\n    a.sort;\n\
    \    if (a.length % 2 == 0)\n        return (a[a.length / 2 - 1] + a[a.length\
    \ / 2]) / 2;\n    else\n        return a[a.length / 2];\n}", "{\n    float[] sorted\
    \ = l.dup;\n    sorted.sort;\n    return sorted[sorted.length / 2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sort(sorted);\n    if (sorted.length % 2 == 0)\
    \ \n    {\n        return (sorted[sorted.length / 2 - 1] + sorted[sorted.length\
    \ / 2]) / 2.0;\n    }\n    else \n    {\n        return sorted[sorted.length /\
    \ 2];\n    }\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    float m;\n    long[] l2 = l.dup;\n    l2.sort;\n    if (l2.length\
    \ % 2 == 0)\n    {\n        m = (l2[l2.length / 2 - 1] + l2[l2.length / 2]) /\
    \ 2.0;\n    }\n    else\n    {\n        m = l2[l2.length / 2];\n    }\n    return\
    \ m;\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    float[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    if (sorted.length\
    \ % 2 == 0) \n    {\n        return (sorted[sorted.length / 2 - 1] + sorted[sorted.length\
    \ / 2]) / 2.0;\n    } \n    else \n    {\n        return sorted[sorted.length\
    \ / 2];\n    }\n}\n/*\nReturn mean of elements in the list l.\n            \n\
    */\nfloat mean(long[] l) \n{\n    long sum = 0;\n    foreach (long x; l) \n  \
    \  {\n        sum += x;\n    }\n    return sum / l.length;\n}\n/*\nReturn standard\
    \ deviation of elements in the list l.\n            \n*/\nfloat stddev(long[]\
    \ l) \n{\n    float m = mean(l);\n    float sum = 0;\n    foreach (long x; l)\
    \ \n    {\n        sum += (x - m) * (x - m);\n    }\n    return sqrt(sum / (l.length\
    \ - 1));\n}\n/*\nReturn the number of elements in the list l that are within the\
    \ range [low, high].\n            \n*/\nlong numInRange(long[] l, long low, long\
    \ high) \n{\n    long count = 0;\n    foreach (long x; l) \n    {\n        if\
    \ (x >= low && x <= high) \n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\nReturn the number of elements in the list l that are\
    \ within the range [low, high].\n            \n*/\nlong numInRange(long[] l, long\
    \ low, long high) \n{\n    long count = 0;\n    foreach (long x; l) \n    {\n\
    \        if (x >= low && x <= high) \n        {\n            count++;\n      \
    \  }\n    }\n    return count;\n}\n/*\nReturn the number of elements in the list\
    \ l that are within the range [low, high].\n            \n*/\nlong numInRange(long[]\
    \ l, long low, long high) \n{\n    long count = 0;\n    foreach", "{\n    long[]\
    \ sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length / 2];\n}",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    if (l2.length % 2 ==\
    \ 0)\n        return (l2[l2.length / 2 - 1] + l2[l2.length / 2]) / 2.0;\n    else\n\
    \        return l2[l2.length / 2];\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n\
    \    return l2[l2.length / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n\
    \    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n \
    \   sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n    long[] l2\
    \ = l.dup;\n    l2.sort;\n    return l2[l2.length / 2];\n}\n/*\nReturn the average\
    \ of elements in the list l.\n            \n*/\nfloat average(long[] l) \n{\n\
    \    long sum = 0;\n    foreach (long i; l) \n    {\n        sum += i;\n    }\n\
    \    return sum / l.length;\n}\n/*\nReturn the standard deviation of elements\
    \ in the list l.\n            \n*/\nfloat stddev(long[] l) \n{\n    float avg\
    \ = average(l);\n    float sum = 0;\n    foreach (long i; l) \n    {\n       \
    \ sum += (i - avg) * (i - avg);\n    }\n    return sqrt(sum / l.length);\n}\n\
    /*\nReturn the standard error of elements in the list l.\n            \n*/\nfloat\
    \ stderr(long[] l) \n{\n    return stddev(l) / sqrt(l.length);\n}\n/*\nReturn\
    \ the average of elements in the list l.\n            \n*/\nfloat average(double[]\
    \ l) \n{\n    double sum = 0;\n    foreach (double i; l) \n    {\n        sum\
    \ += i;\n    }\n    return sum / l.length;\n}\n/*\nReturn the standard deviation\
    \ of elements in the list l.\n            \n*/\nfloat stddev(double[] l) \n{\n\
    \    float avg = average(l);\n    float sum = 0;\n    foreach (double i; l) \n\
    \    {\n        sum += (i - avg) * (i - avg);\n    }\n    return sqrt(sum / l.length);\n\
    }\n/*\nReturn the standard error of elements in the list l.\n            \n*/\n\
    float stderr(double[] l) \n{\n    return stddev(l) / sqrt(l.length);\n}\n/*\n\
    Return the average of elements in the list l.\n            \n*/\nfloat average(float[]\
    \ l) \n{\n    float sum = 0;\n    foreach (float i; l) \n    {\n        sum",
  "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length/2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}\n/*\nReturn the mean of elements in the list l.\n            \n*/\n\
    float mean(long[] l) \n{\n    long sum = 0;\n    foreach (long i; l) \n    {\n\
    \        sum += i;\n    }\n    return float(sum) / l.length;\n}\n/*\nReturn the\
    \ standard deviation of elements in the list l.\n            \n*/\nfloat stddev(long[]\
    \ l) \n{\n    float m = mean(l);\n    float sum = 0;\n    foreach (long i; l)\
    \ \n    {\n        sum += (i - m) * (i - m);\n    }\n    return sqrt(sum / l.length);\n\
    }\n/*\nReturn the standard error of elements in the list l.\n            \n*/\n\
    float stderr(long[] l) \n{\n    return stddev(l) / sqrt(l.length);\n}\n/*\nReturn\
    \ the sum of elements in the list l.\n            \n*/\nlong sum(long[] l) \n\
    {\n    long sum = 0;\n    foreach (long i; l) \n    {\n        sum += i;\n   \
    \ }\n    return sum;\n}\n/*\nReturn the minimum of elements in the list l.\n \
    \           \n*/\nlong min(long[] l) \n{\n    long min = l[0];\n    foreach (long\
    \ i; l) \n    {\n        if (i < min) \n        {\n            min = i;\n    \
    \    }\n    }\n    return min;\n}\n/*\nReturn the maximum of elements in the list\
    \ l.\n            \n*/\nlong max(long[] l) \n{\n    long max = l[0];\n    foreach\
    \ (long i; l) \n    {\n        if (i > max) \n        {\n            max = i;\n\
    \        }\n    }\n    return max;\n}\n/*\nReturn the range of elements in the\
    \ list l.\n            \n*/\nlong range(long[] l) \n{\n    return max(l)", "{\n\
    \    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] ll = l.dup;\n    ll.sort;\n    return ll[ll.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    std.algorithm.sort(sorted);\n\
    \    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n \
    \   sorted.sort;\n    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sorted.sort;\n    long n = sorted.length;\n    if (n % 2 == 0)\n\
    \        return (sorted[n / 2 - 1] + sorted[n / 2]) / 2.0;\n    else\n       \
    \ return sorted[n / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n\
    \    return sorted[sorted.length / 2];\n}\n/*\nReturn mean of elements in the\
    \ list l.\n            \n*/\nfloat mean(long[] l) \n{\n    long sum = 0;\n   \
    \ foreach (long i; l) \n    {\n        sum += i;\n    }\n    return float(sum)\
    \ / l.length;\n}\n/*\nReturn standard deviation of elements in the list l.\n \
    \           \n*/\nfloat stddev(long[] l) \n{\n    float m = mean(l);\n    float\
    \ sum = 0;\n    foreach (long i; l) \n    {\n        sum += (i - m) * (i - m);\n\
    \    }\n    return sqrt(sum / l.length);\n}\n/*\nReturn the number of elements\
    \ in the list l that are less than\nthe median of l.\n            \n*/\nlong numLessThanMedian(long[]\
    \ l) \n{\n    long med = median(l);\n    long count = 0;\n    foreach (long i;\
    \ l) \n    {\n        if (i < med) \n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\nReturn the number of elements in the list\
    \ l that are greater than\nthe median of l.\n            \n*/\nlong numGreaterThanMedian(long[]\
    \ l) \n{\n    long med = median(l);\n    long count = 0;\n    foreach (long i;\
    \ l) \n    {\n        if (i > med) \n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\nReturn the number of elements in the list\
    \ l that are less than\nthe mean of l.\n            \n*/\nlong numLessThanMean(long[]\
    \ l) \n{\n    float m = mean(l);\n    long count = 0;\n    foreach (long i; l)\
    \ \n    {\n        if (i < m) \n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\nReturn the number of elements in the list l",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length/2];\n\
    }", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length/2];\n}",
  "{\n    long[] l2 = l[0..$];\n    std.algorithm.sort(l2);\n    return l2[l2.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l[0..$];\n    l2.sort();\n    if (l2.length %\
    \ 2 == 0)\n    {\n        return (l2[l2.length / 2 - 1] + l2[l2.length / 2]) /\
    \ 2.0;\n    }\n    else\n    {\n        return l2[l2.length / 2];\n    }\n}",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    float m;\n    long[] s = l.dup;\n    s.sort;\n    if (s.length\
    \ % 2 == 0) {\n        m = (s[s.length / 2 - 1] + s[s.length / 2]) / 2.0;\n  \
    \  } else {\n        m = s[s.length / 2];\n    }\n    return m;\n}", "{\n    long[]\
    \ sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length / 2];\n}",
  "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    long len = sorted.length;\n\
    \    if (len % 2 == 0)\n    {\n        return (sorted[len / 2 - 1] + sorted[len\
    \ / 2]) / 2.0;\n    }\n    else\n    {\n        return sorted[len / 2];\n    }\n\
    }", "{\n    long[] l2 = l[0..$];\n    l2.sort();\n    if (l2.length % 2 == 0)\n\
    \    {\n        return (l2[l2.length / 2 - 1] + l2[l2.length / 2]) / 2.0;\n  \
    \  }\n    else\n    {\n        return l2[l2.length / 2];\n    }\n}", "{\n    long[]\
    \ sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length / 2];\n}",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    if (sorted.length % 2 == 0)\
    \ \n    {\n        return (sorted[sorted.length / 2 - 1] + sorted[sorted.length\
    \ / 2]) / 2.0;\n    } \n    else \n    {\n        return sorted[sorted.length\
    \ / 2];\n    }\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return\
    \ sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n\
    \    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n \
    \   sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sorted.sort;\n    long len = sorted.length;\n    if (len % 2 ==\
    \ 0)\n    {\n        return (sorted[len / 2 - 1] + sorted[len / 2]) / 2.0;\n \
    \   }\n    else\n    {\n        return sorted[len / 2];\n    }\n}", "{\n    long[]\
    \ sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length / 2];\n}",
  "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[l.length /\
    \ 2];\n}", "{\n    long[] l2 = l[0..$];\n    sort(l2);\n    return l2[$/2];\n}",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    if (sorted.length % 2 == 0)\n\
    \    {\n        return (sorted[sorted.length / 2 - 1] + sorted[sorted.length /\
    \ 2]) / 2.0;\n    }\n    else\n    {\n        return sorted[sorted.length / 2];\n\
    \    }\n}\n/*\nReturn the mean of elements in the list l.\n*/\nfloat mean(long[]\
    \ l) \n{\n    long sum = 0;\n    foreach (long i; l)\n    {\n        sum += i;\n\
    \    }\n    return sum / float(l.length);\n}\n/*\nReturn the standard deviation\
    \ of elements in the list l.\n*/\nfloat stddev(long[] l) \n{\n    float m = mean(l);\n\
    \    float sum = 0;\n    foreach (long i; l)\n    {\n        sum += (i - m) *\
    \ (i - m);\n    }\n    return sqrt(sum / (l.length - 1));\n}\n/*\nReturn the standard\
    \ error of elements in the list l.\n*/\nfloat stderr(long[] l) \n{\n    return\
    \ stddev(l) / sqrt(l.length);\n}\n/*\nReturn the coefficient of variation of elements\
    \ in the list l.\n*/\nfloat cv(long[] l) \n{\n    return stddev(l) / mean(l);\n\
    }\n/*\nReturn the number of elements in the list l that are greater than or equal\
    \ to x.\n*/\nlong count(long[] l, long x) \n{\n    long c = 0;\n    foreach (long\
    \ i; l)\n    {\n        if (i >= x)\n        {\n            c++;\n        }\n\
    \    }\n    return c;\n}\n/*\nReturn the number of elements in the list l that\
    \ are greater than or equal to x.\n*/\nlong count(long[] l, float x) \n{\n   \
    \ long c = 0;\n    foreach (long i; l)\n    {\n        if (i >= x)\n        {\n\
    \            c++;\n        }\n    }\n    return", "{\n    long[] sorted = l.dup;\n\
    \    sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n    long[]\
    \ sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length / 2];\n}",
  "{\n    long[] l2 = l.dup;\n    l2.sort;\n    if (l2.length & 1)\n        return\
    \ l2[l2.length / 2];\n    else\n        return (l2[l2.length / 2 - 1] + l2[l2.length\
    \ / 2]) / 2.0f;\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return\
    \ sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n\
    \    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n \
    \   sorted.sort;\n    return sorted[sorted.length / 2];\n}", "{\n    long[] m\
    \ = l.dup;\n    m.sort;\n    return m[m.length/2];\n}", "{\n    long[] l2 = l[0..$];\n\
    \    sort(l2);\n    return l2[$/2];\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n\
    \    return l2[l2.length / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n\
    \    int len = sorted.length;\n    if (len % 2 == 0)\n    {\n        return (sorted[len\
    \ / 2 - 1] + sorted[len / 2]) / 2.0f;\n    }\n    else\n    {\n        return\
    \ sorted[len / 2];\n    }\n}\n/*\nReturn mean of elements in the list l.\n   \
    \         \n*/\nfloat mean(long[] l) \n{\n    long sum = 0;\n    foreach (long\
    \ i; l)\n    {\n        sum += i;\n    }\n    return sum / l.length;\n}\n/*\n\
    Return variance of elements in the list l.\n            \n*/\nfloat variance(long[]\
    \ l) \n{\n    float m = mean(l);\n    float sum = 0;\n    foreach (long i; l)\n\
    \    {\n        sum += (i - m) * (i - m);\n    }\n    return sum / l.length;\n\
    }\n/*\nReturn standard deviation of elements in the list l.\n            \n*/\n\
    float stddev(long[] l) \n{\n    return sqrt(variance(l));\n}\n/*\nReturn the sum\
    \ of elements in the list l.\n            \n*/\nlong sum(long[] l) \n{\n    long\
    \ sum = 0;\n    foreach (long i; l)\n    {\n        sum += i;\n    }\n    return\
    \ sum;\n}\n/*\nReturn the maximum element in the list l.\n            \n*/\nlong\
    \ max(long[] l) \n{\n    long max = l[0];\n    foreach (long i; l)\n    {\n  \
    \      if (i > max)\n        {\n            max = i;\n        }\n    }\n    return\
    \ max;\n}\n/*\nReturn the minimum element in the list l.\n            \n*/\nlong\
    \ min(long[] l) \n{\n    long min = l[0];\n    foreach (long i; l)\n    {\n  \
    \      if (i < min)\n        {\n            min = i;\n        }\n    }\n    return\
    \ min;\n}\n/*\nReturn", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n   \
    \ return sorted[sorted.length / 2];\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n\
    \    return l2[l2.length / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n\
    \    long len = sorted.length;\n    if (len % 2 == 0)\n    {\n        return (sorted[len\
    \ / 2 - 1] + sorted[len / 2]) / 2.0;\n    }\n    else\n    {\n        return sorted[len\
    \ / 2];\n    }\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    std.algorithm.sort(sorted);\n    return\
    \ sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n\
    \    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n \
    \   sorted.sort;\n    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sorted.sort;\n    return sorted[sorted.length / 2];\n}", "{\n\
    \    long[] l2 = l[0..$];\n    std.algorithm.sort(l2);\n    return l2[$/2];\n}",
  "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    long len = sorted.length;\n\
    \    if (len % 2 == 0) {\n        return (sorted[len / 2 - 1] + sorted[len / 2])\
    \ / 2.0;\n    } else {\n        return sorted[len / 2];\n    }\n}", "{\n    long[]\
    \ temp = l.dup;\n    temp.sort;\n    return temp[temp.length / 2];\n}", "{\n \
    \   long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] m = l.dup;\n    m.sort;\n    return m[m.length / 2];\n\
    }", "{\n    long[] temp = l.dup;\n    temp.sort;\n    return temp[temp.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] ll = l.dup;\n    ll.sort;\n    return ll[ll.length\
    \ / 2];\n}", "{\n    float[] a = l.dup;\n    a.sort;\n    return a[a.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    if (l.length == 0) \n    {\n        return 0.0f;\n    }\n\
    \    else \n    {\n        long[] sorted = l.dup;\n        std.algorithm.sort(sorted);\n\
    \        if (sorted.length % 2 == 0) \n        {\n            return (sorted[sorted.length\
    \ / 2 - 1] + sorted[sorted.length / 2]) / 2.0f;\n        }\n        else \n  \
    \      {\n            return sorted[sorted.length / 2];\n        }\n    }\n}",
  "{\n    float[] a = l.dup;\n    a.sort;\n    return a[a.length / 2];\n}", "{\n \
    \   long[] m = l.dup;\n    m.sort;\n    return m[m.length / 2];\n}", "{\n    long[]\
    \ sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length / 2];\n}",
  "{\n    float[] m = l.dup;\n    m.sort;\n    return m[m.length / 2];\n}", "{\n \
    \   long[] temp = l.dup;\n    temp.sort;\n    if (temp.length % 2 == 0)\n    {\n\
    \        return (temp[temp.length / 2] + temp[temp.length / 2 - 1]) / 2.0;\n \
    \   }\n    else\n    {\n        return temp[temp.length / 2];\n    }\n}", "{\n\
    \    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length/2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[l.length\
    \ / 2];\n}", "{\n    long[] l2 = l[0..$];\n    std.algorithm.sort(l2);\n    return\
    \ l2[l2.length/2];\n}", "{\n    long[] sorted = l.dup;\n    std.algorithm.sort(sorted);\n\
    \    return sorted[sorted.length / 2];\n}", "{\n    long[] l2 = l[0..$];\n   \
    \ l2.sort();\n    return l2[l2.length / 2];\n}", "{\n    long[] sorted = l.dup;\n\
    \    sorted.sort;\n    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sorted.sort;\n    return sorted[sorted.length / 2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] a = l.dup;\n    a.sort;\n    return a[a.length / 2];\n\
    }", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length/2];\n\
    }", "{\n    float[] f = l.dup;\n    f.sort;\n    return f[f.length / 2];\n}",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] a = l.dup;\n    a.sort;\n    return a[a.length / 2];\n\
    }", "{\n    float[] a = l.dup;\n    a.sort;\n    return a[a.length/2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length/2];\n\
    }", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length / 2];\n}",
  "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length / 2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    float[] a = l.dup;\n    a.sort;\n    return a[a.length /\
    \ 2];\n}", "{\n    long[] s = l.dup;\n    s.sort;\n    if (s.length & 1)\n   \
    \     return s[s.length / 2];\n    else\n        return (s[s.length / 2 - 1] +\
    \ s[s.length / 2]) / 2.0;\n}", "{\n    float[] a = l.dup;\n    a.sort;\n    return\
    \ a[a.length / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n   \
    \ return sorted[sorted.length / 2];\n}", "{\n    float m;\n    long[] l2 = l.dup;\n\
    \    l2.sort;\n    if (l2.length % 2 == 0)\n    {\n        m = (l2[l2.length /\
    \ 2 - 1] + l2[l2.length / 2]) / 2.0;\n    }\n    else\n    {\n        m = l2[l2.length\
    \ / 2];\n    }\n    return m;\n}", "{\n    long[] sorted = l.dup;\n    std.algorithm.sort(sorted);\n\
    \    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted = l.dup;\n \
    \   sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n\
    \    long[] temp = l[0..$];\n    sort(temp);\n    return temp[temp.length / 2];\n\
    }", "{\n    long[] temp = l.dup;\n    temp.sort;\n    if (temp.length % 2 == 0)\n\
    \    {\n        return (temp[temp.length / 2] + temp[temp.length / 2 - 1]) / 2.0;\n\
    \    }\n    else\n    {\n        return temp[temp.length / 2];\n    }\n}", "{\n\
    \    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] a = l.dup;\n    a.sort;\n    return a[a.length / 2];\n\
    }", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length / 2];\n}",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length/2];\n\
    }", "{\n    float[] a = l.dup;\n    a.sort;\n    return a[a.length / 2];\n}",
  "{\n    long[] t = l.dup;\n    t.sort;\n    return t[t.length/2];\n}", "{\n    long[]\
    \ sorted = l.dup;\n    sorted.sort;\n    long len = sorted.length;\n    if (len\
    \ % 2 == 0) \n    {\n        return (sorted[len / 2 - 1] + sorted[len / 2]) /\
    \ 2.0;\n    } \n    else \n    {\n        return sorted[len / 2];\n    }\n}\n\
    /*\nReturn mean of elements in the list l.\n            \n*/\nfloat mean(long[]\
    \ l) \n{\n    long sum = 0;\n    foreach (long i; l) \n    {\n        sum += i;\n\
    \    }\n    return sum / l.length;\n}\n/*\nReturn standard deviation of elements\
    \ in the list l.\n            \n*/\nfloat stddev(long[] l) \n{\n    float m =\
    \ mean(l);\n    float sum = 0;\n    foreach (long i; l) \n    {\n        sum +=\
    \ (i - m) * (i - m);\n    }\n    return sqrt(sum / (l.length - 1));\n}\n/*\nReturn\
    \ the number of elements in the list l that are greater than or equal to x.\n\
    \            \n*/\nlong geq(long[] l, long x) \n{\n    long count = 0;\n    foreach\
    \ (long i; l) \n    {\n        if (i >= x) \n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\nReturn the number of elements in\
    \ the list l that are less than or equal to x.\n            \n*/\nlong leq(long[]\
    \ l, long x) \n{\n    long count = 0;\n    foreach (long i; l) \n    {\n     \
    \   if (i <= x) \n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\nReturn the number of elements in the list l that are equal to\
    \ x.\n            \n*/\nlong eq(long[] l, long x) \n{\n    long count = 0;\n \
    \   foreach (long i; l) \n    {\n        if (i == x) \n        {\n           \
    \ count++;\n        }\n", "{\n    long[] m = l.dup;\n    m.sort;\n    if (m.length\
    \ % 2 == 0)\n        return (m[m.length / 2 - 1] + m[m.length / 2]) / 2.0;\n \
    \   else\n        return m[m.length / 2];\n}", "{\n    long[] sorted = l.dup;\n\
    \    std.algorithm.sort(sorted);\n    return sorted[sorted.length / 2];\n}", "{\n\
    \    long[] l2 = l.dup;\n    l2.sort;\n    return l2[l2.length / 2];\n}", "{\n\
    \    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    return sorted[sorted.length\
    \ / 2];\n}", "{\n    long[] sorted = l.dup;\n    sort(sorted);\n    return sorted[sorted.length\
    \ / 2];\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
