language: d
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ int start_index = 0;\n    int end_index = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            if(open_paren_count == 0)\n\
    \            {\n                start_index = i;\n            }\n            open_paren_count++;\n\
    \        }\n        else if(c == ')')\n        {\n            close_paren_count++;\n\
    \            if(open_paren_count == close_paren_count)\n            {\n      \
    \          end_index = i;\n                result ~= paren_string[start_index..end_index];\n\
    \                open_paren_count = 0;\n                close_paren_count = 0;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk10wa0xv.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpk10wa0xv.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk10wa0xv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open = 0;\n    int close = 0;\n    int start = 0;\n    int\
    \ end = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            open++;\n            if(open == 1)\n       \
    \     {\n                start = i;\n            }\n        }\n        else if(c\
    \ == ')')\n        {\n            close++;\n            if(open == close)\n  \
    \          {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \                open = 0;\n                close = 0;\n            }\n      \
    \  }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8yxi8r_5.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmp8yxi8r_5.__unittest_L43_C1() [0x427da7]

    ??:? void tmp8yxi8r_5.__modtest() [0x428104]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_top = 0;\n    int paren_string_len\
    \ = paren_string.length;\n    int i = 0;\n    int start = 0;\n    int end = 0;\n\
    \    int count = 0;\n    int j = 0;\n    int k = 0;\n    int len = 0;\n    int\
    \ len_result = 0;\n    int len_stack = 0;\n    int len_paren_string = 0;\n   \
    \ int len_result_new = 0;\n    int len_stack_new = 0;\n    int len_paren_string_new\
    \ = 0;\n    int len_result_old = 0;\n    int len_stack_old = 0;\n    int len_paren_string_old\
    \ = 0;\n    int len_result_temp = 0;\n    int len_stack_temp = 0;\n    int len_paren_string_temp\
    \ = 0;\n    int len_result_temp_new = 0;\n    int len_stack_temp_new = 0;\n  \
    \  int len_paren_string_temp_new = 0;\n    int len_result_temp_old = 0;\n    int\
    \ len_stack_temp_old = 0;\n    int len_paren_string_temp_old = 0;\n    int len_result_temp_temp\
    \ = 0;\n    int len_stack_temp_temp = 0;\n    int len_paren_string_temp_temp =\
    \ 0;\n    int len_result_temp_temp_new = 0;\n    int len_stack_temp_temp_new =\
    \ 0;\n    int len_paren_string_temp_temp_new = 0;\n    int len_result_temp_temp_old\
    \ = 0;\n    int len_stack_temp_temp_old = 0;\n    int len_paren_string_temp_temp_old\
    \ = 0;\n    int len_result_temp_temp_temp = 0;\n    int len_stack_temp_temp_temp\
    \ = 0;\n    int len_paren_string_temp_temp_temp = 0;\n    int len_result_temp_temp_temp_new\
    \ = 0;\n    int len_stack_temp\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8z6cqjql.d(55): Error: semicolon expected, not `unittest`

    /tmp/tmp8z6cqjql.d(55): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8z6cqjql.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp96y0qbsx.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp96y0qbsx.__unittest_L38_C1() [0x427d93]

    ??:? void tmp96y0qbsx.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= start;\n       \
    \ }\n        else if(c == ')')\n        {\n            if(stack.length == 0)\n\
    \            {\n                throw new Exception(\"Unbalanced parentheses\"\
    );\n            }\n            int start_index = stack.pop;\n            result\
    \ ~= paren_string[start_index..$];\n            start = $;\n        }\n    }\n\
    \    if(stack.length != 0)\n    {\n        throw new Exception(\"Unbalanced parentheses\"\
    );\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppyyhbrt8.d(29): Error: `$` is valid only inside [] of index or
    slice

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppyyhbrt8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            count++;\n\
    \            if(count == 1)\n            {\n                start = end;\n   \
    \         }\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3wfmjdbg.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmp3wfmjdbg.__unittest_L38_C1() [0x427d97]

    ??:? void tmp3wfmjdbg.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = i;\n            }\n          \
    \  count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                end = i;\n       \
    \         result ~= paren_string[start..end];\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1xl0pjt9.d(22): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmp1xl0pjt9.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1xl0pjt9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  for (int i = 0; i < paren_string.length; i++)\n    {\n        if (paren_string[i]\
    \ == '(')\n        {\n            if (paren_count == 0)\n            {\n     \
    \           start = i;\n            }\n            paren_count++;\n        }\n\
    \        else if (paren_string[i] == ')')\n        {\n            paren_count--;\n\
    \            if (paren_count == 0)\n            {\n                end = i;\n\
    \                result ~= paren_string[start..end];\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphczvydkp.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmphczvydkp.__unittest_L38_C1() [0x427dab]

    ??:? void tmphczvydkp.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(int i, char c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            if(open_paren_count == 0)\n            {\n           \
    \     start_index = i;\n            }\n            open_paren_count++;\n     \
    \   }\n        else if(c == ')')\n        {\n            open_paren_count--;\n\
    \            if(open_paren_count == 0)\n            {\n                end_index\
    \ = i;\n                result ~= paren_string[start_index..end_index];\n    \
    \        }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprj9ggbhq.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmprj9ggbhq.__unittest_L38_C1() [0x427d93]

    ??:? void tmprj9ggbhq.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp96y0qbsx.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp96y0qbsx.__unittest_L38_C1() [0x427d93]

    ??:? void tmp96y0qbsx.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    string current_group = \"\";\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    // TODO:\
    \ implement\n    return null;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv29nh1mq.d(19): unittest failure

    ----------------

    ??:? _d_unittestp [0x428d65]

    ??:? void tmpv29nh1mq.__unittest_L15_C1() [0x427c6f]

    ??:? void tmpv29nh1mq.__modtest() [0x427fcc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d63f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428abe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a4ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a57c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a479]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428a95]

    ??:? runModuleUnitTests [0x42d415]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4291b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_index = 0;\n    int start_index = 0;\n\
    \    int end_index = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            stack[stack_index] = i;\n      \
    \      stack_index++;\n        }\n        else if(c == ')')\n        {\n     \
    \       stack_index--;\n            end_index = i;\n            if(stack_index\
    \ == 0)\n            {\n                result ~= paren_string[start_index..end_index];\n\
    \                start_index = end_index + 1;\n            }\n        }\n    \
    \    i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp5q1dx92e.d(22): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f7e]

    ??:? immutable(char)[][] tmp5q1dx92e.separate_paren_groups(immutable(char)[])
    [0x427c22]

    ??:? void tmp5q1dx92e.__unittest_L39_C1() [0x427d1d]

    ??:? void tmp5q1dx92e.__modtest() [0x428138]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e207]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b0b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b144]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b041]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bfd]

    ??:? runModuleUnitTests [0x42dfdd]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            start = end;\n        }\n        else if(c == ')')\n       \
    \ {\n            stack ~= -1;\n            end = end + 1;\n            if(sum(stack)\
    \ == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \                stack = [];\n            }\n        }\n        else\n       \
    \ {\n            end = end + 1;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdusmmhae.d(27): Error: undefined identifier `sum`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdusmmhae.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ groups;\n    int start = 0;\n    int end = 0;\n    int open_paren = 0;\n   \
    \ int close_paren = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            if(open_paren == 0)\n            {\n                start\
    \ = end;\n            }\n            open_paren++;\n        }\n        else if(c\
    \ == ')')\n        {\n            close_paren++;\n            if(open_paren ==\
    \ close_paren)\n            {\n                groups ~= paren_string[start..end];\n\
    \                open_paren = 0;\n                close_paren = 0;\n         \
    \   }\n        }\n        end++;\n    }\n    return groups;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkkwriz_r.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpkkwriz_r.__unittest_L41_C1() [0x427d9f]

    ??:? void tmpkkwriz_r.__modtest() [0x4280fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto result\
    \ = new string[];\n    auto paren_stack = new Stack!(char[])();\n    auto current_group\
    \ = new char[];\n    foreach(c; paren_string) \n    {\n        if(c == '(') \n\
    \        {\n            paren_stack.push(current_group);\n            current_group\
    \ = new char[];\n        }\n        else if(c == ')') \n        {\n          \
    \  if(paren_stack.empty) \n            {\n                throw new Exception(\"\
    Unbalanced parentheses\");\n            }\n            result ~= current_group.idup;\n\
    \            current_group = paren_stack.pop;\n        }\n        else if(c !=\
    \ ' ') \n        {\n            current_group ~= c;\n        }\n    }\n    if(!paren_stack.empty)\
    \ \n    {\n        throw new Exception(\"Unbalanced parentheses\");\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfyrq9w0h.d(12): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpfyrq9w0h.d(13): Error: template instance `Stack!(char[])` template `Stack`
    is not defined

    /tmp/tmpfyrq9w0h.d(14): Error: new can only create structs, dynamic arrays or
    class objects, not `char[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfyrq9w0h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    int paren_index = 0;\n    int paren_count_index = 0;\n    int paren_count_length\
    \ = 0;\n    int paren_count_sum = 0;\n    int paren_count_sum_prev = 0;\n    int\
    \ paren_count_sum_curr = 0;\n    int paren_count_sum_next = 0;\n    int paren_count_sum_next_next\
    \ = 0;\n    int paren_count_sum_next_next_next = 0;\n    int paren_count_sum_next_next_next_next\
    \ = 0;\n    int paren_count_sum_next_next_next_next_next = 0;\n    int paren_count_sum_next_next_next_next_next_next\
    \ = 0;\n    int paren_count_sum_next_next_next_next_next_next_next = 0;\n    int\
    \ paren_count_sum_next_next_next_next_next_next_next_next = 0;\n    int paren_count_sum_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    int paren_count_sum_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    int paren_count_sum_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    int paren_count_sum_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    int paren_count_sum_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    int paren_count_sum_next_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    int paren_count_sum_next_next_next_next_next_next_next_\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6xogil0x.d(37): Error: semicolon expected, not `unittest`

    /tmp/tmp6xogil0x.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6xogil0x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n   \
    \     {\n            if(paren_count == 0)\n            {\n                start\
    \ = i;\n            }\n            paren_count++;\n        }\n        else if(c\
    \ == ')')\n        {\n            paren_count--;\n            if(paren_count ==\
    \ 0)\n            {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1a8lwu4l.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp1a8lwu4l.__unittest_L40_C1() [0x427d93]

    ??:? void tmp1a8lwu4l.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    int i = 0;\n    foreach(char c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_parens++;\n        \
    \    if(open_parens == 1)\n            {\n                start = i;\n       \
    \     }\n        }\n        else if(c == ')')\n        {\n            close_parens++;\n\
    \            if(close_parens == open_parens)\n            {\n                end\
    \ = i;\n                result ~= paren_string[start..end];\n                open_parens\
    \ = 0;\n                close_parens = 0;\n            }\n        }\n        i++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdnnhdi1_.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmpdnnhdi1_.__unittest_L43_C1() [0x427da7]

    ??:? void tmpdnnhdi1_.__modtest() [0x428104]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto result\
    \ = new string[];\n    int start = 0;\n    int end = 0;\n    int open_parens =\
    \ 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            if(open_parens == 0)\n            {\n                start = i;\n\
    \            }\n            open_parens++;\n        }\n        else if(c == ')')\n\
    \        {\n            open_parens--;\n            if(open_parens == 0)\n   \
    \         {\n                end = i;\n                result ~= paren_string[start..end+1];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcbdrb59q.d(12): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpcbdrb59q.d(22): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpcbdrb59q.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcbdrb59q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_stack;\n    int paren_count = 0;\n    int paren_start\
    \ = 0;\n    int paren_end = 0;\n    foreach(i, c; paren_string)\n    {\n     \
    \   if(c == '(')\n        {\n            paren_stack ~= i;\n            paren_count++;\n\
    \        }\n        else if(c == ')')\n        {\n            paren_stack.popBack();\n\
    \            paren_count--;\n        }\n        if(paren_count == 0)\n       \
    \ {\n            paren_end = i;\n            result ~= paren_string[paren_start..paren_end];\n\
    \            paren_start = i + 1;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpycp2u7xd.d(21): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpycp2u7xd.d(26): Error: no property `popBack` for type `int[]`

    /tmp/tmpycp2u7xd.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpycp2u7xd.d(33): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpycp2u7xd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    // your\
    \ code here\n    string[] result;\n    int count = 0;\n    int start = 0;\n  \
    \  foreach(i, c; paren_string)\n    {\n        if(c == '(')\n        {\n     \
    \       if(count == 0)\n                start = i;\n            count++;\n   \
    \     }\n        else if(c == ')')\n        {\n            count--;\n        \
    \    if(count == 0)\n                result ~= paren_string[start..i];\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp70yrry8k.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp70yrry8k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            if(paren_count == 0)\n            {\n                start_index\
    \ = i;\n            }\n            paren_count++;\n        }\n        else if(c\
    \ == ')')\n        {\n            paren_count--;\n            if(paren_count ==\
    \ 0)\n            {\n                end_index = i;\n                result ~=\
    \ paren_string[start_index..end_index];\n            }\n        }\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo9hvj6ui.d(22): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpo9hvj6ui.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo9hvj6ui.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int i;\n    int start;\n    int end;\n    int\
    \ len;\n    int stack_len;\n    int stack_top;\n    int stack_bottom;\n    int\
    \ stack_size;\n    int stack_index;\n    int stack_top_index;\n    int stack_bottom_index;\n\
    \    int stack_top_value;\n    int stack_bottom_value;\n    int stack_top_value_index;\n\
    \    int stack_bottom_value_index;\n    int stack_top_value_index_top;\n    int\
    \ stack_top_value_index_bottom;\n    int stack_bottom_value_index_top;\n    int\
    \ stack_bottom_value_index_bottom;\n    int stack_top_value_index_top_value;\n\
    \    int stack_top_value_index_bottom_value;\n    int stack_bottom_value_index_top_value;\n\
    \    int stack_bottom_value_index_bottom_value;\n    int stack_top_value_index_top_value_index;\n\
    \    int stack_top_value_index_bottom_value_index;\n    int stack_bottom_value_index_top_value_index;\n\
    \    int stack_bottom_value_index_bottom_value_index;\n    int stack_top_value_index_top_value_index_value;\n\
    \    int stack_top_value_index_bottom_value_index_value;\n    int stack_bottom_value_index_top_value_index_value;\n\
    \    int stack_bottom_value_index_bottom_value_index_value;\n    int stack_top_value_index_top_value_index_value_index;\n\
    \    int stack_top_value_index_bottom_value_index_value_index;\n    int stack_bottom_value_index_top_value_index_value_index;\n\
    \    int stack_bottom_value_index_bottom_value_index_value_index;\n    int stack_top_value_index_top_value_index_value_index_value;\n\
    \    int stack_top_value_index_bottom_value_index_value_index_value\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppu9nwnd4.d(51): Error: semicolon expected, not `unittest`

    /tmp/tmppu9nwnd4.d(51): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppu9nwnd4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int i;\n    int j;\n    int k;\n    int\
    \ l;\n    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n\
    \    int s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int\
    \ y;\n    int z;\n    int aa;\n    int bb;\n    int cc;\n    int dd;\n    int\
    \ ee;\n    int ff;\n    int gg;\n    int hh;\n    int ii;\n    int jj;\n    int\
    \ kk;\n    int ll;\n    int mm;\n    int nn;\n    int oo;\n    int pp;\n    int\
    \ qq;\n    int rr;\n    int ss;\n    int tt;\n    int uu;\n    int vv;\n    int\
    \ ww;\n    int xx;\n    int yy;\n    int zz;\n    int aaa;\n    int bbb;\n   \
    \ int ccc;\n    int ddd;\n    int eee;\n    int fff;\n    int ggg;\n    int hhh;\n\
    \    int iii;\n    int jjj;\n    int kkk;\n    int lll;\n    int mmm;\n    int\
    \ nnn;\n    int ooo;\n    int ppp;\n    int qqq;\n    int rrr;\n    int sss;\n\
    \    int ttt;\n    int uuu;\n    int vvv;\n    int www;\n    int xxx;\n    int\
    \ yyy;\n    int zzz;\n    int aaaa;\n    int bbbb;\n    int cccc;\n    int dddd;\n\
    \    int eeee;\n    int ffff;\n    int gggg;\n    int hhhh;\n    int iiii;\n \
    \   int jjjj;\n    int kkkk;\n    int llll;\n    int mmmm;\n    int nnnn;\n  \
    \  int oooo;\n    int pppp\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpupoo9h6h.d(100): Error: semicolon expected, not `unittest`

    /tmp/tmpupoo9h6h.d(100): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpupoo9h6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string current_group;\n    int paren_count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    for (int i\
    \ = 0; i < paren_string.length; i++)\n    {\n        if (paren_string[i] == '(')\n\
    \        {\n            if (paren_count == 0)\n            {\n               \
    \ start_index = i;\n            }\n            paren_count++;\n        }\n   \
    \     else if (paren_string[i] == ')')\n        {\n            paren_count--;\n\
    \            if (paren_count == 0)\n            {\n                result ~= paren_string[start_index..i];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp95inumjr.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmp95inumjr.__unittest_L36_C1() [0x427da3]

    ??:? void tmp95inumjr.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    int len\
    \ = paren_string.length;\n    foreach(i; 0..len)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            if(count == 0)\n            {\n            \
    \    start = i;\n            }\n            count++;\n        }\n        else\
    \ if(paren_string[i] == ')')\n        {\n            count--;\n            if(count\
    \ == 0)\n            {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxuozm2s6.d(16): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxuozm2s6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ int start_index = 0;\n    int end_index = 0;\n    foreach(int i, char c; paren_string)\
    \ \n    {\n        if(c == '(') \n        {\n            open_paren_count++;\n\
    \            if(open_paren_count == 1) \n            {\n                start_index\
    \ = i;\n            }\n        }\n        else if(c == ')') \n        {\n    \
    \        close_paren_count++;\n            if(close_paren_count == open_paren_count)\
    \ \n            {\n                end_index = i;\n                result ~= paren_string[start_index..end_index];\n\
    \                open_paren_count = 0;\n                close_paren_count = 0;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph1ql9p34.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmph1ql9p34.__unittest_L41_C1() [0x427d9f]

    ??:? void tmph1ql9p34.__modtest() [0x4280fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        paren_count++;\n        }\n        else if(c == ')')\n        {\n   \
    \         paren_count--;\n            if(paren_count == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptskjfzxs.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptskjfzxs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int paren_count_index = 0;\n    int paren_count_length\
    \ = 0;\n    int paren_count_max = 0;\n    int paren_count_max_index = 0;\n   \
    \ int paren_count_max_length = 0;\n    int paren_count_max_length_index = 0;\n\
    \    int paren_count_max_length_length = 0;\n    int paren_count_max_length_length_index\
    \ = 0;\n    int paren_count_max_length_length_length = 0;\n    int paren_count_max_length_length_length_index\
    \ = 0;\n    int paren_count_max_length_length_length_length = 0;\n    int paren_count_max_length_length_length_length_index\
    \ = 0;\n    int paren_count_max_length_length_length_length_length = 0;\n    int\
    \ paren_count_max_length_length_length_length_length_index = 0;\n    int paren_count_max_length_length_length_length_length_length\
    \ = 0;\n    int paren_count_max_length_length_length_length_length_length_index\
    \ = 0;\n    int paren_count_max_length_length_length_length_length_length_length\
    \ = 0;\n    int paren_count_max_length_length_length_length_length_length_length_index\
    \ = 0;\n    int paren_count_max_length_length_length_length_length_length_length_length\
    \ = 0;\n    int paren_count_max_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    int paren_count_max_length_length_length_length_length_length_length_length_length\
    \ = 0;\n    int paren_count_max_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    int paren_count_max_length_length_length_length_length_length_length_length_length_length\
    \ = 0\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjvdn1hx_.d(37): Error: semicolon expected, not `unittest`

    /tmp/tmpjvdn1hx_.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjvdn1hx_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            if(open_paren_count == 0)\n            {\n                start_index\
    \ = i;\n            }\n            open_paren_count++;\n        }\n        else\
    \ if(c == ')')\n        {\n            open_paren_count--;\n            if(open_paren_count\
    \ == 0)\n            {\n                end_index = i;\n                result\
    \ ~= paren_string[start_index..end_index];\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplvitetxx.d(22): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmplvitetxx.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplvitetxx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(char c; paren_string)\n    {\n        if(c == '(')\n     \
    \   {\n            open_paren_count++;\n            if(open_paren_count == 1)\n\
    \            {\n                start_index = end_index;\n            }\n    \
    \    }\n        else if(c == ')')\n        {\n            open_paren_count--;\n\
    \            if(open_paren_count == 0)\n            {\n                result\
    \ ~= paren_string[start_index..end_index];\n            }\n        }\n       \
    \ end_index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppf8dn2cr.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmppf8dn2cr.__unittest_L38_C1() [0x427d97]

    ??:? void tmppf8dn2cr.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(immutable\
    \ c; paren_string) \n    {\n        if(c == '(') \n        {\n            stack\
    \ ~= 1;\n            start = end;\n        }\n        else if(c == ')') \n   \
    \     {\n            stack ~= -1;\n            end = end + 1;\n            if(stack.sum\
    \ == 0) \n            {\n                result ~= paren_string[start..end];\n\
    \                stack = [];\n            }\n        }\n        else \n      \
    \  {\n            end = end + 1;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpntyjs4gu.d(27): Error: no property `sum` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpntyjs4gu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_parens++;\n            start = end;\n    \
    \    }\n        else if(c == ')')\n        {\n            close_parens++;\n  \
    \          if(open_parens == close_parens)\n            {\n                result\
    \ ~= paren_string[start..end];\n                open_parens = 0;\n           \
    \     close_parens = 0;\n            }\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp86vdmivv.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmp86vdmivv.__unittest_L38_C1() [0x427d9b]

    ??:? void tmp86vdmivv.__modtest() [0x4280f8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int paren_count_index = 0;\n    int paren_count_size\
    \ = 0;\n    int paren_count_capacity = 0;\n    int paren_count_length = 0;\n \
    \   int paren_count_last_index = 0;\n    int paren_count_last_value = 0;\n   \
    \ int paren_count_last_value_index = 0;\n    int paren_count_last_value_length\
    \ = 0;\n    int paren_count_last_value_last_index = 0;\n    int paren_count_last_value_last_value\
    \ = 0;\n    int paren_count_last_value_last_value_index = 0;\n    int paren_count_last_value_last_value_length\
    \ = 0;\n    int paren_count_last_value_last_value_last_index = 0;\n    int paren_count_last_value_last_value_last_value\
    \ = 0;\n    int paren_count_last_value_last_value_last_value_index = 0;\n    int\
    \ paren_count_last_value_last_value_last_value_length = 0;\n    int paren_count_last_value_last_value_last_value_last_index\
    \ = 0;\n    int paren_count_last_value_last_value_last_value_last_value = 0;\n\
    \    int paren_count_last_value_last_value_last_value_last_value_index = 0;\n\
    \    int paren_count_last_value_last_value_last_value_last_value_length = 0;\n\
    \    int paren_count_last_value_last_value_last_value_last_value_last_index =\
    \ 0;\n    int paren_count_last_value_last_value_last_value_last_value_last_value\
    \ = 0;\n    int paren_count_last_value_last_value_last_value_last_value_last_value_index\
    \ = 0;\n    int paren_count_last_value_last_value_last_value\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoan_tkmq.d(38): Error: semicolon expected, not `unittest`

    /tmp/tmpoan_tkmq.d(38): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoan_tkmq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    int start = 0;\n    int end = 0;\n    int open_count\
    \ = 0;\n    int close_count = 0;\n    foreach(char c; paren_string)\n    {\n \
    \       if(c == '(')\n        {\n            open_count++;\n        }\n      \
    \  else if(c == ')')\n        {\n            close_count++;\n        }\n     \
    \   if(open_count == close_count)\n        {\n            if(open_count != 0)\n\
    \            {\n                result ~= paren_string[start..end];\n        \
    \        open_count = 0;\n                close_count = 0;\n                start\
    \ = i + 1;\n            }\n        }\n        i++;\n        end = i;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsc80dmd_.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ea5]

    ??:? void tmpsc80dmd_.__unittest_L43_C1() [0x427daf]

    ??:? void tmpsc80dmd_.__modtest() [0x42810c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bfe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b08d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b11c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b019]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bd5]

    ??:? runModuleUnitTests [0x42dfb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429368]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    int paren_count = 0;\n    string current_group = \"\";\n\
    \    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n      \
    \      paren_count++;\n            current_group ~= c;\n        }\n        else\
    \ if(c == ')')\n        {\n            paren_count--;\n            current_group\
    \ ~= c;\n            if(paren_count == 0)\n            {\n                paren_groups\
    \ ~= current_group;\n                current_group = \"\";\n            }\n  \
    \      }\n        else if(c != ' ')\n        {\n            current_group ~= c;\n\
    \        }\n    }\n    return paren_groups;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            start = end;\n        }\n        else if(c == ')')\n       \
    \ {\n            stack ~= -1;\n            end = end + 1;\n            if(stack.sum\
    \ == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else\n        {\n            end = end + 1;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpki_1m4_w.d(27): Error: no property `sum` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpki_1m4_w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    for(int\
    \ i = 0; i < paren_string.length; i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            if(count == 0)\n            {\n                start =\
    \ i;\n            }\n            count++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            count--;\n            if(count == 0)\n     \
    \       {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_njoova3.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmp_njoova3.__unittest_L38_C1() [0x427dab]

    ??:? void tmp_njoova3.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  for (int i = 0; i < paren_string.length; i++)\n    {\n        if (paren_string[i]\
    \ == '(')\n        {\n            if (paren_count == 0)\n            {\n     \
    \           start = i;\n            }\n            paren_count++;\n        }\n\
    \        else if (paren_string[i] == ')')\n        {\n            paren_count--;\n\
    \            if (paren_count == 0)\n            {\n                end = i;\n\
    \                result ~= paren_string[start..end];\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphczvydkp.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmphczvydkp.__unittest_L38_C1() [0x427dab]

    ??:? void tmphczvydkp.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string temp;\n    int open_paren_count = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_paren_count++;\n   \
    \         temp ~= c;\n        }\n        else if(c == ')')\n        {\n      \
    \      open_paren_count--;\n            temp ~= c;\n        }\n        else if(c\
    \ == ' ')\n        {\n            //do nothing\n        }\n        else\n    \
    \    {\n            temp ~= c;\n        }\n        if(open_paren_count == 0)\n\
    \        {\n            result ~= temp;\n            temp = \"\";\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnqnj50b7.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f05]

    ??:? void tmpnqnj50b7.__unittest_L43_C1() [0x427e0f]

    ??:? void tmpnqnj50b7.__modtest() [0x42816c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b079]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b108]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b005]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c35]

    ??:? runModuleUnitTests [0x42dfa1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429354]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292db]

    ??:? _d_run_main [0x429246]

    ??:? main [0x42817f]

    ??:? __libc_start_main [0x8af7f554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string current_group;\n    int paren_count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(paren_count\
    \ == 0)\n            {\n                current_group = \"\";\n            }\n\
    \            paren_count++;\n        }\n        else if(c == ')')\n        {\n\
    \            paren_count--;\n            if(paren_count == 0)\n            {\n\
    \                result ~= current_group;\n            }\n        }\n        else\
    \ if(paren_count > 0)\n        {\n            current_group ~= c;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu7qhp9ng.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpu7qhp9ng.__unittest_L40_C1() [0x427d97]

    ??:? void tmpu7qhp9ng.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e153]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b001]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b090]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42af8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df29]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4292dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(depth\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    depth++;\n        }\n        else if(c == ')')\n        {\n            depth--;\n\
    \            if(depth == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else if(c == ' ')\n        {\n            //ignore\n\
    \        }\n        else\n        {\n            assert(false, \"Invalid character\"\
    );\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9ezje6sw.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmp9ezje6sw.__unittest_L46_C1() [0x427dff]

    ??:? void tmp9ezje6sw.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start_pos = 0;\n    int end_pos = 0;\n    int open_paren_count\
    \ = 0;\n    int close_paren_count = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            open_paren_count++;\n        }\n\
    \        else if(c == ')')\n        {\n            close_paren_count++;\n    \
    \    }\n        if(open_paren_count == close_paren_count)\n        {\n       \
    \     result ~= paren_string[start_pos..end_pos];\n            start_pos = end_pos\
    \ + 1;\n            open_paren_count = 0;\n            close_paren_count = 0;\n\
    \        }\n        end_pos++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_9wn9p9z.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmp_9wn9p9z.__unittest_L38_C1() [0x427d97]

    ??:? void tmp_9wn9p9z.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    string current_group = \"\";\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int i;\n    int j;\n    int k;\n    int l;\n\
    \    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int\
    \ s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n\
    \    int z;\n    int aa;\n    int bb;\n    int cc;\n    int dd;\n    int ee;\n\
    \    int ff;\n    int gg;\n    int hh;\n    int ii;\n    int jj;\n    int kk;\n\
    \    int ll;\n    int mm;\n    int nn;\n    int oo;\n    int pp;\n    int qq;\n\
    \    int rr;\n    int ss;\n    int tt;\n    int uu;\n    int vv;\n    int ww;\n\
    \    int xx;\n    int yy;\n    int zz;\n    int aaa;\n    int bbb;\n    int ccc;\n\
    \    int ddd;\n    int eee;\n    int fff;\n    int ggg;\n    int hhh;\n    int\
    \ iii;\n    int jjj;\n    int kkk;\n    int lll;\n    int mmm;\n    int nnn;\n\
    \    int ooo;\n    int ppp;\n    int qqq;\n    int rrr;\n    int sss;\n    int\
    \ ttt;\n    int uuu;\n    int vvv;\n    int www;\n    int xxx;\n    int yyy;\n\
    \    int zzz;\n    int aaaa;\n    int bbbb;\n    int cccc;\n    int dddd;\n  \
    \  int eeee;\n    int ffff;\n    int gggg;\n    int hhhh;\n    int iiii;\n   \
    \ int jjjj;\n    int kkkk;\n    int llll;\n    int mmmm;\n    int nnnn;\n    int\
    \ oooo;\n    int pppp;\n   \nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_pk28cn8.d(101): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_pk28cn8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string) \n    {\n        if(c == '(') \n        {\n            if(paren_count\
    \ == 0) \n            {\n                start_index = i;\n            }\n   \
    \         paren_count++;\n        }\n        else if(c == ')') \n        {\n \
    \           paren_count--;\n            if(paren_count == 0) \n            {\n\
    \                result ~= paren_string[start_index..i];\n            }\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplhe_8_xs.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplhe_8_xs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_parens;\n    int[] close_parens;\n    int open_count\
    \ = 0;\n    int close_count = 0;\n    int i = 0;\n    int j = 0;\n    int k =\
    \ 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int\
    \ p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n   \
    \ int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd\
    \ = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n \
    \   int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm\
    \ = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n \
    \   int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv\
    \ = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n \
    \   int aaa = 0;\n    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int\
    \ eee = 0;\n    int fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii\
    \ = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n\
    \    int nnn = 0;\n    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int\
    \ rrr = 0;\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn0b7j38s.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn0b7j38s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_count = 0;\n   \
    \ int close_count = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_count++;\n            if(open_count == 1)\n\
    \            {\n                start = i;\n            }\n        }\n       \
    \ else if(c == ')')\n        {\n            close_count++;\n            if(close_count\
    \ == open_count)\n            {\n                end = i;\n                result\
    \ ~= paren_string[start..end];\n                open_count = 0;\n            \
    \    close_count = 0;\n            }\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy22ra7vn.d(24): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpy22ra7vn.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy22ra7vn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string current_group;\n    int paren_count = 0;\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_count = 0;\n   \
    \ int close_count = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            close_count++;\n        }\n        if(open_count == close_count)\n\
    \        {\n            result ~= paren_string[start..end];\n            start\
    \ = end + 1;\n            open_count = 0;\n            close_count = 0;\n    \
    \    }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt4jerkxo.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpt4jerkxo.__unittest_L38_C1() [0x427d97]

    ??:? void tmpt4jerkxo.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            start = end;\n        }\n        else if(c == ')')\n       \
    \ {\n            stack ~= -1;\n            end = end + 1;\n            if(stack.sum\
    \ == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else\n        {\n            end = end + 1;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpki_1m4_w.d(27): Error: no property `sum` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpki_1m4_w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    for (int i = 0; i < paren_string.length; i++)\n\
    \    {\n        if (paren_string[i] == '(')\n        {\n            open_parens++;\n\
    \            if (open_parens == 1)\n            {\n                start = i;\n\
    \            }\n        }\n        else if (paren_string[i] == ')')\n        {\n\
    \            close_parens++;\n            if (open_parens == close_parens)\n \
    \           {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \                open_parens = 0;\n                close_parens = 0;\n       \
    \     }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmwt89hho.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ead]

    ??:? void tmpmwt89hho.__unittest_L41_C1() [0x427dbb]

    ??:? void tmpmwt89hho.__modtest() [0x428118]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b095]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b124]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b021]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bdd]

    ??:? runModuleUnitTests [0x42dfbd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429370]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    int start_index = 0;\n    int end_index = 0;\n    int paren_count\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            if(paren_count == 0)\n            {\n                start_index\
    \ = end_index;\n            }\n            paren_count++;\n        }\n       \
    \ else if(c == ')')\n        {\n            paren_count--;\n            if(paren_count\
    \ == 0)\n            {\n                paren_groups ~= paren_string[start_index..end_index];\n\
    \            }\n        }\n        end_index++;\n    }\n    return paren_groups;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnsr4ir4w.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpnsr4ir4w.__unittest_L38_C1() [0x427d93]

    ??:? void tmpnsr4ir4w.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    int start_index = 0;\n    int end_index = 0;\n    int open_paren_count\
    \ = 0;\n    int closed_paren_count = 0;\n    int paren_group_count = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            open_paren_count++;\n\
    \            if(open_paren_count == 1)\n            {\n                start_index\
    \ = i;\n            }\n        }\n        else if(c == ')')\n        {\n     \
    \       closed_paren_count++;\n            if(closed_paren_count == open_paren_count)\n\
    \            {\n                end_index = i;\n                paren_groups[paren_group_count]\
    \ = paren_string[start_index..end_index];\n                paren_group_count++;\n\
    \                open_paren_count = 0;\n                closed_paren_count = 0;\n\
    \            }\n        }\n    }\n    return paren_groups;\n}\nunittest\n{\n \
    \   alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpru4p762o.d(25): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpru4p762o.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpru4p762o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int count = 0;\n    string temp = \"\";\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            count++;\n            temp\
    \ ~= c;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            temp ~= c;\n        }\n        else if(c != ' ')\n        {\n   \
    \         temp ~= c;\n        }\n        if(count == 0 && temp != \"\")\n    \
    \    {\n            result ~= temp;\n            temp = \"\";\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int i = 0;\n    int j = 0;\n\
    \    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n\
    \    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd\
    \ = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n \
    \   int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm\
    \ = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n \
    \   int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv\
    \ = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n \
    \   int aaa = 0;\n    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int\
    \ eee = 0;\n    int fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii\
    \ = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n\
    \    int nnn = 0;\n    int ooo = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int\
    \ rrr = 0;\n    int sss = 0;\n    int ttt = 0;\n    int uuu =\nunittest\n{\n \
    \   alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxev7jemi.d(80): Error: expression expected, not `unittest`

    /tmp/tmpxev7jemi.d(81): Error: semicolon expected, not `{`

    /tmp/tmpxev7jemi.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxev7jemi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n   \
    \ int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj =\
    \ 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n   \
    \ int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss =\
    \ 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n   \
    \ int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n    int bbb\
    \ = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int fff = 0;\n\
    \    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int\
    \ kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n    int ooo\
    \ = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int sss = 0;\n\
    \    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsp9699q_.d(80): Error: semicolon expected, not `unittest`

    /tmp/tmpsp9699q_.d(80): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsp9699q_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    int i =\
    \ 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n \
    \           stack ~= i;\n        }\n        else if(c == ')')\n        {\n   \
    \         if(stack.length == 0)\n            {\n                throw new Exception(\"\
    Invalid input string\");\n            }\n            start = stack.pop;\n    \
    \        end = i;\n            result ~= paren_string[start..end];\n        }\n\
    \        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps9vin3kj.d(29): Error: no property `pop` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps9vin3kj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    int paren_count_index = 0;\n    int paren_count_size = 0;\n    int\
    \ paren_count_capacity = 0;\n    int paren_count_length = 0;\n    int paren_count_last_index\
    \ = 0;\n    int paren_count_last_value = 0;\n    int paren_count_last_value_index\
    \ = 0;\n    int paren_count_last_value_size = 0;\n    int paren_count_last_value_capacity\
    \ = 0;\n    int paren_count_last_value_length = 0;\n    int paren_count_last_value_last_index\
    \ = 0;\n    int paren_count_last_value_last_value = 0;\n    int paren_count_last_value_last_value_index\
    \ = 0;\n    int paren_count_last_value_last_value_size = 0;\n    int paren_count_last_value_last_value_capacity\
    \ = 0;\n    int paren_count_last_value_last_value_length = 0;\n    int paren_count_last_value_last_value_last_index\
    \ = 0;\n    int paren_count_last_value_last_value_last_value = 0;\n    int paren_count_last_value_last_value_last_value_index\
    \ = 0;\n    int paren_count_last_value_last_value_last_value_size = 0;\n    int\
    \ paren_count_last_value_last_value_last_value_capacity = 0;\n    int paren_count_last_value_last_value_last_value_length\
    \ = 0;\n    int paren_count_last_value_last_value_last_value_last_index = 0;\n\
    \    int paren_count_last_value_last_value_last_value_last_value = 0;\n    int\
    \ paren_count_last_value_last_value_last_value_last_value_index = 0;\n\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps_9uwu9r.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps_9uwu9r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        paren_count++;\n        }\n        else if(c == ')')\n        {\n   \
    \         paren_count--;\n            if(paren_count == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptskjfzxs.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptskjfzxs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start_index = 0;\n    int end_index = 0;\n    int paren_count\
    \ = 0;\n    foreach(char c; paren_string)\n    {\n        if(c == '(')\n     \
    \   {\n            if(paren_count == 0)\n            {\n                start_index\
    \ = end_index;\n            }\n            paren_count++;\n        }\n       \
    \ else if(c == ')')\n        {\n            paren_count--;\n            if(paren_count\
    \ == 0)\n            {\n                result ~= paren_string[start_index..end_index];\n\
    \            }\n        }\n        end_index++;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf9rs2xuw.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpf9rs2xuw.__unittest_L38_C1() [0x427d93]

    ??:? void tmpf9rs2xuw.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int paren_count_index = 0;\n    int paren_count_start\
    \ = 0;\n    int paren_count_end = 0;\n    int paren_count_length = 0;\n    int\
    \ paren_count_total = 0;\n    int paren_count_total_start = 0;\n    int paren_count_total_end\
    \ = 0;\n    int paren_count_total_length = 0;\n    int paren_count_total_index\
    \ = 0;\n    int paren_count_total_start_index = 0;\n    int paren_count_total_end_index\
    \ = 0;\n    int paren_count_total_length_index = 0;\n    int paren_count_total_total\
    \ = 0;\n    int paren_count_total_total_start = 0;\n    int paren_count_total_total_end\
    \ = 0;\n    int paren_count_total_total_length = 0;\n    int paren_count_total_total_index\
    \ = 0;\n    int paren_count_total_total_start_index = 0;\n    int paren_count_total_total_end_index\
    \ = 0;\n    int paren_count_total_total_length_index = 0;\n    int paren_count_total_total_total\
    \ = 0;\n    int paren_count_total_total_total_start = 0;\n    int paren_count_total_total_total_end\
    \ = 0;\n    int paren_count_total_total_total_length = 0;\n    int paren_count_total_total_total_index\
    \ = 0;\n    int paren_count_total_total_total_start_index = 0;\n    int paren_count_total_total_total_end_index\
    \ = 0;\n    int paren_count_total_total_total_length_index = 0;\n    int paren_count_total_total_total_total\
    \ = 0;\n    int paren_count_total_total_total_total_start = 0;\n    int paren_count_total_total_total\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsdpe3mcf.d(45): Error: semicolon expected, not `unittest`

    /tmp/tmpsdpe3mcf.d(45): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsdpe3mcf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    string current_paren_group = \"\";\n\
    \    foreach(char c; paren_string)\n    {\n        if(c == '(')\n        {\n \
    \           paren_count++;\n            current_paren_group ~= c;\n        }\n\
    \        else if(c == ')')\n        {\n            paren_count--;\n          \
    \  current_paren_group ~= c;\n            if(paren_count == 0)\n            {\n\
    \                result ~= current_paren_group;\n                current_paren_group\
    \ = \"\";\n            }\n        }\n        else if(c != ' ')\n        {\n  \
    \          current_paren_group ~= c;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else if(c == ' ')\n        {\n            //\
    \ do nothing\n        }\n        else\n        {\n            assert(false, \"\
    Invalid character in input string\");\n        }\n        end++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps5bmggp1.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmps5bmggp1.__unittest_L46_C1() [0x427dff]

    ??:? void tmps5bmggp1.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    int paren_count_index = 0;\n    int paren_count_length = 0;\n    int\
    \ paren_count_sum = 0;\n    int paren_count_sum_prev = 0;\n    int paren_count_sum_next\
    \ = 0;\n    int paren_count_sum_diff = 0;\n    int paren_count_sum_diff_prev =\
    \ 0;\n    int paren_count_sum_diff_next = 0;\n    int paren_count_sum_diff_diff\
    \ = 0;\n    int paren_count_sum_diff_diff_prev = 0;\n    int paren_count_sum_diff_diff_next\
    \ = 0;\n    int paren_count_sum_diff_diff_diff = 0;\n    int paren_count_sum_diff_diff_diff_prev\
    \ = 0;\n    int paren_count_sum_diff_diff_diff_next = 0;\n    int paren_count_sum_diff_diff_diff_diff\
    \ = 0;\n    int paren_count_sum_diff_diff_diff_diff_prev = 0;\n    int paren_count_sum_diff_diff_diff_diff_next\
    \ = 0;\n    int paren_count_sum_diff_diff_diff_diff_diff = 0;\n    int paren_count_sum_diff_diff_diff_diff_diff_prev\
    \ = 0;\n    int paren_count_sum_diff_diff_diff_diff_diff_next = 0;\n    int paren_count_sum_diff_diff_diff_diff_diff_diff\
    \ = 0;\n    int paren_count_sum_diff_diff_diff_diff_diff_diff_prev = 0;\n    int\
    \ paren_count_sum_diff_diff_diff_diff_diff_diff_next = 0;\n    int paren_count_sum_diff_diff_diff_diff_diff_diff_diff\
    \ = 0;\n    int paren_count_sum_diff_diff_diff_diff_diff_diff\nunittest\n{\n \
    \   alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdfgnqy3o.d(41): Error: semicolon expected, not `unittest`

    /tmp/tmpdfgnqy3o.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdfgnqy3o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_paren = 0;\n   \
    \ int close_paren = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            if(open_paren == 0)\n            {\n          \
    \      start = i;\n            }\n            open_paren++;\n        }\n     \
    \   else if(c == ')')\n        {\n            close_paren++;\n            if(open_paren\
    \ == close_paren)\n            {\n                end = i;\n                result\
    \ ~= paren_string[start..end];\n                open_paren = 0;\n            \
    \    close_paren = 0;\n            }\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps3c8yes4.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmps3c8yes4.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps3c8yes4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmna4f07i.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpmna4f07i.__unittest_L38_C1() [0x427d97]

    ??:? void tmpmna4f07i.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            start = end;\n        }\n        else if(c == ')')\n       \
    \ {\n            stack ~= -1;\n            end = end + 1;\n            if(stack.sum\
    \ == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else\n        {\n            end = end + 1;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpki_1m4_w.d(27): Error: no property `sum` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpki_1m4_w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_parens = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            if(open_parens == 0)\n            {\n                start_index\
    \ = i;\n            }\n            open_parens++;\n        }\n        else if(c\
    \ == ')')\n        {\n            open_parens--;\n            if(open_parens ==\
    \ 0)\n            {\n                end_index = i;\n                result ~=\
    \ paren_string[start_index..end_index];\n            }\n        }\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx_08p8dp.d(22): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpx_08p8dp.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_08p8dp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int i, j;\n    int start, end;\n    int count;\n\
    \    int len;\n    int stack_top;\n    int stack_bottom;\n    int stack_size;\n\
    \    int stack_capacity;\n    int stack_capacity_increment;\n    int stack_capacity_max;\n\
    \    int stack_capacity_min;\n    int stack_capacity_threshold;\n    int stack_capacity_threshold_max;\n\
    \    int stack_capacity_threshold_min;\n    int stack_capacity_threshold_increment;\n\
    \    int stack_capacity_threshold_increment_max;\n    int stack_capacity_threshold_increment_min;\n\
    \    int stack_capacity_threshold_increment_threshold;\n    int stack_capacity_threshold_increment_threshold_max;\n\
    \    int stack_capacity_threshold_increment_threshold_min;\n    int stack_capacity_threshold_increment_threshold_increment;\n\
    \    int stack_capacity_threshold_increment_threshold_increment_max;\n    int\
    \ stack_capacity_threshold_increment_threshold_increment_min;\n    int stack_capacity_threshold_increment_threshold_increment_threshold;\n\
    \    int stack_capacity_threshold_increment_threshold_increment_threshold_max;\n\
    \    int stack_capacity_threshold_increment_threshold_increment_threshold_min;\n\
    \    int stack_capacity_threshold_increment_threshold_increment_threshold_increment;\n\
    \    int stack_capacity_threshold_increment_threshold_increment_threshold_increment_max;\n\
    \    int stack_capacity_threshold_increment_threshold_increment_threshold_increment_min;\n\
    \    int stack_capacity_threshold_increment_threshold_increment_threshold_increment_threshold;\n\
    \    int stack_capacity_threshold_increment_threshold_increment_threshold_increment_threshold_max;\n\
    \    int stack_capacity_threshold_increment_threshold_increment_threshold\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzlvtw34a.d(46): Error: semicolon expected, not `unittest`

    /tmp/tmpzlvtw34a.d(46): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzlvtw34a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    // Your\
    \ code here\n    string[] result;\n    int open = 0;\n    int close = 0;\n   \
    \ int start = 0;\n    int end = 0;\n    foreach(i, c; paren_string)\n    {\n \
    \       if(c == '(')\n        {\n            open++;\n            start = i;\n\
    \        }\n        else if(c == ')')\n        {\n            close++;\n     \
    \       end = i;\n        }\n        if(open == close)\n        {\n          \
    \  result ~= paren_string[start..end];\n            open = 0;\n            close\
    \ = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz411owvu.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpz411owvu.d(28): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz411owvu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int[] paren_start;\n    int[] paren_end;\n\
    \    int paren_count_index = 0;\n    int paren_start_index = 0;\n    int paren_end_index\
    \ = 0;\n    int paren_count_size = 0;\n    int paren_start_size = 0;\n    int\
    \ paren_end_size = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int\
    \ l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n   \
    \ int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae\
    \ = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n \
    \   int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an\
    \ = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n \
    \   int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw\
    \ = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n \
    \   int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf\
    \ = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n \
    \   int bk = 0;\n    int bl = 0;\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxr7c4xr9.d(78): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxr7c4xr9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            stack\
    \ ~= i;\n        }\n        else if(c == ')')\n        {\n            if(stack.length\
    \ == 0)\n            {\n                throw new Exception(\"Invalid string\"\
    );\n            }\n            start = stack.pop;\n            end = i;\n    \
    \        result ~= paren_string[start..end];\n        }\n    }\n    if(stack.length\
    \ != 0)\n    {\n        throw new Exception(\"Invalid string\");\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsilmu_g6.d(20): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpsilmu_g6.d(28): Error: no property `pop` for type `int[]`

    /tmp/tmpsilmu_g6.d(29): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsilmu_g6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_count = 0;\n   \
    \ int close_count = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            close_count++;\n        }\n        if(open_count == close_count)\n\
    \        {\n            result ~= paren_string[start..end];\n            start\
    \ = end + 1;\n            open_count = 0;\n            close_count = 0;\n    \
    \    }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt4jerkxo.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpt4jerkxo.__unittest_L38_C1() [0x427d97]

    ??:? void tmpt4jerkxo.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        paren_count++;\n        }\n        else if(c == ')')\n        {\n   \
    \         paren_count--;\n            if(paren_count == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptskjfzxs.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptskjfzxs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int start_index;\n    int end_index;\n\
    \    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int\
    \ o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n\
    \    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int aa;\n   \
    \ int bb;\n    int cc;\n    int dd;\n    int ee;\n    int ff;\n    int gg;\n \
    \   int hh;\n    int ii;\n    int jj;\n    int kk;\n    int ll;\n    int mm;\n\
    \    int nn;\n    int oo;\n    int pp;\n    int qq;\n    int rr;\n    int ss;\n\
    \    int tt;\n    int uu;\n    int vv;\n    int ww;\n    int xx;\n    int yy;\n\
    \    int zz;\n    int aaa;\n    int bbb;\n    int ccc;\n    int ddd;\n    int\
    \ eee;\n    int fff;\n    int ggg;\n    int hhh;\n    int iii;\n    int jjj;\n\
    \    int kkk;\n    int lll;\n    int mmm;\n    int nnn;\n    int ooo;\n    int\
    \ ppp;\n    int qqq;\n    int rrr;\n    int sss;\n    int ttt;\n    int uuu;\n\
    \    int vvv;\n    int www;\n    int xxx;\n    int yyy;\n    int zzz;\n    int\
    \ aaaa;\n    int bbbb;\n    int cccc;\n    int dddd;\n    int eeee;\n    int ffff;\n\
    \    int gggg;\n    int hhhh;\n    int iiii;\n    int jjjj;\n    int kkkk;\n \
    \   int llll;\n    int mmmm;\n    int nnn\nunittest\n{\n    alias candidate =\
    \ separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4lup6o5f.d(100): Error: semicolon expected, not `unittest`

    /tmp/tmp4lup6o5f.d(100): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4lup6o5f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ groups;\n    int start = 0;\n    int end = 0;\n    int open_count = 0;\n   \
    \ int close_count = 0;\n    for(int i = 0; i < paren_string.length; i++)\n   \
    \ {\n        if(paren_string[i] == '(')\n        {\n            open_count++;\n\
    \            if(open_count == 1)\n            {\n                start = i;\n\
    \            }\n        }\n        else if(paren_string[i] == ')')\n        {\n\
    \            close_count++;\n            if(open_count == close_count)\n     \
    \       {\n                end = i;\n                groups ~= paren_string[start..end];\n\
    \                open_count = 0;\n                close_count = 0;\n         \
    \   }\n        }\n    }\n    return groups;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9596pqu9.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ead]

    ??:? void tmp9596pqu9.__unittest_L41_C1() [0x427dbb]

    ??:? void tmp9596pqu9.__modtest() [0x428118]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b095]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b124]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b021]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bdd]

    ??:? runModuleUnitTests [0x42dfbd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429370]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    // TODO:\
    \ implement\n    return null;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv29nh1mq.d(19): unittest failure

    ----------------

    ??:? _d_unittestp [0x428d65]

    ??:? void tmpv29nh1mq.__unittest_L15_C1() [0x427c6f]

    ??:? void tmpv29nh1mq.__modtest() [0x427fcc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d63f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428abe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a4ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a57c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a479]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428a95]

    ??:? runModuleUnitTests [0x42d415]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4291b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int paren_string_length\
    \ = paren_string.length;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee\
    \ = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n \
    \   int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn\
    \ = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n \
    \   int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww\
    \ = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n\
    \    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int\
    \ fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv2dovopm.d(77): Error: semicolon expected, not `unittest`

    /tmp/tmpv2dovopm.d(77): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv2dovopm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  for (int i = 0; i < paren_string.length; i++) \n    {\n        if (paren_string[i]\
    \ == '(') \n        {\n            if (open_parens == 0) \n            {\n   \
    \             start = i;\n            }\n            open_parens++;\n        }\n\
    \        else if (paren_string[i] == ')') \n        {\n            open_parens--;\n\
    \            if (open_parens == 0) \n            {\n                end = i;\n\
    \                result ~= paren_string[start..end];\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd6bkhemq.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmpd6bkhemq.__unittest_L38_C1() [0x427dab]

    ??:? void tmpd6bkhemq.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(char c; paren_string)\n    {\n        if(c == '(')\n        {\n   \
    \         if(paren_count == 0)\n            {\n                start = end;\n\
    \            }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphsyr280z.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmphsyr280z.__unittest_L38_C1() [0x427d93]

    ??:? void tmphsyr280z.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int paren_count_index = 0;\n    int start_index\
    \ = 0;\n    int end_index = 0;\n    int paren_count_length = 0;\n    int paren_count_sum\
    \ = 0;\n    int paren_count_sum_prev = 0;\n    int paren_count_sum_next = 0;\n\
    \    int paren_count_sum_prev_prev = 0;\n    int paren_count_sum_next_next = 0;\n\
    \    int paren_count_sum_prev_prev_prev = 0;\n    int paren_count_sum_next_next_next\
    \ = 0;\n    int paren_count_sum_prev_prev_prev_prev = 0;\n    int paren_count_sum_next_next_next_next\
    \ = 0;\n    int paren_count_sum_prev_prev_prev_prev_prev = 0;\n    int paren_count_sum_next_next_next_next_next\
    \ = 0;\n    int paren_count_sum_prev_prev_prev_prev_prev_prev = 0;\n    int paren_count_sum_next_next_next_next_next_next\
    \ = 0;\n    int paren_count_sum_prev_prev_prev_prev_prev_prev_prev = 0;\n    int\
    \ paren_count_sum_next_next_next_next_next_next_next = 0;\n    int paren_count_sum_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count_sum_next_next_next_next_next_next_next_next = 0;\n\
    \    int paren_count_sum_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n \
    \   int paren_count_sum_next_next_next_next_next_next_next_next_next = 0;\n  \
    \  int paren_count_sum_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n\
    \    int paren_count_sum_next_next\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxl2iro8r.d(39): Error: semicolon expected, not `unittest`

    /tmp/tmpxl2iro8r.d(39): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxl2iro8r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ groups;\n    int start = 0;\n    int end = 0;\n    int depth = 0;\n    int len\
    \ = paren_string.length;\n    for (int i = 0; i < len; i++) \n    {\n        if\
    \ (paren_string[i] == '(') \n        {\n            if (depth == 0) \n       \
    \     {\n                start = i;\n            }\n            depth++;\n   \
    \     }\n        else if (paren_string[i] == ')') \n        {\n            depth--;\n\
    \            if (depth == 0) \n            {\n                end = i;\n     \
    \           groups ~= paren_string[start..end];\n            }\n        }\n  \
    \  }\n    return groups;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppv_j1nv0.d(16): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppv_j1nv0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            start = end;\n        }\n        else if(c == ')')\n       \
    \ {\n            stack ~= -1;\n            end = end + 1;\n            if(stack.sum\
    \ == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else\n        {\n            end = end + 1;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpki_1m4_w.d(27): Error: no property `sum` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpki_1m4_w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int len = paren_string.length;\n    for (int i = 0; i < len; i++)\n\
    \    {\n        if (paren_string[i] == '(')\n        {\n            open++;\n\
    \            if (open == 1)\n            {\n                start = i;\n     \
    \       }\n        }\n        else if (paren_string[i] == ')')\n        {\n  \
    \          close++;\n            if (open == close)\n            {\n         \
    \       end = i;\n                result ~= paren_string[start..end];\n      \
    \          open = 0;\n                close = 0;\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_mure5t3.d(17): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_mure5t3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(char c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            open_parens++;\n        }\n        else if(c\
    \ == ')')\n        {\n            close_parens++;\n        }\n        if(open_parens\
    \ == close_parens)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n            open_parens = 0;\n            close_parens\
    \ = 0;\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps0h8s3gn.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmps0h8s3gn.__unittest_L38_C1() [0x427d97]

    ??:? void tmps0h8s3gn.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open++;\n            if(open == 1)\n            {\n  \
    \              start = i;\n            }\n        }\n        else if(c == ')')\n\
    \        {\n            close++;\n            if(open == close)\n            {\n\
    \                end = i;\n                result ~= paren_string[start..end];\n\
    \                open = 0;\n                close = 0;\n            }\n      \
    \  }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5w3ybpay.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmp5w3ybpay.__unittest_L43_C1() [0x427da7]

    ??:? void tmp5w3ybpay.__modtest() [0x428104]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int paren_count_index = 0;\n    int paren_count_length\
    \ = 0;\n    int paren_count_capacity = 0;\n    int paren_count_capacity_step =\
    \ 10;\n    int paren_count_capacity_max = 100;\n    int paren_count_capacity_min\
    \ = 10;\n    int paren_count_capacity_max_step = 100;\n    int paren_count_capacity_min_step\
    \ = 10;\n    int paren_count_capacity_max_step_step = 10;\n    int paren_count_capacity_min_step_step\
    \ = 10;\n    int paren_count_capacity_max_step_step_step = 10;\n    int paren_count_capacity_min_step_step_step\
    \ = 10;\n    int paren_count_capacity_max_step_step_step_step = 10;\n    int paren_count_capacity_min_step_step_step_step\
    \ = 10;\n    int paren_count_capacity_max_step_step_step_step_step = 10;\n   \
    \ int paren_count_capacity_min_step_step_step_step_step = 10;\n    int paren_count_capacity_max_step_step_step_step_step_step\
    \ = 10;\n    int paren_count_capacity_min_step_step_step_step_step_step = 10;\n\
    \    int paren_count_capacity_max_step_step_step_step_step_step_step = 10;\n \
    \   int paren_count_capacity_min_step_step_step_step_step_step_step = 10;\n  \
    \  int paren_count_capacity_max_step_step_step_step_step_step_step_step = 10;\n\
    \    int paren_count_capacity_min_step_step_step_step_step_step_step_step = 10;\n\
    \    int paren_count_capacity_max_step_step_step_step_step_step_step_step_step\
    \ = 10;\n    int paren_count_capacity_min_step_step_step\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphp19zjla.d(38): Error: semicolon expected, not `unittest`

    /tmp/tmphp19zjla.d(38): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphp19zjla.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_count = 0;\n   \
    \ int close_count = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_count++;\n            if(open_count == 1)\n\
    \            {\n                start = i;\n            }\n        }\n       \
    \ else if(c == ')')\n        {\n            close_count++;\n            if(close_count\
    \ == open_count)\n            {\n                end = i;\n                result\
    \ ~= paren_string[start..end];\n                open_count = 0;\n            \
    \    close_count = 0;\n            }\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy22ra7vn.d(24): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpy22ra7vn.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy22ra7vn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_parens = 0;\n    int start_index = 0;\n    foreach(int\
    \ i, char c; paren_string)\n    {\n        if(c == '(')\n        {\n         \
    \   if(open_parens == 0)\n            {\n                start_index = i;\n  \
    \          }\n            open_parens++;\n        }\n        else if(c == ')')\n\
    \        {\n            open_parens--;\n            if(open_parens == 0)\n   \
    \         {\n                result ~= paren_string[start_index..i];\n       \
    \     }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvmyr5v0e.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e7d]

    ??:? void tmpvmyr5v0e.__unittest_L36_C1() [0x427d87]

    ??:? void tmpvmyr5v0e.__modtest() [0x4280e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b065]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bad]

    ??:? runModuleUnitTests [0x42df8d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429340]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n\
    \    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n\
    \    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n\
    \    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc\
    \ = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n \
    \   int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll\
    \ = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n \
    \   int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu\
    \ = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy = 0;\n \
    \   int zz = 0;\n    int aaa = 0;\n    int bbb = 0;\n    int ccc = 0;\n    int\
    \ ddd = 0;\n    int eee = 0;\n    int fff = 0;\n    int ggg = 0;\n    int hhh\
    \ = 0;\n    int iii = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int lll = 0;\n\
    \    int mmm = 0;\n    int nnn = 0;\n    int ooo = 0;\n    int ppp = 0;\n    int\
    \ qqq = 0;\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnf5eaox8.d(78): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnf5eaox8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  for (int i = 0; i < paren_string.length; i++) \n    {\n        if (paren_string[i]\
    \ == '(') \n        {\n            if (paren_count == 0) \n            {\n   \
    \             start = i;\n            }\n            paren_count++;\n        }\n\
    \        else if (paren_string[i] == ')') \n        {\n            paren_count--;\n\
    \            if (paren_count == 0) \n            {\n                end = i;\n\
    \                result ~= paren_string[start..end];\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphbli7au3.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmphbli7au3.__unittest_L38_C1() [0x427dab]

    ??:? void tmphbli7au3.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_paren = 0;\n   \
    \ foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n         \
    \   if(open_paren == 0)\n            {\n                start = end;\n       \
    \     }\n            open_paren++;\n        }\n        else if(c == ')')\n   \
    \     {\n            open_paren--;\n            if(open_paren == 0)\n        \
    \    {\n                result ~= paren_string[start..end];\n            }\n \
    \       }\n        else if(c == ' ')\n        {\n            //ignore\n      \
    \  }\n        else\n        {\n            assert(false, \"Invalid character\"\
    );\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpshx1cl_g.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmpshx1cl_g.__unittest_L46_C1() [0x427dff]

    ??:? void tmpshx1cl_g.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_positions;\n    int[] close_paren_positions;\n\
    \    int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n   \
    \ int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad\
    \ = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n \
    \   int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am\
    \ = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n \
    \   int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av\
    \ = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n \
    \   int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be\
    \ = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n \
    \   int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn\
    \ = 0;\n    int bo = 0;\n    int bp = 0;\n   \nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpknhcb5f8.d(80): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpknhcb5f8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_paren = 0;\n   \
    \ int close_paren = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open_paren++;\n        }\n        else if(c == ')')\n\
    \        {\n            close_paren++;\n        }\n        if(open_paren == close_paren)\n\
    \        {\n            if(open_paren != 0)\n            {\n                result\
    \ ~= paren_string[start..end];\n                start = end + 1;\n           \
    \     open_paren = 0;\n                close_paren = 0;\n            }\n     \
    \   }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkka73pzh.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpkka73pzh.__unittest_L41_C1() [0x427da3]

    ??:? void tmpkka73pzh.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int paren_string_length = paren_string.length;\n\
    \    int paren_string_index = 0;\n    int paren_group_count = 0;\n    int paren_group_length\
    \ = 0;\n    int paren_group_start_index = 0;\n    int paren_group_end_index =\
    \ 0;\n    int paren_group_index = 0;\n    int paren_group_index_2 = 0;\n    string\
    \ paren_group;\n    // Find the number of open and close parentheses in the string\n\
    \    for (; paren_string_index < paren_string_length; paren_string_index++) \n\
    \    {\n        if (paren_string[paren_string_index] == '(') \n        {\n   \
    \         open_paren_count++;\n        }\n        else if (paren_string[paren_string_index]\
    \ == ')') \n        {\n            close_paren_count++;\n        }\n    }\n  \
    \  // If the number of open and close parentheses are not equal, then the string\
    \ is not balanced\n    if (open_paren_count != close_paren_count) \n    {\n  \
    \      return result;\n    }\n    // Find the indexes of the open and close parentheses\
    \ in the string\n    open_paren_indexes = new int[open_paren_count];\n    close_paren_indexes\
    \ = new int[close_paren_count];\n    open_paren_count = 0;\n    close_paren_count\
    \ = 0;\n    for (paren_string_index = 0; paren_string_index < paren_string_length;\
    \ paren_string_index++) \n    {\n        if (paren_string[paren_string_index]\
    \ == '(') \n        {\n            open_paren_indexes[open_paren_count] = paren_string_index;\n\
    \            open_paren_count\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpty3yzw9v.d(56): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpty3yzw9v.d(65): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpty3yzw9v.d(65): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpty3yzw9v.d(65): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpty3yzw9v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            start = end;\n        }\n        else if(c == ')')\n       \
    \ {\n            stack.popBack();\n            if(stack.length == 0)\n       \
    \     {\n                result ~= paren_string[start..end];\n            }\n\
    \        }\n        else if(c == ' ')\n        {\n            continue;\n    \
    \    }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu8u3swku.d(25): Error: no property `popBack` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8u3swku.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae\
    \ = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n \
    \   int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an\
    \ = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n \
    \   int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw\
    \ = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n \
    \   int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf\
    \ = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n \
    \   int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo\
    \ = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n \
    \   int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx\
    \ = 0;\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv9hxfmty.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv9hxfmty.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    int j = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            open++;\n        }\n        else\
    \ if(c == ')')\n        {\n            close++;\n        }\n        if(open ==\
    \ close)\n        {\n            end = i;\n            result ~= paren_string[start..end];\n\
    \            start = i + 1;\n            open = 0;\n            close = 0;\n \
    \       }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkmtrm_5p.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpkmtrm_5p.__unittest_L41_C1() [0x427d97]

    ??:? void tmpkmtrm_5p.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int i;\n    int j;\n    int k;\n    int\
    \ start;\n    int end;\n    int len;\n    int count;\n    int paren_start;\n \
    \   int paren_end;\n    int paren_len;\n    int paren_count_len;\n    int paren_count_start;\n\
    \    int paren_count_end;\n    int paren_count_len_2;\n    int paren_count_start_2;\n\
    \    int paren_count_end_2;\n    int paren_count_len_3;\n    int paren_count_start_3;\n\
    \    int paren_count_end_3;\n    int paren_count_len_4;\n    int paren_count_start_4;\n\
    \    int paren_count_end_4;\n    int paren_count_len_5;\n    int paren_count_start_5;\n\
    \    int paren_count_end_5;\n    int paren_count_len_6;\n    int paren_count_start_6;\n\
    \    int paren_count_end_6;\n    int paren_count_len_7;\n    int paren_count_start_7;\n\
    \    int paren_count_end_7;\n    int paren_count_len_8;\n    int paren_count_start_8;\n\
    \    int paren_count_end_8;\n    int paren_count_len_9;\n    int paren_count_start_9;\n\
    \    int paren_count_end_9;\n    int paren_count_len_10;\n    int paren_count_start_10;\n\
    \    int paren_count_end_10;\n    int paren_count_len_11;\n    int paren_count_start_11;\n\
    \    int paren_count_end_11;\n    int paren_count_len_12;\n    int paren_count_start_12;\n\
    \    int paren_count_end_12;\n    int paren_count_len_\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpinmhykfj.d(61): Error: semicolon expected, not `unittest`

    /tmp/tmpinmhykfj.d(61): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpinmhykfj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(open_paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        open_paren_count++;\n        }\n        else if(c == ')')\n        {\n\
    \            open_paren_count--;\n            if(open_paren_count == 0)\n    \
    \        {\n                result ~= paren_string[start_index..i];\n        \
    \    }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbufzp8j_.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbufzp8j_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        else if(c == ' ')\n        {\n            // do nothing\n\
    \        }\n        else\n        {\n            assert(false, \"Invalid character\
    \ in input string\");\n        }\n        end++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphv3pnj3x.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmphv3pnj3x.__unittest_L46_C1() [0x427dff]

    ??:? void tmphv3pnj3x.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int paren_count_index = 0;\n    int paren_count_length\
    \ = 0;\n    int paren_count_capacity = 0;\n    int paren_count_capacity_increment\
    \ = 10;\n    int paren_count_capacity_max = 100;\n    int paren_count_capacity_min\
    \ = 10;\n    int paren_count_capacity_new = 0;\n    int paren_count_capacity_old\
    \ = 0;\n    int paren_count_capacity_delta = 0;\n    int paren_count_capacity_delta_max\
    \ = 10;\n    int paren_count_capacity_delta_min = 1;\n    int paren_count_capacity_delta_new\
    \ = 0;\n    int paren_count_capacity_delta_old = 0;\n    int paren_count_capacity_delta_delta\
    \ = 0;\n    int paren_count_capacity_delta_delta_max = 10;\n    int paren_count_capacity_delta_delta_min\
    \ = 1;\n    int paren_count_capacity_delta_delta_new = 0;\n    int paren_count_capacity_delta_delta_old\
    \ = 0;\n    int paren_count_capacity_delta_delta_delta = 0;\n    int paren_count_capacity_delta_delta_delta_max\
    \ = 10;\n    int paren_count_capacity_delta_delta_delta_min = 1;\n    int paren_count_capacity_delta_delta_delta_new\
    \ = 0;\n    int paren_count_capacity_delta_delta_delta_old = 0;\n    int paren_count_capacity_delta_delta_delta_delta\
    \ = 0;\n    int paren_count_capacity_delta_delta_delta_delta_max = 10;\n    int\
    \ paren_count_capacity_delta_delta_delta_delta_min = 1;\n    int paren_count_capacity_delta_delta_delta\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprn0_cghw.d(41): Error: semicolon expected, not `unittest`

    /tmp/tmprn0_cghw.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprn0_cghw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    int paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            if(paren_count == 0)\n            {\n                start_index\
    \ = i;\n            }\n            paren_count++;\n        }\n        else if(c\
    \ == ')')\n        {\n            paren_count--;\n            if(paren_count ==\
    \ 0)\n            {\n                end_index = i;\n                paren_groups\
    \ ~= paren_string[start_index..end_index];\n            }\n        }\n    }\n\
    \    return paren_groups;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl4uresk2.d(22): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpl4uresk2.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl4uresk2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string current_group;\n    int open_paren_count = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            open_paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')') \n    \
    \    {\n            open_paren_count--;\n            current_group ~= c;\n   \
    \         if(open_paren_count == 0) \n            {\n                result ~=\
    \ current_group;\n                current_group = \"\";\n            }\n     \
    \   }\n        else if(c != ' ') \n        {\n            current_group ~= c;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Given a string containing a\
    \ list of integers separated by commas, return the sum of those integers.\n  \
    \  Ignore any spaces in the input string.\n*/\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto result\
    \ = new string[];\n    string temp;\n    int open_paren_count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            open_paren_count++;\n\
    \            temp ~= c;\n        }\n        else if(c == ')')\n        {\n   \
    \         open_paren_count--;\n            temp ~= c;\n            if(open_paren_count\
    \ == 0)\n            {\n                result ~= temp;\n                temp\
    \ = \"\";\n            }\n        }\n        else if(c != ' ')\n        {\n  \
    \          temp ~= c;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzsg3kosg.d(12): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzsg3kosg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    string current_group = \"\";\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(char c; paren_string)\n    {\n        if(c == '(')\n     \
    \   {\n            open_paren_count++;\n            if(open_paren_count == 1)\n\
    \            {\n                start_index = end_index;\n            }\n    \
    \    }\n        else if(c == ')')\n        {\n            open_paren_count--;\n\
    \            if(open_paren_count == 0)\n            {\n                result\
    \ ~= paren_string[start_index..end_index];\n            }\n        }\n       \
    \ end_index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppf8dn2cr.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmppf8dn2cr.__unittest_L38_C1() [0x427d97]

    ??:? void tmppf8dn2cr.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    int start = 0;\n    int end = 0;\n    int paren_count\
    \ = 0;\n    while(i < paren_string.length)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            if(paren_count == 0)\n            {\n      \
    \          start = i;\n            }\n            paren_count++;\n        }\n\
    \        else if(paren_string[i] == ')')\n        {\n            paren_count--;\n\
    \            if(paren_count == 0)\n            {\n                end = i;\n \
    \               result ~= paren_string[start..end];\n            }\n        }\n\
    \        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpddxvq_a8.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmpddxvq_a8.__unittest_L40_C1() [0x427dab]

    ??:? void tmpddxvq_a8.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    int i =\
    \ 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n \
    \           stack ~= i;\n        }\n        else if(c == ')')\n        {\n   \
    \         if(stack.length == 0)\n            {\n                throw new Exception(\"\
    Unbalanced parentheses\");\n            }\n            else\n            {\n \
    \               stack.length--;\n                if(stack.length == 0)\n     \
    \           {\n                    end = i;\n                    result ~= paren_string[start..end];\n\
    \                    start = end + 1;\n                }\n            }\n    \
    \    }\n        i++;\n    }\n    if(stack.length != 0)\n    {\n        throw new\
    \ Exception(\"Unbalanced parentheses\");\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcqc5b7bz.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x429325]

    ??:? void tmpcqc5b7bz.__unittest_L48_C1() [0x42819b]

    ??:? void tmpcqc5b7bz.__modtest() [0x4284f8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42fa0f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428fe6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c5dd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c66c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c569]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fbd]

    ??:? runModuleUnitTests [0x42f7e5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4297e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int i;\n    int j;\n    int k;\n    int l;\n\
    \    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int\
    \ s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n\
    \    int z;\n    int aa;\n    int bb;\n    int cc;\n    int dd;\n    int ee;\n\
    \    int ff;\n    int gg;\n    int hh;\n    int ii;\n    int jj;\n    int kk;\n\
    \    int ll;\n    int mm;\n    int nn;\n    int oo;\n    int pp;\n    int qq;\n\
    \    int rr;\n    int ss;\n    int tt;\n    int uu;\n    int vv;\n    int ww;\n\
    \    int xx;\n    int yy;\n    int zz;\n    int aaa;\n    int bbb;\n    int ccc;\n\
    \    int ddd;\n    int eee;\n    int fff;\n    int ggg;\n    int hhh;\n    int\
    \ iii;\n    int jjj;\n    int kkk;\n    int lll;\n    int mmm;\n    int nnn;\n\
    \    int ooo;\n    int ppp;\n    int qqq;\n    int rrr;\n    int sss;\n    int\
    \ ttt;\n    int uuu;\n    int vvv;\n    int www;\n    int xxx;\n    int yyy;\n\
    \    int zzz;\n    int aaaa;\n    int bbbb;\n    int cccc;\n    int dddd;\n  \
    \  int eeee;\n    int ffff;\n    int gggg;\n    int hhhh;\n    int iiii;\n   \
    \ int jjjj;\n    int kkkk;\n    int llll;\n    int mmmm;\n    int nnnn;\n    int\
    \ oooo;\n    int pppp;\n   \nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_pk28cn8.d(101): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_pk28cn8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int len = paren_string.length;\n    for (int i = 0; i < len; i++)\n\
    \    {\n        if (paren_string[i] == '(')\n        {\n            open++;\n\
    \            if (open == 1)\n            {\n                start = i;\n     \
    \       }\n        }\n        else if (paren_string[i] == ')')\n        {\n  \
    \          close++;\n            if (open == close)\n            {\n         \
    \       end = i;\n                result ~= paren_string[start..end];\n      \
    \          open = 0;\n                close = 0;\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_mure5t3.d(17): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_mure5t3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            if(paren_count == 0)\n            {\n                start_index\
    \ = end_index;\n            }\n            paren_count++;\n        }\n       \
    \ else if(c == ')')\n        {\n            paren_count--;\n            if(paren_count\
    \ == 0)\n            {\n                result ~= paren_string[start_index..end_index];\n\
    \            }\n        }\n        end_index++;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbs7a2vw2.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpbs7a2vw2.__unittest_L38_C1() [0x427d93]

    ??:? void tmpbs7a2vw2.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string current_group;\n    int paren_count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_top = 0;\n    int start = 0;\n    int\
    \ end = 0;\n    int i = 0;\n    int len = paren_string.length;\n    while (i <\
    \ len)\n    {\n        if (paren_string[i] == '(')\n        {\n            stack[stack_top++]\
    \ = i;\n        }\n        else if (paren_string[i] == ')')\n        {\n     \
    \       start = stack[--stack_top];\n            end = i;\n            result\
    \ ~= paren_string[start..end];\n        }\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxl3jwd_a.d(18): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxl3jwd_a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_index = 0;\n    int start_index = 0;\n\
    \    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n        {\n   \
    \         stack[stack_index] = i;\n            stack_index++;\n        }\n   \
    \     else if(c == ')')\n        {\n            stack_index--;\n            if(stack_index\
    \ == 0)\n            {\n                result ~= paren_string[start_index..i];\n\
    \                start_index = i + 1;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa58d3hfh.d(20): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpa58d3hfh.d(29): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa58d3hfh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        else if(c == ' ')\n        {\n            //ignore\n \
    \       }\n        else\n        {\n            assert(false, \"Invalid character\"\
    );\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzrqa4o2y.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmpzrqa4o2y.__unittest_L46_C1() [0x427dff]

    ??:? void tmpzrqa4o2y.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open++;\n            if(open == 1)\n            {\n  \
    \              start = i;\n            }\n        }\n        else if(c == ')')\n\
    \        {\n            close++;\n            if(open == close)\n            {\n\
    \                end = i;\n                result ~= paren_string[start..end];\n\
    \                open = 0;\n                close = 0;\n            }\n      \
    \  }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5w3ybpay.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmp5w3ybpay.__unittest_L43_C1() [0x427da7]

    ??:? void tmp5w3ybpay.__modtest() [0x428104]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        paren_count++;\n        }\n        else if(c == ')')\n        {\n   \
    \         paren_count--;\n            if(paren_count == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptskjfzxs.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptskjfzxs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    int len\
    \ = paren_string.length;\n    foreach(i; 0..len)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            if(count == 0)\n            {\n            \
    \    start = i;\n            }\n            count++;\n        }\n        else\
    \ if(paren_string[i] == ')')\n        {\n            count--;\n            if(count\
    \ == 0)\n            {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxuozm2s6.d(16): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxuozm2s6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            if(open_parens == 0)\n            {\n         \
    \       start = end;\n            }\n            open_parens++;\n        }\n \
    \       else if(c == ')')\n        {\n            close_parens++;\n          \
    \  if(open_parens == close_parens)\n            {\n                result ~= paren_string[start..end];\n\
    \                open_parens = 0;\n                close_parens = 0;\n       \
    \     }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2pj5cpj6.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmp2pj5cpj6.__unittest_L41_C1() [0x427d9f]

    ??:? void tmp2pj5cpj6.__modtest() [0x4280fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start_index = 0;\n    int end_index = 0;\n    int open_paren_count\
    \ = 0;\n    int close_paren_count = 0;\n    foreach(char c; paren_string)\n  \
    \  {\n        if(c == '(')\n        {\n            open_paren_count++;\n     \
    \   }\n        else if(c == ')')\n        {\n            close_paren_count++;\n\
    \        }\n        if(open_paren_count == close_paren_count)\n        {\n   \
    \         end_index = c;\n            result ~= paren_string[start_index..end_index];\n\
    \            start_index = end_index + 1;\n            open_paren_count = 0;\n\
    \            close_paren_count = 0;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpc7wjo73y.d(30): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f3e]

    ??:? immutable(char)[][] tmpc7wjo73y.separate_paren_groups(immutable(char)[])
    [0x427c38]

    ??:? void tmpc7wjo73y.__unittest_L38_C1() [0x427cd9]

    ??:? void tmpc7wjo73y.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            if(open == 0)\n            {\n                start =\
    \ i;\n            }\n            open++;\n        }\n        else if(c == ')')\n\
    \        {\n            close++;\n            if(open == close)\n            {\n\
    \                end = i;\n                result ~= paren_string[start..end];\n\
    \                open = 0;\n                close = 0;\n            }\n      \
    \  }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpprftf8g0.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpprftf8g0.__unittest_L43_C1() [0x427da3]

    ??:? void tmpprftf8g0.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else if(c == ' ')\n        {\n            //\
    \ do nothing\n        }\n        else\n        {\n            assert(false, \"\
    Invalid character\");\n        }\n        end++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0pe_ebmx.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmp0pe_ebmx.__unittest_L46_C1() [0x427dff]

    ??:? void tmp0pe_ebmx.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    int paren_count = 0;\n    string current_paren_group = \"\
    \";\n    foreach(char c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            paren_count++;\n            current_paren_group ~= c;\n        }\n\
    \        else if(c == ')')\n        {\n            paren_count--;\n          \
    \  current_paren_group ~= c;\n            if(paren_count == 0)\n            {\n\
    \                paren_groups ~= current_paren_group;\n                current_paren_group\
    \ = \"\";\n            }\n        }\n        else if(c != ' ')\n        {\n  \
    \          current_paren_group ~= c;\n        }\n    }\n    return paren_groups;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    for (int i = 0; i < paren_string.length; i++)\n\
    \    {\n        if (paren_string[i] == '(')\n        {\n            if (open_parens\
    \ == 0)\n            {\n                start = i;\n            }\n          \
    \  open_parens++;\n        }\n        else if (paren_string[i] == ')')\n     \
    \   {\n            close_parens++;\n            if (open_parens == close_parens)\n\
    \            {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \                open_parens = 0;\n                close_parens = 0;\n       \
    \     }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppunpn34s.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ead]

    ??:? void tmppunpn34s.__unittest_L41_C1() [0x427db7]

    ??:? void tmppunpn34s.__modtest() [0x428114]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b095]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b124]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b021]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bdd]

    ??:? runModuleUnitTests [0x42dfbd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429370]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    string current_group = \"\";\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto result\
    \ = new string[];\n    auto current_group = new string;\n    auto open_parens\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open_parens++;\n            current_group ~= c;\n        }\n    \
    \    else if(c == ')')\n        {\n            open_parens--;\n            current_group\
    \ ~= c;\n            if(open_parens == 0)\n            {\n                result\
    \ ~= current_group;\n                current_group = new string;\n           \
    \ }\n        }\n        else if(c != ' ')\n        {\n            current_group\
    \ ~= c;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfwnm7qf9.d(12): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpfwnm7qf9.d(13): Error: new can only create structs, dynamic arrays or
    class objects, not `string`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfwnm7qf9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(open_paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        open_paren_count++;\n        }\n        else if(c == ')')\n        {\n\
    \            open_paren_count--;\n            if(open_paren_count == 0)\n    \
    \        {\n                result ~= paren_string[start_index..i];\n        \
    \    }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbufzp8j_.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbufzp8j_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            open_paren_count++;\n            if(open_paren_count == 1)\n\
    \            {\n                start_index = i;\n            }\n        }\n \
    \       else if(c == ')')\n        {\n            open_paren_count--;\n      \
    \      if(open_paren_count == 0)\n            {\n                end_index = i;\n\
    \                result ~= paren_string[start_index..end_index];\n           \
    \ }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkk6niwit.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpkk6niwit.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkk6niwit.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string) \n    {\n        if(c == '(') \n        {\n            if(paren_count\
    \ == 0) \n            {\n                start_index = i;\n            }\n   \
    \         paren_count++;\n        }\n        else if(c == ')') \n        {\n \
    \           paren_count--;\n            if(paren_count == 0) \n            {\n\
    \                result ~= paren_string[start_index..i];\n            }\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplhe_8_xs.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplhe_8_xs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n            if(open == 1)\n            {\n             \
    \   start = end;\n            }\n        }\n        else if(c == ')')\n      \
    \  {\n            close++;\n            if(open == close)\n            {\n   \
    \             result ~= paren_string[start..end];\n                open = 0;\n\
    \                close = 0;\n            }\n        }\n        end++;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr95n5ti5.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpr95n5ti5.__unittest_L41_C1() [0x427da3]

    ??:? void tmpr95n5ti5.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start_index = 0;\n    int end_index = 0;\n    int paren_count\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            if(paren_count == 0)\n            {\n                start_index\
    \ = end_index;\n            }\n            paren_count++;\n        }\n       \
    \ else if(c == ')')\n        {\n            paren_count--;\n            if(paren_count\
    \ == 0)\n            {\n                result ~= paren_string[start_index..end_index];\n\
    \            }\n        }\n        end_index++;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6kuop52x.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6kuop52x.__unittest_L38_C1() [0x427d93]

    ??:? void tmp6kuop52x.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            open++;\n            if(open == 1)\n            {\n         \
    \       start = i;\n            }\n        }\n        else if(c == ')')\n    \
    \    {\n            close++;\n            if(open == close)\n            {\n \
    \               end = i;\n                result ~= paren_string[start..end];\n\
    \                open = 0;\n                close = 0;\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwkv3kksr.d(24): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpwkv3kksr.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwkv3kksr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_parens++;\n            if(open_parens == 1)\n\
    \            {\n                start = end;\n            }\n        }\n     \
    \   else if(c == ')')\n        {\n            close_parens++;\n            if(open_parens\
    \ == close_parens)\n            {\n                result ~= paren_string[start..end];\n\
    \                open_parens = 0;\n                close_parens = 0;\n       \
    \     }\n        }\n        else if(c == ' ')\n        {\n            //ignore\n\
    \        }\n        else\n        {\n            assert(false, \"Invalid character\"\
    );\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpek7xnr3u.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fcd]

    ??:? void tmpek7xnr3u.__unittest_L49_C1() [0x427e0b]

    ??:? void tmpek7xnr3u.__modtest() [0x428168]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e307]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b244]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b141]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c2d]

    ??:? runModuleUnitTests [0x42e0dd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429490]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string current_group;\n    int paren_count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\n/*\n    Given a string containing a list of numbers separated\
    \ by spaces, return the sum of those numbers.\n    Ignore any spaces in the input\
    \ string.\n*/\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_parens = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(open_parens\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        open_parens++;\n        }\n        else if(c == ')')\n        {\n   \
    \         open_parens--;\n            if(open_parens == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp04ld50d7.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp04ld50d7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else if(c == ' ')\n        {\n            continue;\n\
    \        }\n        else\n        {\n            assert(false, \"Invalid character\"\
    );\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppmw8rhv_.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmppmw8rhv_.__unittest_L46_C1() [0x427dff]

    ??:? void tmppmw8rhv_.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int\
    \ m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n   \
    \ int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n   \nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpclkpmlcy.d(83): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpclkpmlcy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        paren_count++;\n        }\n        else if(c == ')')\n        {\n   \
    \         paren_count--;\n            if(paren_count == 0)\n            {\n  \
    \              paren_groups ~= paren_string[start_index..i];\n            }\n\
    \        }\n    }\n    return paren_groups;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd2m4yr6p.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2m4yr6p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = i;\n            }\n          \
    \  count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                end = i;\n       \
    \         result ~= paren_string[start..end];\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1xl0pjt9.d(22): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmp1xl0pjt9.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1xl0pjt9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int paren_group_index = 0;\n    int\
    \ paren_group_start = 0;\n    int paren_group_end = 0;\n    int paren_group_length\
    \ = 0;\n    string paren_group;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae\
    \ = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n \
    \   int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an\
    \ = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n \
    \   int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw\
    \ = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n \
    \   int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf\
    \ = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw1o17k7e.d(77): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw1o17k7e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start_index = 0;\n    int end_index = 0;\n    int open_paren_count\
    \ = 0;\n    int close_paren_count = 0;\n    foreach(char c; paren_string)\n  \
    \  {\n        if(c == '(')\n        {\n            open_paren_count++;\n     \
    \   }\n        else if(c == ')')\n        {\n            close_paren_count++;\n\
    \        }\n        if(open_paren_count == close_paren_count)\n        {\n   \
    \         end_index = c;\n            result ~= paren_string[start_index..end_index];\n\
    \            start_index = end_index + 1;\n            open_paren_count = 0;\n\
    \            close_paren_count = 0;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpc7wjo73y.d(30): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f3e]

    ??:? immutable(char)[][] tmpc7wjo73y.separate_paren_groups(immutable(char)[])
    [0x427c38]

    ??:? void tmpc7wjo73y.__unittest_L38_C1() [0x427cd9]

    ??:? void tmpc7wjo73y.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660164045
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    string current_group = \"\";\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        else if(c == ' ')\n        {\n            // ignore\n\
    \        }\n        else\n        {\n            assert(false, \"Invalid character\
    \ in input string\");\n        }\n        end++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9bfwzi1d.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmp9bfwzi1d.__unittest_L46_C1() [0x427dff]

    ??:? void tmp9bfwzi1d.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(char c; paren_string)\n    {\n        if(c == '(')\n     \
    \   {\n            open_paren_count++;\n            if(open_paren_count == 1)\n\
    \            {\n                start_index = end_index;\n            }\n    \
    \    }\n        else if(c == ')')\n        {\n            open_paren_count--;\n\
    \            if(open_paren_count == 0)\n            {\n                result\
    \ ~= paren_string[start_index..end_index];\n            }\n        }\n       \
    \ end_index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppf8dn2cr.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmppf8dn2cr.__unittest_L38_C1() [0x427d97]

    ??:? void tmppf8dn2cr.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            start = end;\n        }\n        else if(c == ')')\n       \
    \ {\n            stack ~= -1;\n            end = end + 1;\n            if(stack.sum\
    \ == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else\n        {\n            end = end + 1;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpki_1m4_w.d(27): Error: no property `sum` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpki_1m4_w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    int i = 0;\n    foreach(char c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_parens++;\n        \
    \    if(open_parens == 1)\n            {\n                start = i;\n       \
    \     }\n        }\n        else if(c == ')')\n        {\n            close_parens++;\n\
    \            if(close_parens == open_parens)\n            {\n                end\
    \ = i;\n                result ~= paren_string[start..end];\n                open_parens\
    \ = 0;\n                close_parens = 0;\n            }\n        }\n        i++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdnnhdi1_.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmpdnnhdi1_.__unittest_L43_C1() [0x427da7]

    ??:? void tmpdnnhdi1_.__modtest() [0x428104]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    int start = 0;\n    int end = 0;\n    int count\
    \ = 0;\n    while(i < paren_string.length)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            count++;\n            if(count == 1)\n     \
    \       {\n                start = i;\n            }\n        }\n        else\
    \ if(paren_string[i] == ')')\n        {\n            count--;\n            if(count\
    \ == 0)\n            {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvn98dak4.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ea5]

    ??:? void tmpvn98dak4.__unittest_L40_C1() [0x427daf]

    ??:? void tmpvn98dak4.__modtest() [0x42810c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bfe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b08d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b11c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b019]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bd5]

    ??:? runModuleUnitTests [0x42dfb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429368]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        paren_count++;\n        }\n        else if(c == ')')\n        {\n   \
    \         paren_count--;\n            if(paren_count == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptskjfzxs.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptskjfzxs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_parens++;\n            if(open_parens == 1)\n\
    \            {\n                start = end;\n            }\n        }\n     \
    \   else if(c == ')')\n        {\n            close_parens++;\n            if(open_parens\
    \ == close_parens)\n            {\n                result ~= paren_string[start..end];\n\
    \                open_parens = 0;\n                close_parens = 0;\n       \
    \     }\n        }\n        else if(c == ' ')\n        {\n            //do nothing\n\
    \        }\n        else\n        {\n            assert(false, \"Invalid input\"\
    );\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv3o0pl75.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fcd]

    ??:? void tmpv3o0pl75.__unittest_L49_C1() [0x427e0b]

    ??:? void tmpv3o0pl75.__modtest() [0x428168]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e307]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b244]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b141]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c2d]

    ??:? runModuleUnitTests [0x42e0dd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429490]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    string current_group = \"\";\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open++;\n            if(open == 1)\n            {\n  \
    \              start = i;\n            }\n        }\n        else if(c == ')')\n\
    \        {\n            close++;\n            if(open == close)\n            {\n\
    \                end = i;\n                result ~= paren_string[start..end];\n\
    \                open = 0;\n                close = 0;\n            }\n      \
    \  }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5w3ybpay.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmp5w3ybpay.__unittest_L43_C1() [0x427da7]

    ??:? void tmp5w3ybpay.__modtest() [0x428104]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto result\
    \ = new string[];\n    auto paren_stack = new Stack!(char[])();\n    auto current_group\
    \ = new char[];\n    foreach(c; paren_string) \n    {\n        if(c == '(') \n\
    \        {\n            paren_stack.push(current_group);\n            current_group\
    \ = new char[];\n        }\n        else if(c == ')') \n        {\n          \
    \  if(paren_stack.empty)\n                throw new Exception(\"Unbalanced parentheses\"\
    );\n            auto prev_group = paren_stack.pop;\n            prev_group ~=\
    \ current_group;\n            current_group = prev_group;\n        }\n       \
    \ else if(c != ' ')\n            current_group ~= c;\n    }\n    if(!paren_stack.empty)\n\
    \        throw new Exception(\"Unbalanced parentheses\");\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf50jkczd.d(12): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpf50jkczd.d(13): Error: template instance `Stack!(char[])` template `Stack`
    is not defined

    /tmp/tmpf50jkczd.d(14): Error: new can only create structs, dynamic arrays or
    class objects, not `char[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf50jkczd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n            if(open == 1)\n            {\n             \
    \   start = end;\n            }\n        }\n        else if(c == ')')\n      \
    \  {\n            close++;\n            if(open == close)\n            {\n   \
    \             result ~= paren_string[start..end];\n                open = 0;\n\
    \                close = 0;\n            }\n        }\n        end++;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr95n5ti5.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpr95n5ti5.__unittest_L41_C1() [0x427da3]

    ??:? void tmpr95n5ti5.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        paren_count++;\n        }\n        else if(c == ')')\n        {\n   \
    \         paren_count--;\n            if(paren_count == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptskjfzxs.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptskjfzxs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwavqnyt.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzwavqnyt.__unittest_L38_C1() [0x427d93]

    ??:? void tmpzwavqnyt.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4292cf]

    ??:? _d_run_main [0x42923a]

    ??:? main [0x428103]

    ??:? __libc_start_main [0x4ec08554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    count++;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            if(count == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else if(c == ' ')\n        {\n            continue;\n\
    \        }\n        else\n        {\n            assert(false, \"Invalid character\"\
    );\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppmw8rhv_.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmppmw8rhv_.__unittest_L46_C1() [0x427dff]

    ??:? void tmppmw8rhv_.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.range;\n    import std.stdio;\n\
    \    import std.string;\n    import std.typecons;\n    import std.math;\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ int start_index = 0;\n    int end_index = 0;\n    foreach(i, c; paren_string)\
    \ \n    {\n        if(c == '(') \n        {\n            open_paren_count++;\n\
    \            if(open_paren_count == 1) \n            {\n                start_index\
    \ = i;\n            }\n        }\n        else if(c == ')') \n        {\n    \
    \        close_paren_count++;\n            if(close_paren_count == open_paren_count)\
    \ \n            {\n                end_index = i;\n                result ~= paren_string[start_index..end_index\
    \ + 1];\n                open_paren_count = 0;\n                close_paren_count\
    \ = 0;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn0g626dn.d(31): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpn0g626dn.d(39): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn0g626dn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            open_parens++;\n        }\n    \
    \    else if(c == ')')\n        {\n            close_parens++;\n        }\n  \
    \      if(open_parens == close_parens)\n        {\n            if(open_parens\
    \ != 0)\n            {\n                result ~= paren_string[start..end];\n\
    \                open_parens = 0;\n                close_parens = 0;\n       \
    \         start = i + 1;\n            }\n        }\n        end = i;\n       \
    \ i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpysoea_nn.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ea5]

    ??:? void tmpysoea_nn.__unittest_L43_C1() [0x427daf]

    ??:? void tmpysoea_nn.__modtest() [0x42810c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bfe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b08d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b11c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b019]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bd5]

    ??:? runModuleUnitTests [0x42dfb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429368]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp96y0qbsx.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp96y0qbsx.__unittest_L38_C1() [0x427d93]

    ??:? void tmp96y0qbsx.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int level = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(level\
    \ == 0)\n                start = end;\n            level++;\n        }\n     \
    \   else if(c == ')')\n        {\n            level--;\n            if(level ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ else if(c == ' ')\n        {\n            // do nothing\n        }\n       \
    \ else\n        {\n            assert(false, \"Invalid character in input string\"\
    );\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphtois6bm.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x428fc5]

    ??:? void tmphtois6bm.__unittest_L42_C1() [0x427dff]

    ??:? void tmphtois6bm.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b1ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b23c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b139]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c25]

    ??:? runModuleUnitTests [0x42e0d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429488]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp96y0qbsx.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp96y0qbsx.__unittest_L38_C1() [0x427d93]

    ??:? void tmp96y0qbsx.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n            if(open == 1)\n            {\n             \
    \   start = end;\n            }\n        }\n        else if(c == ')')\n      \
    \  {\n            close++;\n            if(open == close)\n            {\n   \
    \             result ~= paren_string[start..end];\n                open = 0;\n\
    \                close = 0;\n            }\n        }\n        end++;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr95n5ti5.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpr95n5ti5.__unittest_L41_C1() [0x427da3]

    ??:? void tmpr95n5ti5.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    int paren_count = 0;\n    string current_group = \"\";\n\
    \    foreach(char c; paren_string) \n    {\n        if(c == '(') \n        {\n\
    \            paren_count++;\n            current_group ~= c;\n        }\n    \
    \    else if(c == ')') \n        {\n            paren_count--;\n            current_group\
    \ ~= c;\n            if(paren_count == 0) \n            {\n                paren_groups\
    \ ~= current_group;\n                current_group = \"\";\n            }\n  \
    \      }\n        else if(c != ' ') \n        {\n            current_group ~=\
    \ c;\n        }\n    }\n    return paren_groups;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n   \
    \ int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd\
    \ = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n \
    \   int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm\
    \ = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n \
    \   int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv\
    \ = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n \
    \   int aaa = 0;\n    int bbb = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int\
    \ eee = 0;\n    int fff = 0;\n    int ggg = 0;\n    int hhh = 0;\n    int iii\
    \ = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n\
    \    int nnn = 0;\n   \nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0szba_d9.d(78): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0szba_d9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ groups;\n    string current_group;\n    int open_parens = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            open_parens++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            open_parens--;\n            current_group ~= c;\n         \
    \   if(open_parens == 0)\n            {\n                groups ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n        else\
    \ if(c != ' ')\n        {\n            current_group ~= c;\n        }\n    }\n\
    \    return groups;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start_index = 0;\n    int end_index = 0;\n    int open_paren_count\
    \ = 0;\n    int close_paren_count = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            open_paren_count++;\n        }\n\
    \        else if(c == ')')\n        {\n            close_paren_count++;\n    \
    \    }\n        if(open_paren_count == close_paren_count)\n        {\n       \
    \     if(open_paren_count != 0)\n            {\n                result ~= paren_string[start_index..end_index];\n\
    \                start_index = end_index + 1;\n                open_paren_count\
    \ = 0;\n                close_paren_count = 0;\n            }\n        }\n   \
    \     end_index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsfjyydlu.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpsfjyydlu.__unittest_L41_C1() [0x427da3]

    ??:? void tmpsfjyydlu.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    int i\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            if(count == 0)\n            {\n                start = i;\n     \
    \       }\n            count++;\n        }\n        else if(c == ')')\n      \
    \  {\n            count--;\n            if(count == 0)\n            {\n      \
    \          end = i;\n                result ~= paren_string[start..end];\n   \
    \         }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp32auysto.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp32auysto.__unittest_L40_C1() [0x427d93]

    ??:? void tmp32auysto.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int paren_string_length = paren_string.length;\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb =\
    \ 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n   \
    \ int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk =\
    \ 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n   \
    \ int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt =\
    \ 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n   \
    \ int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n    int bbb = 0;\n    int ccc\
    \ = 0;\n    int ddd = 0;\n    int eee = 0;\n    int fff = 0;\n    int ggg = 0;\n\
    \    int hhh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int\
    \ lll = 0;\n\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3qjh35p0.d(77): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3qjh35p0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_top;\n    int i;\n    int start;\n\
    \    int end;\n    int len;\n    int count;\n    int temp;\n    int temp2;\n \
    \   int temp3;\n    int temp4;\n    int temp5;\n    int temp6;\n    int temp7;\n\
    \    int temp8;\n    int temp9;\n    int temp10;\n    int temp11;\n    int temp12;\n\
    \    int temp13;\n    int temp14;\n    int temp15;\n    int temp16;\n    int temp17;\n\
    \    int temp18;\n    int temp19;\n    int temp20;\n    int temp21;\n    int temp22;\n\
    \    int temp23;\n    int temp24;\n    int temp25;\n    int temp26;\n    int temp27;\n\
    \    int temp28;\n    int temp29;\n    int temp30;\n    int temp31;\n    int temp32;\n\
    \    int temp33;\n    int temp34;\n    int temp35;\n    int temp36;\n    int temp37;\n\
    \    int temp38;\n    int temp39;\n    int temp40;\n    int temp41;\n    int temp42;\n\
    \    int temp43;\n    int temp44;\n    int temp45;\n    int temp46;\n    int temp47;\n\
    \    int temp48;\n    int temp49;\n    int temp50;\n    int temp51;\n    int temp52;\n\
    \    int temp53;\n    int temp54;\n    int temp55;\n    int temp56;\n    int temp57;\n\
    \    int temp58;\n    int temp59;\n    int temp60;\n    int temp61;\n    int temp62;\n\
    \    int temp63;\n    int temp64;\n    int temp65;\n    int temp66;\n    int temp67;\n\
    \    int temp68;\n    int temp69;\n    int temp70;\n    int temp71;\n    int temp72;\n\
    \    int temp73;\n    int temp74;\n    int temp75;\n    int temp76;\n    int temp77;\n\
    \    int temp78\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphst3iuu0.d(98): Error: semicolon expected, not `unittest`

    /tmp/tmphst3iuu0.d(98): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphst3iuu0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp96y0qbsx.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp96y0qbsx.__unittest_L38_C1() [0x427d93]

    ??:? void tmp96y0qbsx.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164043
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.conv;\n    import std.range;\n\
    \    import std.string;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.stdio;\n    import std.exception;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.conv;\n    import std.string;\n    import std.stdio;\n\
    \    import std.exception;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.conv;\n    import std.string;\n    import std.stdio;\n\
    \    import std.exception;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.conv;\n    import std.string;\n    import std.stdio;\n\
    \    import std.exception;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.conv;\n    import std.string;\n    import std.stdio;\n\
    \    import std.exception;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.conv;\n    import std.string;\n    import std.stdio;\n\
    \    import std.exception;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.conv;\n    import std.string;\n    import std.stdio;\n\
    \nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0wr2zwpv.d(81): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0wr2zwpv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(open_paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        open_paren_count++;\n        }\n        else if(c == ')')\n        {\n\
    \            open_paren_count--;\n            if(open_paren_count == 0)\n    \
    \        {\n                result ~= paren_string[start_index..i];\n        \
    \    }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbufzp8j_.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbufzp8j_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164044
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    // your\
    \ code here\n    string[] result;\n    int start = 0;\n    int end = 0;\n    int\
    \ count = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n \
    \       {\n            if(count == 0)\n            {\n                start =\
    \ i;\n            }\n            count++;\n        }\n        else if(c == ')')\n\
    \        {\n            count--;\n            if(count == 0)\n            {\n\
    \                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa4_hnnai.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpa4_hnnai.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa4_hnnai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_parens++;\n            if(open_parens == 1)\n\
    \            {\n                start = end;\n            }\n        }\n     \
    \   else if(c == ')')\n        {\n            close_parens++;\n            if(open_parens\
    \ == close_parens)\n            {\n                result ~= paren_string[start..end];\n\
    \                open_parens = 0;\n                close_parens = 0;\n       \
    \     }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn5_x1d9q.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpn5_x1d9q.__unittest_L41_C1() [0x427da3]

    ??:? void tmpn5_x1d9q.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(i, char c; paren_string)\n    {\n        if(c == '(')\n  \
    \      {\n            if(paren_count == 0)\n            {\n                start_index\
    \ = i;\n            }\n            paren_count++;\n        }\n        else if(c\
    \ == ')')\n        {\n            paren_count--;\n            if(paren_count ==\
    \ 0)\n            {\n                end_index = i;\n                result ~=\
    \ paren_string[start_index..end_index];\n            }\n        }\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp54b73c6e.d(22): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmp54b73c6e.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp54b73c6e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    foreach(int\
    \ i, char c; paren_string)\n    {\n        if(c == '(')\n        {\n         \
    \   open_paren_count++;\n        }\n        else if(c == ')')\n        {\n   \
    \         open_paren_count--;\n        }\n        if(open_paren_count == 0)\n\
    \        {\n            result ~= paren_string[start_index..i];\n            start_index\
    \ = i + 1;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphtyotgiz.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e75]

    ??:? void tmphtyotgiz.__unittest_L33_C1() [0x427d83]

    ??:? void tmphtyotgiz.__modtest() [0x4280e0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b05d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0ec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42afe9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ba5]

    ??:? runModuleUnitTests [0x42df85]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429338]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n     \
    \   \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        paren_count++;\n        }\n        else if(c == ')')\n        {\n   \
    \         paren_count--;\n            if(paren_count == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptskjfzxs.d(21): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptskjfzxs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164043
