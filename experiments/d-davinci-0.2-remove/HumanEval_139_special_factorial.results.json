{
  "language": "d",
  "name": "HumanEval_139_special_factorial",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (int i = n; i > 0; i--)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6ri6koqo.d(17): Error: cannot implicitly convert expression `n` of type `long` to `int`\n/tmp/tmp6ri6koqo.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ri6koqo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    if (n <= 1)\n        return 1;\n    return n * special_factorial(n - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz06r_2hr.d(24): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpz06r_2hr.__unittest_L20_C1() [0x427a5a]\n??:? void tmpz06r_2hr.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    if (n == 0)\n        return 1;\n    long result = n;\n    for (long i = n - 1; i > 0; i--)\n        result *= i;\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyeuuwmxs.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d7d]\n??:? void tmpyeuuwmxs.__unittest_L23_C1() [0x427a76]\n??:? void tmpyeuuwmxs.__modtest() [0x427afc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42baa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a936]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a90d]\n??:? runModuleUnitTests [0x42b879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long res = 1;\n    foreach(i; 1..n)\n    {\n        res *= i;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpl5l0jgqt.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpl5l0jgqt.__unittest_L23_C1() [0x427a62]\n??:? void tmpl5l0jgqt.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long res = 1;\n    foreach(i; 1..n+1)\n    {\n        res *= factorial(i);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqtyjrci8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqtyjrci8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long res = 1;\n    foreach(i; 1..n)\n    {\n        res *= i;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpl5l0jgqt.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpl5l0jgqt.__unittest_L23_C1() [0x427a62]\n??:? void tmpl5l0jgqt.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    if (n <= 1)\n        return 1;\n    return n * special_factorial(n - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz06r_2hr.d(24): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpz06r_2hr.__unittest_L20_C1() [0x427a5a]\n??:? void tmpz06r_2hr.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    // your code here\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpga4aoqdc.d(20): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpga4aoqdc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    foreach(i; 1..n)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbpdw5jnt.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpbpdw5jnt.__unittest_L23_C1() [0x427a62]\n??:? void tmpbpdw5jnt.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    if (n <= 1)\n        return 1;\n    else\n        return n * special_factorial(n - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7i7yqty3.d(25): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmp7i7yqty3.__unittest_L21_C1() [0x427a5a]\n??:? void tmp7i7yqty3.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    foreach(i; 1..n)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbpdw5jnt.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpbpdw5jnt.__unittest_L23_C1() [0x427a62]\n??:? void tmpbpdw5jnt.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    if (n <= 1)\n        return 1;\n    return n * special_factorial(n - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz06r_2hr.d(24): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpz06r_2hr.__unittest_L20_C1() [0x427a5a]\n??:? void tmpz06r_2hr.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm659p15i.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpm659p15i.__unittest_L23_C1() [0x427a62]\n??:? void tmpm659p15i.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n+1)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4y2pgqqu.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y2pgqqu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = n; i > 0; i--)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0_dtbjo.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d5d]\n??:? void tmpa0_dtbjo.__unittest_L23_C1() [0x427a5a]\n??:? void tmpa0_dtbjo.__modtest() [0x427ae0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ac]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163920
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    \n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    foreach(i; 1..n)\n    {\n        result *= factorial(i);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwyfc6h8.d(19): Error: undefined identifier `factorial`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwyfc6h8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163919
    }
  ]
}