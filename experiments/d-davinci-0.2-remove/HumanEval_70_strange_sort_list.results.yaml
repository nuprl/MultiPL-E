language: d
name: HumanEval_70_strange_sort_list
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n\
    \        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`

    /tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`

    /tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkuuwd_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n\
    \        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`

    /tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`

    /tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkuuwd_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    while(lst.length\
    \ > 0)\n    {\n        long min = lst[0];\n        long max = lst[0];\n      \
    \  foreach(el; lst)\n        {\n            if(el < min)\n                min\
    \ = el;\n            if(el > max)\n                max = el;\n        }\n    \
    \    res[i] = min;\n        res[i+1] = max;\n        lst = lst.filter!(el => el\
    \ != min && el != max);\n        i += 2;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprc4qsn51.d(29): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprc4qsn51.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    while\
    \ (lst.length > 0) {\n        result[i] = lst[0];\n        lst = lst[1..$];\n\
    \        if (lst.length > 0) {\n            result[i] = lst[$-1];\n          \
    \  lst = lst[0..$-1];\n        }\n        i++;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphnvhjlwu.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x428915]

    ??:? void tmphnvhjlwu.__unittest_L27_C1() [0x428042]

    ??:? void tmphnvhjlwu.__modtest() [0x428698]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9f3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b886]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430a9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b85d]

    ??:? runModuleUnitTests [0x42c7c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428dd8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    int j = 0;\n    while (lst_copy.length > 0) {\n        result[i]\
    \ = lst_copy[j];\n        lst_copy = lst_copy[0..$-1];\n        if (lst_copy.length\
    \ > 0) {\n            result[i+1] = lst_copy[lst_copy.length-1];\n           \
    \ lst_copy = lst_copy[0..$-1];\n        }\n        i += 2;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkze3yedl.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x429a99]

    ??:? void tmpkze3yedl.__unittest_L29_C1() [0x428246]

    ??:? void tmpkze3yedl.__modtest() [0x428a10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x429722]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b461]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b4f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b3ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4296f9]

    ??:? runModuleUnitTests [0x42e4ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429fb0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy.remove(lst_copy.min);\n        if(lst_copy.length > 0)\n   \
    \     {\n            result[i+1] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjyb5233f.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpjyb5233f.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpjyb5233f.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpjyb5233f.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjyb5233f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort();\n\
    \    bool is_min = true;\n    int i = 0;\n    int j = 0;\n    while (i < lst.length)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = lst_sorted[j];\n\
    \            j++;\n        }\n        else\n        {\n            res[i] = lst_sorted[lst.length\
    \ - j];\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1kn4twjl.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1kn4twjl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    auto min = min(lst);\n    auto max = max(lst);\n\
    \    auto min_index = indexOf(lst, min);\n    auto max_index = indexOf(lst, max);\n\
    \    result ~= min;\n    result ~= max;\n    lst[min_index] = 0;\n    lst[max_index]\
    \ = 0;\n    while(lst.length > 0)\n    {\n        min = min(lst);\n        max\
    \ = max(lst);\n        min_index = indexOf(lst, min);\n        max_index = indexOf(lst,\
    \ max);\n        result ~= min;\n        result ~= max;\n        lst[min_index]\
    \ = 0;\n        lst[max_index] = 0;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppn92is7b.d(15): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmppn92is7b.d(16): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmppn92is7b.d(17): Error: undefined identifier `indexOf`

    /tmp/tmppn92is7b.d(18): Error: undefined identifier `indexOf`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppn92is7b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (k % 2\
    \ == 0) {\n            result[k] = lst[i];\n            i++;\n        } else {\n\
    \            result[k] = lst[j];\n            j--;\n        }\n        k++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmgzuyx7x.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmgzuyx7x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i\
    \ <= j) {\n        result[k++] = sorted[i++];\n        if (i <= j) {\n       \
    \     result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3p260i7_.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp3p260i7_.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3p260i7_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        if (k\
    \ % 2 == 0)\n        {\n            result[k] = lst[i];\n            i++;\n  \
    \      }\n        else\n        {\n            result[k] = lst[j];\n         \
    \   j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpimzrdujr.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpimzrdujr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] sorted = new long[lst.length];\n    long[] remaining =\
    \ lst.dup;\n    int i = 0;\n    bool ascending = true;\n    while (remaining.length\
    \ > 0)\n    {\n        if (ascending)\n        {\n            sorted[i] = remaining.min;\n\
    \            remaining = remaining.remove(remaining.min);\n        }\n       \
    \ else\n        {\n            sorted[i] = remaining.max;\n            remaining\
    \ = remaining.remove(remaining.max);\n        }\n        i++;\n        ascending\
    \ = !ascending;\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp67x4g032.d(22): Error: no property `min` for type `long[]`

    /tmp/tmp67x4g032.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmp67x4g032.d(27): Error: no property `max` for type `long[]`

    /tmp/tmp67x4g032.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp67x4g032.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n\
    \    long max = lst_copy[0];\n    foreach (el; lst_copy)\n    {\n        if (el\
    \ < min)\n            min = el;\n        if (el > max)\n            max = el;\n\
    \    }\n    res[0] = min;\n    lst_copy.remove(min);\n    res[1] = max;\n    lst_copy.remove(max);\n\
    \    int i = 2;\n    while (lst_copy.length > 0)\n    {\n        min = lst_copy[0];\n\
    \        max = lst_copy[0];\n        foreach (el; lst_copy)\n        {\n     \
    \       if (el < min)\n                min = el;\n            if (el > max)\n\
    \                max = el;\n        }\n        res[i] = min;\n        lst_copy.remove(min);\n\
    \        i++;\n        res[i] = max;\n        lst_copy.remove(max);\n        i++;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpres9z6jb.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmpres9z6jb.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpres9z6jb.d(44): Error: no property `remove` for type `long[]`

    /tmp/tmpres9z6jb.d(47): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpres9z6jb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst2 = lst.dup;\n\
    \    lst2.sort;\n    int i = 0;\n    int j = lst2.length - 1;\n    foreach(e;\
    \ lst)\n    {\n        if(e == lst2[i])\n        {\n            res[i] = e;\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = e;\n\
    \            j--;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7zbseznv.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmp7zbseznv.d(18): Error: cannot implicitly convert expression `lst2.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7zbseznv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst2 = lst[];\n\
    \    int i = 0;\n    while (lst2.length > 0)\n    {\n        ret[i] = lst2[0];\n\
    \        lst2 = lst2[1..$];\n        if (lst2.length == 0)\n            break;\n\
    \        ret[i+1] = lst2[$-1];\n        lst2 = lst2[0..$-1];\n        i += 2;\n\
    \    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp71_vtrdh.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x428935]

    ??:? void tmp71_vtrdh.__unittest_L29_C1() [0x4282b3]

    ??:? void tmp71_vtrdh.__modtest() [0x4286b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430abd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b87d]

    ??:? runModuleUnitTests [0x42c7e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428df8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool flag = true;\n    while (i <= j)\n    {\n    \
    \    if (flag)\n        {\n            result[i] = lst[i];\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = lst[j];\n       \
    \     j--;\n        }\n        flag = !flag;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpix2cm0wj.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpix2cm0wj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i\
    \ <= j) {\n        result[k++] = sorted[i++];\n        if (i <= j) {\n       \
    \     result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3p260i7_.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp3p260i7_.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3p260i7_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    while\
    \ (lst.length > 0) {\n        long min = lst[0];\n        long max = lst[0];\n\
    \        foreach (el; lst) {\n            if (el < min) {\n                min\
    \ = el;\n            }\n            if (el > max) {\n                max = el;\n\
    \            }\n        }\n        result[i] = min;\n        i++;\n        result[i]\
    \ = max;\n        i++;\n        lst = lst.filter!(el => el != min && el != max);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiqfgxrzc.d(31): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiqfgxrzc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n       \
    \ if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n      \
    \  }\n        else\n        {\n            res[j] = lst[j];\n            j--;\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm7gx5pe_.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm7gx5pe_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n       \
    \ if (is_min) {\n            result[i] = lst[i];\n            i++;\n        }\
    \ else {\n            result[j] = lst[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qfw2d3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] =\
    \ lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        if (lst_copy.length\
    \ > 0) \n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tcct287.d(19): Error: no property `min` for type `long[]`

    /tmp/tmp_tcct287.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmp_tcct287.d(23): Error: no property `max` for type `long[]`

    /tmp/tmp_tcct287.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tcct287.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool ascending = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(ascending)\n\
    \        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        ascending = !ascending;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp69bw2ttv.d(21): Error: no property `min` for type `long[]`

    /tmp/tmp69bw2ttv.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmp69bw2ttv.d(26): Error: no property `max` for type `long[]`

    /tmp/tmp69bw2ttv.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp69bw2ttv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n \
    \       if(is_min)\n        {\n            result[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = e;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpov9oqqai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        if (k\
    \ % 2 == 0)\n        {\n            res[k] = lst[i];\n            i++;\n     \
    \   }\n        else\n        {\n            res[k] = lst[j];\n            j--;\n\
    \        }\n        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppuyipqy7.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppuyipqy7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] sorted_lst = sort(lst);\n    long[]\
    \ sorted_lst_rev = sort(lst, (a, b) => b < a);\n    bool is_even = true;\n   \
    \ foreach(elem; sorted_lst)\n    {\n        if(is_even)\n        {\n         \
    \   result ~= elem;\n        }\n        else\n        {\n            result =\
    \ elem ~ result;\n        }\n        is_even = !is_even;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk27wghqz.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpk27wghqz.d(16): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk27wghqz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    bool asc = true;\n    int i = 0;\n    while (sorted.length > 0)\n    {\n\
    \        if (asc)\n        {\n            result[i] = sorted[0];\n           \
    \ sorted = sorted[1..$];\n        }\n        else\n        {\n            result[i]\
    \ = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n        asc\
    \ = !asc;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfml8mdyq.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfml8mdyq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res;\n    bool asc = true;\n    long min, max;\n    long[]\
    \ lst_remaining;\n    while (lst.length > 0)\n    {\n        if (asc)\n      \
    \  {\n            min = lst[0];\n            foreach (i; lst)\n            {\n\
    \                if (i < min)\n                    min = i;\n            }\n \
    \           res ~= min;\n            lst_remaining = lst.filter!(i => i != min);\n\
    \            lst = lst_remaining;\n        }\n        else\n        {\n      \
    \      max = lst[0];\n            foreach (i; lst)\n            {\n          \
    \      if (i > max)\n                    max = i;\n            }\n           \
    \ res ~= max;\n            lst_remaining = lst.filter!(i => i != max);\n     \
    \       lst = lst_remaining;\n        }\n        asc = !asc;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwfzhmn4r.d(29): Error: no property `filter` for type `long[]`

    /tmp/tmpwfzhmn4r.d(41): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfzhmn4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res;\n    long[] tmp;\n    long min;\n    long max;\n \
    \   long min_idx;\n    long max_idx;\n    long i;\n    long j;\n    long k;\n\
    \    long l;\n    long m;\n    long n;\n    long o;\n    long p;\n    long q;\n\
    \    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n    long w;\n\
    \    long x;\n    long y;\n    long z;\n    long aa;\n    long ab;\n    long ac;\n\
    \    long ad;\n    long ae;\n    long af;\n    long ag;\n    long ah;\n    long\
    \ ai;\n    long aj;\n    long ak;\n    long al;\n    long am;\n    long an;\n\
    \    long ao;\n    long ap;\n    long aq;\n    long ar;\n    long as;\n    long\
    \ at;\n    long au;\n    long av;\n    long aw;\n    long ax;\n    long ay;\n\
    \    long az;\n    long ba;\n    long bb;\n    long bc;\n    long bd;\n    long\
    \ be;\n    long bf;\n    long bg;\n    long bh;\n    long bi;\n    long bj;\n\
    \    long bk;\n    long bl;\n    long bm;\n    long bn;\n    long bo;\n    long\
    \ bp;\n    long bq;\n    long br;\n    long bs;\n    long bt;\n    long bu;\n\
    \    long bv;\n    long bw;\n    long bx;\n    long by;\n    long bz;\n    long\
    \ ca;\n    long cb;\n    long cc;\n    long cd;\n    long ce;\n    long cf;\n\
    \    long cg;\n    long ch;\n    long ci;\n    long cj;\n    long ck;\n    long\
    \ cl;\n    long cm;\n    long cn;\n    long co;\n    long cp;\n    long cq;\n\
    \    long cr;\n   \nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmz0fijc5.d(109): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmz0fijc5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j) \n    {\n        if (k % 2 == 0) \n        {\n            res[k] = lst_copy.min();\n\
    \            lst_copy.remove(lst_copy.min());\n            i++;\n        }\n \
    \       else \n        {\n            res[k] = lst_copy.max();\n            lst_copy.remove(lst_copy.max());\n\
    \            j--;\n        }\n        k++;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv0ql7w8q.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpv0ql7w8q.d(23): Error: no property `min` for type `long[]`

    /tmp/tmpv0ql7w8q.d(24): Error: no property `remove` for type `long[]`

    /tmp/tmpv0ql7w8q.d(29): Error: no property `max` for type `long[]`

    /tmp/tmpv0ql7w8q.d(30): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv0ql7w8q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        if (k\
    \ % 2 == 0) \n        {\n            res[k] = lst[i];\n            i++;\n    \
    \    }\n        else \n        {\n            res[k] = lst[j];\n            j--;\n\
    \        }\n        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprk27g1_v.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprk27g1_v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++]\
    \ = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa8kqw5ii.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa8kqw5ii.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n       \
    \ if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n      \
    \  }\n        else\n        {\n            res[j] = lst[j];\n            j--;\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm7gx5pe_.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm7gx5pe_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool asc = true;\n    foreach(e; lst)\n    {\n      \
    \  if(asc)\n        {\n            res[i] = e;\n            i++;\n        }\n\
    \        else\n        {\n            res[j] = e;\n            j--;\n        }\n\
    \        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw7y6y7ge.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7y6y7ge.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            result[k] = min(lst[i],\
    \ lst[j]);\n            if (lst[i] < lst[j])\n                i++;\n         \
    \   else\n                j--;\n        }\n        else\n        {\n         \
    \   result[k] = max(lst[i], lst[j]);\n            if (lst[i] > lst[j])\n     \
    \           i++;\n            else\n                j--;\n        }\n        is_min\
    \ = !is_min;\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnkckbdou.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpnkckbdou.d(23): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpnkckbdou.d(31): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnkckbdou.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n       \
    \ if (is_min) {\n            result[i] = lst[i];\n            i++;\n        }\
    \ else {\n            result[j] = lst[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qfw2d3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        res[i] = lst_copy[0];\n\
    \        lst_copy = lst_copy[1..$];\n        if (lst_copy.length > 0)\n      \
    \  {\n            res[i+1] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n\
    \        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_t5t1si7.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429aa1]

    ??:? void tmp_t5t1si7.__unittest_L30_C1() [0x42849f]

    ??:? void tmp_t5t1si7.__modtest() [0x428a14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42972a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b469]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b4f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b3f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429701]

    ??:? runModuleUnitTests [0x42e4b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429fb8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    auto min_max = minmax(lst);\n\
    \    long min = min_max[0];\n    long max = min_max[1];\n    long min_idx = 0;\n\
    \    long max_idx = lst.length - 1;\n    long idx = 0;\n    while (idx < lst.length)\
    \ \n    {\n        if (idx % 2 == 0) \n        {\n            ret[idx] = min;\n\
    \            min_idx++;\n            min = lst[min_idx];\n        } \n       \
    \ else \n        {\n            ret[idx] = max;\n            max_idx--;\n    \
    \        max = lst[max_idx];\n        }\n        idx++;\n    }\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps2qp0dyg.d(15): Error: undefined identifier `minmax`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps2qp0dyg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) {\n        ret[i] = lst_copy.min;\n\
    \        lst_copy = lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length\
    \ == 0) break;\n        ret[i] = lst_copy.max;\n        lst_copy = lst_copy.remove(lst_copy.max);\n\
    \        i++;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpechhl7lz.d(18): Error: no property `min` for type `long[]`

    /tmp/tmpechhl7lz.d(19): Error: no property `remove` for type `long[]`

    /tmp/tmpechhl7lz.d(22): Error: no property `max` for type `long[]`

    /tmp/tmpechhl7lz.d(23): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpechhl7lz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        res[i] = lst_copy.min;\n\
    \        lst_copy = lst_copy.remove(lst_copy.min);\n        if (lst_copy.length\
    \ > 0) \n        {\n            res[i + 1] = lst_copy.max;\n            lst_copy\
    \ = lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjlq0pw5w.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpjlq0pw5w.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpjlq0pw5w.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpjlq0pw5w.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjlq0pw5w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool asc = true;\n    lst.sort();\n    foreach(e; lst)\n\
    \    {\n        if(asc)\n        {\n            res[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = e;\n            j--;\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp96il0m9g.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp96il0m9g.d(18): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp96il0m9g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    foreach(e; lst)\n    {\n        if(i % 2 == 0)\n    \
    \    {\n            res[i] = min(lst);\n            lst = lst[1..$];\n       \
    \ }\n        else\n        {\n            res[i] = max(lst);\n            lst\
    \ = lst[0..$-1];\n        }\n        i++;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0iv2rcpt.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp0iv2rcpt.d(21): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp0iv2rcpt.d(26): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0iv2rcpt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool inc = true;\n    while (i <= j)\n    {\n     \
    \   if (inc)\n        {\n            result[i] = lst[i];\n            i++;\n \
    \       }\n        else\n        {\n            result[j] = lst[j];\n        \
    \    j--;\n        }\n        inc = !inc;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp53m9rq4d.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp53m9rq4d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n\
    \    bool is_min = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_min)\n\
    \        {\n            result ~= elem;\n            is_min = false;\n       \
    \ }\n        else\n        {\n            result.insert(0, elem);\n          \
    \  is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb8padfgk.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpb8padfgk.d(27): Error: no property `insert` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb8padfgk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j) \n    {\n        res[k++] = sorted[i++];\n        if (i <= j) \n        {\n\
    \            res[k++] = sorted[j--];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbuslrynw.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpbuslrynw.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbuslrynw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    lst_copy.sort;\n    int i = 0;\n    int j = lst_copy.length - 1;\n    int\
    \ k = 0;\n    while (i <= j) \n    {\n        result[k] = lst_copy[i];\n     \
    \   i++;\n        k++;\n        if (i <= j) \n        {\n            result[k]\
    \ = lst_copy[j];\n            j--;\n            k++;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0xa7835c.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmp0xa7835c.d(18): Error: cannot implicitly convert expression `lst_copy.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0xa7835c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst2 = lst.dup;\n\
    \    bool asc = true;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n  \
    \      if (asc)\n        {\n            res[i] = lst2.min;\n            lst2.remove(lst2.min);\n\
    \        }\n        else\n        {\n            res[i] = lst2.max;\n        \
    \    lst2.remove(lst2.max);\n        }\n        i++;\n        asc = !asc;\n  \
    \  }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu9583c1l.d(22): Error: no property `min` for type `long[]`

    /tmp/tmpu9583c1l.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpu9583c1l.d(27): Error: no property `max` for type `long[]`

    /tmp/tmpu9583c1l.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu9583c1l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n\
    \    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    foreach(e;\
    \ temp)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = temp[j];\n\
    \            j--;\n        }\n        else\n        {\n            result[i] =\
    \ temp[j];\n            j++;\n        }\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqiauud9v.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpqiauud9v.d(18): Error: cannot implicitly convert expression `temp.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqiauud9v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach(i; lst)\n    {\n        if(i < min)\n   \
    \         min = i;\n        if(i > max)\n            max = i;\n    }\n    auto\
    \ min_index = 0;\n    auto max_index = lst.length - 1;\n    foreach(i; 0..lst.length)\n\
    \    {\n        if(i % 2 == 0)\n        {\n            result[i] = min;\n    \
    \        min_index++;\n            min = lst[min_index];\n            foreach(j;\
    \ lst)\n            {\n                if(j < min && j > result[i])\n        \
    \            min = j;\n            }\n        }\n        else\n        {\n   \
    \         result[i] = max;\n            max_index--;\n            max = lst[max_index];\n\
    \            foreach(j; lst)\n            {\n                if(j > max && j <\
    \ result[i])\n                    max = j;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp38dh6z0t.d(60): unittest failure

    ----------------

    ??:? _d_unittestp [0x428b05]

    ??:? void tmp38dh6z0t.__unittest_L53_C1() [0x428487]

    ??:? void tmp38dh6z0t.__modtest() [0x428888]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cbe3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ba76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430d01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4311b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430c8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba4d]

    ??:? runModuleUnitTests [0x42c9b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428fc8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n \
    \       if(is_min)\n        {\n            result[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = e;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpov9oqqai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst2 = lst.dup;\n\
    \    lst2.sort;\n    bool asc = true;\n    int i = 0;\n    while (lst2.length\
    \ > 0)\n    {\n        if (asc)\n        {\n            ret[i] = lst2[0];\n  \
    \          lst2 = lst2[1..$];\n        }\n        else\n        {\n          \
    \  ret[i] = lst2[$-1];\n            lst2 = lst2[0..$-1];\n        }\n        i++;\n\
    \        asc = !asc;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmqxb7gm3.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmqxb7gm3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n\
    \    bool is_min = true;\n    foreach(el; sorted_lst)\n    {\n        if(is_min)\n\
    \        {\n            result ~= el;\n            is_min = false;\n        }\n\
    \        else\n        {\n            result.insert(0, el);\n            is_min\
    \ = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvwyd_foh.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpvwyd_foh.d(27): Error: no property `insert` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvwyd_foh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    long[] reversed = sorted.dup.reverse;\n    bool is_reversed = false;\n  \
    \  foreach(i, ref e; result)\n    {\n        if(is_reversed)\n        {\n    \
    \        result[i] = reversed.front;\n            reversed.popFront;\n       \
    \ }\n        else\n        {\n            result[i] = sorted.front;\n        \
    \    sorted.popFront;\n        }\n        is_reversed = !is_reversed;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp93jay5st.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp93jay5st.d(16): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmp93jay5st.d(22): Error: no property `front` for type `long[]`

    /tmp/tmp93jay5st.d(23): Error: no property `popFront` for type `long[]`

    /tmp/tmp93jay5st.d(27): Error: no property `front` for type `long[]`

    /tmp/tmp93jay5st.d(28): Error: no property `popFront` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp93jay5st.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] =\
    \ lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        i++;\n      \
    \  if (lst_copy.length > 0) \n        {\n            result[i] = lst_copy.max;\n\
    \            lst_copy.remove(lst_copy.max);\n            i++;\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ff7vqc2.d(19): Error: no property `min` for type `long[]`

    /tmp/tmp2ff7vqc2.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmp2ff7vqc2.d(24): Error: no property `max` for type `long[]`

    /tmp/tmp2ff7vqc2.d(25): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ff7vqc2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    bool asc = true;\n    while (i <= j)\n\
    \    {\n        if (asc)\n        {\n            result[k] = lst[i];\n       \
    \     i++;\n        }\n        else\n        {\n            result[k] = lst[j];\n\
    \            j--;\n        }\n        k++;\n        asc = !asc;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmr4iua6p.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmr4iua6p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) {\n        ret[i] = lst_copy.min;\n\
    \        lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length\
    \ > 0) {\n            ret[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \            i++;\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy2rig_c3.d(18): Error: no property `min` for type `long[]`

    /tmp/tmpy2rig_c3.d(19): Error: no property `remove` for type `long[]`

    /tmp/tmpy2rig_c3.d(22): Error: no property `max` for type `long[]`

    /tmp/tmpy2rig_c3.d(23): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy2rig_c3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    long[] reversed = sorted.dup.reverse;\n    bool is_reversed = false;\n  \
    \  foreach(i, ref e; result)\n    {\n        if(is_reversed)\n        {\n    \
    \        e = reversed.front;\n            reversed = reversed[1..$];\n       \
    \ }\n        else\n        {\n            e = sorted.front;\n            sorted\
    \ = sorted[1..$];\n        }\n        is_reversed = !is_reversed;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdguf5kcn.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpdguf5kcn.d(16): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    /tmp/tmpdguf5kcn.d(22): Error: no property `front` for type `long[]`

    /tmp/tmpdguf5kcn.d(27): Error: no property `front` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdguf5kcn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) {\n        ret[i] = lst_copy.min;\n\
    \        lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length\
    \ > 0) {\n            ret[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \            i++;\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy2rig_c3.d(18): Error: no property `min` for type `long[]`

    /tmp/tmpy2rig_c3.d(19): Error: no property `remove` for type `long[]`

    /tmp/tmpy2rig_c3.d(22): Error: no property `max` for type `long[]`

    /tmp/tmpy2rig_c3.d(23): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy2rig_c3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    result.length = lst.length;\n    auto lst_copy\
    \ = lst.dup;\n    auto lst_copy_sorted = lst_copy.sort;\n    auto lst_copy_sorted_reversed\
    \ = lst_copy_sorted.dup.reverse;\n    int i = 0;\n    int j = 0;\n    foreach(e;\
    \ lst_copy_sorted)\n    {\n        result[i] = e;\n        i += 2;\n    }\n  \
    \  foreach(e; lst_copy_sorted_reversed)\n    {\n        result[j] = e;\n     \
    \   j += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnvqh1ew2.d(17): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnvqh1ew2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n\
    \    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    int k = 0;\n\
    \    while (i <= j)\n    {\n        result[k] = temp[i];\n        i++;\n     \
    \   k++;\n        if (i <= j)\n        {\n            result[k] = temp[j];\n \
    \           j--;\n            k++;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdlacnsqs.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpdlacnsqs.d(18): Error: cannot implicitly convert expression `temp.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdlacnsqs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length\
    \ > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0mv_pmlq.d(19): Error: no property `min` for type `long[]`

    /tmp/tmp0mv_pmlq.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmp0mv_pmlq.d(24): Error: no property `max` for type `long[]`

    /tmp/tmp0mv_pmlq.d(25): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0mv_pmlq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n\
    \    bool is_min = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_min)\n\
    \        {\n            result ~= elem;\n            is_min = false;\n       \
    \ }\n        else\n        {\n            result.insert(0, elem);\n          \
    \  is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb8padfgk.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpb8padfgk.d(27): Error: no property `insert` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb8padfgk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n       \
    \ if (is_min) {\n            result[i] = lst[i];\n            i++;\n        }\
    \ else {\n            result[j] = lst[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qfw2d3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] =\
    \ lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        if\
    \ (lst_copy.length > 0) \n        {\n            result[i + 1] = lst_copy.max;\n\
    \            lst_copy = lst_copy.remove(lst_copy.max);\n        }\n        i +=\
    \ 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8rvx7suj.d(19): Error: no property `min` for type `long[]`

    /tmp/tmp8rvx7suj.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmp8rvx7suj.d(23): Error: no property `max` for type `long[]`

    /tmp/tmp8rvx7suj.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8rvx7suj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n\
    \        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`

    /tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`

    /tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkuuwd_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    bool is_min = true;\n   \
    \ foreach(e; lst) \n    {\n        if (is_min) \n        {\n            result[i]\
    \ = sorted[i];\n            i++;\n        } \n        else \n        {\n     \
    \       result[j] = sorted[j];\n            j--;\n        }\n        is_min =\
    \ !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpytdru00o.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpytdru00o.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpytdru00o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy = lst_copy.remove(lst_copy.min);\n        i++;\n        if(lst_copy.length\
    \ > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy\
    \ = lst_copy.remove(lst_copy.max);\n            i++;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnd3d6e5u.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpnd3d6e5u.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpnd3d6e5u.d(24): Error: no property `max` for type `long[]`

    /tmp/tmpnd3d6e5u.d(25): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnd3d6e5u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length > 0) {\n\
    \        if (is_min) {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        } else {\n            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvno4bpgh.d(20): Error: no property `min` for type `long[]`

    /tmp/tmpvno4bpgh.d(21): Error: no property `remove` for type `long[]`

    /tmp/tmpvno4bpgh.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpvno4bpgh.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvno4bpgh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool flag = true;\n    while (i <= j) {\n        if\
    \ (flag) {\n            result[i] = lst[i];\n            i++;\n        } else\
    \ {\n            result[j] = lst[j];\n            j--;\n        }\n        flag\
    \ = !flag;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc4gl007n.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc4gl007n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if\
    \ (is_min) {\n            res[i] = lst[i];\n            i++;\n        } else {\n\
    \            res[j] = lst[j];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprp2utyi0.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprp2utyi0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n\
    \    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    int k = 0;\n\
    \    while (i <= j)\n    {\n        result[k] = temp[i];\n        k++;\n     \
    \   if (i != j)\n        {\n            result[k] = temp[j];\n            k++;\n\
    \        }\n        i++;\n        j--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzouupttv.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpzouupttv.d(18): Error: cannot implicitly convert expression `temp.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzouupttv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool asc = true;\n    while (i <= j) {\n        if (asc)\
    \ {\n            res[i] = min(lst);\n            lst = remove(lst, min(lst));\n\
    \            i++;\n        } else {\n            res[j] = max(lst);\n        \
    \    lst = remove(lst, max(lst));\n            j--;\n        }\n        asc =\
    \ !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzbt2uz_6.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpzbt2uz_6.d(20): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpzbt2uz_6.d(21): Error: undefined identifier `remove`

    /tmp/tmpzbt2uz_6.d(24): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpzbt2uz_6.d(25): Error: undefined identifier `remove`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzbt2uz_6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool asc = true;\n    int i = 0;\n    while (lst_copy.length > 0) \n    {\n\
    \        if (asc) \n        {\n            res[i] = lst_copy.min;\n          \
    \  lst_copy.remove(lst_copy.min);\n        }\n        else \n        {\n     \
    \       res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n \
    \       }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcn4ud7si.d(22): Error: no property `min` for type `long[]`

    /tmp/tmpcn4ud7si.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpcn4ud7si.d(27): Error: no property `max` for type `long[]`

    /tmp/tmpcn4ud7si.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcn4ud7si.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n  \
    \      if (is_min)\n        {\n            result[i] = lst[i];\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = lst[j];\n       \
    \     j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8j550_23.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8j550_23.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    lst_copy.sort;\n    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length\
    \ > 0) {\n        if (is_min) {\n            result[i] = lst_copy[0];\n      \
    \      lst_copy = lst_copy[1..$];\n        } else {\n            result[i] = lst_copy[$-1];\n\
    \            lst_copy = lst_copy[0..$-1];\n        }\n        is_min = !is_min;\n\
    \        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbd4ad5el.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbd4ad5el.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining =\
    \ lst.dup;\n    long[] min_max = new long[2];\n    int i = 0;\n    while (remaining.length\
    \ > 0) {\n        min_max = min_max_tuple(remaining);\n        result[i] = min_max[0];\n\
    \        remaining = remaining.remove(min_max[0]);\n        if (remaining.length\
    \ > 0) {\n            result[i+1] = min_max[1];\n            remaining = remaining.remove(min_max[1]);\n\
    \        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1omxflk6.d(19): Error: undefined identifier `min_max_tuple`

    /tmp/tmp1omxflk6.d(21): Error: no property `remove` for type `long[]`

    /tmp/tmp1omxflk6.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1omxflk6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n       \
    \ if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n      \
    \  }\n        else\n        {\n            res[j] = lst[j];\n            j--;\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm7gx5pe_.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm7gx5pe_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    int index = 0;\n    while (lst_copy.length > 0)\
    \ {\n        if (is_min) {\n            result[index] = lst_copy.min;\n      \
    \      lst_copy.remove(lst_copy.min);\n        } else {\n            result[index]\
    \ = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n   \
    \     is_min = !is_min;\n        index++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxwxpe56z.d(20): Error: no property `min` for type `long[]`

    /tmp/tmpxwxpe56z.d(21): Error: no property `remove` for type `long[]`

    /tmp/tmpxwxpe56z.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpxwxpe56z.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxwxpe56z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    int i = 0;\n    while(lst_copy.length > 0)\n   \
    \ {\n        if(is_min)\n        {\n            result[i] = lst_copy.min;\n  \
    \          lst_copy = lst_copy.remove(lst_copy.min);\n        }\n        else\n\
    \        {\n            result[i] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo65tl9ux.d(22): Error: no property `min` for type `long[]`

    /tmp/tmpo65tl9ux.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpo65tl9ux.d(27): Error: no property `max` for type `long[]`

    /tmp/tmpo65tl9ux.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo65tl9ux.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n       \
    \ if (is_min) {\n            result[i] = lst[i];\n            i++;\n        }\
    \ else {\n            result[j] = lst[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qfw2d3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    foreach(e; lst)\n    {\n\
    \        if (i % 2 == 0)\n        {\n            result[i] = sorted[i / 2];\n\
    \        }\n        else\n        {\n            result[i] = sorted[j];\n    \
    \        j--;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq29_sryr.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpq29_sryr.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq29_sryr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int r = 0;\n    while(lst.length\
    \ > 0)\n    {\n        result[r++] = lst[0];\n        lst = lst[1..$];\n     \
    \   if(lst.length > 0)\n        {\n            result[r++] = lst[$-1];\n     \
    \       lst = lst[0..$-1];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp42eofxqw.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42891d]

    ??:? void tmp42eofxqw.__unittest_L28_C1() [0x42829b]

    ??:? void tmp42eofxqw.__modtest() [0x42869c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9fb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b88e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430aa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b865]

    ??:? runModuleUnitTests [0x42c7d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428de0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n\
    \    bool is_min = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_min)\n\
    \        {\n            result ~= elem;\n            is_min = false;\n       \
    \ }\n        else\n        {\n            result.insert(0, elem);\n          \
    \  is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb8padfgk.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpb8padfgk.d(27): Error: no property `insert` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb8padfgk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy.remove(lst_copy.min);\n        if (lst_copy.length > 0)\n  \
    \      {\n            result[i+1] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp27rtq4qf.d(19): Error: no property `min` for type `long[]`

    /tmp/tmp27rtq4qf.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmp27rtq4qf.d(23): Error: no property `max` for type `long[]`

    /tmp/tmp27rtq4qf.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27rtq4qf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length != 0) {\n        ret[i] = lst_copy.min;\n\
    \        lst_copy = lst_copy.remove(ret[i]);\n        i++;\n        if (lst_copy.length\
    \ == 0) break;\n        ret[i] = lst_copy.max;\n        lst_copy = lst_copy.remove(ret[i]);\n\
    \        i++;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpasrvpzmv.d(18): Error: no property `min` for type `long[]`

    /tmp/tmpasrvpzmv.d(19): Error: no property `remove` for type `long[]`

    /tmp/tmpasrvpzmv.d(22): Error: no property `max` for type `long[]`

    /tmp/tmpasrvpzmv.d(23): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasrvpzmv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n       \
    \ if (is_min) {\n            result[i] = lst[i];\n            i++;\n        }\
    \ else {\n            result[j] = lst[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qfw2d3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort();\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i\
    \ <= j)\n    {\n        result[k++] = sorted[i++];\n        if (i <= j)\n    \
    \        result[k++] = sorted[j--];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4z57g7_a.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp4z57g7_a.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4z57g7_a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool asc = true;\n    while (i <= j) {\n        if\
    \ (asc) {\n            result[i] = lst[i];\n            i++;\n        } else {\n\
    \            result[j] = lst[j];\n            j--;\n        }\n        asc = !asc;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph_ppw4hf.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph_ppw4hf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    res[0] = lst[0];\n    int i = 1;\n    int j = lst.length\
    \ - 1;\n    int k = 1;\n    while (i <= j)\n    {\n        if (k % 2 == 1)\n \
    \       {\n            res[k] = lst[j];\n            j--;\n        }\n       \
    \ else\n        {\n            res[k] = lst[i];\n            i++;\n        }\n\
    \        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz034beft.d(19): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz034beft.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy = lst_copy.filter!(x => x != lst_copy.min)();\n        i++;\n\
    \        if(lst_copy.length > 0)\n        {\n            result[i] = lst_copy.max;\n\
    \            lst_copy = lst_copy.filter!(x => x != lst_copy.max)();\n        \
    \    i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppz1p2evu.d(19): Error: no property `min` for type `long[]`

    /tmp/tmppz1p2evu.d(20): Error: no property `filter` for type `long[]`

    /tmp/tmppz1p2evu.d(24): Error: no property `max` for type `long[]`

    /tmp/tmppz1p2evu.d(25): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz1p2evu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] copy = lst.dup;\n\
    \    int i = 0;\n    while (copy.length > 0) {\n        result[i] = copy.min;\n\
    \        copy.remove(copy.min);\n        i++;\n        if (copy.length > 0) {\n\
    \            result[i] = copy.max;\n            copy.remove(copy.max);\n     \
    \       i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwrka3rr9.d(18): Error: no property `min` for type `long[]`

    /tmp/tmpwrka3rr9.d(19): Error: no property `remove` for type `long[]`

    /tmp/tmpwrka3rr9.d(22): Error: no property `max` for type `long[]`

    /tmp/tmpwrka3rr9.d(23): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwrka3rr9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_max = true;\n    int i = 0;\n    while (lst_copy.length > 0) {\n\
    \        if (is_max) {\n            result[i] = max(lst_copy);\n            lst_copy\
    \ = lst_copy.filter!(x => x != result[i]);\n        } else {\n            result[i]\
    \ = min(lst_copy);\n            lst_copy = lst_copy.filter!(x => x != result[i]);\n\
    \        }\n        is_max = !is_max;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcin2uyvz.d(20): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpcin2uyvz.d(21): Error: no property `filter` for type `long[]`

    /tmp/tmpcin2uyvz.d(23): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpcin2uyvz.d(24): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcin2uyvz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] sorted_lst = sort(lst);\n    long[]\
    \ reversed_lst = reverse(sorted_lst);\n    bool is_reversed = false;\n    foreach(i;\
    \ 0 .. lst.length)\n    {\n        if(!is_reversed)\n        {\n            result\
    \ ~= sorted_lst[i];\n            is_reversed = true;\n        }\n        else\n\
    \        {\n            result ~= reversed_lst[i];\n            is_reversed =\
    \ false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph6ir786d.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmph6ir786d.d(16): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph6ir786d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length != 0) {\n\
    \        if (is_min) {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        } else {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbwtt8as_.d(20): Error: no property `min` for type `long[]`

    /tmp/tmpbwtt8as_.d(21): Error: no property `remove` for type `long[]`

    /tmp/tmpbwtt8as_.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpbwtt8as_.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbwtt8as_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n \
    \       if(is_min)\n        {\n            result[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = e;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpov9oqqai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    lst_copy.sort;\n    int i = 0;\n    int j = lst_copy.length - 1;\n    while\
    \ (i < lst_copy.length) \n    {\n        result[i] = lst_copy[j];\n        i +=\
    \ 1;\n        if (i < lst_copy.length) \n        {\n            result[i] = lst_copy[i];\n\
    \            i += 1;\n        }\n        j -= 1;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0u2nxm11.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmp0u2nxm11.d(18): Error: cannot implicitly convert expression `lst_copy.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0u2nxm11.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n\
    \        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`

    /tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`

    /tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkuuwd_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    long min_val = 0;\n    long max_val = 0;\n    long\
    \ min_idx = 0;\n    long max_idx = 0;\n    long idx = 0;\n    while (lst_copy.length\
    \ > 0)\n    {\n        if (is_min)\n        {\n            min_val = lst_copy[0];\n\
    \            min_idx = 0;\n            foreach (i, val; lst_copy)\n          \
    \  {\n                if (val < min_val)\n                {\n                \
    \    min_val = val;\n                    min_idx = i;\n                }\n   \
    \         }\n            result[idx] = min_val;\n            lst_copy = lst_copy[0..min_idx]\
    \ ~ lst_copy[min_idx+1..$];\n            is_min = false;\n        }\n        else\n\
    \        {\n            max_val = lst_copy[0];\n            max_idx = 0;\n   \
    \         foreach (i, val; lst_copy)\n            {\n                if (val >\
    \ max_val)\n                {\n                    max_val = val;\n          \
    \          max_idx = i;\n                }\n            }\n            result[idx]\
    \ = max_val;\n            lst_copy = lst_copy[0..max_idx] ~ lst_copy[max_idx+1..$];\n\
    \            is_min = true;\n        }\n        idx++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        result[k++]\
    \ = lst[i++];\n        if (i <= j) {\n            result[k++] = lst[j--];\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx0l3rbqk.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx0l3rbqk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    int i = 0;\n    while\
    \ (lst.length > 0) \n    {\n        ret[i] = lst[0];\n        lst = lst[1..$];\n\
    \        if (lst.length > 0) \n        {\n            ret[i] = lst[$-1];\n   \
    \         lst = lst[0..$-1];\n        }\n        i++;\n    }\n    return ret;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxgi99lvh.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x428915]

    ??:? void tmpxgi99lvh.__unittest_L29_C1() [0x428042]

    ??:? void tmpxgi99lvh.__modtest() [0x428698]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9f3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b886]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430a9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b85d]

    ??:? runModuleUnitTests [0x42c7c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428dd8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n       \
    \ if (is_min) {\n            result[i] = lst[i];\n            i++;\n        }\
    \ else {\n            result[j] = lst[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qfw2d3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n        if\
    \ (is_min) {\n            res[i] = min(lst);\n            lst = remove(lst, min(lst));\n\
    \            i++;\n        } else {\n            res[j] = max(lst);\n        \
    \    lst = remove(lst, max(lst));\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8lkabr8q.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8lkabr8q.d(20): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp8lkabr8q.d(21): Error: undefined identifier `remove`

    /tmp/tmp8lkabr8q.d(24): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp8lkabr8q.d(25): Error: undefined identifier `remove`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8lkabr8q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n\
    \        {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm1l8mpjw.d(21): Error: no property `min` for type `long[]`

    /tmp/tmpm1l8mpjw.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmpm1l8mpjw.d(26): Error: no property `max` for type `long[]`

    /tmp/tmpm1l8mpjw.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm1l8mpjw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n       \
    \ if (is_min) {\n            result[i] = lst[i];\n            i++;\n        }\
    \ else {\n            result[j] = lst[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qfw2d3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining =\
    \ lst.dup;\n    int i = 0;\n    while (remaining.length > 0) \n    {\n       \
    \ result[i] = remaining[0];\n        remaining = remaining[1..$];\n        if\
    \ (remaining.length > 0) \n        {\n            result[i+1] = remaining[$-1];\n\
    \            remaining = remaining[0..$-2];\n        }\n        i += 2;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi5rcq9zu.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429aa1]

    ??:? void tmpi5rcq9zu.__unittest_L30_C1() [0x42824a]

    ??:? void tmpi5rcq9zu.__modtest() [0x428a14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42972a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b469]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b4f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b3f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429701]

    ??:? runModuleUnitTests [0x42e4b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429fb8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] lst_copy = lst.dup;\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    while (i < j) \n    {\n        result ~= lst_copy[i];\n\
    \        result ~= lst_copy[j];\n        i++;\n        j--;\n    }\n    if (i\
    \ == j) \n    {\n        result ~= lst_copy[i];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5a9nwy3v.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5a9nwy3v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n\
    \        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`

    /tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`

    /tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkuuwd_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] =\
    \ lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        if\
    \ (lst_copy.length == 0) break;\n        result[i+1] = lst_copy.max;\n       \
    \ lst_copy = lst_copy.remove(lst_copy.max);\n        i += 2;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbdilqqjl.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpbdilqqjl.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpbdilqqjl.d(22): Error: no property `max` for type `long[]`

    /tmp/tmpbdilqqjl.d(23): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbdilqqjl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    foreach(e; lst)\n    {\n\
    \        if (e == sorted[i])\n        {\n            result[i] = e;\n        \
    \    i++;\n        }\n        else\n        {\n            result[j] = e;\n  \
    \          j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpev9_4z06.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpev9_4z06.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpev9_4z06.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy.remove(lst_copy.min);\n        if(lst_copy.length > 0)\n   \
    \     {\n            result[i+1] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjyb5233f.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpjyb5233f.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpjyb5233f.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpjyb5233f.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjyb5233f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool ascending = true;\n    while (i <= j) {\n    \
    \    if (ascending) {\n            result[i] = lst[i];\n            i++;\n   \
    \     } else {\n            result[j] = lst[j];\n            j--;\n        }\n\
    \        ascending = !ascending;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprm55eewd.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprm55eewd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort;\n\
    \    int i = 0;\n    while (lst_sorted.length > 0)\n    {\n        res[i] = lst_sorted[0];\n\
    \        lst_sorted = lst_sorted[1..$];\n        if (lst_sorted.length > 0)\n\
    \        {\n            res[i+1] = lst_sorted[$-1];\n            lst_sorted =\
    \ lst_sorted[0..$-1];\n        }\n        i += 2;\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp6txcmub.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp6txcmub.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        if (k\
    \ % 2 == 0)\n        {\n            result[k] = lst[i];\n            i++;\n  \
    \      }\n        else\n        {\n            result[k] = lst[j];\n         \
    \   j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpimzrdujr.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpimzrdujr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while\
    \ (i <= j) {\n        if (is_min) {\n            res[i] = lst_copy.min;\n    \
    \        lst_copy.remove(lst_copy.min);\n            i++;\n        } else {\n\
    \            res[j] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2pp7p6a8.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp2pp7p6a8.d(21): Error: no property `min` for type `long[]`

    /tmp/tmp2pp7p6a8.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmp2pp7p6a8.d(25): Error: no property `max` for type `long[]`

    /tmp/tmp2pp7p6a8.d(26): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2pp7p6a8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    auto minmax = minmaxElement(lst);\n\
    \    bool is_min = true;\n    int i = 0;\n    while (lst.length != 0)\n    {\n\
    \        if (is_min)\n        {\n            result[i] = minmax.min;\n       \
    \     lst = lst.remove(minmax.min);\n        }\n        else\n        {\n    \
    \        result[i] = minmax.max;\n            lst = lst.remove(minmax.max);\n\
    \        }\n        is_min = !is_min;\n        i++;\n        minmax = minmaxElement(lst);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy59oftb6.d(15): Error: undefined identifier `minmaxElement`

    /tmp/tmpy59oftb6.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpy59oftb6.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy59oftb6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    long[] tmp = lst.dup;\n\
    \    int i = 0;\n    while (tmp.length != 0) \n    {\n        ret[i] = tmp.min;\n\
    \        tmp = tmp.remove(tmp.min);\n        if (tmp.length != 0) \n        {\n\
    \            ret[i + 1] = tmp.max;\n            tmp = tmp.remove(tmp.max);\n \
    \       }\n        i += 2;\n    }\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz5dj7oe3.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpz5dj7oe3.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpz5dj7oe3.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpz5dj7oe3.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz5dj7oe3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool asc = true;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n\
    \        if(asc)\n        {\n            result[i] = lst_copy.min;\n         \
    \   lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n     \
    \       result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpiuczfm.d(22): Error: no property `min` for type `long[]`

    /tmp/tmpnpiuczfm.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpnpiuczfm.d(27): Error: no property `max` for type `long[]`

    /tmp/tmpnpiuczfm.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpiuczfm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] sorted = lst.dup;\n    sorted.sort;\n    long[] result\
    \ = new long[sorted.length];\n    int i = 0;\n    int j = sorted.length - 1;\n\
    \    foreach(e; sorted)\n    {\n        if (i % 2 == 0)\n        {\n         \
    \   result[i] = sorted[j];\n            j--;\n        }\n        else\n      \
    \  {\n            result[i] = sorted[j];\n            j++;\n        }\n      \
    \  i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpahvfpjai.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpahvfpjai.d(18): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpahvfpjai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n       \
    \ if (is_min) {\n            result[i] = lst[i];\n            i++;\n        }\
    \ else {\n            result[j] = lst[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qfw2d3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto min_max_lst = zip(lst.min, lst.max);\n    auto min_max_lst_sorted\
    \ = min_max_lst.sort!((a, b) => a[0] > b[0]);\n    return min_max_lst_sorted.map!(a\
    \ => a[1]).array;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3yrdu9w2.d(14): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3yrdu9w2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    if (lst.length == 0) \n    {\n        return\
    \ lst;\n    }\n    else \n    {\n        long min = lst[0];\n        long max\
    \ = lst[0];\n        foreach (i; lst) \n        {\n            if (i < min) \n\
    \            {\n                min = i;\n            }\n            if (i > max)\
    \ \n            {\n                max = i;\n            }\n        }\n      \
    \  result = [min];\n        long[] remaining = lst[1..$];\n        while (remaining.length\
    \ > 0) \n        {\n            long next_max = remaining[0];\n            long\
    \ next_max_index = 0;\n            foreach (i; remaining) \n            {\n  \
    \              if (i > next_max) \n                {\n                    next_max\
    \ = i;\n                    next_max_index = i;\n                }\n         \
    \   }\n            result ~= next_max;\n            remaining = remaining[0..next_max_index]\
    \ ~ remaining[next_max_index + 1..$];\n            if (remaining.length == 0)\
    \ \n            {\n                break;\n            }\n            long next_min\
    \ = remaining[0];\n            long next_min_index = 0;\n            foreach (i;\
    \ remaining) \n            {\n                if (i < next_min) \n           \
    \     {\n                    next_min = i;\n                    next_min_index\
    \ = i;\n                }\n            }\n            result ~= next_min;\n  \
    \          remaining = remaining[0..next_min_index] ~ remaining[next_min_index\
    \ + 1..$];\n        }\n        return result;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpolxv51ez.d(49): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428ca6]

    ??:? long[] tmpolxv51ez.strange_sort_list(long[]) [0x4280a2]

    ??:? void tmpolxv51ez.__unittest_L70_C1() [0x4282af]

    ??:? void tmpolxv51ez.__modtest() [0x428978]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d7ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42c63e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430f49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4313f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ed5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c615]

    ??:? runModuleUnitTests [0x42d581]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int fun'
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        long\
    \ min_max = is_min ? lst_copy.min : lst_copy.max;\n        res[i] = min_max;\n\
    \        lst_copy.remove(min_max);\n        is_min = !is_min;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiw1hbje6.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpiw1hbje6.d(19): Error: no property `max` for type `long[]`

    /tmp/tmpiw1hbje6.d(21): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiw1hbje6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool asc = true;\n    int i = 0;\n    while(lst_copy.length > 0)\n    {\n\
    \        if(asc)\n        {\n            result[i] = lst_copy.min;\n         \
    \   lst_copy = lst_copy.remove(lst_copy.min);\n        }\n        else\n     \
    \   {\n            result[i] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpajar2z1d.d(22): Error: no property `min` for type `long[]`

    /tmp/tmpajar2z1d.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpajar2z1d.d(27): Error: no property `max` for type `long[]`

    /tmp/tmpajar2z1d.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajar2z1d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    while\
    \ (lst.length > 0) {\n        result[i] = lst[0];\n        lst = lst[1..$];\n\
    \        if (lst.length > 0) {\n            result[i] = lst[$-1];\n          \
    \  lst = lst[0..$-1];\n        }\n        i++;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphnvhjlwu.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x428915]

    ??:? void tmphnvhjlwu.__unittest_L27_C1() [0x428042]

    ??:? void tmphnvhjlwu.__modtest() [0x428698]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9f3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b886]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430a9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b85d]

    ??:? runModuleUnitTests [0x42c7c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428dd8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j) {\n        result[k++] = sorted[i++];\n        if (i <= j) {\n          \
    \  result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp32ffaq20.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp32ffaq20.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp32ffaq20.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i\
    \ <= j) {\n        result[k++] = sorted[i++];\n        if (i <= j) {\n       \
    \     result[k++] = sorted[j--];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3p260i7_.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp3p260i7_.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3p260i7_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        result[k++]\
    \ = lst[i++];\n        if (i <= j)\n            result[k++] = lst[j--];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5l2w_69o.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5l2w_69o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    while\
    \ (lst.length != 0)\n    {\n        res[i] = lst[0];\n        lst = lst[1..$];\n\
    \        if (lst.length == 0)\n            break;\n        res[i+1] = lst[$-1];\n\
    \        lst = lst[0..$-1];\n        i += 2;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5rawaf4_.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x428925]

    ??:? void tmp5rawaf4_.__unittest_L28_C1() [0x4282a3]

    ??:? void tmp5rawaf4_.__modtest() [0x4286a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b896]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430aad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b86d]

    ??:? runModuleUnitTests [0x42c7d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428de8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    bool is_min = true;\n    foreach(i, ref e; res)\n    {\n        if(is_min)\n\
    \        {\n            res[i] = sorted[0];\n            sorted = sorted[1..$];\n\
    \        }\n        else\n        {\n            res[i] = sorted[$-1];\n     \
    \       sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsmd05_s0.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsmd05_s0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy.remove(lst_copy.min);\n        i++;\n        if(lst_copy.length\
    \ > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcjr656m5.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpcjr656m5.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpcjr656m5.d(24): Error: no property `max` for type `long[]`

    /tmp/tmpcjr656m5.d(25): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcjr656m5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    foreach(x; sorted)\n    {\n\
    \        if (i % 2 == 0)\n        {\n            result[i] = sorted[j];\n    \
    \        j--;\n        }\n        else\n        {\n            result[i] = sorted[j];\n\
    \            j++;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeqni7n_l.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpeqni7n_l.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeqni7n_l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort;\n\
    \    bool asc = true;\n    int i = 0;\n    while (lst_sorted.length > 0)\n   \
    \ {\n        if (asc)\n        {\n            res[i] = lst_sorted[0];\n      \
    \      lst_sorted = lst_sorted[1..$];\n        }\n        else\n        {\n  \
    \          res[i] = lst_sorted[$-1];\n            lst_sorted = lst_sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3k_f4m6_.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3k_f4m6_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort();\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j) \n    {\n        res[k++] = lst_sorted[i++];\n        if (i <= j) \n    \
    \    {\n            res[k++] = lst_sorted[j--];\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp04cpplwr.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp04cpplwr.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp04cpplwr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        res[i] = lst_copy[0];\n\
    \        lst_copy = lst_copy[1..$];\n        if (lst_copy.length > 0)\n      \
    \  {\n            res[i+1] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n\
    \        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_t5t1si7.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x429aa1]

    ??:? void tmp_t5t1si7.__unittest_L30_C1() [0x42849f]

    ??:? void tmp_t5t1si7.__modtest() [0x428a14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42972a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b469]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b4f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b3f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429701]

    ??:? runModuleUnitTests [0x42e4b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429fb8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n\
    \        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`

    /tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`

    /tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkuuwd_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy = lst_copy.remove(lst_copy.min);\n        if(lst_copy.length\
    \ > 0)\n        {\n            result[i+1] = lst_copy.max;\n            lst_copy\
    \ = lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxktn267k.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpxktn267k.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpxktn267k.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpxktn267k.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxktn267k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] =\
    \ lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n        i++;\n\
    \        if (lst_copy.length > 0) \n        {\n            result[i] = lst_copy.max;\n\
    \            lst_copy = lst_copy.remove(lst_copy.max);\n            i++;\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaq_3lk7j.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpaq_3lk7j.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpaq_3lk7j.d(24): Error: no property `max` for type `long[]`

    /tmp/tmpaq_3lk7j.d(25): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaq_3lk7j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining =\
    \ lst.dup;\n    bool ascending = true;\n    int i = 0;\n    while (remaining.length\
    \ > 0) \n    {\n        if (ascending) \n        {\n            result[i] = remaining.min;\n\
    \            remaining.remove(remaining.min);\n        } \n        else \n   \
    \     {\n            result[i] = remaining.max;\n            remaining.remove(remaining.max);\n\
    \        }\n        i++;\n        ascending = !ascending;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpds2_by4s.d(22): Error: no property `min` for type `long[]`

    /tmp/tmpds2_by4s.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpds2_by4s.d(27): Error: no property `max` for type `long[]`

    /tmp/tmpds2_by4s.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpds2_by4s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n  \
    \      if (is_min)\n        {\n            result[i] = lst[i];\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = lst[j];\n       \
    \     j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8j550_23.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8j550_23.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n\
    \    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    bool flag =\
    \ true;\n    foreach(e; temp)\n    {\n        if(flag)\n        {\n          \
    \  result[i] = e;\n            i++;\n        }\n        else\n        {\n    \
    \        result[j] = e;\n            j--;\n        }\n        flag = !flag;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm76jpcgh.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpm76jpcgh.d(18): Error: cannot implicitly convert expression `temp.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm76jpcgh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    foreach(e; lst)\n    {\n\
    \        if(e == sorted[i])\n        {\n            res[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = e;\n            j--;\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpky_lhm55.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpky_lhm55.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpky_lhm55.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n   \
    \     if(is_min)\n        {\n            ret[i] = e;\n            i++;\n     \
    \   }\n        else\n        {\n            ret[j] = e;\n            j--;\n  \
    \      }\n        is_min = !is_min;\n    }\n    return ret;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp04kep12n.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp04kep12n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = new long[lst.length];\n\
    \    temp = lst.dup;\n    temp.sort;\n    bool flag = true;\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    while (i < lst.length)\n    {\n        if (flag)\n\
    \        {\n            result[i] = temp[i];\n            i++;\n        }\n  \
    \      else\n        {\n            result[i] = temp[j];\n            j--;\n \
    \       }\n        flag = !flag;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5pa72mr4.d(17): Error: no property `sort` for type `long[]`

    /tmp/tmp5pa72mr4.d(20): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pa72mr4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool asc = true;\n    foreach(e; lst)\n    {\n    \
    \    if(asc)\n        {\n            result[i] = e;\n            i++;\n      \
    \  }\n        else\n        {\n            result[j] = e;\n            j--;\n\
    \        }\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuvt67387.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuvt67387.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining =\
    \ lst.dup;\n    bool ascending = true;\n    foreach(i; 0 .. lst.length)\n    {\n\
    \        if(ascending)\n        {\n            result[i] = remaining.min;\n  \
    \          remaining.remove(remaining.min);\n        }\n        else\n       \
    \ {\n            result[i] = remaining.max;\n            remaining.remove(remaining.max);\n\
    \        }\n        ascending = !ascending;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp2k6_rbs.d(21): Error: no property `min` for type `long[]`

    /tmp/tmpp2k6_rbs.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmpp2k6_rbs.d(26): Error: no property `max` for type `long[]`

    /tmp/tmpp2k6_rbs.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp2k6_rbs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool ascending = true;\n    while (i <= j)\n    {\n\
    \        if (ascending)\n        {\n            result[i] = lst[i];\n        \
    \    i++;\n        }\n        else\n        {\n            result[j] = lst[j];\n\
    \            j--;\n        }\n        ascending = !ascending;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpivoan3n4.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    bool is_min = true;\n    foreach(i, ref e; sorted)\n    {\n        if(is_min)\n\
    \        {\n            result[i] = e;\n            is_min = false;\n        }\n\
    \        else\n        {\n            result[result.length - i - 1] = e;\n   \
    \         is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqv_n64x8.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqv_n64x8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length > 0)\n  \
    \  {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy6acx31f.d(22): Error: no property `min` for type `long[]`

    /tmp/tmpy6acx31f.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpy6acx31f.d(27): Error: no property `max` for type `long[]`

    /tmp/tmpy6acx31f.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy6acx31f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] temp = lst.dup;\n\
    \    temp.sort;\n    int i = 0;\n    int j = temp.length - 1;\n    foreach(e;\
    \ temp)\n    {\n        if(i <= j)\n        {\n            result[i] = temp[i];\n\
    \            i++;\n        }\n        if(i <= j)\n        {\n            result[j]\
    \ = temp[j];\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_m1y6zs3.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmp_m1y6zs3.d(18): Error: cannot implicitly convert expression `temp.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_m1y6zs3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j) \n    {\n        result[k++] = sorted[i++];\n        if (i <= j) \n     \
    \   {\n            result[k++] = sorted[j--];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyz6sd1sx.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpyz6sd1sx.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyz6sd1sx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++]\
    \ = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa8kqw5ii.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa8kqw5ii.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        res[i] = lst_copy[0];\n\
    \        lst_copy = lst_copy[1..$];\n        if (lst_copy.length > 0) \n     \
    \   {\n            res[i+1] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-2];\n\
    \        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1sdepnhs.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x429aa1]

    ??:? void tmp1sdepnhs.__unittest_L30_C1() [0x42824a]

    ??:? void tmp1sdepnhs.__modtest() [0x428a14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42972a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b469]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b4f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b3f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429701]

    ??:? runModuleUnitTests [0x42e4b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429fb8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] tmp = lst.dup;\n\
    \    int i = 0;\n    while (tmp.length > 0) {\n        result[i] = tmp.min;\n\
    \        tmp = tmp.remove(tmp.min);\n        if (tmp.length > 0) {\n         \
    \   result[i + 1] = tmp.max;\n            tmp = tmp.remove(tmp.max);\n       \
    \ }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqiw06h76.d(18): Error: no property `min` for type `long[]`

    /tmp/tmpqiw06h76.d(19): Error: no property `remove` for type `long[]`

    /tmp/tmpqiw06h76.d(21): Error: no property `max` for type `long[]`

    /tmp/tmpqiw06h76.d(22): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqiw06h76.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    int k = 0;\n    bool asc = true;\n    while (k < lst.length)\
    \ {\n        if (asc) {\n            res[k] = lst[i];\n            ++i;\n    \
    \    } else {\n            res[k] = lst[j];\n            --j;\n        }\n   \
    \     asc = !asc;\n        ++k;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7o0v6mkr.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7o0v6mkr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    int k = 0;\n    bool asc = true;\n    while (k < lst.length)\
    \ \n    {\n        if (asc) \n        {\n            res[k] = lst[i];\n      \
    \      i++;\n        } \n        else \n        {\n            res[k] = lst[j];\n\
    \            j--;\n        }\n        asc = !asc;\n        k++;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmped13qliu.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmped13qliu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_max = true;\n    for (int i = 0; i < lst.length; i++)\n    {\n  \
    \      long max_val = lst_copy[0];\n        long min_val = lst_copy[0];\n    \
    \    int max_idx = 0;\n        int min_idx = 0;\n        for (int j = 0; j < lst_copy.length;\
    \ j++)\n        {\n            if (lst_copy[j] > max_val)\n            {\n   \
    \             max_val = lst_copy[j];\n                max_idx = j;\n         \
    \   }\n            if (lst_copy[j] < min_val)\n            {\n               \
    \ min_val = lst_copy[j];\n                min_idx = j;\n            }\n      \
    \  }\n        if (is_max)\n        {\n            res[i] = max_val;\n        \
    \    lst_copy[max_idx] = -1;\n        }\n        else\n        {\n           \
    \ res[i] = min_val;\n            lst_copy[min_idx] = -1;\n        }\n        is_max\
    \ = !is_max;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1xm0tofa.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x429b81]

    ??:? void tmp1xm0tofa.__unittest_L50_C1() [0x42832e]

    ??:? void tmp1xm0tofa.__modtest() [0x428af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e7bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42980a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b549]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b5d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b4d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4297e1]

    ??:? runModuleUnitTests [0x42e595]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a098]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n       \
    \ if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n      \
    \  }\n        else\n        {\n            res[j] = lst[j];\n            j--;\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm7gx5pe_.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm7gx5pe_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool asc = true;\n    while (i <= j) {\n        if\
    \ (asc) {\n            result[i] = lst[i];\n            i++;\n        } else {\n\
    \            result[j] = lst[j];\n            j--;\n        }\n        asc = !asc;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph_ppw4hf.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph_ppw4hf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            result[k] = min(lst[i],\
    \ lst[j]);\n            if (lst[i] == result[k])\n                i++;\n     \
    \       else\n                j--;\n        }\n        else\n        {\n     \
    \       result[k] = max(lst[i], lst[j]);\n            if (lst[i] == result[k])\n\
    \                i++;\n            else\n                j--;\n        }\n   \
    \     is_min = !is_min;\n        k++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq8w5efkh.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpq8w5efkh.d(23): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpq8w5efkh.d(31): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8w5efkh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    foreach(i; 0 .. lst.length)\n    {\n        if(is_min)\n\
    \        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphkuuwd_8.d(21): Error: no property `min` for type `long[]`

    /tmp/tmphkuuwd_8.d(22): Error: no property `remove` for type `long[]`

    /tmp/tmphkuuwd_8.d(26): Error: no property `max` for type `long[]`

    /tmp/tmphkuuwd_8.d(27): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkuuwd_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        res[i] = lst_copy.min;\n\
    \        lst_copy = lst_copy.remove(lst_copy.min);\n        if (lst_copy.length\
    \ > 0) \n        {\n            res[i] = lst_copy.max;\n            lst_copy =\
    \ lst_copy.remove(lst_copy.max);\n        }\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc6a6n_ye.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpc6a6n_ye.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpc6a6n_ye.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpc6a6n_ye.d(24): Error: no property `remove` for type `long[]`

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n \
    \       if(is_min)\n        {\n            result[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = e;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpov9oqqai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j) \n    {\n        result[k++] = sorted[i++];\n        if (i <= j) \n     \
    \   {\n            result[k++] = sorted[j--];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyz6sd1sx.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpyz6sd1sx.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyz6sd1sx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    foreach(e; lst)\n    {\n   \
    \     if(i % 2 == 0)\n        {\n            res[i] = lst_sorted[j];\n       \
    \     j--;\n        }\n        else\n        {\n            res[i] = lst_sorted[0];\n\
    \            lst_sorted = lst_sorted[1..$];\n        }\n        i++;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpghq84_61.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpghq84_61.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpghq84_61.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    int k = 0;\n    while (i <= j) \n    {\n        if (k\
    \ % 2 == 0) \n        {\n            res[k] = min(lst[i], lst[j]);\n         \
    \   if (lst[i] < lst[j]) \n            {\n                i++;\n            }\
    \ \n            else \n            {\n                j--;\n            }\n  \
    \      } \n        else \n        {\n            res[k] = max(lst[i], lst[j]);\n\
    \            if (lst[i] > lst[j]) \n            {\n                i++;\n    \
    \        } \n            else \n            {\n                j--;\n        \
    \    }\n        }\n        k++;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbeg3a3d9.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpbeg3a3d9.d(22): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpbeg3a3d9.d(34): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbeg3a3d9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        res[k++] = lst_sorted[i++];\n        if (i <= j)\n      \
    \      res[k++] = lst_sorted[j--];\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpffd4h6wq.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpffd4h6wq.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while(lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy.remove(lst_copy.min);\n        i++;\n        if(lst_copy.length\
    \ > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcjr656m5.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpcjr656m5.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpcjr656m5.d(24): Error: no property `max` for type `long[]`

    /tmp/tmpcjr656m5.d(25): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcjr656m5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n \
    \       if(is_min)\n        {\n            result[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = e;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpov9oqqai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n  \
    \      if (is_min)\n        {\n            result[i] = min(lst);\n           \
    \ lst = remove(lst, min(lst));\n            i++;\n        }\n        else\n  \
    \      {\n            result[j] = max(lst);\n            lst = remove(lst, max(lst));\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzrcjzdi1.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpzrcjzdi1.d(22): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpzrcjzdi1.d(23): Error: undefined identifier `remove`

    /tmp/tmpzrcjzdi1.d(28): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpzrcjzdi1.d(29): Error: undefined identifier `remove`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzrcjzdi1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] remaining =\
    \ lst.dup;\n    bool even = true;\n    foreach(i; 0 .. lst.length) {\n       \
    \ if (even) {\n            result[i] = remaining.min;\n        } else {\n    \
    \        result[i] = remaining.max;\n        }\n        remaining.remove(result[i]);\n\
    \        even = !even;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuz52vln_.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpuz52vln_.d(21): Error: no property `max` for type `long[]`

    /tmp/tmpuz52vln_.d(23): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuz52vln_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] ret = new long[lst.length];\n    long[] tmp = lst.dup;\n\
    \    tmp.sort();\n    int i = 0;\n    while (tmp.length > 0) {\n        ret[i]\
    \ = tmp[0];\n        tmp = tmp[1..$];\n        if (tmp.length > 0) {\n       \
    \     ret[i+1] = tmp[$-1];\n            tmp = tmp[0..$-1];\n        }\n      \
    \  i += 2;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeyuy139m.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeyuy139m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort();\n\
    \    bool asc = true;\n    long i = 0;\n    long j = 0;\n    while (i < lst.length)\n\
    \    {\n        if (asc)\n        {\n            res[i] = sorted[j];\n       \
    \     j++;\n        }\n        else\n        {\n            res[i] = sorted[sorted.length\
    \ - j - 1];\n        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ty9jtq1.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ty9jtq1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i\
    \ <= j)\n    {\n        result[k++] = sorted[i++];\n        if (i <= j)\n    \
    \        result[k++] = sorted[j--];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnesbm38e.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpnesbm38e.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnesbm38e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] temp;\n    long min;\n    long max;\n\
    \    long i;\n    long j;\n    long k;\n    long l;\n    long m;\n    long n;\n\
    \    long o;\n    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n\
    \    long u;\n    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n\
    \    long aa;\n    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long\
    \ af;\n    long ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n\
    \    long al;\n    long am;\n    long an;\n    long ao;\n    long ap;\n    long\
    \ aq;\n    long ar;\n    long as;\n    long at;\n    long au;\n    long av;\n\
    \    long aw;\n    long ax;\n    long ay;\n    long az;\n    long ba;\n    long\
    \ bb;\n    long bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n\
    \    long bh;\n    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long\
    \ bm;\n    long bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n\
    \    long bs;\n    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long\
    \ bx;\n    long by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n\
    \    long cd;\n    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long\
    \ ci;\n    long cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n\
    \    long co;\n    long cp;\n    long cq;\n    long cr;\n    long cs;\n    long\
    \ ct;\n    long cu;\n   \nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi1o5cg4u.d(110): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi1o5cg4u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool ascending = true;\n    foreach(e; lst)\n    {\n\
    \        if(ascending)\n        {\n            result[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = e;\n            j--;\n\
    \        }\n        ascending = !ascending;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcwxcake3.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcwxcake3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    foreach(e; lst) {\n     \
    \   if (e == sorted[i]) {\n            result[i] = e;\n            i++;\n    \
    \    } else {\n            result[j] = e;\n            j--;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbxsb7t7i.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpbxsb7t7i.d(17): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbxsb7t7i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    int i = 0;\n    int j = lst.length - 1;\n\
    \    bool is_min = true;\n    while (i <= j) {\n        if (is_min) {\n      \
    \      result ~= lst[i];\n            i++;\n        } else {\n            result\
    \ ~= lst[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9uzhhbec.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9uzhhbec.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n\
    \    result = [];\n    bool is_min = true;\n    foreach(elem; sorted_lst)\n  \
    \  {\n        if(is_min)\n        {\n            result ~= elem;\n           \
    \ is_min = false;\n        }\n        else\n        {\n            result.insert(0,\
    \ elem);\n            is_min = true;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5bk0arab.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmp5bk0arab.d(28): Error: no property `insert` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5bk0arab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool asc = true;\n    foreach(e; lst)\n    {\n      \
    \  if(asc)\n        {\n            res[i] = e;\n            i++;\n        }\n\
    \        else\n        {\n            res[j] = e;\n            j--;\n        }\n\
    \        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw7y6y7ge.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7y6y7ge.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) {\n        res[i] = lst_copy[0];\n\
    \        lst_copy = lst_copy[1..$];\n        if (lst_copy.length > 0) {\n    \
    \        res[i] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n \
    \       }\n        i += 1;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnbmwjxyb.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x429a99]

    ??:? void tmpnbmwjxyb.__unittest_L28_C1() [0x428242]

    ??:? void tmpnbmwjxyb.__modtest() [0x428a0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x429722]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b461]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b4f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b3ed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4296f9]

    ??:? runModuleUnitTests [0x42e4ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429fb0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164215
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n    \
    \    if (is_min)\n        {\n            res[i] = min(lst);\n            lst =\
    \ remove(lst, min(lst));\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = max(lst);\n            lst = remove(lst, max(lst));\n  \
    \          j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj015eg_q.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpj015eg_q.d(22): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpj015eg_q.d(23): Error: undefined identifier `remove`

    /tmp/tmpj015eg_q.d(28): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpj015eg_q.d(29): Error: undefined identifier `remove`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj015eg_q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    size_t i = 0;\n    while (lst_copy.length > 0)\n\
    \    {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwxsb625_.d(22): Error: no property `min` for type `long[]`

    /tmp/tmpwxsb625_.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpwxsb625_.d(27): Error: no property `max` for type `long[]`

    /tmp/tmpwxsb625_.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwxsb625_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res;\n    long[] temp;\n    long min;\n    long max;\n\
    \    long min_index;\n    long max_index;\n    long i;\n    long j;\n    long\
    \ k;\n    long l;\n    bool is_min;\n    bool is_max;\n    bool is_odd;\n    bool\
    \ is_even;\n    bool is_first;\n    bool is_last;\n    bool is_first_even;\n \
    \   bool is_first_odd;\n    bool is_last_even;\n    bool is_last_odd;\n    bool\
    \ is_even_index;\n    bool is_odd_index;\n    bool is_even_index_first;\n    bool\
    \ is_odd_index_first;\n    bool is_even_index_last;\n    bool is_odd_index_last;\n\
    \    bool is_even_index_first_even;\n    bool is_even_index_first_odd;\n    bool\
    \ is_even_index_last_even;\n    bool is_even_index_last_odd;\n    bool is_odd_index_first_even;\n\
    \    bool is_odd_index_first_odd;\n    bool is_odd_index_last_even;\n    bool\
    \ is_odd_index_last_odd;\n    bool is_even_index_first_even_even;\n    bool is_even_index_first_even_odd;\n\
    \    bool is_even_index_first_odd_even;\n    bool is_even_index_first_odd_odd;\n\
    \    bool is_even_index_last_even_even;\n    bool is_even_index_last_even_odd;\n\
    \    bool is_even_index_last_odd_even;\n    bool is_even_index_last_odd_odd;\n\
    \    bool is_odd_index_first_even_even;\n    bool is_odd_index_first_even_odd;\n\
    \    bool is_odd_index_first_odd_even;\n    bool is_odd_index_first_odd_odd;\n\
    \    bool is_odd_index_last_even_even;\n    bool is_odd_index_last_even_odd;\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu7hjz6_y.d(62): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu7hjz6_y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n\
    \    bool is_max = true;\n    foreach(elem; sorted_lst)\n    {\n        if(is_max)\n\
    \        {\n            result ~= elem;\n            is_max = false;\n       \
    \ }\n        else\n        {\n            result.insert(0, elem);\n          \
    \  is_max = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp1yfzpvk.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpp1yfzpvk.d(27): Error: no property `insert` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp1yfzpvk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n    \
    \    if (is_min)\n        {\n            res[i] = lst[i];\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = lst[j];\n          \
    \  j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeze426n1.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeze426n1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    while\
    \ (lst.length > 0) {\n        result[i] = lst[0];\n        lst = lst[1..$];\n\
    \        if (lst.length > 0) {\n            auto max = maxElement(lst);\n    \
    \        result[i+1] = max;\n            lst = lst[0..max] ~ lst[max+1..$];\n\
    \        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmporacgor4.d(20): Error: undefined identifier `maxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmporacgor4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n\
    \    result.length = lst.length;\n    bool is_min = true;\n    int i = 0;\n  \
    \  int j = 0;\n    while (i < lst.length)\n    {\n        if (is_min)\n      \
    \  {\n            result[i] = sorted_lst[j];\n            j++;\n        }\n  \
    \      else\n        {\n            result[i] = sorted_lst[sorted_lst.length -\
    \ j - 1];\n        }\n        is_min = !is_min;\n        i++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdpzwtej8.d(16): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdpzwtej8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result;\n    auto minmax = minmaxElement(lst);\n    auto\
    \ min = minmax.min;\n    auto max = minmax.max;\n    bool is_min = true;\n   \
    \ while(lst.length > 0)\n    {\n        if(is_min)\n        {\n            result\
    \ ~= min;\n            lst = lst.filter!(x => x != min);\n            is_min =\
    \ false;\n        }\n        else\n        {\n            result ~= max;\n   \
    \         lst = lst.filter!(x => x != max);\n            is_min = true;\n    \
    \    }\n        minmax = minmaxElement(lst);\n        min = minmax.min;\n    \
    \    max = minmax.max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp5thu_oq.d(15): Error: undefined identifier `minmaxElement`

    /tmp/tmpp5thu_oq.d(24): Error: no property `filter` for type `long[]`

    /tmp/tmpp5thu_oq.d(30): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp5thu_oq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n \
    \       if(is_min)\n        {\n            result[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = e;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpov9oqqai.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpov9oqqai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length > 0)\n  \
    \  {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy6acx31f.d(22): Error: no property `min` for type `long[]`

    /tmp/tmpy6acx31f.d(23): Error: no property `remove` for type `long[]`

    /tmp/tmpy6acx31f.d(27): Error: no property `max` for type `long[]`

    /tmp/tmpy6acx31f.d(28): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy6acx31f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool is_min = true;\n    foreach(e; lst)\n    {\n   \
    \     if(is_min)\n        {\n            res[i] = e;\n            i++;\n     \
    \   }\n        else\n        {\n            res[j] = e;\n            j--;\n  \
    \      }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0p1_arve.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0p1_arve.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n\
    \    bool asc = true;\n    foreach(i, ref e; result)\n    {\n        if (asc)\n\
    \        {\n            e = sorted[0];\n            sorted = sorted[1..$];\n \
    \       }\n        else\n        {\n            e = sorted[$-1];\n           \
    \ sorted = sorted[0..$-1];\n        }\n        asc = !asc;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpymjgcklp.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymjgcklp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool inc = true;\n    while\
    \ (i <= j) {\n        if (inc) {\n            res[i] = lst[i];\n            i++;\n\
    \        } else {\n            res[j] = lst[i];\n            j--;\n        }\n\
    \        inc = !inc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxpo8oz56.d(17): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxpo8oz56.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164215
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool is_min = true;\n    sort(lst);\n    foreach(e; lst)\n\
    \    {\n        if(is_min)\n        {\n            res[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = e;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf51l_gq0.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpf51l_gq0.d(18): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf51l_gq0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164215
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    while\
    \ (lst.length != 0)\n    {\n        res[i] = lst[0];\n        lst = lst[1..$];\n\
    \        if (lst.length == 0)\n            break;\n        res[i+1] = lst[$-1];\n\
    \        lst = lst[0..$-1];\n        i += 2;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5rawaf4_.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x428925]

    ??:? void tmp5rawaf4_.__unittest_L28_C1() [0x4282a3]

    ??:? void tmp5rawaf4_.__modtest() [0x4286a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b896]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430aad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b86d]

    ??:? runModuleUnitTests [0x42c7d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428de8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0) \n    {\n        result[i] =\
    \ lst_copy.min;\n        lst_copy.remove(result[i]);\n        i++;\n        if\
    \ (lst_copy.length > 0) \n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(result[i]);\n            i++;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqhuz7x0p.d(19): Error: no property `min` for type `long[]`

    /tmp/tmpqhuz7x0p.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmpqhuz7x0p.d(24): Error: no property `max` for type `long[]`

    /tmp/tmpqhuz7x0p.d(25): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqhuz7x0p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164215
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool min = true;\n    while (i <= j) {\n        if (min)\
    \ {\n            res[i] = lst[i];\n            i++;\n        } else {\n      \
    \      res[j] = lst[j];\n            j--;\n        }\n        min = !min;\n  \
    \  }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj9xp28e0.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj9xp28e0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j) {\n       \
    \ if (is_min) {\n            result[i] = lst[i];\n            i++;\n        }\
    \ else {\n            result[j] = lst[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qfw2d3a.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qfw2d3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164213
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        result[i] = lst_copy.min;\n\
    \        lst_copy = lst_copy.remove(result[i]);\n        i++;\n        if (lst_copy.length\
    \ > 0)\n        {\n            result[i] = lst_copy.max;\n            lst_copy\
    \ = lst_copy.remove(result[i]);\n            i++;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppn6_ota6.d(19): Error: no property `min` for type `long[]`

    /tmp/tmppn6_ota6.d(20): Error: no property `remove` for type `long[]`

    /tmp/tmppn6_ota6.d(24): Error: no property `max` for type `long[]`

    /tmp/tmppn6_ota6.d(25): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppn6_ota6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164215
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int index = 0;\n    bool is_min = true;\n    while (lst_copy.length > 0)\
    \ {\n        if (is_min) {\n            result[index] = lst_copy.min;\n      \
    \      lst_copy.remove(lst_copy.min);\n        } else {\n            result[index]\
    \ = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n        }\n   \
    \     index++;\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpro7u4d35.d(20): Error: no property `min` for type `long[]`

    /tmp/tmpro7u4d35.d(21): Error: no property `remove` for type `long[]`

    /tmp/tmpro7u4d35.d(23): Error: no property `max` for type `long[]`

    /tmp/tmpro7u4d35.d(24): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpro7u4d35.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164214
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n                \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    foreach(long val; lst)\n \
    \   {\n        if(is_min)\n        {\n            result[i] = val;\n         \
    \   i++;\n        }\n        else\n        {\n            result[j] = val;\n \
    \           j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7nd87j83.d(16): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nd87j83.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164215
