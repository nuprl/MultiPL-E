{
  "name": "HumanEval_70_strange_sort_list",
  "language": "rs",
  "prompt": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    } else if i < max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n\n  let min_value = lst[0]\n  let min_index = 0\n  for i in lst.iter() {\n    if i > min_value {\n      min_value = i\n      min_index = i\n    } else if i < min_value {\n      min_value = i\n      min_index = i\n    }\n  }\n\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(min_index)\n    } else if i == max_value {\n      result = result.append(max_index)\n    } else {\n      result = result.append(i)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpszj62lm9.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpszj62lm9.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpszj62lm9.rs:14:25\n   |\n14 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpszj62lm9.rs:17:20\n   |\n17 |       max_value = i\n   |                    ^ help: add `;` here\n18 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpszj62lm9.rs:20:20\n   |\n20 |       max_value = i\n   |                    ^ help: add `;` here\n21 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpszj62lm9.rs:25:25\n   |\n25 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n26 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpszj62lm9.rs:26:20\n   |\n26 |   let min_index = 0\n   |                    ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpszj62lm9.rs:29:20\n   |\n29 |       min_value = i\n   |                    ^ help: add `;` here\n30 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpszj62lm9.rs:32:20\n   |\n32 |       min_value = i\n   |                    ^ help: add `;` here\n33 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpszj62lm9.rs:37:26\n   |\n37 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n38 | ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return lst;\n  }\n\n  let min_index = 0;\n  let max_index = lst_len - 1;\n  let min_value = lst[min_index];\n  let max_value = lst[max_index];\n\n  let min_index_prev = min_index;\n  let max_index_prev = max_index;\n\n  while (min_index < max_index) {\n    if (lst[min_index] < lst[max_index]) {\n      min_index_prev = min_index;\n      min_index = (min_index + 1) % lst_len;\n    } else {\n      max_index_prev = max_index;\n      max_index = (max_index - 1) % lst_len;\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < lst_len; i++) {\n    if (i == min_index_prev) {\n      result.push(min_value);\n    } else if (i == max_index_prev) {\n      result.push(max_value);\n    } else {\n      result.push(lst[i]);\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmppfmmq654.rs:36:8\n   |\n36 |   for (let i = 0; i < lst_len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmppfmmq654.rs:36:12\n   |\n36 |   for (let i = 0; i < lst_len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppfmmq654.rs:36:14\n   |\n36 |   for (let i = 0; i < lst_len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppfmmq654.rs:36:13\n   |\n36 |   for (let i = 0; i < lst_len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppfmmq654.rs:36:14\n   |\n36 |   for (let i = 0; i < lst_len; i++) {\n   |              ^ expected expression\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppfmmq654.rs:25:9\n   |\n25 |   while (min_index < max_index) {\n   |         ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -   while (min_index < max_index) {\n25 +   while min_index < max_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppfmmq654.rs:26:8\n   |\n26 |     if (lst[min_index] < lst[max_index]) {\n   |        ^                               ^\n   |\nhelp: remove these parentheses\n   |\n26 -     if (lst[min_index] < lst[max_index]) {\n26 +     if lst[min_index] < lst[max_index] {\n   | \n\nerror: aborting due to 5 previous errors; 2 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new(lst.len());\n  let i = 0;\n  for (let v of lst) {\n    if (v < min) {\n      result[i] = min;\n      min = v;\n    } else if (v > max) {\n      result[i] = max;\n      max = v;\n    } else {\n      result[i] = v;\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpggcs4sol.rs:16:8\n   |\n16 |   for (let v of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `v`\n  --> /tmp/tmpggcs4sol.rs:16:12\n   |\n16 |   for (let v of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpggcs4sol.rs:16:14\n   |\n16 |   for (let v of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmpggcs4sol.rs:16:17\n   |\n16 |   for (let v of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpggcs4sol.rs:16:21\n   |\n16 |   for (let v of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpggcs4sol.rs:28:3\n   |\n28 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n28 |   { return result; }\n   |   +                +\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpggcs4sol.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpggcs4sol.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpggcs4sol.rs:14:16\n    |\n14  |   let result = Vec::new(lst.len());\n    |                ^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let max_index = 0;\n  let min_index = 0;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n      min_index = i;\n    }\n    if i > max {\n      max = i;\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i == min_index {\n      result = result.append(i);\n    }\n    if i == max_index {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpr3crn3ho.rs:17:12\n   |\n17 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3crn3ho.rs:18:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n18 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3crn3ho.rs:19:19\n   |\n15 |   let min_index = 0;\n   |                   - expected due to this value\n...\n19 |       min_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       min_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3crn3ho.rs:21:12\n   |\n21 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3crn3ho.rs:22:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n22 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3crn3ho.rs:23:19\n   |\n14 |   let max_index = 0;\n   |                   - expected due to this value\n...\n23 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpr3crn3ho.rs:28:10\n   |\n28 |     if i == min_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index(min_value);\n  let max_index = lst.index(max_value);\n  let max_value_index = lst.index(max_value);\n  let min_value_index = lst.index(min_value);\n  let max_value_index_next = lst.index(max_value, max_index + 1);\n  let min_value_index_next = lst.index(min_value, min_index + 1);\n  let max_value_index_prev = lst.index(max_value, max_index - 1);\n  let min_value_index_prev = lst.index(min_value, min_index - 1);\n  let max_value_index_prev_next = lst.index(max_value, max_index - 1, max_index + 1);\n  let min_value_index_prev_next = lst.index(min_value, min_index - 1, min_index + 1);\n  let max_value_index_next_next = lst.index(max_value, max_index + 1, max_index + 1);\n  let min_value_index_next_next = lst.index(min_value, min_index + 1, min_index + 1);\n  let max_value_index_next_prev = lst.index(max_value, max_index + 1, max_index - 1);\n  let min_value_index_next_prev = lst.index(min_value, min_index + 1, min_index - 1);\n  let max_value_index_prev_prev = lst.index(max_value, max_index - 1, max_index - 1);\n  let min_value_index_prev_prev = lst.index(min_value, min_index - 1, min_index - 1);\n  let max_value_index_prev_prev_prev = lst.index(max_value, max_index - 1, max_index - 1, max_index - 1);\n  let\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmp0oqj7x1r.rs:32:1\n   |\n32 | }\n   | ^ expected pattern\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0oqj7x1r.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0oqj7x1r.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp0oqj7x1r.rs:14:23\n   |\n14 |   let min_index = lst.index(min_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp0oqj7x1r.rs:15:23\n   |\n15 |   let max_index = lst.index(max_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp0oqj7x1r.rs:16:29\n   |\n16 |   let max_value_index = lst.index(max_value);\n   |                             ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpablhkhs4.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpablhkhs4.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpablhkhs4.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpablhkhs4.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpablhkhs4.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpablhkhs4.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpablhkhs4.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpablhkhs4.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    } else if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n\n  result = result.append(min_value)\n  result = result.append(max_value)\n\n  for i in lst.iter() {\n    if i == min_index {\n      result = result.append(max_index)\n      max_index = i\n    } else if i == max_index {\n      result = result.append(min_index)\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjm9visag.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpjm9visag.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpjm9visag.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjm9visag.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpjm9visag.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpjm9visag.rs:21:20\n   |\n21 |       max_value = i\n   |                    ^ help: add `;` here\n22 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjm9visag.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpjm9visag.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpjm9visag.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpjm9visag.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    } else if i > max {\n      max = i;\n    }\n    result.append(i);\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^\n   |                   |\n   |                   expected `&isize`, found `isize`\n   |                   help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:21:19\n   |\n21 |     result.append(i);\n   |                   ^ types differ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                      found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:23:17\n   |\n23 |   result.append(min);\n   |                 ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:24:17\n   |\n24 |   result.append(max);\n   |                 ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting due to 7 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = vec![];\n  for i in lst {\n    if i < min {\n      result = result.append(i);\n    } else if i > max {\n      result = result.append(i);\n    } else {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpq1ysll10.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpq1ysll10.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ysll10.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ysll10.rs:17:30\n   |\n17 |       result = result.append(i);\n   |                              ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ysll10.rs:17:16\n   |\n14 |   let result = vec![];\n   |                ------ expected due to this value\n...\n17 |       result = result.append(i);\n   |                ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpq1ysll10.rs:17:23\n   |\n17 |       result = result.append(i);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ysll10.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.set(i, min);\n    } else if i == max_index {\n      result.set(i, max);\n    } else {\n      result.set(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9knwfehx.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp9knwfehx.rs:19:14\n    |\n19  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n19  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no me",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result = result.append(i);\n    } else if i > max {\n      result = result.append(i);\n    } else {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:30\n   |\n17 |       result = result.append(i);\n   |                              ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:16\n   |\n14 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n17 |       result = result.append(i);\n   |                ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpez6grb8u.rs:17:23\n   |\n17 |       result = result.append(i);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return lst;\n  }\n  let min_index = 0;\n  let max_index = lst_len - 1;\n  let min_value = lst[min_index];\n  let max_value = lst[max_index];\n  let min_value_index = 0;\n  let max_value_index = 0;\n  let i = 0;\n  for i in 0..lst_len {\n    if lst[i] < min_value {\n      min_value = lst[i];\n      min_value_index = i;\n    }\n    if lst[i] > max_value {\n      max_value = lst[i];\n      max_value_index = i;\n    }\n  }\n  let result = Vec::new(lst_len);\n  for i in 0..lst_len {\n    if i == min_value_index {\n      result[i] = min_value;\n    } else if i == max_value_index {\n      result[i] = max_value;\n    } else {\n      result[i] = lst[i];\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpatsjnb_a.rs:33:16\n    |\n33  |   let result = Vec::new(lst_len);\n    |                ^^^^^^^^ ------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result.unsafe_slice(min_index, max_index - min_index + 1)\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpkla_g63j.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpkla_g63j.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpkla_g63j.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpkla_g63j.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpkla_g63j.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpkla_g63j.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpkla_g63j.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpkla_g63j.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpkla_g63j.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpkla_g63j.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min = lst[0];\n    let max = lst[0];\n    for i in lst.iter() {\n        if i < min {\n            min = i;\n        } else if i > max {\n            max = i;\n        }\n    }\n    let result = Vec::new(lst.len());\n    for i in lst.iter() {\n        if i == min {\n            result.append(max);\n            max = min;\n            min = lst[i];\n        } else if i == max {\n            result.append(min);\n            min = max;\n            max = lst[i];\n        } else {\n            result.append(i);\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmptcbi6rrx.rs:15:16\n   |\n15 |         if i < min {\n   |                ^^^\n   |                |\n   |                expected `&isize`, found `isize`\n   |                help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptcbi6rrx.rs:16:19\n   |\n12 |     let min = lst[0];\n   |               ------ expected due to this value\n...\n16 |             min = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |             min = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptcbi6rrx.rs:17:23\n   |\n17 |         } else if i > max {\n   |                       ^^^\n   |                       |\n   |                       expected `&isize`, found `isize`\n   |                       help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptcbi6rrx.rs:18:19\n   |\n13 |     let max = lst[0];\n   |               ------ expected due to this value\n...\n18 |             max = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |             max = *i;\n   |                   +\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmptcbi6rrx.rs:21:18\n    |\n21  |     let result = Vec::new(lst.len());\n    |                  ^^^^^^^^ --------- supplied 1 argument\n    |                  |\n    |                  expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmptcbi6rrx.rs:23:14\n   |\n23 |         if i == min {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new(lst.len() + 2);\n  let i = 0;\n  for (let v of lst) {\n    if (v < min) {\n      result[i] = min;\n      min = v;\n    } else if (v > max) {\n      result[i] = max;\n      max = v;\n    } else {\n      result[i] = v;\n    }\n    i += 1;\n  }\n  result[i] = min;\n  result[i + 1] = max;\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp06vutuwk.rs:16:8\n   |\n16 |   for (let v of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `v`\n  --> /tmp/tmp06vutuwk.rs:16:12\n   |\n16 |   for (let v of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp06vutuwk.rs:16:14\n   |\n16 |   for (let v of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmp06vutuwk.rs:16:17\n   |\n16 |   for (let v of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp06vutuwk.rs:16:21\n   |\n16 |   for (let v of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found `result`\n  --> /tmp/tmp06vutuwk.rs:28:3\n   |\n28 |   result[i] = min;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n28 |   { result[i] = min; }\n   |   +                  +\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp06vutuwk.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp06vutuwk.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp06vutuwk.rs:14:16\n    |\n14  |   let result = Vec::new(lst.len() + 2);\n    |                ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min_index = 0\n    let max_index = 0\n    for i in lst.iter() {\n        if i < lst[min_index] {\n            min_index = i\n        }\n        if i > lst[max_index] {\n            max_index = i\n        }\n    }\n    let min_value = lst[min_index]\n    let max_value = lst[max_index]\n    let result = Vec::new()\n    for i in lst.iter() {\n        if i == min_value {\n            result = result.append(max_value)\n            max_value = lst[max_index]\n            max_index = max_index + 1\n        } else if i == max_value {\n            result = result.append(min_value)\n            min_value = lst[min_index]\n            min_index = min_index + 1\n        } else {\n            result = result.append(i)\n        }\n    }\n    return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpoere7pj5.rs:12:22\n   |\n12 |     let min_index = 0\n   |                      ^ help: add `;` here\n13 |     let max_index = 0\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpoere7pj5.rs:13:22\n   |\n13 |     let max_index = 0\n   |                      ^ help: add `;` here\n14 |     for i in lst.iter() {\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpoere7pj5.rs:22:35\n   |\n22 |     let min_value = lst[min_index]\n   |                                   ^ help: add `;` here\n23 |     let max_value = lst[max_index]\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpoere7pj5.rs:23:35\n   |\n23 |     let max_value = lst[max_index]\n   |                                   ^ help: add `;` here\n24 |     let result = Vec::new()\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpoere7pj5.rs:24:28\n   |\n24 |     let result = Vec::new()\n   |                            ^ help: add `;` here\n25 |     for i in lst.iter() {\n   |     --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpoere7pj5.rs:27:46\n   |\n27 |             result = result.append(max_value)\n   |                                              ^ help: add `;` here\n28 |             max_value = lst[max_index]\n   |             --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpoere7pj5.rs:28:39\n   |\n28 |             max_value = lst[max_index]\n   |                                       ^ help: add `;` here\n29 |             max_index = max_index + 1\n   |             --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpoere7pj5.rs:31:46\n   |\n31 |             result = result.append(min_value)\n   |                                              ^ help: add `;` here\n32 |             min_value = lst[min_index]\n   |             --------- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpoere7pj5",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result = result.append(max);\n      max = lst[max_index];\n      max_index = lst.index_of(max);\n    } else if i == max_index {\n      result = result.append(min);\n      min = lst[min_index];\n      min_index = lst.index_of(min);\n    } else {\n      result = result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpem3hljko.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpem3hljko.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpem3hljko.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpem3hljko.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpem3hljko.rs:19:30\n   |\n19 |       result = result.append(max);\n   |                              ^^^\n   |                              |\n   |                              expected `&mut Vec<_>`, found struct `Vec`\n   |                              help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpem3hljko.rs:19:16\n   |\n16 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n19 |       result = result.append(max);\n   |                ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpem3hljko.rs:19:23\n   |\n19 |       result = result.append(max);\n   |                ------ ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result.unsafe_slice(min_index, max_index - min_index + 1)\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpkla_g63j.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpkla_g63j.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpkla_g63j.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpkla_g63j.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpkla_g63j.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpkla_g63j.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpkla_g63j.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpkla_g63j.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpkla_g63j.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpkla_g63j.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let min_index = lst.index_of(min);\n  let max_index = lst.index_of(max);\n  let max_index_next = max_index + 1;\n  let max_index_next_next = max_index_next + 1;\n  let min_index_next = min_index + 1;\n  let min_index_next_next = min_index_next + 1;\n  let result = lst.slice(min_index_next, max_index_next_next);\n  result = result.append(lst.slice(min_index, min_index_next));\n  result = result.append(lst.slice(max_index_next_next, max_index));\n  result = result.append(lst.slice(min_index_next_next, max_index_next));\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmphyq8p40d.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmphyq8p40d.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmphyq8p40d.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmphyq8p40d.rs:15:23\n   |\n15 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmphyq8p40d.rs:20:20\n   |\n20 |   let result = lst.slice(min_index_next, max_index_next_next);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n20 |   let result = lst.as_slice(min_index_next, max_index_next_next);\n   |                    ~~~~~~~~\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmphyq8p40d.rs:21:30\n   |\n21 |   result = result.append(lst.slice(min_index, min_index_next));\n   |                              ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_idx = lst.index_of(max);\n  let min_idx = lst.index_of(min);\n  let result = Vec::new(lst.len() - 1);\n  let i = 0;\n  for (let j = 0; j < lst.len(); j++) {\n    if (j == max_idx) {\n      result[i] = min;\n      i += 1;\n    } else if (j == min_idx) {\n      result[i] = max;\n      i += 1;\n    } else {\n      result[i] = lst[j];\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpvm8qjem4.rs:18:8\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `j`\n  --> /tmp/tmpvm8qjem4.rs:18:12\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpvm8qjem4.rs:18:14\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpvm8qjem4.rs:18:13\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpvm8qjem4.rs:18:14\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |              ^ expected expression\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpvm8qjem4.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpvm8qjem4.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpvm8qjem4.rs:14:21\n   |\n14 |   let max_idx = lst.index_of(max);\n   |                     ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpvm8qjem4.rs:15:21\n   |\n15 |   let min_idx = lst.index_of(min);\n   |                     ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this fu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut max_index = 0;\n  let mut min_index = 0;\n  let mut min_index_set = false;\n  let mut max_index_set = false;\n\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n      min_index = i;\n      min_index_set = true;\n    }\n    if i > max {\n      max = i;\n      max_index = i;\n      max_index_set = true;\n    }\n  }\n\n  if min_index_set {\n    result = result.append(min);\n  }\n  if max_index_set {\n    result = result.append(max);\n  }\n\n  for i in lst.iter() {\n    if i == min_index {\n      result = result.append(max);\n    }\n    if i == max_index {\n      result = result.append(min);\n    }\n    result = result.append(i);\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp402xa28z.rs:21:12\n   |\n21 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp402xa28z.rs:22:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n22 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp402xa28z.rs:23:19\n   |\n16 |   let mut min_index = 0;\n   |                       - expected due to this value\n...\n23 |       min_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |       min_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp402xa28z.rs:26:12\n   |\n26 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp402xa28z.rs:27:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n27 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n27 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp402xa28z.rs:28:19\n   |\n15 |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n28 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |       max_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp402xa28z.rs:34:28\n   |\n34 |     result = result.append(min);\n   |                            ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = lst[min_index]\n      max_index = min_index\n      min_value = lst[min_index]\n      min_index = min_index + 1\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = lst[max_index]\n      min_index = max_index\n      max_value = lst[max_index]\n      max_index = max_index + 1\n    } else {\n      result = result.append(i)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvl2p32h.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphvl2p32h.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphvl2p32h.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvl2p32h.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmphvl2p32h.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvl2p32h.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvl2p32h.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmphvl2p32h.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = lst[min_index]\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvl2p32h.rs:30:33\n   |\n30 |       max_value = lst[min_index]\n   |                                 ^ help: add `;` here\n31 |       max_index = min_index\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmphvl2p32h",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  let i = 0;\n  for i in 0..lst.len() {\n    if lst[i] == min {\n      result.append(max);\n      i += 1;\n      if i < lst.len() {\n        max = lst[i];\n      }\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpp4849utt.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpp4849utt.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp4849utt.rs:17:18\n   |\n17 |     if lst[i] == min {\n   |                  ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp4849utt.rs:18:21\n   |\n18 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp4849utt.rs:21:15\n   |\n13 |   let max = lst.max();\n   |             --------- expected due to this value\n...\n21 |         max = lst[i];\n   |               ^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp4849utt.rs:24:21\n   |\n24 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_val = lst.min();\n  let max_val = lst.max();\n  let min_index = lst.index_of(min_val);\n  let max_index = lst.index_of(max_val);\n  let min_index_rev = lst.index_of(max_val) - 1;\n  let max_index_rev = lst.index_of(min_val) - 1;\n  let result = Vec::new(lst.len() + 2);\n  for i in 0..lst.len() {\n    if i == min_index {\n      result[i] = max_val;\n      result[i + 1] = min_val;\n    } else if i == max_index {\n      result[i] = min_val;\n      result[i + 1] = max_val;\n    } else if i == min_index_rev {\n      result[i] = max_val;\n      result[i + 1] = min_val;\n    } else if i == max_index_rev {\n      result[i] = min_val;\n      result[i + 1] = max_val;\n    } else {\n      result[i] = lst[i];\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwj9wmh15.rs:12:21\n    |\n12  |   let min_val = lst.min();\n    |                     ^^^- supplied 0 arguments\n    |                     |\n    |                     expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwj9wmh15.rs:13:21\n    |\n13  |   let max_val = lst.max();\n    |                     ^^^- supplied 0 arguments\n    |                     |\n    |                     expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwj9wmh15.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min_val);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwj9wmh15.rs:15:23\n   |\n15 |   let max_index = lst.index_of(max_val);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwj9wmh15.rs:16:27\n   |\n16 |   let min_index_rev = lst.index_of(max_val) - 1;\n   |                           ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwj9wmh15.rs:17:27\n   |\n17 |   let max_index_rev = lst.index_of(min_val) - 1;\n   |                           ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwj9wmh15.rs:18:16\n    |\n18  |   let result = Vec::new(lst.len() + 2);\n    |                ^^^^^^^^ ------------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwj9wmh15.rs:33:19\n   |\n33 |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst.get(0);\n  let mut max = lst.get(0);\n  let mut i = 1;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(i);\n      min = lst.get(i);\n    }\n    if i == max {\n      result.append(i);\n      max = lst.get(i);\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(i);\n      min = lst.get(i);\n    }\n    if i == max {\n      result.append(i);\n      max = lst.get(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpi3q4t_71.rs:17:12\n   |\n17 |     if i < min {\n   |            ^^^ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi3q4t_71.rs:18:13\n   |\n13 |   let mut min = lst.get(0);\n   |                 ---------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n18 |       min = Some(i);\n   |             +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi3q4t_71.rs:20:12\n   |\n20 |     if i > max {\n   |            ^^^ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi3q4t_71.rs:21:13\n   |\n14 |   let mut max = lst.get(0);\n   |                 ---------- expected due to this value\n...\n21 |       max = i;\n   |             ^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n21 |       max = Some(i);\n   |             +++++ +\n\nerror[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpi3q4t_71.rs:25:10\n   |\n25 |     if i == min {\n   |          ^^ no implementation for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi3q4t_71.rs:26:21\n   |\n26 |       result.append(i);\n   |                     ^ types differ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min_value {\n      result.push(i);\n    } else if i > max_value {\n      result.push(i);\n    } else {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp43u7w9a7.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp43u7w9a7.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43u7w9a7.rs:16:12\n   |\n16 |     if i < min_value {\n   |            ^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43u7w9a7.rs:18:19\n   |\n18 |     } else if i > max_value {\n   |                   ^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.push(max);\n      max = lst[i];\n    } else if i == max {\n      result.push(min);\n      min = lst[i];\n    } else {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpb1kt_l76.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1kt_l76.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1kt_l76.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1kt_l76.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpb1kt_l76.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpb1kt_l76.rs:26:13\n   |\n26 |       max = lst[i];\n   |             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let rest = lst.filter(x => x < min || x > max);\n  let result = [min];\n  for i in rest {\n    result.push(i);\n  }\n  result.push(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpvxbldt44.rs:14:27\n   |\n14 |   let rest = lst.filter(x => x < min || x > max);\n   |                           ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in 0..min {\n    result.append(lst[i]);\n  }\n  for i in max..lst.len() {\n    result.append(lst[i]);\n  }\n  for i in 0..min {\n    result.append(lst[i]);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpct6x5te6.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpct6x5te6.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpct6x5te6.rs:15:15\n   |\n15 |   for i in 0..min {\n   |               ^^^ expected integer, found struct `Vec`\n   |\n   = note: expected type `{integer}`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpct6x5te6.rs:16:19\n   |\n16 |     result.append(lst[i]);\n   |                   ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpct6x5te6.rs:18:17\n   |\n18 |   for i in max..lst.len() {\n   |                 ^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `usize`\n\nerror[E0277]: the trait bound `Vec<isize>: Step` is not satisfied\n  --> /tmp/tmpct6x5te6.rs:18:12\n   |\n18 |   for i in max..lst.len() {\n   |            ^^^^^^^^^^^^^^ the trait `Step` is not implemented for `Vec<isize>`\n   |\n   = help: the following other types implement trait `Step`:\n             char\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n             u128\n           and 5 others\n   = note: required because of the requirements on the impl of `Iterator` for `std::ops::Range<Vec<isize>>`\n   = note: required because of the requirements on the impl of `IntoIterator` for `std::ops::Range<Vec<isize>>`\n\nerror[E0277]: t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  let result = Vec::new()\n\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(min_index)\n    }\n    if i == max_value {\n      result = result.append(max_index)\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4v2povze.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp4v2povze.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp4v2povze.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp4v2povze.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4v2povze.rs:16:26\n   |\n16 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n17 | \n18 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp4v2povze.rs:20:20\n   |\n20 |       min_value = i\n   |                    ^ help: add `;` here\n21 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp4v2povze.rs:24:20\n   |\n24 |       max_value = i\n   |                    ^ help: add `;` here\n25 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4v2povze.rs:19:12\n   |\n19 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4v2povze.rs:20:19\n   |\n14 |   let min_value = lst[0]\n   |                   ------ expected due to this value\n...\n20 |       min_value = i\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       min_val",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = vec![];\n  for i in lst {\n    if i < min {\n      result = result.append(i);\n    } else if i > max {\n      result = result.append(i);\n    } else {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpq1ysll10.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpq1ysll10.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ysll10.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ysll10.rs:17:30\n   |\n17 |       result = result.append(i);\n   |                              ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ysll10.rs:17:16\n   |\n14 |   let result = vec![];\n   |                ------ expected due to this value\n...\n17 |       result = result.append(i);\n   |                ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpq1ysll10.rs:17:23\n   |\n17 |       result = result.append(i);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ysll10.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index(min_value);\n  let max_index = lst.index(max_value);\n  let max_value_index = lst.index(max_value);\n  let min_value_index = lst.index(min_value);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result = result.append(max_value);\n    } else if i == max_index {\n      result = result.append(min_value);\n    } else if i == min_value_index {\n      result = result.append(max_value);\n    } else if i == max_value_index {\n      result = result.append(min_value);\n    } else {\n      result = result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmppp4mrcq_.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmppp4mrcq_.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmppp4mrcq_.rs:14:23\n   |\n14 |   let min_index = lst.index(min_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmppp4mrcq_.rs:15:23\n   |\n15 |   let max_index = lst.index(max_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmppp4mrcq_.rs:16:29\n   |\n16 |   let max_value_index = lst.index(max_value);\n   |                             ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.push(max);\n      max = i;\n    } else if i == max {\n      result.push(min);\n      min = i;\n    } else {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp2j3z18el.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2j3z18el.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2j3z18el.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2j3z18el.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp2j3z18el.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2j3z18el.rs:26:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n26 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n26 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp2j3z18el.rs:27:17\n   |\n27 |     } else if i == max {\n   |                 ^^ no imple",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.first\n  let max = lst.last\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i < min {\n      min = i\n    }\n    if i > max {\n      max = i\n    }\n    result.append(i)\n  }\n  result.append(min)\n  result.append(max)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpd4307gbf.rs:12:22\n   |\n12 |   let min = lst.first\n   |                      ^ help: add `;` here\n13 |   let max = lst.last\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpd4307gbf.rs:13:21\n   |\n13 |   let max = lst.last\n   |                     ^ help: add `;` here\n14 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpd4307gbf.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `result`\n  --> /tmp/tmpd4307gbf.rs:24:21\n   |\n24 |   result.append(min)\n   |                     ^ help: add `;` here\n25 |   result.append(max)\n   |   ------ unexpected token\n\nerror: expected `;`, found keyword `return`\n  --> /tmp/tmpd4307gbf.rs:25:21\n   |\n25 |   result.append(max)\n   |                     ^ help: add `;` here\n26 |   return result\n   |   ------ unexpected token\n\nerror[E0615]: attempted to take value of method `first` on type `Vec<isize>`\n  --> /tmp/tmpd4307gbf.rs:12:17\n   |\n12 |   let min = lst.first\n   |                 ^^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   let min = lst.first()\n   |                      ++\n\nerror[E0615]: attempted to take value of method `last` on type `Vec<isize>`\n  --> /tmp/tmpd4307gbf.rs:13:17\n   |\n13 |   let max = lst.last\n   |                 ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |   let max = lst.last()\n   |                     ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd4307gbf.rs:22:19\n   |\n22 |     result.append(i)\n   |                   ^ types differ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                      found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd4307gbf.rs:24:17\n   |\n24 |   result.append(min)\n   |                 ^^^ types differ in mutability\n   |\n   = note: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min_index = 0;\n  let mut max_index = 0;\n  let mut max_value = 0;\n  let mut min_value = 0;\n  let mut max_value_index = 0;\n  let mut min_value_index = 0;\n  let mut min_value_index_found = false;\n  let mut max_value_index_found = false;\n  let mut min_value_found = false;\n  let mut max_value_found = false;\n  let mut min_value_index_found_found = false;\n  let mut max_value_index_found_found = false;\n  let mut min_value_found_found = false;\n  let mut max_value_found_found = false;\n  let mut min_value_index_found_found_found = false;\n  let mut max_value_index_found_found_found = false;\n  let mut min_value_found_found_found = false;\n  let mut max_value_found_found_found = false;\n  let mut min_value_index_found_found_found_found = false;\n  let mut max_value_index_found_found_found_found = false;\n  let mut min_value_found_found_found_found = false;\n  let mut max_value_found_found_found_found = false;\n  let mut min_value_index_found_found_found_found = false;\n  let mut max_value_index_found_found_found_found = false;\n  let mut min_value_found_found_found_found = false;\n  let mut max_value_found_found_found_found = false;\n  let mut min_value_index_found_found_found_found = false;\n  let mut max_value_index_found_found_found_found = false;\n  let mut min_value_found_found_found_found = false;\n  let mut max_value_found_found_found_found = false;\n  let mut min_value_index_found_found_found_found = false;\n  let mut max_value_index_found\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpn_15yvbt.rs:44:32\n   |\n44 |   let mut max_value_index_found\n   |                                ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn_15yvbt.rs:11:42\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result = result.append(i);\n    } else if i > max {\n      result = result.append(i);\n    } else {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:30\n   |\n17 |       result = result.append(i);\n   |                              ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:16\n   |\n14 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n17 |       result = result.append(i);\n   |                ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpez6grb8u.rs:17:23\n   |\n17 |       result = result.append(i);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return lst;\n  }\n  let min_index = 0;\n  let max_index = lst_len - 1;\n  let min_value = lst[min_index];\n  let max_value = lst[max_index];\n  let min_value_index = 0;\n  let max_value_index = 0;\n  for i in 0..lst_len - 1 {\n    if lst[i] < min_value {\n      min_value = lst[i];\n      min_value_index = i;\n    }\n    if lst[i] > max_value {\n      max_value = lst[i];\n      max_value_index = i;\n    }\n  }\n  let result = Vec::new(lst_len);\n  for i in 0..lst_len - 1 {\n    if i == min_value_index {\n      result[i] = min_value;\n    } else if i == max_value_index {\n      result[i] = max_value;\n    } else {\n      result[i] = lst[i];\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmppmbto0ze.rs:32:16\n    |\n32  |   let result = Vec::new(lst_len);\n    |                ^^^^^^^^ ------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = i;\n    } else if i == max {\n      result.append(min);\n      min = i;\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp91a_x7sw.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:25:21\n   |\n25 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:26:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n26 |       max = i;\n   |             ^ exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.find(max);\n  let min_index = lst.find(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.set(i, min);\n    } else if i == max_index {\n      result.set(i, max);\n    } else {\n      result.set(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp3prd_x29.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp3prd_x29.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp3prd_x29.rs:14:23\n   |\n14 |   let max_index = lst.find(max);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp3prd_x29.rs:15:23\n   |\n15 |   let min_index = lst.find(min);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp3prd_x29.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp3prd_x29.rs:19:14\n    |\n19  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n19  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no method named `set` found f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min = lst.min();\n    let max = lst.max();\n    let max_index = lst.index_of(max);\n    let min_index = lst.index_of(min);\n\n    let result = Vec::new();\n    for i in lst.iter() {\n        if i == min {\n            result = result.append(max);\n            max = lst[max_index];\n            max_index = lst.index_of(max);\n        } else if i == max {\n            result = result.append(min);\n            min = lst[min_index];\n            min_index = lst.index_of(min);\n        } else {\n            result = result.append(i);\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpma8yzixb.rs:12:19\n    |\n12  |     let min = lst.min();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpma8yzixb.rs:13:19\n    |\n13  |     let max = lst.max();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpma8yzixb.rs:14:25\n   |\n14 |     let max_index = lst.index_of(max);\n   |                         ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpma8yzixb.rs:15:25\n   |\n15 |     let min_index = lst.index_of(min);\n   |                         ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `Vec<isize>`\n  --> /tmp/tmpma8yzixb.rs:19:14\n   |\n19 |         if i == min {\n   |              ^^ no implementation for `&isize == Vec<isize>`\n   |\n   = help: the trait `PartialEq<Vec<isize>>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpma8yzixb.rs:20:36\n   |\n20 |             result = result.append(max);\n   |                                    ^^^\n   |                                    |\n   |                                    expected `&mut Vec<_>`, found struct `Vec`\n   |                                    help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if (i < min) {\n      result.append(lst[i]);\n    } else if (i > max) {\n      result.append(lst[i]);\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpno2pn1c0.rs:16:8\n   |\n16 |     if (i < min) {\n   |        ^       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i < min) {\n16 +     if i < min {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpno2pn1c0.rs:18:15\n   |\n18 |     } else if (i > max) {\n   |               ^       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (i > max) {\n18 +     } else if i > max {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpno2pn1c0.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpno2pn1c0.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpno2pn1c0.rs:16:13\n   |\n16 |     if (i < min) {\n   |             ^^^ expected `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpno2pn1c0.rs:17:21\n   |\n17 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpno2pn1c0.rs:18:20\n   |\n18 |     } else if (i > max) {\n   |                    ^^^ expected `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpno2pn1c0.rs:19:21\n   |\n19 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&mut Vec<_>`,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_idx = lst.index_of(max);\n  let min_idx = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_idx {\n      result.set(i, min);\n    } else if i == max_idx {\n      result.set(i, max);\n    } else {\n      result.set(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpj7uhgim1.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpj7uhgim1.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpj7uhgim1.rs:14:21\n   |\n14 |   let max_idx = lst.index_of(max);\n   |                     ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpj7uhgim1.rs:15:21\n   |\n15 |   let min_idx = lst.index_of(min);\n   |                     ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpj7uhgim1.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmpj7uhgim1.rs:19:14\n    |\n19  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n19  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no method nam",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    } else if i < max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n\n  let min_value = lst[0]\n  let min_index = 0\n  for i in lst.iter() {\n    if i > min_value {\n      min_value = i\n      min_index = i\n    } else if i < min_value {\n      min_value = i\n      min_index = i\n    }\n  }\n\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(min_index)\n    } else if i == max_value {\n      result = result.append(max_index)\n    } else {\n      result = result.append(i)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpszj62lm9.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpszj62lm9.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpszj62lm9.rs:14:25\n   |\n14 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpszj62lm9.rs:17:20\n   |\n17 |       max_value = i\n   |                    ^ help: add `;` here\n18 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpszj62lm9.rs:20:20\n   |\n20 |       max_value = i\n   |                    ^ help: add `;` here\n21 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpszj62lm9.rs:25:25\n   |\n25 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n26 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpszj62lm9.rs:26:20\n   |\n26 |   let min_index = 0\n   |                    ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpszj62lm9.rs:29:20\n   |\n29 |       min_value = i\n   |                    ^ help: add `;` here\n30 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpszj62lm9.rs:32:20\n   |\n32 |       min_value = i\n   |                    ^ help: add `;` here\n33 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpszj62lm9.rs:37:26\n   |\n37 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n38 | ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut max_index = 0;\n  let mut min_index = 0;\n  let mut max_index_prev = 0;\n  let mut min_index_prev = 0;\n  let mut max_index_prev_prev = 0;\n  let mut min_index_prev_prev = 0;\n  let mut max_index_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmph7n6t7zy.rs:37:85\n   |\n37 |   let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\n   |                                                                                     ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph7n6t7zy.rs:11:42\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.first();\n  let max = lst.last();\n  let result = Vec::new();\n  let i = 0;\n  for i in 0..lst.len() - 1 {\n    if lst[i] < min {\n      result = result.append(lst[i]);\n      min = lst[i];\n    } else if lst[i] > max {\n      result = result.append(lst[i]);\n      max = lst[i];\n    }\n  }\n  result = result.append(lst[i]);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp5c93mrya.rs:17:17\n   |\n17 |     if lst[i] < min {\n   |                 ^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5c93mrya.rs:18:30\n   |\n18 |       result = result.append(lst[i]);\n   |                              ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5c93mrya.rs:18:16\n   |\n14 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n18 |       result = result.append(lst[i]);\n   |                ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmp5c93mrya.rs:18:23\n   |\n18 |       result = result.append(lst[i]);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5c93mrya.rs:19:13\n   |\n12 |   let min = lst.first();\n   |             ----------- expected due to this value\n...\n19 |       min = lst[i];\n   |             ^^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5c93mrya.rs:20:24\n   |\n20 |     } else if lst[i] > max {\n   |                        ^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5c93mrya.rs:21:30\n   |\n21 |       result = result.append(lst[i]);\n   |                              ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expec",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new(lst.len());\n  let i = 0;\n  for (let i = 0; i < lst.len(); i++) {\n    if (lst[i] == min) {\n      result[i] = max;\n    } else if (lst[i] == max) {\n      result[i] = min;\n    } else {\n      result[i] = lst[i];\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp7wo3jc25.rs:16:8\n   |\n16 |   for (let i = 0; i < lst.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp7wo3jc25.rs:16:12\n   |\n16 |   for (let i = 0; i < lst.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp7wo3jc25.rs:16:14\n   |\n16 |   for (let i = 0; i < lst.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp7wo3jc25.rs:16:13\n   |\n16 |   for (let i = 0; i < lst.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp7wo3jc25.rs:16:14\n   |\n16 |   for (let i = 0; i < lst.len(); i++) {\n   |              ^ expected expression\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp7wo3jc25.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp7wo3jc25.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp7wo3jc25.rs:14:16\n    |\n14  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 8 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.set(i, min);\n    } else if i == max_index {\n      result.set(i, max);\n    } else {\n      result.set(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9knwfehx.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp9knwfehx.rs:19:14\n    |\n19  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n19  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no me",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i == min {\n      result = result.append(max);\n      max = min;\n      min = lst[0];\n    } else if i == max {\n      result = result.append(min);\n      min = max;\n      max = lst[0];\n    } else {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpgb1zxtg3.rs:15:12\n   |\n15 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgb1zxtg3.rs:16:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n16 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgb1zxtg3.rs:18:12\n   |\n18 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgb1zxtg3.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpgb1zxtg3.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgb1zxtg3.rs:25:30\n   |\n25 |       result = result.append(max);\n   |                              ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgb1zxtg3.rs:25:16\n   |\n22 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n25 |       result = result.append(",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = i;\n    } else if i == max {\n      result.append(min);\n      min = i;\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp91a_x7sw.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:25:21\n   |\n25 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:26:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n26 |       max = i;\n   |             ^ exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if (i < min) {\n      min = i;\n    } else if (i > max) {\n      max = i;\n    }\n    result.push(i);\n  }\n  result.push(min);\n  result.push(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi06pqaez.rs:16:8\n   |\n16 |     if (i < min) {\n   |        ^       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i < min) {\n16 +     if i < min {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi06pqaez.rs:18:15\n   |\n18 |     } else if (i > max) {\n   |               ^       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (i > max) {\n18 +     } else if i > max {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi06pqaez.rs:16:13\n   |\n16 |     if (i < min) {\n   |             ^^^\n   |             |\n   |             expected `&isize`, found `isize`\n   |             help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi06pqaez.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi06pqaez.rs:18:20\n   |\n18 |     } else if (i > max) {\n   |                    ^^^\n   |                    |\n   |                    expected `&isize`, found `isize`\n   |                    help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi06pqaez.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi06pqaez.rs:23:15\n   |\n23 |   result.push(min);\n   |               ^^^\n   |               |\n   |               expected `&isize`, found `isize`\n   |               help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi06pqaez.rs:24:15\n   |\n24 |   result.push(max);\n   |               ^^^\n   |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result.append(min_index)\n    }\n    if i == max_value {\n      result.append(max_index)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxbakvxqv.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxbakvxqv.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxbakvxqv.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxbakvxqv.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpxbakvxqv.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpxbakvxqv.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxbakvxqv.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbakvxqv.rs:17:12\n   |\n17 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbakvxqv.rs:18:19\n   |\n14 |   let min_value = lst[0]\n   |                   ------ expected due to this value\n...\n18 |       min_value = i\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min_value = *i\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.push(max);\n      max = lst[i];\n    } else if i == max {\n      result.push(min);\n      min = lst[i];\n    } else {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpb1kt_l76.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1kt_l76.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1kt_l76.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1kt_l76.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpb1kt_l76.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpb1kt_l76.rs:26:13\n   |\n26 |       max = lst[i];\n   |             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = vec![];\n  for i in 0..lst.len() {\n    if (i == 0) {\n      result = vec![min];\n    } else if (i == lst.len() - 1) {\n      result = vec![max];\n    } else {\n      result = vec![min, max];\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8htyq6xe.rs:16:8\n   |\n16 |     if (i == 0) {\n   |        ^      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i == 0) {\n16 +     if i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8htyq6xe.rs:18:15\n   |\n18 |     } else if (i == lst.len() - 1) {\n   |               ^                  ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (i == lst.len() - 1) {\n18 +     } else if i == lst.len() - 1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp8htyq6xe.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp8htyq6xe.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8htyq6xe.rs:24:10\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                                          ---------- expected `Vec<isize>` because of return type\n...\n24 |   return result;\n   |          ^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let lst_len = lst.len();\n  if (lst_len == 0) {\n    return lst;\n  }\n\n  let min_idx = 0;\n  let max_idx = lst_len - 1;\n  let min_val = lst[min_idx];\n  let max_val = lst[max_idx];\n\n  let min_idx_prev = min_idx;\n  let max_idx_prev = max_idx;\n\n  for (let i = 0; i < lst_len; i++) {\n    if (lst[i] < min_val) {\n      min_idx_prev = min_idx;\n      min_idx = i;\n      min_val = lst[i];\n    } else if (lst[i] > max_val) {\n      max_idx_prev = max_idx;\n      max_idx = i;\n      max_val = lst[i];\n    }\n  }\n\n  let result = Vec::new(lst_len);\n  for (let i = 0; i < lst_len; i++) {\n    if (i == min_idx) {\n      result[i] = min_val;\n    } else if (i == max_idx) {\n      result[i] = max_val;\n    } else {\n      result[i] = lst[i];\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpj39matkf.rs:25:8\n   |\n25 |   for (let i = 0; i < lst_len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpj39matkf.rs:25:12\n   |\n25 |   for (let i = 0; i < lst_len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpj39matkf.rs:25:14\n   |\n25 |   for (let i = 0; i < lst_len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpj39matkf.rs:25:13\n   |\n25 |   for (let i = 0; i < lst_len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpj39matkf.rs:25:14\n   |\n25 |   for (let i = 0; i < lst_len; i++) {\n   |              ^ expected expression\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj39matkf.rs:13:6\n   |\n13 |   if (lst_len == 0) {\n   |      ^            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   if (lst_len == 0) {\n13 +   if lst_len == 0 {\n   | \n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    } else if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = []\n  for i in lst.iter() {\n    if i == min_value {\n      result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result.append(i)\n    }\n  }\n  result.append(min_value)\n  result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbv887g77.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpbv887g77.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpbv887g77.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbv887g77.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpbv887g77.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpbv887g77.rs:21:20\n   |\n21 |       max_value = i\n   |                    ^ help: add `;` here\n22 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbv887g77.rs:25:18\n   |\n25 |   let result = []\n   |                  ^ help: add `;` here\n26 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpbv887g77.rs:28:31\n   |\n28 |       result.append(max_value)\n   |                               ^ help: add `;` here\n29 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpbv887g77.rs:29:20\n   |\n29 |       max_value = i\n   |                    ^ help: add `;` here\n30 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpbv887g77.rs:32:31\n   |\n32 |       result.append(min_value)\n   |                          ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = lst[min_index]\n      max_index = min_index\n      min_value = lst[min_index]\n      min_index = min_index + 1\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = lst[max_index]\n      min_index = max_index\n      max_value = lst[max_index]\n      max_index = max_index + 1\n    } else {\n      result = result.append(i)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvl2p32h.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphvl2p32h.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphvl2p32h.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvl2p32h.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmphvl2p32h.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvl2p32h.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvl2p32h.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmphvl2p32h.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = lst[min_index]\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvl2p32h.rs:30:33\n   |\n30 |       max_value = lst[min_index]\n   |                                 ^ help: add `;` here\n31 |       max_index = min_index\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmphvl2p32h",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut i = 1;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(i);\n      min = i;\n    }\n    if i == max {\n      result.append(i);\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(i);\n      min = i;\n    }\n    if i == max {\n      result.append(i);\n      max = i;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpresx8r5b.rs:17:12\n   |\n17 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpresx8r5b.rs:18:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n18 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpresx8r5b.rs:20:12\n   |\n20 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpresx8r5b.rs:21:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n21 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpresx8r5b.rs:25:10\n   |\n25 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpresx8r5b.rs:26:21\n   |\n26 |       result.append(i);\n   |                     ^ types differ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                      found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpresx8r5b.rs:27:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n27 |       min = i;\n   |             ^ expected `isize`,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  let i = 0;\n  for (let j = 0; j < lst.len(); j++) {\n    if (j == max_index) {\n      result[i] = min;\n      i += 1;\n    } else if (j == min_index) {\n      result[i] = max;\n      i += 1;\n    } else {\n      result[i] = lst[j];\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpx0eo9cu2.rs:18:8\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `j`\n  --> /tmp/tmpx0eo9cu2.rs:18:12\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpx0eo9cu2.rs:18:14\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpx0eo9cu2.rs:18:13\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpx0eo9cu2.rs:18:14\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |              ^ expected expression\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpx0eo9cu2.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpx0eo9cu2.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpx0eo9cu2.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpx0eo9cu2.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let max_value = lst[0]\n  let min_value = lst[0]\n  for i in lst.iter() {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_index {\n      result = result.append(i)\n    }\n    if i == max_index {\n      result = result.append(i)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_juhu4m6.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp_juhu4m6.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp_juhu4m6.rs:14:25\n   |\n14 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_juhu4m6.rs:15:25\n   |\n15 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp_juhu4m6.rs:18:20\n   |\n18 |       max_value = i\n   |                    ^ help: add `;` here\n19 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp_juhu4m6.rs:22:20\n   |\n22 |       min_value = i\n   |                    ^ help: add `;` here\n23 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_juhu4m6.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_juhu4m6.rs:17:12\n   |\n17 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_juhu4m6.rs:18:19\n   |\n14 |   let max_value = lst[0]\n   |                   ------ expected due to this value\n...\n18 |       max_value = i\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       max_value = *i\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let min_index = lst.index_of(min);\n  let max_index = lst.index_of(max);\n  let max_index_next = lst.index_of(max) + 1;\n  let min_index_next = lst.index_of(min) + 1;\n\n  let max_index_next_next = lst.index_of(max) + 2;\n  let min_index_next_next = lst.index_of(min) + 2;\n\n  let max_index_next_next_next = lst.index_of(max) + 3;\n  let min_index_next_next_next = lst.index_of(min) + 3;\n\n  let max_index_next_next_next_next = lst.index_of(max) + 4;\n  let min_index_next_next_next_next = lst.index_of(min) + 4;\n\n  let max_index_next_next_next_next_next = lst.index_of(max) + 5;\n  let min_index_next_next_next_next_next = lst.index_of(min) + 5;\n\n  let max_index_next_next_next_next_next_next = lst.index_of(max) + 6;\n  let min_index_next_next_next_next_next_next = lst.index_of(min) + 6;\n\n  let max_index_next_next_next_next_next_next_next = lst.index_of(max) + 7;\n  let min_index_next_next_next_next_next_next_next = lst.index_of(min) + 7;\n\n  let max_index_next_next_next_next_next_next_next_next = lst.index_of(max) + 8;\n  let min_index_next_next_next_next_next_next_next_next = lst.index_of(min) + 8;\n\n  let max_index_next_next_next_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpcxy381wu.rs:40:32\n   |\n40 |   let max_index_next_next_next_\n   |                                ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpcxy381wu.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpcxy381wu.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcxy381wu.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcxy381wu.rs:15:23\n   |\n15 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcxy381wu.rs:16:28\n   |\n16 |   let max_index_next = lst.index_of(max) + 1;\n   |                            ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcxy381wu.rs:17:28\n   |\n17 |   let min_index_next = lst.index_of(min) + 1;\n   |                            ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcxy381wu.rs:19:33\n   |\n19 |   let max_index_next_next = lst.index_of(max) + 2;\n   |                                 ^^^^^^^^ method not found in `Vec<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut i = 0;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = i;\n    } else if i == max {\n      result.append(min);\n      min = i;\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpxyr4f_z1.rs:17:12\n   |\n17 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyr4f_z1.rs:18:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n18 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyr4f_z1.rs:20:12\n   |\n20 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyr4f_z1.rs:21:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n21 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpxyr4f_z1.rs:25:10\n   |\n25 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyr4f_z1.rs:26:21\n   |\n26 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyr4f_z1.rs:27:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n27 |       max = i;\n   |             ^ exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return Vec::new();\n  }\n\n  let min_index = 0;\n  let max_index = lst_len - 1;\n  let min_value = lst[min_index];\n  let max_value = lst[max_index];\n\n  let result = Vec::new();\n  for i in 0..lst_len {\n    if min_value == max_value {\n      result = result.append(min_value);\n      min_value = lst[min_index];\n      max_value = lst[max_index];\n      min_index = (min_index + 1) % lst_len;\n      max_index = (max_index - 1 + lst_len) % lst_len;\n    } else if min_value < max_value {\n      result = result.append(min_value);\n      min_value = lst[min_index];\n      min_index = (min_index + 1) % lst_len;\n    } else {\n      result = result.append(max_value);\n      max_value = lst[max_index];\n      max_index = (max_index - 1 + lst_len) % lst_len;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpq1ekujw9.rs:25:30\n   |\n25 |       result = result.append(min_value);\n   |                              ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ekujw9.rs:25:16\n   |\n22 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n25 |       result = result.append(min_value);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpq1ekujw9.rs:25:23\n   |\n25 |       result = result.append(min_value);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ekujw9.rs:31:30\n   |\n31 |       result = result.append(min_value);\n   |                              ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1ekujw9.rs:31:16\n   |\n22 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n31 |       result = result.append(min_value);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpq1ekujw9.rs:31:23\n   |\n31 |       result = result.append(min_value);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let max_value_index = lst.index_of(max_value);\n  let min_value_index = lst.index_of(min_value);\n  let max_value_index_next = lst.index_of(max_value) + 1;\n  let min_value_index_next = lst.index_of(min_value) + 1;\n  let result = Vec::new(lst.len() - 2);\n  for i in 0..lst.len() - 2 {\n    if i == max_value_index_next {\n      result = result.append(max_value);\n      max_value_index_next += 1;\n    } else if i == min_value_index_next {\n      result = result.append(min_value);\n      min_value_index_next += 1;\n    } else {\n      result = result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpcohl9j8_.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpcohl9j8_.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcohl9j8_.rs:14:29\n   |\n14 |   let max_value_index = lst.index_of(max_value);\n   |                             ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcohl9j8_.rs:15:29\n   |\n15 |   let min_value_index = lst.index_of(min_value);\n   |                             ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcohl9j8_.rs:16:34\n   |\n16 |   let max_value_index_next = lst.index_of(max_value) + 1;\n   |                                  ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcohl9j8_.rs:17:34\n   |\n17 |   let min_value_index_next = lst.index_of(min_value) + 1;\n   |                                  ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcohl9j8_.rs:18:16\n    |\n18  |   let result = Vec::new(lst.len() - 2);\n    |                ^^^^^^^^ ------------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined he",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index(min_value);\n  let max_index = lst.index(max_value);\n  let max_value_index = lst.index(max_value);\n  let min_value_index = lst.index(min_value);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result = result.append(max_value);\n    } else if i == max_index {\n      result = result.append(min_value);\n    } else if i == min_value_index {\n      result = result.append(max_value);\n    } else if i == max_value_index {\n      result = result.append(min_value);\n    } else {\n      result = result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmppp4mrcq_.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmppp4mrcq_.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmppp4mrcq_.rs:14:23\n   |\n14 |   let min_index = lst.index(min_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmppp4mrcq_.rs:15:23\n   |\n15 |   let max_index = lst.index(max_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmppp4mrcq_.rs:16:29\n   |\n16 |   let max_value_index = lst.index(max_value);\n   |                             ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.find(max);\n  let min_index = lst.find(min);\n  let result = lst.slice(min_index, max_index + 1);\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpmhvpzrw3.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpmhvpzrw3.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmhvpzrw3.rs:14:23\n   |\n14 |   let max_index = lst.find(max);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmhvpzrw3.rs:15:23\n   |\n15 |   let min_index = lst.find(min);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmhvpzrw3.rs:16:20\n   |\n16 |   let result = lst.slice(min_index, max_index + 1);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n16 |   let result = lst.as_slice(min_index, max_index + 1);\n   |                    ~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min = lst[0];\n    let max = lst[0];\n    let result = Vec::new();\n    for i in lst.iter() {\n        if i < min {\n            min = i;\n        } else if i > max {\n            max = i;\n        }\n        result.push(i);\n    }\n    result.push(min);\n    result.push(max);\n    return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp2ltmhz1p.rs:16:16\n   |\n16 |         if i < min {\n   |                ^^^\n   |                |\n   |                expected `&isize`, found `isize`\n   |                help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ltmhz1p.rs:17:19\n   |\n12 |     let min = lst[0];\n   |               ------ expected due to this value\n...\n17 |             min = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ltmhz1p.rs:18:23\n   |\n18 |         } else if i > max {\n   |                       ^^^\n   |                       |\n   |                       expected `&isize`, found `isize`\n   |                       help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ltmhz1p.rs:19:19\n   |\n13 |     let max = lst[0];\n   |               ------ expected due to this value\n...\n19 |             max = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |             max = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ltmhz1p.rs:23:17\n   |\n23 |     result.push(min);\n   |                 ^^^\n   |                 |\n   |                 expected `&isize`, found `isize`\n   |                 help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ltmhz1p.rs:24:17\n   |\n24 |     result.push(max);\n   |                 ^^^\n   |                 |\n   |                 expected `&isize`, found `isize`\n   |                 help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ltmhz1p.rs:25:12\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                                          ---------- expected `Vec<isize>` because of return type\n...\n25 |     return result;\n   |            ^^^^^^ expected `isize`, found `&isize`\n   |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min = lst.min();\n    let max = lst.max();\n    let result = vec![];\n    for i in lst {\n        if i < min {\n            result = result.append(i);\n        } else if i > max {\n            result = result.append(i);\n        } else {\n            result = result.append(i);\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp74xitw0y.rs:12:19\n    |\n12  |     let min = lst.min();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp74xitw0y.rs:13:19\n    |\n13  |     let max = lst.max();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp74xitw0y.rs:16:16\n   |\n16 |         if i < min {\n   |                ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp74xitw0y.rs:17:36\n   |\n17 |             result = result.append(i);\n   |                                    ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp74xitw0y.rs:17:22\n   |\n14 |     let result = vec![];\n   |                  ------ expected due to this value\n...\n17 |             result = result.append(i);\n   |                      ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmp74xitw0y.rs:17:29\n   |\n17 |             result = result.append(i);\n   |                      ------ ^^^^^^ this call modifies `result` in-place\n   |                      |\n   |                      you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp74xitw0y.rs:18:23\n   |\n18 |         } else if i > max {\n   |                       ^^^ expected `isize`, found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.append(min);\n    } else if i == max_index {\n      result.append(max);\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:19:21\n   |\n19 |       result.append(min);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut min`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:21:21\n   |\n21 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:23:21\n   |\n23 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let max_value = lst[0]\n  let min_value = lst[0]\n  for i in lst.iter() {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n  }\n  let max_index_copy = max_index\n  let min_index_copy = min_index\n  let max_value_copy = max_value\n  let min_value_copy = min_value\n  for i in lst.iter() {\n    if i == max_value_copy {\n      max_index_copy = i\n    }\n    if i == min_value_copy {\n      min_index_copy = i\n    }\n  }\n  let result = []\n  for i in lst.iter() {\n    if i == max_index_copy {\n      result.append(max_value_copy)\n    }\n    if i == min_index_copy {\n      result.append(min_value_copy)\n    }\n    result.append(i)\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpqcnygrrb.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpqcnygrrb.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpqcnygrrb.rs:14:25\n   |\n14 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpqcnygrrb.rs:15:25\n   |\n15 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpqcnygrrb.rs:18:20\n   |\n18 |       max_value = i\n   |                    ^ help: add `;` here\n19 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpqcnygrrb.rs:22:20\n   |\n22 |       min_value = i\n   |                    ^ help: add `;` here\n23 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpqcnygrrb.rs:26:33\n   |\n26 |   let max_index_copy = max_index\n   |                                 ^ help: add `;` here\n27 |   let min_index_copy = min_index\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpqcnygrrb.rs:27:33\n   |\n27 |   let min_index_copy = min_index\n   |                                 ^ help: add `;` here\n28 |   let max_value_copy = max_value\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpqcnygrrb.rs:28:33\n   |\n28 |   let max_value_copy = max_value\n   |                                 ^ help: add `;` here\n29 |   let min_value_copy = min_value\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpqcnygrrb",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return lst;\n  }\n\n  let min_idx = 0;\n  let max_idx = lst_len - 1;\n  let min_val = lst[min_idx];\n  let max_val = lst[max_idx];\n\n  for i in 0..lst_len - 1 {\n    if lst[i] < min_val {\n      min_val = lst[i];\n      min_idx = i;\n    }\n    if lst[i] > max_val {\n      max_val = lst[i];\n      max_idx = i;\n    }\n  }\n\n  let lst_new = Vec::new(lst_len);\n  for i in 0..lst_len - 1 {\n    lst_new[i] = lst[min_idx];\n    min_idx = (min_idx + 1) % lst_len;\n  }\n  lst_new[lst_len - 1] = lst[max_idx];\n  return lst_new;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpa58gzp4w.rs:33:17\n    |\n33  |   let lst_new = Vec::new(lst_len);\n    |                 ^^^^^^^^ ------- supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.find(max);\n  let min_index = lst.find(min);\n  let result = Vec::new();\n  let i = 0;\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.append(min);\n    } else if i == max_index {\n      result.append(max);\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp3pggnhbv.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp3pggnhbv.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp3pggnhbv.rs:14:23\n   |\n14 |   let max_index = lst.find(max);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp3pggnhbv.rs:15:23\n   |\n15 |   let min_index = lst.find(min);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pggnhbv.rs:20:21\n   |\n20 |       result.append(min);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut min`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pggnhbv.rs:22:21\n   |\n22 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3pggnhbv.rs:24:21\n   |\n24 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&mut Vec<_>`, found `isize",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.append(min);\n    } else if i == max_index {\n      result.append(max);\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:19:21\n   |\n19 |       result.append(min);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut min`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:21:21\n   |\n21 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:23:21\n   |\n23 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst.get(0);\n    let mut max = lst.get(0);\n    for i in lst.iter() {\n        if i < min {\n            min = i;\n        }\n        if i > max {\n            max = i;\n        }\n    }\n    for i in lst.iter() {\n        if i == min {\n            result.append(i);\n        }\n        if i == max {\n            result.append(i);\n        }\n    }\n    for i in lst.iter() {\n        if i == min {\n            result.append(i);\n        }\n        if i == max {\n            result.append(i);\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpeagr855w.rs:16:16\n   |\n16 |         if i < min {\n   |                ^^^ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeagr855w.rs:17:19\n   |\n13 |     let mut min = lst.get(0);\n   |                   ---------- expected due to this value\n...\n17 |             min = i;\n   |                   ^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n17 |             min = Some(i);\n   |                   +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeagr855w.rs:19:16\n   |\n19 |         if i > max {\n   |                ^^^ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeagr855w.rs:20:19\n   |\n14 |     let mut max = lst.get(0);\n   |                   ---------- expected due to this value\n...\n20 |             max = i;\n   |                   ^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n20 |             max = Some(i);\n   |                   +++++ +\n\nerror[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpeagr855w.rs:24:14\n   |\n24 |         if i == min {\n   |              ^^ no implementation for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeagr855w.rs:25:27\n   |\n25 |             result.append(i);\n   |                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = lst.slice(min_index, max_index + 1);\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:16:20\n   |\n16 |   let result = lst.slice(min_index, max_index + 1);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n16 |   let result = lst.as_slice(min_index, max_index + 1);\n   |                    ~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_idx = lst.find(max);\n  let min_idx = lst.find(min);\n\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if (i < min_idx) {\n      result.append(lst[i]);\n    } else if (i > max_idx) {\n      result.append(lst[i]);\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpve67t5nk.rs:19:8\n   |\n19 |     if (i < min_idx) {\n   |        ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -     if (i < min_idx) {\n19 +     if i < min_idx {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpve67t5nk.rs:21:15\n   |\n21 |     } else if (i > max_idx) {\n   |               ^           ^\n   |\nhelp: remove these parentheses\n   |\n21 -     } else if (i > max_idx) {\n21 +     } else if i > max_idx {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpve67t5nk.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpve67t5nk.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpve67t5nk.rs:14:21\n   |\n14 |   let max_idx = lst.find(max);\n   |                     ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpve67t5nk.rs:15:21\n   |\n15 |   let min_idx = lst.find(min);\n   |                     ^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpve67t5nk.rs:20:21\n   |\n20 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpve67t5nk.rs:22:21\n   |\n22 |       result.append(lst[i]);\n   |                     ^^^^^^ expected ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index(min_value);\n  let max_index = lst.index(max_value);\n  let max_value_index = lst.index(max_value);\n  let min_value_index = lst.index(min_value);\n  let max_value_index_next = lst.index(max_value) + 1;\n  let min_value_index_next = lst.index(min_value) + 1;\n  let max_value_index_prev = lst.index(max_value) - 1;\n  let min_value_index_prev = lst.index(min_value) - 1;\n  let max_value_index_next_next = lst.index(max_value) + 2;\n  let min_value_index_next_next = lst.index(min_value) + 2;\n  let max_value_index_prev_prev = lst.index(max_value) - 2;\n  let min_value_index_prev_prev = lst.index(min_value) - 2;\n  let max_value_index_next_prev = lst.index(max_value) + 1;\n  let min_value_index_next_prev = lst.index(min_value) + 1;\n  let max_value_index_prev_prev_prev = lst.index(max_value) - 1;\n  let min_value_index_prev_prev_prev = lst.index(min_value) - 1;\n  let max_value_index_next_prev_prev = lst.index(max_value) + 2;\n  let min_value_index_next_prev_prev = lst.index(min_value) + 2;\n  let max_value_index_prev_prev_prev_prev = lst.index(max_value) - 2;\n  let min_value_index_prev_prev_prev_prev = lst.index(min_value) - 2;\n  let max_value_index_next_prev_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp18ay0i63.rs:34:33\n   |\n34 |   let max_value_index_next_prev_\n   |                                 ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp18ay0i63.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp18ay0i63.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp18ay0i63.rs:14:23\n   |\n14 |   let min_index = lst.index(min_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp18ay0i63.rs:15:23\n   |\n15 |   let max_index = lst.index(max_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp18ay0i63.rs:16:29\n   |\n16 |   let max_value_index = lst.index(max_value);\n   |                             ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    } else if i > max {\n      max = i;\n    }\n    result.push_back(i);\n  }\n  result.push_back(min);\n  result.push_back(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmppduhx659.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppduhx659.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppduhx659.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^\n   |                   |\n   |                   expected `&isize`, found `isize`\n   |                   help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppduhx659.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppduhx659.rs:21:12\n   |\n21 |     result.push_back(i);\n   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppduhx659.rs:23:10\n   |\n23 |   result.push_back(min);\n   |          ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppduhx659.rs:24:10\n   |\n24 |   result.push_back(max);\n   |          ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result = result.append(i);\n    } else if i > max {\n      result = result.append(i);\n    } else {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:30\n   |\n17 |       result = result.append(i);\n   |                              ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:16\n   |\n14 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n17 |       result = result.append(i);\n   |                ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpez6grb8u.rs:17:23\n   |\n17 |       result = result.append(i);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = lst.slice(min_index, max_index + 1);\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:16:20\n   |\n16 |   let result = lst.slice(min_index, max_index + 1);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n16 |   let result = lst.as_slice(min_index, max_index + 1);\n   |                    ~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = lst[i];\n    } else if i == max {\n      result.append(min);\n      min = lst[i];\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpdng9cb04.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:25:21\n   |\n25 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpdng9cb04.rs:26:13\n   |\n26 |       max = lst[i];\n   |             ^^^^^^ slice indices are of type `usize` or ranges of `u",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut index = 0;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n      index = result.len();\n    }\n    if i > max {\n      max = i;\n    }\n    result.push_back(i);\n  }\n  result.set(index, min);\n  result.set(result.len() - 1, max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpbl9p6rhi.rs:17:12\n   |\n17 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbl9p6rhi.rs:18:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n18 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbl9p6rhi.rs:21:12\n   |\n21 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbl9p6rhi.rs:22:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n22 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |       max = *i;\n   |             +\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpbl9p6rhi.rs:24:12\n   |\n24 |     result.push_back(i);\n   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmpbl9p6rhi.rs:26:10\n    |\n26  |   result.set(index, min);\n    |          ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n26  |   Pin::new(result).set(index, min);\n    |   +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n26  |   Pin::new(&mut result).set(index, min);\n    |   +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n26  |   result.get(index, min);\n    |          ~~~\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmpbl9p6rhi.rs:27:10\n    |\n27  |   resul",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.set(i, min);\n    } else if i == max_index {\n      result.set(i, max);\n    } else {\n      result.set(i, lst.get(i));\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0r9suvlc.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0r9suvlc.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp0r9suvlc.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp0r9suvlc.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp0r9suvlc.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp0r9suvlc.rs:19:14\n    |\n19  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n19  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no me",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_val = lst.first();\n  let max_val = lst.last();\n  let min_index = 0;\n  let max_index = 0;\n  for i in lst.iter() {\n    if i < min_val {\n      min_val = i;\n      min_index = i;\n    } else if i > max_val {\n      max_val = i;\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i == min_index {\n      result.append(max_val);\n    } else if i == max_index {\n      result.append(min_val);\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpsvijx919.rs:17:12\n   |\n17 |     if i < min_val {\n   |            ^^^^^^^ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsvijx919.rs:18:17\n   |\n12 |   let min_val = lst.first();\n   |                 ----------- expected due to this value\n...\n18 |       min_val = i;\n   |                 ^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n18 |       min_val = Some(i);\n   |                 +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsvijx919.rs:19:19\n   |\n14 |   let min_index = 0;\n   |                   - expected due to this value\n...\n19 |       min_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       min_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsvijx919.rs:20:19\n   |\n20 |     } else if i > max_val {\n   |                   ^^^^^^^ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsvijx919.rs:21:17\n   |\n13 |   let max_val = lst.last();\n   |                 ---------- expected due to this value\n...\n21 |       max_val = i;\n   |                 ^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n21 |       max_val = Some(i);\n   |                 +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsvijx919.rs:22:19\n   |\n15 |   let max_index = 0;\n   |                   - expected due to this value\n...\n22 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |       max_index = *i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.find(max);\n  let min_index = lst.find(min);\n  let result = lst.slice(min_index, max_index + 1);\n  result.extend(lst.slice(0, min_index));\n  result.extend(lst.slice(max_index + 1, lst.len()));\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczfdgjca.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczfdgjca.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpczfdgjca.rs:14:23\n   |\n14 |   let max_index = lst.find(max);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpczfdgjca.rs:15:23\n   |\n15 |   let min_index = lst.find(min);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpczfdgjca.rs:16:20\n   |\n16 |   let result = lst.slice(min_index, max_index + 1);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n16 |   let result = lst.as_slice(min_index, max_index + 1);\n   |                    ~~~~~~~~\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpczfdgjca.rs:17:21\n   |\n17 |   result.extend(lst.slice(0, min_index));\n   |                     ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | u",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut max_index = 0;\n  let mut min_index = 0;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n      min_index = i;\n    }\n    if i > max {\n      max = i;\n      max_index = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min_index {\n      result.append(min);\n      min = lst[i + 1];\n      min_index = i + 1;\n    }\n    if i == max_index {\n      result.append(max);\n      max = lst[i + 1];\n      max_index = i + 1;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp800sjkdn.rs:18:12\n   |\n18 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp800sjkdn.rs:19:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n19 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp800sjkdn.rs:20:19\n   |\n16 |   let mut min_index = 0;\n   |                       - expected due to this value\n...\n20 |       min_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       min_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp800sjkdn.rs:22:12\n   |\n22 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp800sjkdn.rs:23:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n23 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp800sjkdn.rs:24:19\n   |\n15 |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n24 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp800sjkdn.rs:28:10\n   |\n28 |     if i == min_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let min_index = lst.index_of(min);\n  let max_index = lst.index_of(max);\n  let max_index_next = lst.index_of(max) + 1;\n  let max_index_next_next = lst.index_of(max) + 2;\n  let max_index_next_next_next = lst.index_of(max) + 3;\n  let max_index_next_next_next_next = lst.index_of(max) + 4;\n  let max_index_next_next_next_next_next = lst.index_of(max) + 5;\n  let max_index_next_next_next_next_next_next = lst.index_of(max) + 6;\n  let max_index_next_next_next_next_next_next_next = lst.index_of(max) + 7;\n  let max_index_next_next_next_next_next_next_next_next = lst.index_of(max) + 8;\n  let max_index_next_next_next_next_next_next_next_next_next = lst.index_of(max) + 9;\n  let max_index_next_next_next_next_next_next_next_next_next_next = lst.index_of(max) + 10;\n  let max_index_next_next_next_next_next_next_next_next_next_next_next = lst.index_of(max) + 11;\n  let max_index_next_next_next_next_next_next_next_next_next_next_next_next = lst.index_of(max) + 12;\n  let max_index_next_next_next_next_next_next_next_next_next_next_next_next_next = lst.index_of(max) + 13;\n  let max_index_next_next_next_next_next_next_next_next_next_next_next_next_next\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp6q65i4bq.rs:29:81\n   |\n29 |   let max_index_next_next_next_next_next_next_next_next_next_next_next_next_next\n   |                                                                                 ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp6q65i4bq.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp6q65i4bq.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp6q65i4bq.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp6q65i4bq.rs:15:23\n   |\n15 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp6q65i4bq.rs:16:28\n   |\n16 |   let max_index_next = lst.index_of(max) + 1;\n   |                            ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp6q65i4bq.rs:17:33\n   |\n17 |   let max_index_next_next = lst.index_of(max) + 2;\n   |                                 ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp6q65i4bq.rs:18:38\n   |\n18 |   let max_inde",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut last = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n    if i < last {\n      result.push(i);\n      last = i;\n    }\n  }\n  result.push(min);\n  result.push(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpyw6zce8k.rs:17:12\n   |\n17 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyw6zce8k.rs:18:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n18 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyw6zce8k.rs:20:12\n   |\n20 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyw6zce8k.rs:21:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n21 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyw6zce8k.rs:23:12\n   |\n23 |     if i < last {\n   |            ^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&last`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyw6zce8k.rs:25:14\n   |\n15 |   let mut last = lst[0];\n   |                  ------ expected due to this value\n...\n25 |       last = i;\n   |              ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n25 |       last = *i;\n   |              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyw6zce8k.rs:28:15\n   |\n28 |   result.push(min);\n   |               ^^^\n   |               |\n   |               expected `&isize`, found `isize`\n   |               help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyw6zce8k.rs:29:15\n   |\n29 |   result.push(max);\n   |               ^^^\n   |               |\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min_value = lst.min();\n    let max_value = lst.max();\n    let min_index = lst.index(min_value);\n    let max_index = lst.index(max_value);\n    let max_value_index = lst.index(max_value);\n    let min_value_index = lst.index(min_value);\n    let max_value_index_next = lst.index(max_value) + 1;\n    let min_value_index_next = lst.index(min_value) + 1;\n    let max_value_index_prev = lst.index(max_value) - 1;\n    let min_value_index_prev = lst.index(min_value) - 1;\n    let max_value_index_prev_next = lst.index(max_value) - 2;\n    let min_value_index_prev_next = lst.index(min_value) - 2;\n    let max_value_index_next_next = lst.index(max_value) + 2;\n    let min_value_index_next_next = lst.index(min_value) + 2;\n    let max_value_index_next_prev = lst.index(max_value) + 1;\n    let min_value_index_next_prev = lst.index(min_value) + 1;\n    let max_value_index_prev_prev = lst.index(max_value) - 1;\n    let min_value_index_prev_prev = lst.index(min_value) - 1;\n    let max_value_index_prev_prev_prev = lst.index(max_value) - 3;\n    let min_value_index_prev_prev_prev = lst.index(min_value) - 3;\n    let max_value_index_prev_prev_next = lst.index(max_value) - 2;\n    let min_value_index_prev_prev_next = lst.index(min_value) - 2;\n    let max_value_index_prev_next_next = lst.index(max\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmppz_ja78t.rs:35:1\n   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmppz_ja78t.rs:34:51\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                                                     - closing delimiter possibly meant for this\n...\n34 |     let max_value_index_prev_next_next = lst.index(max\n   |                                                   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmppz_ja78t.rs:12:25\n    |\n12  |     let min_value = lst.min();\n    |                         ^^^- supplied 0 arguments\n    |                         |\n    |                         expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmppz_ja78t.rs:13:25\n    |\n13  |     let max_value = lst.max();\n    |                         ^^^- supplied 0 arguments\n    |                         |\n    |                         expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmppz_ja78t.rs:14:25\n   |\n14 |     let min_index = lst.index(min_value);\n   |                         ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmppz_ja78t.rs:15:25\n   |\n15 |     let max_index = lst.index(max_value);\n   |                         ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index_of(min_value);\n  let max_index = lst.index_of(max_value);\n  let result = Vec::new();\n  for i in min_index..max_index {\n    result.append(lst[i]);\n  }\n  for i in max_index..min_index {\n    result.append(lst[i]);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwzgpsg56.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwzgpsg56.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwzgpsg56.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min_value);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwzgpsg56.rs:15:23\n   |\n15 |   let max_index = lst.index_of(max_value);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min = lst.min();\n    let max = lst.max();\n    let max_index = lst.index(max);\n    let min_index = lst.index(min);\n    let max_value = lst[max_index];\n    let min_value = lst[min_index];\n    let result = [min_value, max_value];\n    for i in lst.iter() {\n        if i == min_index {\n            result = [min_value, i, max_value];\n        } else if i == max_index {\n            result = [min_value, max_value, i];\n        } else {\n            result = [min_value, i, max_value];\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpn0lkox2h.rs:12:19\n    |\n12  |     let min = lst.min();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpn0lkox2h.rs:13:19\n    |\n13  |     let max = lst.max();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpn0lkox2h.rs:14:25\n   |\n14 |     let max_index = lst.index(max);\n   |                         ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpn0lkox2h.rs:15:25\n   |\n15 |     let min_index = lst.index(min);\n   |                         ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn0lkox2h.rs:21:22\n   |\n21 |             result = [min_value, i, max_value];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected an array with a fixed size of 2 elements, found one with 3 elements\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn0lkox2h.rs:23:22\n   |\n23 |             result = [min_value, max_value, i];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected an array with a fixed size of 2 elements, found one with 3 elements\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn0lkox2h.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min = lst.min();\n    let max = lst.max();\n    let max_idx = lst.find(max);\n    let min_idx = lst.find(min);\n    let temp = lst.get(max_idx);\n    lst.set(max_idx, lst.get(min_idx));\n    lst.set(min_idx, temp);\n    lst.remove(max);\n    lst.remove(min);\n    lst.insert(min, max);\n    lst.insert(max, min);\n    return lst;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpixc2f6vj.rs:12:19\n    |\n12  |     let min = lst.min();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpixc2f6vj.rs:13:19\n    |\n13  |     let max = lst.max();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpixc2f6vj.rs:14:23\n   |\n14 |     let max_idx = lst.find(max);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpixc2f6vj.rs:15:23\n   |\n15 |     let min_idx = lst.find(min);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `set` found for struct `Vec<isize>` in the current scope\n   --> /tmp/tmpixc2f6vj.rs:17:9\n    |\n17  |     lst.set(max_idx, lst.get(min_idx));\n    |         ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n17  |     Pin::new(lst).set(max_idx, lst.get(min_idx));\n    |     +++++++++   +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n17  |     Pin::new(&mut lst).set(max_idx, lst.get(min_idx));\n    |     +++++++++++++    +\nhelp: there is an associated function with a similar name\n    |\n17  |     lst.get(max_idx, lst.get(min_idx));\n    |         ~~~\n\nerror[E0599]: no method named `set` found for struct `Vec<isize>` in the current scope\n   --> /tmp/tmpixc2f6vj.rs:18:9\n    |\n18  |     lst.set(min_idx, temp);\n    |         ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n18  |     Pin::new(lst).set(min_idx, temp);\n    |  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.find(max);\n  let min_index = lst.find(min);\n  let max_index_next = lst.find(max, max_index + 1);\n  let min_index_next = lst.find(min, min_index + 1);\n  let max_index_prev = lst.find(max, max_index - 1);\n  let min_index_prev = lst.find(min, min_index - 1);\n  let max_index_prev_next = lst.find(max, max_index_prev + 1);\n  let min_index_next_prev = lst.find(min, min_index_next - 1);\n  let max_index_next_next = lst.find(max, max_index_next + 1);\n  let min_index_next_next_prev = lst.find(min, min_index_next_prev - 1);\n  let max_index_next_next_next = lst.find(max, max_index_next_next + 1);\n  let min_index_next_next_next_prev = lst.find(min, min_index_next_next_prev - 1);\n  let max_index_next_next_next_next = lst.find(max, max_index_next_next_next + 1);\n  let min_index_next_next_next_next_prev = lst.find(min, min_index_next_next_next_prev - 1);\n  let max_index_next_next_next_next_next = lst.find(max, max_index_next_next_next_next + 1);\n  let min_index_next_next_next_next_next_prev = lst.find(min, min_index_next_next_next_next_prev - 1);\n  let max_index_next_next_next_next_next_next = lst.find(max, max_index_next_next_next_next_next + 1);\n  let min_index_next_next_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpmy4hoxkv.rs:31:27\n   |\n31 |   let min_index_next_next_\n   |                           ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpmy4hoxkv.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpmy4hoxkv.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmy4hoxkv.rs:14:23\n   |\n14 |   let max_index = lst.find(max);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmy4hoxkv.rs:15:23\n   |\n15 |   let min_index = lst.find(min);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmy4hoxkv.rs:16:28\n   |\n16 |   let max_index_next = lst.find(max, max_index + 1);\n   |                            ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmy4hoxkv.rs:17:28\n   |\n17 |   let min_index_next = lst.find(min, min_index + 1);\n   |                            ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmy4hoxkv.rs:18:28\n   |\n18 |   let max_index_prev = lst.find(max, max_index - 1);\n   |                            ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut min_index = 0;\n  let mut max_index = 0;\n  let mut max_value = 0;\n  let mut min_value = 0;\n  let mut max_value_index = 0;\n  let mut min_value_index = 0;\n\n  for i in lst {\n    if i > max_value {\n      max_value = i;\n      max_value_index = i;\n    }\n    if i < min_value {\n      min_value = i;\n      min_value_index = i;\n    }\n  }\n\n  for i in lst {\n    if i == max_value {\n      min_index = max_index;\n      max_index = i;\n    }\n    if i == min_value {\n      max_index = min_index;\n      min_index = i;\n    }\n  }\n\n  let mut result = Vec::new();\n  for i in lst {\n    if i == max_value_index {\n      result = result.push(max_value);\n      result = result.push(min_value);\n    }\n    if i == min_value_index {\n      result = result.push(min_value);\n      result = result.push(max_value);\n    }\n    result = result.push(i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpu2wo9gob.rs:44:16\n   |\n41 |   let mut result = Vec::new();\n   |                    ---------- expected due to this value\n...\n44 |       result = result.push(max_value);\n   |                ^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu2wo9gob.rs:45:16\n   |\n41 |   let mut result = Vec::new();\n   |                    ---------- expected due to this value\n...\n45 |       result = result.push(min_value);\n   |                ^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpu2wo9gob.rs:45:23\n   |\n45 |       result = result.push(min_value);\n   |                ------ ^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu2wo9gob.rs:48:16\n   |\n41 |   let mut result = Vec::new();\n   |                    ---------- expected due to this value\n...\n48 |       result = result.push(min_value);\n   |                ^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpu2wo9gob.rs:48:23\n   |\n48 |       result = result.push(min_value);\n   |                ------ ^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu2wo9gob.rs:49:16\n   |\n41 |   let mut result = Vec::new();\n   |                    ---------- expected due to this value\n...\n49 |       result = result.push(max_value",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = lst[i]\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = lst[i]\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpy9tyx5zq.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpy9tyx5zq.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpy9tyx5zq.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpy9tyx5zq.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpy9tyx5zq.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpy9tyx5zq.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpy9tyx5zq.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpy9tyx5zq.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = lst[i]\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpy9tyx5zq.rs:30:25\n   |\n30 |       max_value = lst[i]\n   |                         ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpy9tyx5zq.rs:33:40\n   |\n33 |       result",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut max_index = 0;\n  let mut min_index = 0;\n\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n      min_index = i;\n    }\n    if i > max {\n      max = i;\n      max_index = i;\n    }\n  }\n\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = i;\n      max_index = i;\n    }\n    if i == max {\n      result.append(min);\n      min = i;\n      min_index = i;\n    }\n    if i == min_index {\n      result.append(max);\n      max = i;\n      max_index = i;\n    }\n    if i == max_index {\n      result.append(min);\n      min = i;\n      min_index = i;\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpj3mts2su.rs:19:12\n   |\n19 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3mts2su.rs:20:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3mts2su.rs:21:19\n   |\n16 |   let mut min_index = 0;\n   |                       - expected due to this value\n...\n21 |       min_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |       min_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3mts2su.rs:23:12\n   |\n23 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3mts2su.rs:24:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n24 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3mts2su.rs:25:19\n   |\n15 |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n25 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n25 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpj3mts2su.rs:30:10\n   |\n30 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = lst[max_index]\n      max_index = max_index + 1\n      min_value = lst[min_index]\n      min_index = min_index + 1\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = lst[min_index]\n      min_index = min_index + 1\n      max_value = lst[max_index]\n      max_index = max_index + 1\n    } else {\n      result = result.append(i)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpejzcga4a.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpejzcga4a.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpejzcga4a.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpejzcga4a.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpejzcga4a.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpejzcga4a.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpejzcga4a.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpejzcga4a.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = lst[max_index]\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpejzcga4a.rs:30:33\n   |\n30 |       max_value = lst[max_index]\n   |                                 ^ help: add `;` here\n31 |       max_index = max_index + 1\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpejzc",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.store(i, min);\n    } else if i == max_index {\n      result.store(i, max);\n    } else {\n      result.store(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpk2f22t91.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpk2f22t91.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpk2f22t91.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpk2f22t91.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpk2f22t91.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `store` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpk2f22t91.rs:19:14\n   |\n19 |       result.store(i, min);\n   |              ^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `store` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpk2f22t91.rs:21:14\n   |\n21 |       result.store(i, max);\n   |              ^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `store` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpk2f22t91.rs:23:14\n   |\n23 |       result.store(i, lst[i]);\n   |              ^^^^^ method not found in `Vec<_>`\n\nerro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index(min_value);\n  let max_index = lst.index(max_value);\n  let min_value_index = lst.index(min_value);\n  let max_value_index = lst.index(max_value);\n  let min_value_index_next = min_value_index + 1;\n  let max_value_index_next = max_value_index + 1;\n  let min_value_index_prev = min_value_index - 1;\n  let max_value_index_prev = max_value_index - 1;\n\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value);\n      result = result.append(min_value);\n    } else if i == max_value {\n      result = result.append(min_value);\n      result = result.append(max_value);\n    } else if i == min_value_index {\n      result = result.append(max_value);\n      result = result.append(min_value);\n    } else if i == max_value_index {\n      result = result.append(min_value);\n      result = result.append(max_value);\n    } else if i == min_value_index_next {\n      result = result.append(max_value);\n      result = result.append(min_value);\n    } else if i == max_value_index_next {\n      result = result.append(min_value);\n      result = result.append(max_value);\n    } else if i == min_value_index_prev {\n      result = result.append(max_value);\n      result = result.append(min_value);\n    } else if i == max_value_index_prev {\n      result = result.append(min_value);\n      result = result.append(max_value);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpga6vy2py.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpga6vy2py.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpga6vy2py.rs:14:23\n   |\n14 |   let min_index = lst.index(min_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpga6vy2py.rs:15:23\n   |\n15 |   let max_index = lst.index(max_value);\n   |                       ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpga6vy2py.rs:16:29\n   |\n16 |   let min_value_index = lst.index(min_value);\n   |                             ^^^^^ method not found in `Vec<isize>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0599]: no method named `index` found for struct `Vec<isize>` in ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  if len(lst) == 0 {\n    return Vec::new()\n  }\n\n  let min = lst[0]\n  let max = lst[0]\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i < min {\n      min = i\n    }\n    if i > max {\n      max = i\n    }\n    result = result.append(i)\n  }\n  result = result.append(min)\n  result = result.append(max)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpi_7ohbk8.rs:16:19\n   |\n16 |   let min = lst[0]\n   |                   ^ help: add `;` here\n17 |   let max = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpi_7ohbk8.rs:17:19\n   |\n17 |   let max = lst[0]\n   |                   ^ help: add `;` here\n18 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpi_7ohbk8.rs:18:26\n   |\n18 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n19 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `result`\n  --> /tmp/tmpi_7ohbk8.rs:28:30\n   |\n28 |   result = result.append(min)\n   |                              ^ help: add `;` here\n29 |   result = result.append(max)\n   |   ------ unexpected token\n\nerror: expected `;`, found keyword `return`\n  --> /tmp/tmpi_7ohbk8.rs:29:30\n   |\n29 |   result = result.append(max)\n   |                              ^ help: add `;` here\n30 |   return result\n   |   ------ unexpected token\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpi_7ohbk8.rs:12:6\n   |\n12 |   if len(lst) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi_7ohbk8.rs:20:12\n   |\n20 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi_7ohbk8.rs:21:13\n   |\n16 |   let min = lst[0]\n   |             ------ expected due to this value\n...\n21 |       min = i\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |       min = *i\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi_7ohbk8.rs:23:12\n   |\n23 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min = lst.min();\n    let max = lst.max();\n    let max_idx = lst.index_of(max);\n    let min_idx = lst.index_of(min);\n    let result = Vec::new(lst.len());\n    let i = 0;\n    for (i = 0; i < lst.len(); i++) {\n        if (i == min_idx) {\n            result.set(i, min);\n        } else if (i == max_idx) {\n            result.set(i, max);\n        } else {\n            result.set(i, lst.get(i));\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpvku2gfup.rs:18:12\n   |\n18 |     for (i = 0; i < lst.len(); i++) {\n   |            ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpvku2gfup.rs:18:11\n   |\n18 |     for (i = 0; i < lst.len(); i++) {\n   |           ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpvku2gfup.rs:18:12\n   |\n18 |     for (i = 0; i < lst.len(); i++) {\n   |            ^ expected expression\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpvku2gfup.rs:12:19\n    |\n12  |     let min = lst.min();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpvku2gfup.rs:13:19\n    |\n13  |     let max = lst.max();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpvku2gfup.rs:14:23\n   |\n14 |     let max_idx = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpvku2gfup.rs:15:23\n   |\n15 |     let min_idx = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpvku2gfup.rs:16:18\n    |\n16  |     let result = Vec::new(lst.len());\n    |                  ^^^^^^^^ --------- supplied 1 argument\n    |                  |\n    |                  expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let max_value = lst[0]\n  let min_value = lst[0]\n  for i in lst.iter() {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(min_index)\n    }\n    if i == max_value {\n      result = result.append(max_index)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmppwh7jaaq.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmppwh7jaaq.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmppwh7jaaq.rs:14:25\n   |\n14 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppwh7jaaq.rs:15:25\n   |\n15 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmppwh7jaaq.rs:18:20\n   |\n18 |       max_value = i\n   |                    ^ help: add `;` here\n19 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmppwh7jaaq.rs:22:20\n   |\n22 |       min_value = i\n   |                    ^ help: add `;` here\n23 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppwh7jaaq.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppwh7jaaq.rs:17:12\n   |\n17 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppwh7jaaq.rs:18:19\n   |\n14 |   let max_value = lst[0]\n   |                   ------ expected due to this value\n...\n18 |       max_value = i\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       max_value = *i\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let min_index = lst.index_of(min);\n  let max_index = lst.index_of(max);\n  let result = Vec::new(lst.len() - 1);\n  for i in 0..lst.len() - 1 {\n    let index = (i + min_index) % lst.len();\n    result[i] = lst[index];\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpspucqush.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpspucqush.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpspucqush.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpspucqush.rs:15:23\n   |\n15 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpspucqush.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len() - 1);\n    |                ^^^^^^^^ ------------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if (i < min) {\n      result.set(i, lst.get(i));\n    } else if (i > max) {\n      result.set(i, lst.get(i));\n    } else {\n      result.set(i, lst.get(i));\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm22w5g0h.rs:16:8\n   |\n16 |     if (i < min) {\n   |        ^       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i < min) {\n16 +     if i < min {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm22w5g0h.rs:18:15\n   |\n18 |     } else if (i > max) {\n   |               ^       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (i > max) {\n18 +     } else if i > max {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpm22w5g0h.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpm22w5g0h.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpm22w5g0h.rs:14:16\n    |\n14  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm22w5g0h.rs:16:13\n   |\n16 |     if (i < min) {\n   |             ^^^ expected `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n            found struct `Vec<isize>`\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmpm22w5g0h.rs:17:14\n    |\n17  |       result.set(i, lst.get(i));\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n17  |       Pin::new(result).set(i, lst.get(i));\n    |       +++++++++      +\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if (i < min) {\n      min = i;\n    } else if (i > max) {\n      max = i;\n    }\n    result.push_back(i);\n  }\n  result.push_back(min);\n  result.push_back(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmilzprpv.rs:16:8\n   |\n16 |     if (i < min) {\n   |        ^       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i < min) {\n16 +     if i < min {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmilzprpv.rs:18:15\n   |\n18 |     } else if (i > max) {\n   |               ^       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (i > max) {\n18 +     } else if i > max {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmilzprpv.rs:16:13\n   |\n16 |     if (i < min) {\n   |             ^^^\n   |             |\n   |             expected `&isize`, found `isize`\n   |             help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmilzprpv.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmilzprpv.rs:18:20\n   |\n18 |     } else if (i > max) {\n   |                    ^^^\n   |                    |\n   |                    expected `&isize`, found `isize`\n   |                    help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmilzprpv.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpmilzprpv.rs:21:12\n   |\n21 |     result.push_back(i);\n   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpmilzprpv.rs:23:10\n   |\n23 |   result.push_back(min);\n   |  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    } else if i > max {\n      max = i;\n    }\n    result.append(i);\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^\n   |                   |\n   |                   expected `&isize`, found `isize`\n   |                   help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:21:19\n   |\n21 |     result.append(i);\n   |                   ^ types differ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                      found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:23:17\n   |\n23 |   result.append(min);\n   |                 ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdmwd6_n6.rs:24:17\n   |\n24 |   result.append(max);\n   |                 ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting due to 7 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    } else if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpa8yi257g.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpa8yi257g.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpa8yi257g.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpa8yi257g.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 | \n17 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpa8yi257g.rs:19:20\n   |\n19 |       min_value = i\n   |                    ^ help: add `;` here\n20 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpa8yi257g.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpa8yi257g.rs:27:26\n   |\n27 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n28 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpa8yi257g.rs:30:40\n   |\n30 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n31 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpa8yi257g.rs:31:20\n   |\n31 |       max_value = i\n   |                    ^ help: add `;` here\n32 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpa8yi257g.rs:34:40\n   |\n34 |       result = result",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    } else if i > max {\n      max = i;\n    }\n    result = result.concat(vec![i, max, min]);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp1aj18wfi.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1aj18wfi.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1aj18wfi.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^\n   |                   |\n   |                   expected `&isize`, found `isize`\n   |                   help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1aj18wfi.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1aj18wfi.rs:21:36\n   |\n21 |     result = result.concat(vec![i, max, min]);\n   |                                    ^^^ expected `&isize`, found `isize`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1aj18wfi.rs:21:21\n    |\n21  |     result = result.concat(vec![i, max, min]);\n    |                     ^^^^^^ ----------------- supplied 1 argument\n    |                     |\n    |                     expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp1aj18wfi.rs:21:21\n    |\n21  |     result = result.concat(vec![i, max, min]);\n    |                     ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let max_value_index = lst.find(max_value);\n  let min_value_index = lst.find(min_value);\n  let max_value_index_next = max_value_index + 1;\n  let min_value_index_next = min_value_index + 1;\n  let max_value_index_prev = max_value_index - 1;\n  let min_value_index_prev = min_value_index - 1;\n\n  if (max_value_index_next < min_value_index_prev) {\n    return lst;\n  }\n\n  let max_value_index_next_prev = max_value_index_next - 1;\n  let min_value_index_next_prev = min_value_index_next - 1;\n\n  if (max_value_index_next_prev < min_value_index_prev) {\n    return lst;\n  }\n\n  let max_value_index_next_next = max_value_index_next + 1;\n  let min_value_index_next_next = min_value_index_next + 1;\n\n  if (max_value_index_next_next < min_value_index_next_prev) {\n    return lst;\n  }\n\n  let max_value_index_next_next_prev = max_value_index_next_next - 1;\n  let min_value_index_next_next_prev = min_value_index_next_next - 1;\n\n  if (max_value_index_next_next_prev < min_value_index_next_prev) {\n    return lst;\n  }\n\n  let max_value_index_next_next_next = max_value_index_next_next + 1;\n  let min_value_index_next_next_next = min_value_index_next_next + 1;\n\n  if (max_value_index_next_next_next < min_value_index_next_next_prev) {\n    return lst;\n  }\n\n  let max_value_\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpbr4813pr.rs:53:17\n   |\n53 |   let max_value_\n   |                 ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbr4813pr.rs:21:6\n   |\n21 |   if (max_value_index_next < min_value_index_prev) {\n   |      ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n21 -   if (max_value_index_next < min_value_index_prev) {\n21 +   if max_value_index_next < min_value_index_prev {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbr4813pr.rs:28:6\n   |\n28 |   if (max_value_index_next_prev < min_value_index_prev) {\n   |      ^                                                ^\n   |\nhelp: remove these parentheses\n   |\n28 -   if (max_value_index_next_prev < min_value_index_prev) {\n28 +   if max_value_index_next_prev < min_value_index_prev {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbr4813pr.rs:35:6\n   |\n35 |   if (max_value_index_next_next < min_value_index_next_prev) {\n   |      ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n35 -   if (max_value_index_next_next < min_value_index_next_prev) {\n35 +   if max_value_index_next_next < min_value_index_next_prev {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbr4813pr.rs:42:6\n   |\n42 |   if (max_value_index_next_next_prev < min_value_index_next_prev) {\n   |      ^                                                          ^\n   |\nhelp: remove these parentheses\n   |\n42 -   if (max_value_index_next_next_prev < min_value_index_next_prev) {\n42 +   if max_value_index_next_next_prev < min_value_index_next_prev {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbr4813pr.rs:49:6\n   |\n49 |   if (max_value_index_next_next_next < min_value_index_next_next_prev) {\n   |      ^                                                               ^\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.set(i, min);\n    } else if i == max_index {\n      result.set(i, max);\n    } else {\n      result.set(i, lst.get(i));\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0r9suvlc.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0r9suvlc.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp0r9suvlc.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp0r9suvlc.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp0r9suvlc.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp0r9suvlc.rs:19:14\n    |\n19  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n19  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no me",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = lst.slice(min_index, max_index + 1);\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:16:20\n   |\n16 |   let result = lst.slice(min_index, max_index + 1);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n16 |   let result = lst.as_slice(min_index, max_index + 1);\n   |                    ~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < lst.len) {\n    if (lst[i] == min) {\n      result.append(lst[i]);\n      i += 1;\n    } else if (lst[i] == max) {\n      result.append(lst[i]);\n      i += 1;\n    } else {\n      result.append(lst[i]);\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1zjh7qf5.rs:18:9\n   |\n18 |   while (i < lst.len) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n18 -   while (i < lst.len) {\n18 +   while i < lst.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1zjh7qf5.rs:19:8\n   |\n19 |     if (lst[i] == min) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (lst[i] == min) {\n19 +     if lst[i] == min {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1zjh7qf5.rs:22:15\n   |\n22 |     } else if (lst[i] == max) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (lst[i] == max) {\n22 +     } else if lst[i] == max {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp1zjh7qf5.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp1zjh7qf5.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp1zjh7qf5.rs:18:18\n   |\n18 |   while (i < lst.len) {\n   |                  ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n18 |   while (i < lst.len()) {\n   |                     ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1zjh7qf5.rs:19:19\n   |\n19 |     if (lst[i] == min) {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1zjh7qf5.rs:20:21\n   |\n20 |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let min_idx = lst.index_of(min);\n  let max_idx = lst.index_of(max);\n  let max_idx_next = lst.index_of(max) + 1;\n  let max_idx_prev = lst.index_of(max) - 1;\n  let min_idx_next = lst.index_of(min) + 1;\n  let min_idx_prev = lst.index_of(min) - 1;\n  let result = Vec::new(lst.len());\n  let i = 0;\n  for (i; i < min_idx; i++) {\n    result.store(i, lst.at(i));\n  }\n  for (i; i < max_idx_next; i++) {\n    result.store(i, lst.at(i));\n  }\n  for (i; i < min_idx_prev; i++) {\n    result.store(i, lst.at(i));\n  }\n  for (i; i < max_idx; i++) {\n    result.store(i, lst.at(i));\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `;`\n  --> /tmp/tmpod0q1mkd.rs:22:9\n   |\n22 |   for (i; i < min_idx; i++) {\n   |         ^\n   |         |\n   |         expected one of `)`, `,`, `@`, or `|`\n   |         help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `<`\n  --> /tmp/tmpod0q1mkd.rs:22:13\n   |\n22 |   for (i; i < min_idx; i++) {\n   |            -^ expected one of `)`, `,`, `@`, or `|`\n   |            |\n   |            help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `;`\n  --> /tmp/tmpod0q1mkd.rs:22:22\n   |\n22 |   for (i; i < min_idx; i++) {\n   |                      ^\n   |                      |\n   |                      expected one of `)`, `,`, `@`, or `|`\n   |                      help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `+`\n  --> /tmp/tmpod0q1mkd.rs:22:25\n   |\n22 |   for (i; i < min_idx; i++) {\n   |                         ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpod0q1mkd.rs:22:25\n   |\n22 |   for (i; i < min_idx; i++) {\n   |                         ^ help: try adding `in` here\n\nerror: expected expression, found `)`\n  --> /tmp/tmpod0q1mkd.rs:22:27\n   |\n22 |   for (i; i < min_idx; i++) {\n   |                           ^ expected expression\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpod0q1mkd.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpod0q1mkd.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpod0q1mkd.rs:14:21\n   |\n14 |   let min_",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result = result.append(i);\n    } else if i > max {\n      result = result.append(i);\n    } else {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:30\n   |\n17 |       result = result.append(i);\n   |                              ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:16\n   |\n14 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n17 |       result = result.append(i);\n   |                ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpez6grb8u.rs:17:23\n   |\n17 |       result = result.append(i);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index_of(min_value);\n  let max_index = lst.index_of(max_value);\n  let min_index_next = min_index + 1;\n  let max_index_next = max_index + 1;\n  let result = Vec::new();\n  let i = 0;\n  while (i < min_index_next) {\n    result = result.append(lst[i]);\n    i = i + 1;\n  }\n  while (i < max_index_next) {\n    result = result.append(lst[i]);\n    i = i + 1;\n  }\n  while (i < lst.len()) {\n    result = result.append(lst[i]);\n    i = i + 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpg4kefpq9.rs:20:9\n   |\n20 |   while (i < min_index_next) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -   while (i < min_index_next) {\n20 +   while i < min_index_next {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpg4kefpq9.rs:24:9\n   |\n24 |   while (i < max_index_next) {\n   |         ^                  ^\n   |\nhelp: remove these parentheses\n   |\n24 -   while (i < max_index_next) {\n24 +   while i < max_index_next {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpg4kefpq9.rs:28:9\n   |\n28 |   while (i < lst.len()) {\n   |         ^             ^\n   |\nhelp: remove these parentheses\n   |\n28 -   while (i < lst.len()) {\n28 +   while i < lst.len() {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpg4kefpq9.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpg4kefpq9.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpg4kefpq9.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min_value);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpg4kefpq9.rs:15:23\n   |\n15 |   let max_index = lst.index_of(max_value);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index_of(min_value);\n  let max_index = lst.index_of(max_value);\n  let min_index_plus_one = min_index + 1;\n  let max_index_minus_one = max_index - 1;\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result = result.append(max_value);\n    } else if i == max_index {\n      result = result.append(min_value);\n    } else if i == min_index_plus_one {\n      result = result.append(max_value);\n    } else if i == max_index_minus_one {\n      result = result.append(min_value);\n    } else {\n      result = result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpjwvaqh7t.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpjwvaqh7t.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpjwvaqh7t.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min_value);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpjwvaqh7t.rs:15:23\n   |\n15 |   let max_index = lst.index_of(max_value);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpjwvaqh7t.rs:18:16\n    |\n18  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwvaqh7t.rs:21:30\n   |\n21 |       result = result.append(max_value);\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&mut Vec<_>`, found struct `Vec`\n   |                              help: consider mutably borrowing here: `&mut max_value`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwvaqh7t.rs:21:16\n   |\n18 |   let result = Vec::new(lst.len",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new(lst.len())\n  for i in lst.iter() {\n    if i == min_index {\n      result.append(min_value)\n    }\n    if i == max_index {\n      result.append(max_value)\n    }\n    if i != min_index and i != max_index {\n      result.append(i)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpojg3bj10.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpojg3bj10.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpojg3bj10.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpojg3bj10.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpojg3bj10.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpojg3bj10.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpojg3bj10.rs:26:35\n   |\n26 |   let result = Vec::new(lst.len())\n   |                                   ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: `and` is not a logical operator\n  --> /tmp/tmpojg3bj10.rs:34:23\n   |\n34 |     if i != min_index and i != max_index {\n   |                       ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpojg3bj10.rs:17:12\n   |\n17 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min_value`\n\nerror",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = i;\n    } else if i == max {\n      result.append(min);\n      min = i;\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp91a_x7sw.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:25:21\n   |\n25 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:26:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n26 |       max = i;\n   |             ^ exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  if lst.len() == 0 {\n    return lst\n  }\n\n  let min_value = lst.get(0)\n  let max_value = lst.get(0)\n  let max_index = 0\n  let min_index = 0\n  let i = 1\n  for i in lst.iter() {\n    if lst.get(i) < min_value {\n      min_value = lst.get(i)\n      min_index = i\n    }\n    if lst.get(i) > max_value {\n      max_value = lst.get(i)\n      max_index = i\n    }\n  }\n\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_index {\n      result.append(min_value)\n    } else if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(lst.get(i))\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsn4wvuhn.rs:16:29\n   |\n16 |   let min_value = lst.get(0)\n   |                             ^ help: add `;` here\n17 |   let max_value = lst.get(0)\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsn4wvuhn.rs:17:29\n   |\n17 |   let max_value = lst.get(0)\n   |                             ^ help: add `;` here\n18 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsn4wvuhn.rs:18:20\n   |\n18 |   let max_index = 0\n   |                    ^ help: add `;` here\n19 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsn4wvuhn.rs:19:20\n   |\n19 |   let min_index = 0\n   |                    ^ help: add `;` here\n20 |   let i = 1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsn4wvuhn.rs:20:12\n   |\n20 |   let i = 1\n   |            ^ help: add `;` here\n21 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsn4wvuhn.rs:23:29\n   |\n23 |       min_value = lst.get(i)\n   |                             ^ help: add `;` here\n24 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsn4wvuhn.rs:27:29\n   |\n27 |       max_value = lst.get(i)\n   |                             ^ help: add `;` here\n28 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsn4wvuhn.rs:32:26\n   |\n32 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n33 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n   --> /tmp/tmpsn4wvuhn.rs:22:16\n    |\n22  |     if lst.get(i) < min_value {\n    |            --- ^ slice indices are of type `usize` or ranges of `usize`\n    |            |\n    |            required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = i;\n    } else if i == max {\n      result.append(min);\n      min = i;\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp91a_x7sw.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:25:21\n   |\n25 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:26:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n26 |       max = i;\n   |             ^ exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result.unsafe_slice(min_index, max_index - min_index + 1)\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpkla_g63j.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpkla_g63j.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpkla_g63j.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpkla_g63j.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpkla_g63j.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpkla_g63j.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpkla_g63j.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpkla_g63j.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpkla_g63j.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpkla_g63j.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index_of(min_value);\n  let max_index = lst.index_of(max_value);\n  let min_index_next = min_index + 1;\n  let max_index_next = max_index + 1;\n  let result = Vec::new(lst.len() - 2);\n  for i in 0..lst.len() - 2 {\n    if (i == min_index) {\n      result[i] = min_value;\n    } else if (i == max_index) {\n      result[i] = max_value;\n    } else if (i < min_index_next) {\n      result[i] = lst[i];\n    } else if (i > max_index_next) {\n      result[i] = lst[i];\n    } else {\n      result[i] = lst[i];\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpq2cccykx.rs:20:8\n   |\n20 |     if (i == min_index) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (i == min_index) {\n20 +     if i == min_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpq2cccykx.rs:22:15\n   |\n22 |     } else if (i == max_index) {\n   |               ^              ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == max_index) {\n22 +     } else if i == max_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpq2cccykx.rs:24:15\n   |\n24 |     } else if (i < min_index_next) {\n   |               ^                  ^\n   |\nhelp: remove these parentheses\n   |\n24 -     } else if (i < min_index_next) {\n24 +     } else if i < min_index_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpq2cccykx.rs:26:15\n   |\n26 |     } else if (i > max_index_next) {\n   |               ^                  ^\n   |\nhelp: remove these parentheses\n   |\n26 -     } else if (i > max_index_next) {\n26 +     } else if i > max_index_next {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpq2cccykx.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpq2cccykx.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpq2cccykx.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min_value);\n   |        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let max_value = lst[0]\n  let min_value = lst[0]\n  for i in lst.iter() {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(i)\n    }\n    if i == max_value {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp0qciccso.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp0qciccso.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp0qciccso.rs:14:25\n   |\n14 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp0qciccso.rs:15:25\n   |\n15 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp0qciccso.rs:18:20\n   |\n18 |       max_value = i\n   |                    ^ help: add `;` here\n19 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp0qciccso.rs:22:20\n   |\n22 |       min_value = i\n   |                    ^ help: add `;` here\n23 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp0qciccso.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `result`\n  --> /tmp/tmp0qciccso.rs:35:36\n   |\n35 |   result = result.append(min_value)\n   |                                    ^ help: add `;` here\n36 |   result = result.append(max_value)\n   |   ------ unexpected token\n\nerror: expected `;`, found keyword `return`\n  --> /tmp/tmp0qciccso.rs:36:36\n   |\n36 |   result = result.append(max_value)\n   |                                    ^ help: add `;` here\n37 |   return result\n   |   ------ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0qciccso.rs:17:12\n   |\n17 |     if i > ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  if lst.len == 0 {\n    return lst\n  }\n\n  let min = lst.head\n  let max = lst.head\n  let max_index = 0\n  let min_index = 0\n\n  for i in lst.tail {\n    if i < min {\n      min = i\n      min_index = i\n    } else if i > max {\n      max = i\n      max_index = i\n    }\n  }\n\n  let result = Vec::new()\n  for i in lst.tail {\n    if i == min {\n      result = result.append(min_index)\n    } else if i == max {\n      result = result.append(max_index)\n    } else {\n      result = result.append(i)\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb485dzaz.rs:16:21\n   |\n16 |   let min = lst.head\n   |                     ^ help: add `;` here\n17 |   let max = lst.head\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb485dzaz.rs:17:21\n   |\n17 |   let max = lst.head\n   |                     ^ help: add `;` here\n18 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb485dzaz.rs:18:20\n   |\n18 |   let max_index = 0\n   |                    ^ help: add `;` here\n19 |   let min_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpb485dzaz.rs:19:20\n   |\n19 |   let min_index = 0\n   |                    ^ help: add `;` here\n20 | \n21 |   for i in lst.tail {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpb485dzaz.rs:23:14\n   |\n23 |       min = i\n   |              ^ help: add `;` here\n24 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpb485dzaz.rs:26:14\n   |\n26 |       max = i\n   |              ^ help: add `;` here\n27 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpb485dzaz.rs:31:26\n   |\n31 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n32 |   for i in lst.tail {\n   |   --- unexpected token\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpb485dzaz.rs:12:10\n   |\n12 |   if lst.len == 0 {\n   |          ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   if lst.len() == 0 {\n   |             ++\n\nerror[E0609]: no field `head` on type `Vec<isize>`\n  --> /tmp/tmpb485dzaz.rs:16:17\n   |\n16 |   let min = lst.head\n   |                 ^^^^ unknown field\n\nerror[E0609]: no field `head` on type `Vec<isize>`\n  --> /tmp/tmpb485dzaz.rs:17:17\n   |\n17 |   let max = lst.head\n   |                 ^^^^ unknown field\n\nerror[E0609]: no field `tail` on type `Ve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result.append(min_index)\n    }\n    if i == max_value {\n      result.append(max_index)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxbakvxqv.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxbakvxqv.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxbakvxqv.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxbakvxqv.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpxbakvxqv.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpxbakvxqv.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxbakvxqv.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbakvxqv.rs:17:12\n   |\n17 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbakvxqv.rs:18:19\n   |\n14 |   let min_value = lst[0]\n   |                   ------ expected due to this value\n...\n18 |       min_value = i\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min_value = *i\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let lst_len = lst.len();\n  if (lst_len == 0) {\n    return lst;\n  }\n  let min_idx = 0;\n  let max_idx = lst_len - 1;\n  let min_val = lst[min_idx];\n  let max_val = lst[max_idx];\n  let idx = 0;\n  for (; idx < lst_len; idx++) {\n    if (lst[idx] < min_val) {\n      min_val = lst[idx];\n      min_idx = idx;\n    }\n    if (lst[idx] > max_val) {\n      max_val = lst[idx];\n      max_idx = idx;\n    }\n  }\n  let tmp = lst[min_idx];\n  lst[min_idx] = lst[max_idx];\n  lst[max_idx] = tmp;\n  return strange_sort_list(lst);\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmprrqsj57m.rs:21:8\n   |\n21 |   for (; idx < lst_len; idx++) {\n   |        ^ expected pattern\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprrqsj57m.rs:13:6\n   |\n13 |   if (lst_len == 0) {\n   |      ^            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   if (lst_len == 0) {\n13 +   if lst_len == 0 {\n   | \n\nerror: aborting due to previous error; 1 warning emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if (i < min) {\n      result.set(i, min);\n    } else if (i > max) {\n      result.set(i, max);\n    } else {\n      result.set(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3dkp2tby.rs:16:8\n   |\n16 |     if (i < min) {\n   |        ^       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i < min) {\n16 +     if i < min {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3dkp2tby.rs:18:15\n   |\n18 |     } else if (i > max) {\n   |               ^       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (i > max) {\n18 +     } else if i > max {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp3dkp2tby.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp3dkp2tby.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp3dkp2tby.rs:14:16\n    |\n14  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3dkp2tby.rs:16:13\n   |\n16 |     if (i < min) {\n   |             ^^^ expected `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n            found struct `Vec<isize>`\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp3dkp2tby.rs:17:14\n    |\n17  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n17  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_idx = lst.find(max);\n  let min_idx = lst.find(min);\n  let max_idx_next = lst.find(max, max_idx + 1);\n  let min_idx_next = lst.find(min, min_idx + 1);\n  let result = Vec::new(lst.len() - 2);\n  for i in 0..(lst.len() - 2) {\n    if (i == max_idx_next) {\n      result.set(i, max);\n      max_idx_next = lst.find(max, max_idx_next + 1);\n    } else if (i == min_idx_next) {\n      result.set(i, min);\n      min_idx_next = lst.find(min, min_idx_next + 1);\n    } else {\n      result.set(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp115jslsk.rs:20:8\n   |\n20 |     if (i == max_idx_next) {\n   |        ^                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (i == max_idx_next) {\n20 +     if i == max_idx_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp115jslsk.rs:23:15\n   |\n23 |     } else if (i == min_idx_next) {\n   |               ^                 ^\n   |\nhelp: remove these parentheses\n   |\n23 -     } else if (i == min_idx_next) {\n23 +     } else if i == min_idx_next {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp115jslsk.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp115jslsk.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp115jslsk.rs:14:21\n   |\n14 |   let max_idx = lst.find(max);\n   |                     ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp115jslsk.rs:15:21\n   |\n15 |   let min_idx = lst.find(min);\n   |                     ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp115jslsk.rs:16:26\n   |\n16 |   let max_idx_next = lst.find(max, max_idx + 1);\n   |                          ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp115jslsk.rs:17:26\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  let i = 0;\n  for i in 0..min {\n    result.push_back(lst[i]);\n  }\n  for i in max..lst.len() {\n    result.push_back(lst[i]);\n  }\n  for i in 0..min {\n    result.push_back(lst[i]);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpmp15omt1.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpmp15omt1.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmp15omt1.rs:16:15\n   |\n16 |   for i in 0..min {\n   |               ^^^ expected integer, found struct `Vec`\n   |\n   = note: expected type `{integer}`\n            found struct `Vec<isize>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpmp15omt1.rs:17:12\n   |\n17 |     result.push_back(lst[i]);\n   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmp15omt1.rs:19:17\n   |\n19 |   for i in max..lst.len() {\n   |                 ^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `usize`\n\nerror[E0277]: the trait bound `Vec<isize>: Step` is not satisfied\n  --> /tmp/tmpmp15omt1.rs:19:12\n   |\n19 |   for i in max..lst.len() {\n   |            ^^^^^^^^^^^^^^ the trait `Step` is not implemented for `Vec<isize>`\n   |\n   = help: the following other types implement trait `Step`:\n             char\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n             u128\n           and 5 others\n   = note: required because of the requirements on the impl of `Iterator` for `std::ops::Range<Vec<isize>>`\n   = note: required because of the requirements on the impl of `IntoIterator` for `std::ops::Range<Vec<isize>>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.set(i, min);\n    } else if i == max_index {\n      result.set(i, max);\n    } else {\n      result.set(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9knwfehx.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp9knwfehx.rs:19:14\n    |\n19  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n19  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no me",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    } else if i > max {\n      max = i;\n    }\n    result.push_back(i);\n  }\n  result.push_back(min);\n  result.push_back(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmppduhx659.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppduhx659.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppduhx659.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^\n   |                   |\n   |                   expected `&isize`, found `isize`\n   |                   help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppduhx659.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppduhx659.rs:21:12\n   |\n21 |     result.push_back(i);\n   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppduhx659.rs:23:10\n   |\n23 |   result.push_back(min);\n   |          ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppduhx659.rs:24:10\n   |\n24 |   result.push_back(max);\n   |          ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  let i = 0;\n  for i in 0..lst.len() {\n    if lst[i] == min {\n      result.append(max);\n      max = lst[i];\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpe50tma1s.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpe50tma1s.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:17:18\n   |\n17 |     if lst[i] == min {\n   |                  ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:18:21\n   |\n18 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:19:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due to this value\n...\n19 |       max = lst[i];\n   |             ^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:21:21\n   |\n21 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:24:17\n   |\n24 |   result.append(min);\n   |                 ^^^\n   |                 |\n   |                 expected `&mut Vec<_>`, found struct `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = min;\n      min = lst[i];\n    } else if i == max {\n      result.append(min);\n      min = max;\n      max = lst[i];\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpx1xglr5b.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1xglr5b.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1xglr5b.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1xglr5b.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpx1xglr5b.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx1xglr5b.rs:25:21\n   |\n25 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpx1xglr5b.rs:27:13\n   |\n27 |       min = lst[i];\n   |             ^^^^^^ slice indices are of type `usize` or ranges of `u",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if (i < min) {\n      min = i;\n    } else if (i > max) {\n      max = i;\n    }\n    result.push_back(i);\n  }\n  result.push_back(min);\n  result.push_back(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmilzprpv.rs:16:8\n   |\n16 |     if (i < min) {\n   |        ^       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i < min) {\n16 +     if i < min {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmilzprpv.rs:18:15\n   |\n18 |     } else if (i > max) {\n   |               ^       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (i > max) {\n18 +     } else if i > max {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmilzprpv.rs:16:13\n   |\n16 |     if (i < min) {\n   |             ^^^\n   |             |\n   |             expected `&isize`, found `isize`\n   |             help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmilzprpv.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmilzprpv.rs:18:20\n   |\n18 |     } else if (i > max) {\n   |                    ^^^\n   |                    |\n   |                    expected `&isize`, found `isize`\n   |                    help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmilzprpv.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpmilzprpv.rs:21:12\n   |\n21 |     result.push_back(i);\n   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpmilzprpv.rs:23:10\n   |\n23 |   result.push_back(min);\n   |  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut min_index = 0;\n  let mut max_index = 0;\n  let mut max_index_prev = 0;\n  let mut min_index_prev = 0;\n  let mut min_index_prev_prev = 0;\n  let mut max_index_prev_prev = 0;\n  let mut min_index_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut max\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwu2cozzp.rs:38:14\n   |\n38 |   let mut max\n   |              ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwu2cozzp.rs:11:42\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result = result.append(i);\n    } else if i > max {\n      result = result.append(i);\n    } else {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpez6grb8u.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:30\n   |\n17 |       result = result.append(i);\n   |                              ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:17:16\n   |\n14 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n17 |       result = result.append(i);\n   |                ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpez6grb8u.rs:17:23\n   |\n17 |       result = result.append(i);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpez6grb8u.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in min..max {\n    result.push(i);\n  }\n  for i in lst.iter() {\n    result.push(i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp_ah_sk2f.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp_ah_sk2f.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `Vec<isize>: Step` is not satisfied\n  --> /tmp/tmp_ah_sk2f.rs:15:12\n   |\n15 |   for i in min..max {\n   |            ^^^^^^^^ the trait `Step` is not implemented for `Vec<isize>`\n   |\n   = help: the following other types implement trait `Step`:\n             char\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n             u128\n           and 5 others\n   = note: required because of the requirements on the impl of `Iterator` for `std::ops::Range<Vec<isize>>`\n   = note: required because of the requirements on the impl of `IntoIterator` for `std::ops::Range<Vec<isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ah_sk2f.rs:19:17\n   |\n19 |     result.push(i);\n   |                 ^ expected struct `Vec`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n           found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ah_sk2f.rs:21:10\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                                          ---------- expected `Vec<isize>` because of return type\n...\n21 |   return result;\n   |          ^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Vec<isize>>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0277, E0308.\nFor more information about an error, try",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.push(i);\n    } else if i > max {\n      result.push(i);\n    } else {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpxq620c99.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpxq620c99.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq620c99.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq620c99.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = i;\n    } else if i == max {\n      result.append(min);\n      min = i;\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp91a_x7sw.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:25:21\n   |\n25 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp91a_x7sw.rs:26:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n26 |       max = i;\n   |             ^ exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let max_index = 0;\n  let min_index = 0;\n  for i in lst.iter() {\n    if i > max {\n      max = i;\n      max_index = i;\n    }\n    if i < min {\n      min = i;\n      min_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i == min_index {\n      result = result.append(min);\n    }\n    if i == max_index {\n      result = result.append(max);\n    }\n    result = result.append(i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp0sccwh28.rs:17:12\n   |\n17 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0sccwh28.rs:18:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n18 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0sccwh28.rs:19:19\n   |\n14 |   let max_index = 0;\n   |                   - expected due to this value\n...\n19 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0sccwh28.rs:21:12\n   |\n21 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0sccwh28.rs:22:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n22 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0sccwh28.rs:23:19\n   |\n15 |   let min_index = 0;\n   |                   - expected due to this value\n...\n23 |       min_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |       min_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp0sccwh28.rs:28:10\n   |\n28 |     if i == min_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut min_index = 0;\n  let mut max_index = 0;\n  let mut max_value = 0;\n  let mut min_value = 0;\n  let mut min_index_value = 0;\n  let mut max_index_value = 0;\n  let mut max_value_value = 0;\n  let mut min_value_value = 0;\n  let mut min_index_value_value = 0;\n  let mut max_index_value_value = 0;\n  let mut max_value_value_value = 0;\n  let mut min_value_value_value = 0;\n  let mut min_index_value_value_value = 0;\n  let mut max_index_value_value_value = 0;\n  let mut max_value_value_value_value = 0;\n  let mut min_value_value_value_value = 0;\n  let mut min_index_value_value_value_value = 0;\n  let mut max_index_value_value_value_value = 0;\n  let mut max_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value = 0;\n  let mut min_index_value_value_value_value_value = 0;\n  let mut max_index_value_value_value_value_value = 0;\n  let mut max_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value = 0;\n  let mut min_index_value_value_value_value_value_value = 0;\n  let mut max_index_value_value_value_value_value_value = 0;\n  let mut max_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value = 0;\n  let mut min_index_value_value_value_value_value_value_value = 0;\n  let mut max_index_value\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp25wp7asc.rs:44:26\n   |\n44 |   let mut max_index_value\n   |                          ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25wp7asc.rs:11:42\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |    -----------------                     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = lst.slice(min_index, max_index + 1);\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:16:20\n   |\n16 |   let result = lst.slice(min_index, max_index + 1);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n16 |   let result = lst.as_slice(min_index, max_index + 1);\n   |                    ~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  let i = 0;\n  for i in 0..lst.len() - 1 {\n    if lst[i] < min {\n      result = result.append(lst[i]);\n    } else if lst[i] > max {\n      result = result.append(lst[i]);\n    } else {\n      result = result.append(lst[i]);\n    }\n  }\n  result = result.append(lst[i]);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp_g1apisj.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp_g1apisj.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_g1apisj.rs:17:17\n   |\n17 |     if lst[i] < min {\n   |                 ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_g1apisj.rs:18:30\n   |\n18 |       result = result.append(lst[i]);\n   |                              ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_g1apisj.rs:18:16\n   |\n14 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n18 |       result = result.append(lst[i]);\n   |                ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmp_g1apisj.rs:18:23\n   |\n18 |       result = result.append(lst[i]);\n   |                ------ ^^^^^^ this call modifies `result` in-place\n   |                |\n   |                you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_g1apisj.rs:19:24\n   |\n19 |     } else if lst[i] > max {\n   |                        ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: ex",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.first\n  let max = lst.last\n  let result = Vec::new()\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:12:22\n   |\n12 |   let min = lst.first\n   |                      ^ help: add `;` here\n13 |   let max = lst.last\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:13:21\n   |\n13 |   let max = lst.last\n   |                     ^ help: add `;` here\n14 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:15:12\n   |\n15 |   let i = 0\n   |            ^ help: add `;` here\n16 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:16:12\n   |\n16 |   let j = 0\n   |            ^ help: add `;` here\n17 |   let k = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:17:12\n   |\n17 |   let k = 0\n   |            ^ help: add `;` here\n18 |   let l = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:18:12\n   |\n18 |   let l = 0\n   |            ^ help: add `;` here\n19 |   let m = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:19:12\n   |\n19 |   let m = 0\n   |            ^ help: add `;` here\n20 |   let n = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:20:12\n   |\n20 |   let n = 0\n   |            ^ help: add `;` here\n21 |   let o = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:21:12\n   |\n21 |   let o = 0\n   |            ^ help: add `;` here\n22 |   let p = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpvfkba4_2.rs:22:12\n   |\n22 |   let p = 0\n   |            ^ help: add `;` here\n23 |   let q = 0\n   |   --- unexpected token\n\ne",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.set(i, min);\n    } else if i == max_index {\n      result.set(i, max);\n    } else {\n      result.set(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9knwfehx.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp9knwfehx.rs:19:14\n    |\n19  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n19  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no me",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.append(min);\n    } else if i == max_index {\n      result.append(max);\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:19:21\n   |\n19 |       result.append(min);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut min`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:21:21\n   |\n21 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:23:21\n   |\n23 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_value = lst.min();\n  let max_value = lst.max();\n  let min_index = lst.index_of(min_value);\n  let max_index = lst.index_of(max_value);\n  let max_value_index = lst.index_of(max_value);\n  let min_value_index = lst.index_of(min_value);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    let value = lst[i];\n    if (i == min_index) {\n      result.set(value, i);\n    } else if (i == max_value_index) {\n      result.set(value, i);\n    } else if (i == min_value_index) {\n      result.set(value, i);\n    } else if (i == max_index) {\n      result.set(value, i);\n    } else {\n      result.set(value, i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbon0y5to.rs:21:8\n   |\n21 |     if (i == min_index) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n21 -     if (i == min_index) {\n21 +     if i == min_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbon0y5to.rs:23:15\n   |\n23 |     } else if (i == max_value_index) {\n   |               ^                    ^\n   |\nhelp: remove these parentheses\n   |\n23 -     } else if (i == max_value_index) {\n23 +     } else if i == max_value_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbon0y5to.rs:25:15\n   |\n25 |     } else if (i == min_value_index) {\n   |               ^                    ^\n   |\nhelp: remove these parentheses\n   |\n25 -     } else if (i == min_value_index) {\n25 +     } else if i == min_value_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbon0y5to.rs:27:15\n   |\n27 |     } else if (i == max_index) {\n   |               ^              ^\n   |\nhelp: remove these parentheses\n   |\n27 -     } else if (i == max_index) {\n27 +     } else if i == max_index {\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpbon0y5to.rs:12:23\n    |\n12  |   let min_value = lst.min();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpbon0y5to.rs:13:23\n    |\n13  |   let max_value = lst.max();\n    |                       ^^^- supplied 0 arguments\n    |                       |\n    |                       expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpbon0y5to.rs:14:23\n   |\n14 |   let min_index = lst.index_of(min_valu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  let i = 0;\n  for i in 0..lst.len() {\n    if lst[i] == min {\n      result.append(max);\n      max = lst[i];\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpe50tma1s.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpe50tma1s.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:17:18\n   |\n17 |     if lst[i] == min {\n   |                  ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:18:21\n   |\n18 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:19:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due to this value\n...\n19 |       max = lst[i];\n   |             ^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:21:21\n   |\n21 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe50tma1s.rs:24:17\n   |\n24 |   result.append(min);\n   |                 ^^^\n   |                 |\n   |                 expected `&mut Vec<_>`, found struct `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.append(min);\n    } else if i == max_index {\n      result.append(max);\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:19:21\n   |\n19 |       result.append(min);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut min`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:21:21\n   |\n21 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:23:21\n   |\n23 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    } else if i > max {\n      max = i;\n    }\n    result.push(i);\n  }\n  result.push(min);\n  result.push(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpqvuzoscn.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvuzoscn.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvuzoscn.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^\n   |                   |\n   |                   expected `&isize`, found `isize`\n   |                   help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvuzoscn.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvuzoscn.rs:23:15\n   |\n23 |   result.push(min);\n   |               ^^^\n   |               |\n   |               expected `&isize`, found `isize`\n   |               help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvuzoscn.rs:24:15\n   |\n24 |   result.push(max);\n   |               ^^^\n   |               |\n   |               expected `&isize`, found `isize`\n   |               help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvuzoscn.rs:25:10\n   |\n11 | fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n   |                                          ---------- expected `Vec<isize>` because of return type\n...\n25 |   return result;\n   |          ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting due to 7 previous err",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  let i = 0;\n  for (let j = 0; j < lst.len(); j++) {\n    if (j == min_index) {\n      result[i] = min;\n      i += 1;\n    } else if (j == max_index) {\n      result[i] = max;\n      i += 1;\n    } else {\n      result[i] = lst[j];\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp0e6ck1e6.rs:18:8\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `j`\n  --> /tmp/tmp0e6ck1e6.rs:18:12\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp0e6ck1e6.rs:18:14\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp0e6ck1e6.rs:18:13\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp0e6ck1e6.rs:18:14\n   |\n18 |   for (let j = 0; j < lst.len(); j++) {\n   |              ^ expected expression\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0e6ck1e6.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0e6ck1e6.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp0e6ck1e6.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp0e6ck1e6.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.find(max);\n  let min_index = lst.find(min);\n  let result = lst.slice(min_index, max_index + 1);\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpmhvpzrw3.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpmhvpzrw3.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmhvpzrw3.rs:14:23\n   |\n14 |   let max_index = lst.find(max);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmhvpzrw3.rs:15:23\n   |\n15 |   let min_index = lst.find(min);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmhvpzrw3.rs:16:20\n   |\n16 |   let result = lst.slice(min_index, max_index + 1);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n16 |   let result = lst.as_slice(min_index, max_index + 1);\n   |                    ~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut max_index = 0;\n  let mut min_index = 0;\n  let mut max_index_prev = 0;\n  let mut min_index_prev = 0;\n  let mut max_index_prev_prev = 0;\n  let mut min_index_prev_prev = 0;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n      min_index = i;\n    }\n    if i > max {\n      max = i;\n      max_index = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == max {\n      result = result.append(max);\n      result = result.append(min);\n      min_index_prev = min_index;\n      min_index = max_index;\n      max_index_prev = max_index;\n      max_index = i;\n    } else if i == min {\n      result = result.append(min);\n      result = result.append(max);\n      min_index_prev_prev = min_index_prev;\n      min_index_prev = min_index;\n      max_index_prev_prev = max_index_prev;\n      max_index_prev = max_index;\n      max_index = i;\n    } else {\n      result = result.append(i);\n    }\n  }\n  result = result.append(max);\n  result = result.append(min);\n  result = result.append(max_index_prev);\n  result = result.append(min_index_prev);\n  result = result.append(max_index_prev_prev);\n  result = result.append(min_index_prev_prev);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpxis89f5b.rs:22:12\n   |\n22 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxis89f5b.rs:23:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n23 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxis89f5b.rs:24:19\n   |\n16 |   let mut min_index = 0;\n   |                       - expected due to this value\n...\n24 |       min_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |       min_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxis89f5b.rs:26:12\n   |\n26 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxis89f5b.rs:27:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n27 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n27 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxis89f5b.rs:28:19\n   |\n15 |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n28 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpxis89f5b.rs:32:10\n   |\n32 |     if i == max {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let res = Vec::new();\n  for i in lst {\n    if i < min {\n      res = res.append(i);\n    } else if i > max {\n      res = res.append(i);\n    } else {\n      res = res.append(i);\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpj0k5c9_1.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpj0k5c9_1.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj0k5c9_1.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj0k5c9_1.rs:17:24\n   |\n17 |       res = res.append(i);\n   |                        ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj0k5c9_1.rs:17:13\n   |\n14 |   let res = Vec::new();\n   |             ---------- expected due to this value\n...\n17 |       res = res.append(i);\n   |             ^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpj0k5c9_1.rs:17:17\n   |\n17 |       res = res.append(i);\n   |             --- ^^^^^^ this call modifies `res` in-place\n   |             |\n   |             you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj0k5c9_1.rs:18:19\n   |\n18 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.append(min);\n    } else if i == max_index {\n      result.append(max);\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpqb5bhsnv.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpqb5bhsnv.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:19:21\n   |\n19 |       result.append(min);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut min`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:21:21\n   |\n21 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqb5bhsnv.rs:23:21\n   |\n23 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    } else if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4e6fs5_e.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp4e6fs5_e.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp4e6fs5_e.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4e6fs5_e.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp4e6fs5_e.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp4e6fs5_e.rs:21:20\n   |\n21 |       max_value = i\n   |                    ^ help: add `;` here\n22 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp4e6fs5_e.rs:25:26\n   |\n25 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n26 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmp4e6fs5_e.rs:28:40\n   |\n28 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n29 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp4e6fs5_e.rs:29:20\n   |\n29 |       max_value = i\n   |                    ^ help: add `;` here\n30 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmp4e6fs5_e.rs:32:40\n   |\n32 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == 0 {\n      result.set(i, min);\n    } else if i == lst.len() - 1 {\n      result.set(i, max);\n    } else {\n      result.set(i, lst[i - 1]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpa21j8sfl.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpa21j8sfl.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpa21j8sfl.rs:14:16\n    |\n14  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmpa21j8sfl.rs:17:14\n    |\n17  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n17  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n17  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n17  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmpa21j8sfl.rs:19:14\n    |\n19  |       result.set(i, max);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, max);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, max);\n    |       +++++++++++++       +\nhelp: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let result = Vec::new();\n  for i in lst.iter() {\n    if (i < min) {\n      min = i;\n    } else if (i > max) {\n      max = i;\n    }\n    result = result.concat(vec![min, max, i]);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprfmzu89g.rs:16:8\n   |\n16 |     if (i < min) {\n   |        ^       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i < min) {\n16 +     if i < min {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprfmzu89g.rs:18:15\n   |\n18 |     } else if (i > max) {\n   |               ^       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (i > max) {\n18 +     } else if i > max {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmprfmzu89g.rs:16:13\n   |\n16 |     if (i < min) {\n   |             ^^^\n   |             |\n   |             expected `&isize`, found `isize`\n   |             help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprfmzu89g.rs:17:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprfmzu89g.rs:18:20\n   |\n18 |     } else if (i > max) {\n   |                    ^^^\n   |                    |\n   |                    expected `&isize`, found `isize`\n   |                    help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprfmzu89g.rs:19:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n19 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprfmzu89g.rs:21:43\n   |\n21 |     result = result.concat(vec![min, max, i]);\n   |                                           ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |     result = result.concat(vec![min, max, *i]);\n   |                                           +\n\nerror[E0061]: this ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut i = 1;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = i;\n    } else if i == max {\n      result.append(min);\n      min = i;\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpsh2iyx4e.rs:17:12\n   |\n17 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsh2iyx4e.rs:18:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n18 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsh2iyx4e.rs:20:12\n   |\n20 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsh2iyx4e.rs:21:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n21 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpsh2iyx4e.rs:25:10\n   |\n25 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsh2iyx4e.rs:26:21\n   |\n26 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsh2iyx4e.rs:27:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n27 |       max = i;\n   |             ^ exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new(lst.len());\n  let i = 0;\n  for (let v of lst) {\n    if (v < min) {\n      result[i] = min;\n      min = v;\n    } else if (v > max) {\n      result[i] = max;\n      max = v;\n    } else {\n      result[i] = v;\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpggcs4sol.rs:16:8\n   |\n16 |   for (let v of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `v`\n  --> /tmp/tmpggcs4sol.rs:16:12\n   |\n16 |   for (let v of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpggcs4sol.rs:16:14\n   |\n16 |   for (let v of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmpggcs4sol.rs:16:17\n   |\n16 |   for (let v of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpggcs4sol.rs:16:21\n   |\n16 |   for (let v of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpggcs4sol.rs:28:3\n   |\n28 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n28 |   { return result; }\n   |   +                +\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpggcs4sol.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpggcs4sol.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpggcs4sol.rs:14:16\n    |\n14  |   let result = Vec::new(lst.len());\n    |                ^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return Vec::new(0);\n  }\n\n  let min_index = 0;\n  let max_index = lst_len - 1;\n  let min_value = lst[min_index];\n  let max_value = lst[max_index];\n\n  let result = Vec::new(lst_len);\n  for i in 0..lst_len {\n    let value = lst[i];\n    if value < min_value {\n      min_value = value;\n      min_index = i;\n    }\n    if value > max_value {\n      max_value = value;\n      max_index = i;\n    }\n    result[i] = value;\n  }\n\n  result[min_index] = min_value;\n  result[max_index] = max_value;\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp99vs14lu.rs:14:12\n    |\n14  |     return Vec::new(0);\n    |            ^^^^^^^^ - supplied 1 argument\n    |            |\n    |            expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp99vs14lu.rs:22:16\n    |\n22  |   let result = Vec::new(lst_len);\n    |                ^^^^^^^^ ------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut min = lst[0];\n    let mut max = lst[0];\n    for i in lst.iter() {\n        if i < min {\n            min = i;\n        }\n        if i > max {\n            max = i;\n        }\n    }\n    for i in lst.iter() {\n        if i == min {\n            result.push(i);\n            min = lst[0];\n        }\n        if i == max {\n            result.push(i);\n            max = lst[0];\n        }\n    }\n    for i in lst.iter() {\n        if i == min {\n            result.push(i);\n            min = lst[0];\n        }\n        if i == max {\n            result.push(i);\n            max = lst[0];\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpj1w1docq.rs:16:16\n   |\n16 |         if i < min {\n   |                ^^^\n   |                |\n   |                expected `&isize`, found `isize`\n   |                help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj1w1docq.rs:17:19\n   |\n13 |     let mut min = lst[0];\n   |                   ------ expected due to this value\n...\n17 |             min = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |             min = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj1w1docq.rs:19:16\n   |\n19 |         if i > max {\n   |                ^^^\n   |                |\n   |                expected `&isize`, found `isize`\n   |                help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj1w1docq.rs:20:19\n   |\n14 |     let mut max = lst[0];\n   |                   ------ expected due to this value\n...\n20 |             max = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |             max = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpj1w1docq.rs:24:14\n   |\n24 |         if i == min {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpj1w1docq.rs:28:14\n   |\n28 |         if i == max {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new(lst.len());\n  let i = 0;\n  for (let v of lst) {\n    if (v < min) {\n      result[i] = min;\n      min = v;\n    } else if (v > max) {\n      result[i] = max;\n      max = v;\n    } else {\n      result[i] = v;\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpggcs4sol.rs:16:8\n   |\n16 |   for (let v of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `v`\n  --> /tmp/tmpggcs4sol.rs:16:12\n   |\n16 |   for (let v of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpggcs4sol.rs:16:14\n   |\n16 |   for (let v of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmpggcs4sol.rs:16:17\n   |\n16 |   for (let v of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpggcs4sol.rs:16:21\n   |\n16 |   for (let v of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpggcs4sol.rs:28:3\n   |\n28 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n28 |   { return result; }\n   |   +                +\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpggcs4sol.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpggcs4sol.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpggcs4sol.rs:14:16\n    |\n14  |   let result = Vec::new(lst.len());\n    |                ^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result = result.append(max);\n    } else if i == max_index {\n      result = result.append(min);\n    } else {\n      result = result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp4bv99smb.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp4bv99smb.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp4bv99smb.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp4bv99smb.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4bv99smb.rs:19:30\n   |\n19 |       result = result.append(max);\n   |                              ^^^\n   |                              |\n   |                              expected `&mut Vec<_>`, found struct `Vec`\n   |                              help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4bv99smb.rs:19:16\n   |\n16 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n19 |       result = result.append(max);\n   |                ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmp4bv99smb.rs:19:23\n   |\n19 |       result = result.append(max);\n   |                ------ ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst[0];\n  let max = lst[0];\n  let max_index = 0;\n  let min_index = 0;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n      min_index = i;\n    }\n    if i > max {\n      max = i;\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in lst.iter() {\n    if i == min_index {\n      result = result.append(max);\n      max = min;\n      max_index = min_index;\n      min = lst[0];\n      min_index = 0;\n    } else if i == max_index {\n      result = result.append(min);\n      min = max;\n      min_index = max_index;\n      max = lst[0];\n      max_index = 0;\n    } else {\n      result = result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpwlx4ddbl.rs:17:12\n   |\n17 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwlx4ddbl.rs:18:13\n   |\n12 |   let min = lst[0];\n   |             ------ expected due to this value\n...\n18 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwlx4ddbl.rs:19:19\n   |\n15 |   let min_index = 0;\n   |                   - expected due to this value\n...\n19 |       min_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       min_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwlx4ddbl.rs:21:12\n   |\n21 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwlx4ddbl.rs:22:13\n   |\n13 |   let max = lst[0];\n   |             ------ expected due to this value\n...\n22 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwlx4ddbl.rs:23:19\n   |\n14 |   let max_index = 0;\n   |                   - expected due to this value\n...\n23 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwlx4ddbl.rs:28:10\n   |\n28 |     if i == min_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = lst.slice(min_index, max_index + 1);\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwuifug8d.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwuifug8d.rs:16:20\n   |\n16 |   let result = lst.slice(min_index, max_index + 1);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n16 |   let result = lst.as_slice(min_index, max_index + 1);\n   |                    ~~~~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.append(max);\n      max = lst[i];\n    } else if i == max {\n      result.append(min);\n      min = lst[i];\n    } else {\n      result.append(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:17:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n17 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:19:12\n   |\n19 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:20:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n20 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpdng9cb04.rs:24:10\n   |\n24 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdng9cb04.rs:25:21\n   |\n25 |       result.append(max);\n   |                     ^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpdng9cb04.rs:26:13\n   |\n26 |       max = lst[i];\n   |             ^^^^^^ slice indices are of type `usize` or ranges of `u",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new(lst.len());\n  let i = 0;\n  for (let v of lst) {\n    if (v == min) {\n      result[i] = max;\n      i += 1;\n      max = lst.min();\n    } else if (v == max) {\n      result[i] = min;\n      i += 1;\n      min = lst.max();\n    } else {\n      result[i] = v;\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp91qoaxug.rs:16:8\n   |\n16 |   for (let v of lst) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `v`\n  --> /tmp/tmp91qoaxug.rs:16:12\n   |\n16 |   for (let v of lst) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp91qoaxug.rs:16:14\n   |\n16 |   for (let v of lst) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `lst`\n  --> /tmp/tmp91qoaxug.rs:16:17\n   |\n16 |   for (let v of lst) {\n   |                -^^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp91qoaxug.rs:16:21\n   |\n16 |   for (let v of lst) {\n   |                     ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmp91qoaxug.rs:30:3\n   |\n30 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n30 |   { return result; }\n   |   +                +\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp91qoaxug.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp91qoaxug.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp91qoaxug.rs:14:16\n    |\n14  |   let result = Vec::new(lst.len());\n    |                ^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let result = Vec::new();\n  for i in lst {\n    if i < min {\n      result.append(i);\n      min = i;\n    } else if i > max {\n      result.append(i);\n      max = i;\n    }\n  }\n  result.append(min);\n  result.append(max);\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczbt080x.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:16:12\n   |\n16 |     if i < min {\n   |            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:17:21\n   |\n17 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:18:13\n   |\n12 |   let min = lst.min();\n   |             --------- expected due to this value\n...\n18 |       min = i;\n   |             ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:19:19\n   |\n19 |     } else if i > max {\n   |                   ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:20:21\n   |\n20 |       result.append(i);\n   |                     ^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpczbt080x.rs:21:13\n   |\n13 |   let max = lst.max();\n   |             --------- expected due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.index_of(max);\n  let min_index = lst.index_of(min);\n  let result = Vec::new(lst.len());\n  for i in 0..lst.len() {\n    if i == min_index {\n      result.set(i, min);\n    } else if i == max_index {\n      result.set(i, max);\n    } else {\n      result.set(i, lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp9knwfehx.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:14:23\n   |\n14 |   let max_index = lst.index_of(max);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp9knwfehx.rs:15:23\n   |\n15 |   let min_index = lst.index_of(min);\n   |                       ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9knwfehx.rs:16:16\n    |\n16  |   let result = Vec::new(lst.len());\n    |                ^^^^^^^^ --------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `set` found for struct `Vec<_>` in the current scope\n   --> /tmp/tmp9knwfehx.rs:19:14\n    |\n19  |       result.set(i, min);\n    |              ^^^\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(result).set(i, min);\n    |       +++++++++      +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n19  |       Pin::new(&mut result).set(i, min);\n    |       +++++++++++++       +\nhelp: there is an associated function with a similar name\n    |\n19  |       result.get(i, min);\n    |              ~~~\n\nerror[E0599]: no me",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min = lst[0];\n  let mut max = lst[0];\n  let mut i = 1;\n  for i in lst.iter() {\n    if i < min {\n      min = i;\n    }\n    if i > max {\n      max = i;\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.push(i);\n    }\n    if i == max {\n      result.push(i);\n    }\n  }\n  for i in lst.iter() {\n    if i == min {\n      result.push(i);\n    }\n  }\n  for i in lst.iter() {\n    if i == max {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpqptqncmx.rs:17:12\n   |\n17 |     if i < min {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqptqncmx.rs:18:13\n   |\n13 |   let mut min = lst[0];\n   |                 ------ expected due to this value\n...\n18 |       min = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqptqncmx.rs:20:12\n   |\n20 |     if i > max {\n   |            ^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqptqncmx.rs:21:13\n   |\n14 |   let mut max = lst[0];\n   |                 ------ expected due to this value\n...\n21 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |       max = *i;\n   |             +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpqptqncmx.rs:25:10\n   |\n25 |     if i == min {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpqptqncmx.rs:28:10\n   |\n28 |     if i == max {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let min = lst.min();\n    let max = lst.max();\n    let result = Vec::new();\n    for i in lst {\n        if i < min {\n            result.push(i);\n            min = i;\n        } else if i > max {\n            result.push(i);\n            max = i;\n        }\n    }\n    result.push(min);\n    result.push(max);\n    return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpsaf2vh8b.rs:12:19\n    |\n12  |     let min = lst.min();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpsaf2vh8b.rs:13:19\n    |\n13  |     let max = lst.max();\n    |                   ^^^- supplied 0 arguments\n    |                   |\n    |                   expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsaf2vh8b.rs:16:16\n   |\n16 |         if i < min {\n   |                ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsaf2vh8b.rs:18:19\n   |\n12 |     let min = lst.min();\n   |               --------- expected due to this value\n...\n18 |             min = i;\n   |                   ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsaf2vh8b.rs:19:23\n   |\n19 |         } else if i > max {\n   |                       ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsaf2vh8b.rs:21:19\n   |\n13 |     let max = lst.max();\n   |               --------- expected due to this value\n...\n21 |             max = i;\n   |                   ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsaf2vh8b.rs:24:17\n   |\n24 |     result.push(min);\n   |                 ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsaf2vh8b.rs:25:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    }\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(max_value)\n      max_value = i\n      max_index = i\n    } else if i == max_value {\n      result = result.append(min_value)\n      min_value = i\n      min_index = i\n    } else {\n      result = result.append(i)\n    }\n  }\n  result = result.append(min_value)\n  result = result.append(max_value)\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpsgn8d3a7.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpsgn8d3a7.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:22:20\n   |\n22 |       max_value = i\n   |                    ^ help: add `;` here\n23 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsgn8d3a7.rs:26:26\n   |\n26 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n27 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpsgn8d3a7.rs:29:40\n   |\n29 |       result = result.append(max_value)\n   |                                        ^ help: add `;` here\n30 |       max_value = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsgn8d3a7.rs:30:20\n   |\n30 |       max_value = i\n   |                    ^ help: add `;` here\n31 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `min_value`\n  --> /tmp/tmpsgn8d3a7.rs:33:40\n   |\n33 |       result = result.appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_idx = lst.index_of(max);\n  let min_idx = lst.index_of(min);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_idx {\n      result.append(min);\n    } else if i == max_idx {\n      result.append(max);\n    } else {\n      result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpsgv9shqx.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpsgv9shqx.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpsgv9shqx.rs:14:21\n   |\n14 |   let max_idx = lst.index_of(max);\n   |                     ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `index_of` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpsgv9shqx.rs:15:21\n   |\n15 |   let min_idx = lst.index_of(min);\n   |                     ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsgv9shqx.rs:19:21\n   |\n19 |       result.append(min);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut min`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsgv9shqx.rs:21:21\n   |\n21 |       result.append(max);\n   |                     ^^^\n   |                     |\n   |                     expected `&mut Vec<_>`, found struct `Vec`\n   |                     help: consider mutably borrowing here: `&mut max`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsgv9shqx.rs:23:21\n   |\n23 |       result.append(lst[i]);\n   |                     ^^^^^^ expected `&mut Vec<_",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.find(max);\n  let min_index = lst.find(min);\n  let result = Vec::new();\n  for i in 0..lst.len() {\n    if i == min_index {\n      result = result.append(min);\n    } else if i == max_index {\n      result = result.append(max);\n    } else {\n      result = result.append(lst[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwqk_zckj.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpwqk_zckj.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwqk_zckj.rs:14:23\n   |\n14 |   let max_index = lst.find(max);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpwqk_zckj.rs:15:23\n   |\n15 |   let min_index = lst.find(min);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwqk_zckj.rs:19:30\n   |\n19 |       result = result.append(min);\n   |                              ^^^\n   |                              |\n   |                              expected `&mut Vec<_>`, found struct `Vec`\n   |                              help: consider mutably borrowing here: `&mut min`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                         found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwqk_zckj.rs:19:16\n   |\n16 |   let result = Vec::new();\n   |                ---------- expected due to this value\n...\n19 |       result = result.append(min);\n   |                ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmpwqk_zckj.rs:19:23\n   |\n19 |       result = result.append(min);\n   |                ------ ^^^^^^ this call modifies `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut min_index = 0;\n  let mut max_index = 0;\n  let mut max_value = 0;\n  let mut min_value = 0;\n  let mut max_value_index = 0;\n  let mut min_value_index = 0;\n  let mut min_value_index_found = false;\n  let mut max_value_index_found = false;\n  let mut min_value_found = false;\n  let mut max_value_found = false;\n\n  for i in lst.iter() {\n    if !min_value_found {\n      min_value = i;\n      min_value_found = true;\n      min_value_index = i;\n    }\n    if !max_value_found {\n      max_value = i;\n      max_value_found = true;\n      max_value_index = i;\n    }\n    if min_value_found && max_value_found {\n      if i < min_value {\n        min_value = i;\n        min_value_index = i;\n      }\n      if i > max_value {\n        max_value = i;\n        max_value_index = i;\n      }\n    }\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n\n  for i in lst.iter() {\n    if i == min_value {\n      result = result.append(min_value_index);\n    }\n    if i == max_value {\n      result = result.append(max_value_index);\n    }\n    if i == min_value_index {\n      result = result.append(min_value_index_found);\n    }\n    if i == max_value_index {\n      result = result.append(max_value_index_found);\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp904892h1.rs:26:19\n   |\n16 |   let mut min_value = 0;\n   |                       - expected due to this value\n...\n26 |       min_value = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n26 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp904892h1.rs:28:25\n   |\n18 |   let mut min_value_index = 0;\n   |                             - expected due to this value\n...\n28 |       min_value_index = i;\n   |                         ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |       min_value_index = *i;\n   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp904892h1.rs:31:19\n   |\n15 |   let mut max_value = 0;\n   |                       - expected due to this value\n...\n31 |       max_value = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp904892h1.rs:33:25\n   |\n17 |   let mut max_value_index = 0;\n   |                             - expected due to this value\n...\n33 |       max_value_index = i;\n   |                         ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |       max_value_index = *i;\n   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp904892h1.rs:36:14\n   |\n36 |       if i < min_value {\n   |              ^^^^^^^^^\n   |              |\n   |              expected `&isize`, found integer\n   |              help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp904892h1.rs:37:21\n   |\n16 |   let mut min_value = 0;\n   |                       - expected due to this value\n...\n37 |         min_value = i;\n   |                     ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n37 |         min_value = *i;\n   |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min_index = 0\n  let max_index = 0\n  let min_value = lst[0]\n  let max_value = lst[0]\n  for i in lst.iter() {\n    if i < min_value {\n      min_value = i\n      min_index = i\n    } else if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in lst.iter() {\n    if i == min_value {\n      result.push_back(min_index)\n    } else if i == max_value {\n      result.push_back(max_index)\n    } else {\n      result.push_back(i)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpc4p6pz2k.rs:12:20\n   |\n12 |   let min_index = 0\n   |                    ^ help: add `;` here\n13 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpc4p6pz2k.rs:13:20\n   |\n13 |   let max_index = 0\n   |                    ^ help: add `;` here\n14 |   let min_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpc4p6pz2k.rs:14:25\n   |\n14 |   let min_value = lst[0]\n   |                         ^ help: add `;` here\n15 |   let max_value = lst[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpc4p6pz2k.rs:15:25\n   |\n15 |   let max_value = lst[0]\n   |                         ^ help: add `;` here\n16 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpc4p6pz2k.rs:18:20\n   |\n18 |       min_value = i\n   |                    ^ help: add `;` here\n19 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpc4p6pz2k.rs:21:20\n   |\n21 |       max_value = i\n   |                    ^ help: add `;` here\n22 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpc4p6pz2k.rs:25:26\n   |\n25 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n26 |   for i in lst.iter() {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc4p6pz2k.rs:17:12\n   |\n17 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc4p6pz2k.rs:18:19\n   |\n14 |   let min_value = lst[0]\n   |                   ------ expected due to this value\n...\n18 |       min_value = i\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       min_value = *i\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let lst_len = lst.len();\n  if lst_len == 0 {\n    return Vec::new(0);\n  }\n\n  let min_index = 0;\n  let max_index = lst_len - 1;\n  let min_value = lst[min_index];\n  let max_value = lst[max_index];\n\n  for i in 0..lst_len - 1 {\n    if lst[i] < min_value {\n      min_value = lst[i];\n      min_index = i;\n    }\n    if lst[i] > max_value {\n      max_value = lst[i];\n      max_index = i;\n    }\n  }\n\n  let result = Vec::new(lst_len);\n  for i in 0..lst_len - 1 {\n    if i == min_index {\n      result[i] = min_value;\n    } else if i == max_index {\n      result[i] = max_value;\n    } else {\n      result[i] = lst[i];\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpzfdcdclx.rs:14:12\n    |\n14  |     return Vec::new(0);\n    |            ^^^^^^^^ - supplied 1 argument\n    |            |\n    |            expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpzfdcdclx.rs:33:16\n    |\n33  |   let result = Vec::new(lst_len);\n    |                ^^^^^^^^ ------- supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n  let min = lst.min();\n  let max = lst.max();\n  let max_index = lst.find(max);\n  let min_index = lst.find(min);\n  let result = lst.slice(min_index, max_index + 1);\n  result.extend(lst.slice(0, min_index));\n  result.extend(lst.slice(max_index + 1, lst.len()));\n  return result;\n}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczfdgjca.rs:12:17\n    |\n12  |   let min = lst.min();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpczfdgjca.rs:13:17\n    |\n13  |   let max = lst.max();\n    |                 ^^^- supplied 0 arguments\n    |                 |\n    |                 expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpczfdgjca.rs:14:23\n   |\n14 |   let max_index = lst.find(max);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `find` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpczfdgjca.rs:15:23\n   |\n15 |   let min_index = lst.find(min);\n   |                       ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpczfdgjca.rs:16:20\n   |\n16 |   let result = lst.slice(min_index, max_index + 1);\n   |                    ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n16 |   let result = lst.as_slice(min_index, max_index + 1);\n   |                    ~~~~~~~~\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpczfdgjca.rs:17:21\n   |\n17 |   result.extend(lst.slice(0, min_index));\n   |                     ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | u",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}