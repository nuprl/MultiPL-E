{
  "name": "HumanEval_95_check_dict_case",
  "language": "rs",
  "prompt": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n",
  "tests": "}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let all_lower = keys.all(|x| x.is_lower());\n    let all_upper = keys.all(|x| x.is_upper());\n    return all_lower || all_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplx_2heca.rs:19:36\n   |\n19 |     let all_lower = keys.all(|x| x.is_lower());\n   |                                    ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmplx_2heca.rs:20:36\n   |\n20 |     let all_upper = keys.all(|x| x.is_upper());\n   |                                    ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if !(k.is_lower() || k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpqyj06720.rs:19:16\n   |\n19 |         if !(k.is_lower() || k.is_upper()) {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpqyj06720.rs:19:32\n   |\n19 |         if !(k.is_lower() || k.is_upper()) {\n   |                                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_char = key[0];\n        if key_char.is_upper() != key.len() == 1 {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpg0ep6536.rs:24:32\n   |\n24 |         if key_char.is_upper() != key.len() == 1 {\n   |                                ^^           ^^\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpg0ep6536.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg0ep6536.rs:24:48\n   |\n24 |         if key_char.is_upper() != key.len() == 1 {\n   |                                                ^ expected `bool`, found integer\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        if !(k.is_lower() || k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpea7rklat.rs:20:16\n   |\n20 |         if !(k.is_lower() || k.is_upper()) {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpea7rklat.rs:20:32\n   |\n20 |         if !(k.is_lower() || k.is_upper()) {\n   |                                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.is_upper()) {\n            return false;\n        }\n    }\n    for key in keys {\n        if (key.is_lower()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpve44mngu.rs:20:12\n   |\n20 |         if (key.is_upper()) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.is_upper()) {\n20 +         if key.is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpve44mngu.rs:25:12\n   |\n25 |         if (key.is_lower()) {\n   |            ^              ^\n   |\nhelp: remove these parentheses\n   |\n25 -         if (key.is_lower()) {\n25 +         if key.is_lower() {\n   | \n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpve44mngu.rs:20:17\n   |\n20 |         if (key.is_upper()) {\n   |                 ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpve44mngu.rs:25:17\n   |\n25 |         if (key.is_lower()) {\n   |                 ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    for k in keys {\n        let key = k.to_upper();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:26:21\n   |\n26 |         let key = k.to_upper();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_char = key[0];\n        if (key_char.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwr2yvzti.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwr2yvzti.rs:24:12\n   |\n24 |         if (key_char.is_upper()) {\n   |            ^                   ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key_char.is_upper()) {\n24 +         if key_char.is_upper() {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwr2yvzti.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_keys = dict.keys().map(String::to_lower);\n    let upper_keys = dict.keys().map(String::to_upper);\n    return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:18:46\n   |\n18 |     let lower_keys = dict.keys().map(String::to_lower);\n   |                                              ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:19:46\n   |\n19 |     let upper_keys = dict.keys().map(String::to_upper);\n   |                                              ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:20:23\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                       ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:20:58\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                                                          ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_keys = dict.keys().map(String::to_lower);\n    let upper_keys = dict.keys().map(String::to_upper);\n    return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:18:46\n   |\n18 |     let lower_keys = dict.keys().map(String::to_lower);\n   |                                              ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:19:46\n   |\n19 |     let upper_keys = dict.keys().map(String::to_upper);\n   |                                              ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:20:23\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                       ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:20:58\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                                                          ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    for k in keys {\n        let key = k.to_upper();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:26:21\n   |\n26 |         let key = k.to_upper();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if (key != key_lower) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:24:12\n   |\n24 |         if (key != key_lower) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key != key_lower) {\n24 +         if key != key_lower {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpzihqghr7.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if !(key.is_lower() || key.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpuoch_x_k.rs:20:18\n   |\n20 |         if !(key.is_lower() || key.is_upper()) {\n   |                  ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpuoch_x_k.rs:20:36\n   |\n20 |         if !(key.is_lower() || key.is_upper()) {\n   |                                    ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        if k.len() != 1 {\n            return false;\n        }\n        let key = k[0];\n        if key.len() != 1 {\n            return false;\n        }\n        let c = key[0];\n        if (c >= 'a' && c <= 'z') {\n            continue;\n        }\n        if (c >= 'A' && c <= 'Z') {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpczinkwt8.rs:28:12\n   |\n28 |         if (c >= 'a' && c <= 'z') {\n   |            ^                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n28 -         if (c >= 'a' && c <= 'z') {\n28 +         if c >= 'a' && c <= 'z' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpczinkwt8.rs:31:12\n   |\n31 |         if (c >= 'A' && c <= 'Z') {\n   |            ^                    ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (c >= 'A' && c <= 'Z') {\n31 +         if c >= 'A' && c <= 'Z' {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpczinkwt8.rs:23:19\n   |\n23 |         let key = k[0];\n   |                   ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if (key != key_lower) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:24:12\n   |\n24 |         if (key != key_lower) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key != key_lower) {\n24 +         if key != key_lower {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpzihqghr7.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.to_upper() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpio1x5nny.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpio1x5nny.rs:25:16\n   |\n25 |         if key.to_upper() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3u6t0edd.rs:20:12\n   |\n20 |         if (key.is_upper()) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.is_upper()) {\n20 +         if key.is_upper() {\n   | \n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp3u6t0edd.rs:20:17\n   |\n20 |         if (key.is_upper()) {\n   |                 ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(String::to_lower);\n    let upper_case_keys = dict.keys().map(String::to_upper);\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp97499_yg.rs:18:51\n   |\n18 |     let lower_case_keys = dict.keys().map(String::to_lower);\n   |                                                   ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp97499_yg.rs:19:51\n   |\n19 |     let upper_case_keys = dict.keys().map(String::to_upper);\n   |                                                   ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmp97499_yg.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmp97499_yg.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if !(k.is_lower() || k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpqyj06720.rs:19:16\n   |\n19 |         if !(k.is_lower() || k.is_upper()) {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpqyj06720.rs:19:32\n   |\n19 |         if !(k.is_lower() || k.is_upper()) {\n   |                                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_char = key[0];\n        if (key_char.is_upper() != key.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kwt62gi.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kwt62gi.rs:24:12\n   |\n24 |         if (key_char.is_upper() != key.is_upper()) {\n   |            ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key_char.is_upper() != key.is_upper()) {\n24 +         if key_char.is_upper() != key.is_upper() {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp8kwt62gi.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp8kwt62gi.rs:24:40\n   |\n24 |         if (key_char.is_upper() != key.is_upper()) {\n   |                                        ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp5_t2vh74.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys)\n        && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys)\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:21:28\n   |\n21 |         && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if not (k.is_lower() || k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `not` in this scope\n  --> /tmp/tmp4h4z9moa.rs:19:12\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |            ^^^ not found in this scope\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:19\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                   ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:35\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                                   ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_keys = dict.keys().map(|key| key.to_lower());\n    let upper_keys = dict.keys().map(|key| key.to_upper());\n    return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpbomftn_d.rs:18:48\n   |\n18 |     let lower_keys = dict.keys().map(|key| key.to_lower());\n   |                                                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpbomftn_d.rs:19:48\n   |\n19 |     let upper_keys = dict.keys().map(|key| key.to_upper());\n   |                                                ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpbomftn_d.rs:20:23\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                       ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpbomftn_d.rs:20:58\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                                                          ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_char = key[0];\n        if (key_char.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwr2yvzti.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwr2yvzti.rs:24:12\n   |\n24 |         if (key_char.is_upper()) {\n   |            ^                   ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key_char.is_upper()) {\n24 +         if key_char.is_upper() {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwr2yvzti.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let all_lower = all(keys.iter().map(k => k.to_lower()));\n    let all_upper = all(keys.iter().map(k => k.to_upper()));\n    return all_lower || all_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpcdx06ucu.rs:19:43\n   |\n19 |     let all_lower = all(keys.iter().map(k => k.to_lower()));\n   |                                           ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    for k in keys {\n        let key = k.to_upper();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:26:21\n   |\n26 |         let key = k.to_upper();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let all_lower = all(keys.map(k => k.to_lower()));\n    let all_upper = all(keys.map(k => k.to_upper()));\n    return all_lower || all_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp66dill8i.rs:19:36\n   |\n19 |     let all_lower = all(keys.map(k => k.to_lower()));\n   |                                    ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_char = key[0];\n        if key_char.is_upper() != key.len() == 1 {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n  --> /tmp/tmpg0ep6536.rs:24:32\n   |\n24 |         if key_char.is_upper() != key.len() == 1 {\n   |                                ^^           ^^\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpg0ep6536.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg0ep6536.rs:24:48\n   |\n24 |         if key_char.is_upper() != key.len() == 1 {\n   |                                                ^ expected `bool`, found integer\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if not (k.is_lower() or k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: `or` is not a logical operator\n  --> /tmp/tmpafhyz3fl.rs:19:30\n   |\n19 |         if not (k.is_lower() or k.is_upper()) {\n   |                              ^^ help: use `||` to perform logical disjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0425]: cannot find function `not` in this scope\n  --> /tmp/tmpafhyz3fl.rs:19:12\n   |\n19 |         if not (k.is_lower() or k.is_upper()) {\n   |            ^^^ not found in this scope\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpafhyz3fl.rs:19:19\n   |\n19 |         if not (k.is_lower() or k.is_upper()) {\n   |                   ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpafhyz3fl.rs:19:35\n   |\n19 |         if not (k.is_lower() or k.is_upper()) {\n   |                                   ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if k.len() != 1 {\n            return false;\n        }\n        let c = k[0];\n        if c.len() == 1 && (c.to_lower() != c || c.to_upper() != c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpptmjr9d1.rs:28:1\n   |\n17 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |                                                           - this opening brace...\n...\n26 |     }\n   |     - ...matches this closing brace\n27 |     return true;\n28 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpptmjr9d1.rs:18:26\n   |\n18 |     for k in dict.keys() {\n   |                          ^ unclosed delimiter\n...\n23 |         if c.len() == 1 && (c.to_lower() != c || c.to_upper() != c)) {\n   |                                                                    ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let all_lower = all(keys.map(key => key.to_lower() == key));\n    let all_upper = all(keys.map(key => key.to_upper() == key));\n    return all_lower || all_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpiozyvonn.rs:19:38\n   |\n19 |     let all_lower = all(keys.map(key => key.to_lower() == key));\n   |                                      ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys)\n        && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys)\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:21:28\n   |\n21 |         && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if not (k.is_lower() || k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `not` in this scope\n  --> /tmp/tmp4h4z9moa.rs:19:12\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |            ^^^ not found in this scope\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:19\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                   ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:35\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                                   ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|k| k.to_lower());\n    let upper_case_keys = dict.keys().map(|k| k.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpd0eoc8q2.rs:18:49\n   |\n18 |     let lower_case_keys = dict.keys().map(|k| k.to_lower());\n   |                                                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpd0eoc8q2.rs:19:49\n   |\n19 |     let upper_case_keys = dict.keys().map(|k| k.to_upper());\n   |                                                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpd0eoc8q2.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpd0eoc8q2.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if not (k.is_lower() || k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `not` in this scope\n  --> /tmp/tmp4h4z9moa.rs:19:12\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |            ^^^ not found in this scope\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:19\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                   ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:35\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                                   ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_keys = dict.keys().map(|key| key.to_lower());\n    let upper_keys = dict.keys().map(|key| key.to_upper());\n    return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpbomftn_d.rs:18:48\n   |\n18 |     let lower_keys = dict.keys().map(|key| key.to_lower());\n   |                                                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpbomftn_d.rs:19:48\n   |\n19 |     let upper_keys = dict.keys().map(|key| key.to_upper());\n   |                                                ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpbomftn_d.rs:20:23\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                       ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpbomftn_d.rs:20:58\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                                                          ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        if k.is_upper() {\n            return false;\n        }\n    }\n    for k in keys {\n        if k.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp5b545pb8.rs:20:14\n   |\n20 |         if k.is_upper() {\n   |              ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp5b545pb8.rs:25:14\n   |\n25 |         if k.is_lower() {\n   |              ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() != key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpq4odnc53.rs:20:16\n   |\n20 |         if key.is_upper() != key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpq4odnc53.rs:20:34\n   |\n20 |         if key.is_upper() != key.is_lower() {\n   |                                  ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpc8q38c6z.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if (key != key_lower) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:24:12\n   |\n24 |         if (key != key_lower) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key != key_lower) {\n24 +         if key != key_lower {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpzihqghr7.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_char = key[0];\n        if key_char.is_upper() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpy5oc2w4t.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    for k in keys {\n        let key = k.to_upper();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:26:21\n   |\n26 |         let key = k.to_upper();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_keys = dict.keys().map(|key| key.to_lower());\n    let upper_keys = dict.keys().map(|key| key.to_upper());\n    return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpbomftn_d.rs:18:48\n   |\n18 |     let lower_keys = dict.keys().map(|key| key.to_lower());\n   |                                                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpbomftn_d.rs:19:48\n   |\n19 |     let upper_keys = dict.keys().map(|key| key.to_upper());\n   |                                                ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpbomftn_d.rs:20:23\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                       ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpbomftn_d.rs:20:58\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                                                          ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    for k in keys {\n        let key = k.to_upper();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:26:21\n   |\n26 |         let key = k.to_upper();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys)\n        && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys)\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:21:28\n   |\n21 |         && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if k.len() != 1 {\n            return false;\n        }\n        let c = k[0];\n        if c.len() != 1 {\n            return false;\n        }\n        let c2 = c.to_lower();\n        if c != c2 {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpr88kt6mh.rs:22:17\n   |\n22 |         let c = k[0];\n   |                 ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp5_t2vh74.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if (key != key_lower) {\n            return false;\n        }\n        let value = dict.get(key);\n        if (value.len() != 1) {\n            return false;\n        }\n        let value_lower = value.to_lower();\n        if (value != value_lower) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe1swa3ij.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe1swa3ij.rs:24:12\n   |\n24 |         if (key != key_lower) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key != key_lower) {\n24 +         if key != key_lower {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe1swa3ij.rs:28:12\n   |\n28 |         if (value.len() != 1) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n28 -         if (value.len() != 1) {\n28 +         if value.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe1swa3ij.rs:32:12\n   |\n32 |         if (value != value_lower) {\n   |            ^                    ^\n   |\nhelp: remove these parentheses\n   |\n32 -         if (value != value_lower) {\n32 +         if value != value_lower {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpe1swa3ij.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpe1swa3ij.rs:28:19\n   |\n28 |         if (value.len() != 1) {\n   |                   ^^^ method not found in `Option<&String>`\n\nerror[E0599]: no method named `to_lower` found for enum `Option` in the current scope\n  --> /tmp/tmpe1swa3ij.rs:31:33\n   |\n31 |         let value_lower = value.to_lower();\n   |                                 ^^^^^^^^ method not found in `Option<&String>`\n\nerror: aborting due to 3 previous errors; 4 warnings emitted\n\nFor more information ab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| String::lower(key));\n    let upper_case_keys = dict.keys().map(|key| String::upper(key));\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `lower` found for struct `String` in the current scope\n  --> /tmp/tmpkockgcyq.rs:18:57\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| String::lower(key));\n   |                                                         ^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `upper` found for struct `String` in the current scope\n  --> /tmp/tmpkockgcyq.rs:19:57\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| String::upper(key));\n   |                                                         ^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpkockgcyq.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpkockgcyq.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        if k.to_lower() != k {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp9vcy_atu.rs:20:14\n   |\n20 |         if k.to_lower() != k {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if k.len() != 1 {\n            return false;\n        }\n        let c = k.char(0);\n        if c != to_lower(c) && c != to_upper(c) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmp_rbozsc0.rs:23:17\n   |\n23 |         if c != to_lower(c) && c != to_upper(c) {\n   |                 ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmp_rbozsc0.rs:23:37\n   |\n23 |         if c != to_lower(c) && c != to_upper(c) {\n   |                                     ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `char` found for reference `&String` in the current scope\n  --> /tmp/tmp_rbozsc0.rs:22:19\n   |\n22 |         let c = k.char(0);\n   |                   ^^^^ help: there is an associated function with a similar name: `chars`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_char = key[0];\n        if (key_char.is_upper() != key.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kwt62gi.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kwt62gi.rs:24:12\n   |\n24 |         if (key_char.is_upper() != key.is_upper()) {\n   |            ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key_char.is_upper() != key.is_upper()) {\n24 +         if key_char.is_upper() != key.is_upper() {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp8kwt62gi.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp8kwt62gi.rs:24:40\n   |\n24 |         if (key_char.is_upper() != key.is_upper()) {\n   |                                        ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if !key.is_lower() {\n            return false;\n        }\n    }\n    for key in keys {\n        if !key.is_upper() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplmucpa_j.rs:20:17\n   |\n20 |         if !key.is_lower() {\n   |                 ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmplmucpa_j.rs:25:17\n   |\n25 |         if !key.is_upper() {\n   |                 ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let lower_case_key = key.to_lower();\n        if !lower_case_key.equals(key) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmps2_5kyqh.rs:20:34\n   |\n20 |         let lower_case_key = key.to_lower();\n   |                                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_keys = dict.keys().map(String::to_lower);\n    let upper_keys = dict.keys().map(String::to_upper);\n    return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:18:46\n   |\n18 |     let lower_keys = dict.keys().map(String::to_lower);\n   |                                              ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:19:46\n   |\n19 |     let upper_keys = dict.keys().map(String::to_upper);\n   |                                              ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:20:23\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                       ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmplxxjkf8r.rs:20:58\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                                                          ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp5_t2vh74.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if (key != key_lower) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:24:12\n   |\n24 |         if (key != key_lower) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key != key_lower) {\n24 +         if key != key_lower {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpzihqghr7.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if (key != key_lower) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:24:12\n   |\n24 |         if (key != key_lower) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key != key_lower) {\n24 +         if key != key_lower {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpzihqghr7.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if !(key.is_lower() || key.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpuoch_x_k.rs:20:18\n   |\n20 |         if !(key.is_lower() || key.is_upper()) {\n   |                  ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpuoch_x_k.rs:20:36\n   |\n20 |         if !(key.is_lower() || key.is_upper()) {\n   |                                    ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if not (k.is_lower() || k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `not` in this scope\n  --> /tmp/tmp4h4z9moa.rs:19:12\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |            ^^^ not found in this scope\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:19\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                   ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:35\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                                   ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() != key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpq4odnc53.rs:20:16\n   |\n20 |         if key.is_upper() != key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpq4odnc53.rs:20:34\n   |\n20 |         if key.is_upper() != key.is_lower() {\n   |                                  ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys)\n        && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys)\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:21:28\n   |\n21 |         && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys)\n        && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys)\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:21:28\n   |\n21 |         && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_keys = dict.keys().map(|key| key.to_lower());\n    let upper_keys = dict.keys().map(|key| key.to_upper());\n    return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpbomftn_d.rs:18:48\n   |\n18 |     let lower_keys = dict.keys().map(|key| key.to_lower());\n   |                                                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpbomftn_d.rs:19:48\n   |\n19 |     let upper_keys = dict.keys().map(|key| key.to_upper());\n   |                                                ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpbomftn_d.rs:20:23\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                       ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpbomftn_d.rs:20:58\n   |\n20 |     return lower_keys.contains(upper_keys) && upper_keys.contains(lower_keys);\n   |                                                          ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if (key != key_lower) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:24:12\n   |\n24 |         if (key != key_lower) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key != key_lower) {\n24 +         if key != key_lower {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpzihqghr7.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    for k in keys {\n        let key = k.to_upper();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:26:21\n   |\n26 |         let key = k.to_upper();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let all_lower = all(keys.map(key => key.to_lower()));\n    let all_upper = all(keys.map(key => key.to_upper()));\n    return all_lower || all_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpvast8qll.rs:19:38\n   |\n19 |     let all_lower = all(keys.map(key => key.to_lower()));\n   |                                      ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let all_lower = keys.map(String::to_lower).all(|x| x == keys.first());\n    let all_upper = keys.map(String::to_upper).all(|x| x == keys.first());\n    return all_lower || all_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpp1jwbd_c.rs:19:38\n   |\n19 |     let all_lower = keys.map(String::to_lower).all(|x| x == keys.first());\n   |                                      ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no method named `first` found for struct `std::collections::hash_map::Keys` in the current scope\n  --> /tmp/tmpp1jwbd_c.rs:19:66\n   |\n19 |     let all_lower = keys.map(String::to_lower).all(|x| x == keys.first());\n   |                                                                  ^^^^^ method not found in `std::collections::hash_map::Keys<'_, String, String>`\n\nerror[E0599]: no function or associated item named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpp1jwbd_c.rs:20:38\n   |\n20 |     let all_upper = keys.map(String::to_upper).all(|x| x == keys.first());\n   |                                      ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no method named `first` found for struct `std::collections::hash_map::Keys` in the current scope\n  --> /tmp/tmpp1jwbd_c.rs:20:66\n   |\n20 |     let all_upper = keys.map(String::to_upper).all(|x| x == keys.first());\n   |                                                                  ^^^^^ method not found in `std::collections::hash_map::Keys<'_, String, String>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if not (k.is_lower() || k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `not` in this scope\n  --> /tmp/tmp4h4z9moa.rs:19:12\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |            ^^^ not found in this scope\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:19\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                   ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:35\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                                   ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_keys = dict.keys().map(|key| String::lower(key));\n    let upper_keys = dict.keys().map(|key| String::upper(key));\n    return lower_keys.contains_all(upper_keys) && upper_keys.contains_all(lower_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `lower` found for struct `String` in the current scope\n  --> /tmp/tmpnot_f87y.rs:18:52\n   |\n18 |     let lower_keys = dict.keys().map(|key| String::lower(key));\n   |                                                    ^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `upper` found for struct `String` in the current scope\n  --> /tmp/tmpnot_f87y.rs:19:52\n   |\n19 |     let upper_keys = dict.keys().map(|key| String::upper(key));\n   |                                                    ^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no method named `contains_all` found for struct `Map` in the current scope\n  --> /tmp/tmpnot_f87y.rs:20:23\n   |\n20 |     return lower_keys.contains_all(upper_keys) && upper_keys.contains_all(lower_keys);\n   |                       ^^^^^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains_all` found for struct `Map` in the current scope\n  --> /tmp/tmpnot_f87y.rs:20:62\n   |\n20 |     return lower_keys.contains_all(upper_keys) && upper_keys.contains_all(lower_keys);\n   |                                                              ^^^^^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    for k in keys {\n        let key = k.to_upper();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:26:21\n   |\n26 |         let key = k.to_upper();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let all_lower = all(keys.map(key => key.to_lower()));\n    let all_upper = all(keys.map(key => key.to_upper()));\n    return all_lower || all_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpvast8qll.rs:19:38\n   |\n19 |     let all_lower = all(keys.map(key => key.to_lower()));\n   |                                      ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys)\n        && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpekxx087x.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys)\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpekxx087x.rs:21:28\n   |\n21 |         && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_char = key[0];\n        if key_char.is_upper() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpy5oc2w4t.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp7x3626ct.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() != key.to_lower().is_upper() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpq_5y3pip.rs:20:16\n   |\n20 |         if key.is_upper() != key.to_lower().is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpq_5y3pip.rs:20:34\n   |\n20 |         if key.is_upper() != key.to_lower().is_upper() {\n   |                                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        if k.to_lower() != k {\n            return false;\n        }\n    }\n    for k in keys {\n        if k.to_upper() != k {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpjmgoukq6.rs:20:14\n   |\n20 |         if k.to_lower() != k {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpjmgoukq6.rs:25:14\n   |\n25 |         if k.to_upper() != k {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_char = key[0];\n        if (key_char.is_upper() != key.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kwt62gi.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kwt62gi.rs:24:12\n   |\n24 |         if (key_char.is_upper() != key.is_upper()) {\n   |            ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key_char.is_upper() != key.is_upper()) {\n24 +         if key_char.is_upper() != key.is_upper() {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp8kwt62gi.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp8kwt62gi.rs:24:40\n   |\n24 |         if (key_char.is_upper() != key.is_upper()) {\n   |                                        ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_char = key[0];\n        if (key_char.is_upper() != true) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph4djlofe.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph4djlofe.rs:24:12\n   |\n24 |         if (key_char.is_upper() != true) {\n   |            ^                           ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key_char.is_upper() != true) {\n24 +         if key_char.is_upper() != true {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmph4djlofe.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let values = dict.values();\n    let all_lower = all(keys.iter().map(k => k.to_lower()));\n    let all_upper = all(keys.iter().map(k => k.to_upper()));\n    return all_lower || all_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp00663e9m.rs:20:43\n   |\n20 |     let all_lower = all(keys.iter().map(k => k.to_lower()));\n   |                                           ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_keys = dict.keys().map(String::to_lower);\n    let upper_keys = dict.keys().map(String::to_upper);\n    return lower_keys.all(|key| key == upper_keys.find(|key| key == key));\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp63y9erkh.rs:18:46\n   |\n18 |     let lower_keys = dict.keys().map(String::to_lower);\n   |                                              ^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp63y9erkh.rs:19:46\n   |\n19 |     let upper_keys = dict.keys().map(String::to_upper);\n   |                                              ^^^^^^^^ function or associated item not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_char = key[0];\n        if key_char.is_upper() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpy5oc2w4t.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.to_lower() != key) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmmc2tba8.rs:20:12\n   |\n20 |         if (key.to_lower() != key) {\n   |            ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.to_lower() != key) {\n20 +         if key.to_lower() != key {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpmmc2tba8.rs:20:17\n   |\n20 |         if (key.to_lower() != key) {\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for k in dict.keys() {\n        if not (k.is_lower() || k.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `not` in this scope\n  --> /tmp/tmp4h4z9moa.rs:19:12\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |            ^^^ not found in this scope\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:19\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                   ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp4h4z9moa.rs:19:35\n   |\n19 |         if not (k.is_lower() || k.is_upper()) {\n   |                                   ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.len() != 1 {\n            return false;\n        }\n        let key_char = key[0];\n        if key_char.is_upper() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpy5oc2w4t.rs:23:24\n   |\n23 |         let key_char = key[0];\n   |                        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.is_upper() {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.is_lower() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:20:16\n   |\n20 |         if key.is_upper() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpy7gnldhl.rs:25:16\n   |\n25 |         if key.is_lower() {\n   |                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let lower_case_key = key.to_lower();\n        if (lower_case_key != key) {\n            return false;\n        }\n        let value = dict.get(key);\n        if (value.len() != 1) {\n            return false;\n        }\n        let lower_case_value = value.to_lower();\n        if (lower_case_value != value) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjmz0iurx.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjmz0iurx.rs:24:12\n   |\n24 |         if (lower_case_key != key) {\n   |            ^                     ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (lower_case_key != key) {\n24 +         if lower_case_key != key {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjmz0iurx.rs:28:12\n   |\n28 |         if (value.len() != 1) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n28 -         if (value.len() != 1) {\n28 +         if value.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjmz0iurx.rs:32:12\n   |\n32 |         if (lower_case_value != value) {\n   |            ^                         ^\n   |\nhelp: remove these parentheses\n   |\n32 -         if (lower_case_value != value) {\n32 +         if lower_case_value != value {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpjmz0iurx.rs:23:34\n   |\n23 |         let lower_case_key = key.to_lower();\n   |                                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpjmz0iurx.rs:28:19\n   |\n28 |         if (value.len() != 1) {\n   |                   ^^^ method not found in `Option<&String>`\n\nerror[E0599]: no method named `to_lower` found for enum `Option` in the current scope\n  --> /tmp/tmpjmz0iurx.rs:31:38\n   |\n31 |         let lower_case_value = value.to_lower();\n   |                                      ^^^^^^^^ method not found in `Option<&String>`\n\nerror: aborting due to 3 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let lower_key = key.to_lower();\n        if (lower_key != key) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1th3ck1n.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1th3ck1n.rs:24:12\n   |\n24 |         if (lower_key != key) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (lower_key != key) {\n24 +         if lower_key != key {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp1th3ck1n.rs:23:29\n   |\n23 |         let lower_key = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        if (k.len() != 1) {\n            return false;\n        }\n        let key = k[0];\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_char = key[0];\n        if (key_char.is_upper() != key.is_upper()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmoj1kkdn.rs:20:12\n   |\n20 |         if (k.len() != 1) {\n   |            ^            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (k.len() != 1) {\n20 +         if k.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmoj1kkdn.rs:24:12\n   |\n24 |         if (key.len() != 1) {\n   |            ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key.len() != 1) {\n24 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmoj1kkdn.rs:28:12\n   |\n28 |         if (key_char.is_upper() != key.is_upper()) {\n   |            ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n28 -         if (key_char.is_upper() != key.is_upper()) {\n28 +         if key_char.is_upper() != key.is_upper() {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpmoj1kkdn.rs:23:19\n   |\n23 |         let key = k[0];\n   |                   ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        if key != key_lower {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpypu5m2qm.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        let key = k.to_lower();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    for k in keys {\n        let key = k.to_upper();\n        if !key.equals(k) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:20:21\n   |\n20 |         let key = k.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpyfab0d7a.rs:26:21\n   |\n26 |         let key = k.to_upper();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|key| key.to_lower());\n    let upper_case_keys = dict.keys().map(|key| key.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:18:53\n   |\n18 |     let lower_case_keys = dict.keys().map(|key| key.to_lower());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpiiqk4377.rs:19:53\n   |\n19 |     let upper_case_keys = dict.keys().map(|key| key.to_upper());\n   |                                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpiiqk4377.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        if k.to_lower() != k.to_upper() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp652ta9pd.rs:20:14\n   |\n20 |         if k.to_lower() != k.to_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp652ta9pd.rs:20:30\n   |\n20 |         if k.to_lower() != k.to_upper() {\n   |                              ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let lower_case_keys = dict.keys().map(|k| k.to_lower());\n    let upper_case_keys = dict.keys().map(|k| k.to_upper());\n    return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpd0eoc8q2.rs:18:49\n   |\n18 |     let lower_case_keys = dict.keys().map(|k| k.to_lower());\n   |                                                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpd0eoc8q2.rs:19:49\n   |\n19 |     let upper_case_keys = dict.keys().map(|k| k.to_upper());\n   |                                                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpd0eoc8q2.rs:20:28\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                            ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror[E0599]: no method named `contains` found for struct `Map` in the current scope\n  --> /tmp/tmpd0eoc8q2.rs:20:73\n   |\n20 |     return lower_case_keys.contains(upper_case_keys) && upper_case_keys.contains(lower_case_keys);\n   |                                                                         ^^^^^^^^ method not found in `Map<std::collections::hash_map::Keys<'_, String, String>, _>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if (key.len() != 1) {\n            return false;\n        }\n        let key_lower = key.to_lower();\n        if (key != key_lower) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:20:12\n   |\n20 |         if (key.len() != 1) {\n   |            ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -         if (key.len() != 1) {\n20 +         if key.len() != 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzihqghr7.rs:24:12\n   |\n24 |         if (key != key_lower) {\n   |            ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (key != key_lower) {\n24 +         if key != key_lower {\n   | \n\nerror[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpzihqghr7.rs:23:29\n   |\n23 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for k in keys {\n        if !k.is_lower() && !k.is_upper() {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_lower` found for reference `&String` in the current scope\n  --> /tmp/tmp9e0vpfz7.rs:20:15\n   |\n20 |         if !k.is_lower() && !k.is_upper() {\n   |               ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named `is_upper` found for reference `&String` in the current scope\n  --> /tmp/tmp9e0vpfz7.rs:20:32\n   |\n20 |         if !k.is_lower() && !k.is_upper() {\n   |                                ^^^^^^^^ method not found in `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    for key in keys {\n        if key.to_upper() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpio1x5nny.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpio1x5nny.rs:25:16\n   |\n25 |         if key.to_upper() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        let key_lower = key.to_lower();\n        let key_upper = key.to_upper();\n        if key != key_lower && key != key_upper {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:20:29\n   |\n20 |         let key_lower = key.to_lower();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for reference `&String` in the current scope\n  --> /tmp/tmpwh4u9v_m.rs:21:29\n   |\n21 |         let key_upper = key.to_upper();\n   |                             ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    for key in keys {\n        if key.to_lower() != key {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n",
      "timestamp": 1664293099,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for reference `&String` in the current scope\n  --> /tmp/tmplbm12em8.rs:20:16\n   |\n20 |         if key.to_lower() != key {\n   |                ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}