{
  "name": "HumanEval_153_Strongest_Extension",
  "language": "rs",
  "prompt": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n",
  "tests": "}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if(strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpyky_md5x.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpyky_md5x.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyky_md5x.rs:24:11\n   |\n24 |         if(strength > best_extension.length()) {\n   |           ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpyky_md5x.rs:24:38\n   |\n24 |         if(strength > best_extension.length()) {\n   |                                      ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyky_md5x.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^^^^^^^^^\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp3jz19r11.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp3jz19r11.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3jz19r11.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3jz19r11.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp3jz19r11.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp3jz19r11.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3jz19r11.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3jz19r11.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmplwpcpelf.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmplwpcpelf.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplwpcpelf.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmplwpcpelf.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplwpcpelf.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    let max_extension_strength = 0.0;\n    let max_extension_name_strength = 0.0;\n    let max_extension_name_index = 0;\n    let max_extension_index = 0;\n    let max_extension_name_index_index = 0;\n    let max_extension_index_index = 0;\n    let max_extension_name_index_index_index = 0;\n    let max_extension_index_index_index = 0;\n    let max_extension_name_index_index_index_index = 0;\n    let max_extension_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwcyi781l.rs:44:57\n   |\n44 |     let max_extension_name_index_index_index_index_index\n   |                                                         ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwcyi781l.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        strength += (cap - sm) / cap;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpwx20cq2n.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpwx20cq2n.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwx20cq2n.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n    let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n    let strength_val = cap - sm;\n    if(strength_val > strength) {\n      strength = strength_val;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpv9ggjkel.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpv9ggjkel.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpv9ggjkel.rs:24:7\n   |\n24 |     if(strength_val > strength) {\n   |       ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength_val > strength) {\n24 +     if strength_val > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpv9ggjkel.rs:21:25\n   |\n21 |     let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                         ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpv9ggjkel.rs:22:24\n   |\n22 |     let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                        ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv9ggjkel.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpcl2xqz1z.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpcl2xqz1z.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcl2xqz1z.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpcl2xqz1z.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpcl2xqz1z.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcl2xqz1z.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n    let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n    strength += cap - sm;\n    if (strength > best_extension.length()) {\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpjyo6bm8o.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpjyo6bm8o.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjyo6bm8o.rs:24:8\n   |\n24 |     if (strength > best_extension.length()) {\n   |        ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > best_extension.length()) {\n24 +     if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpjyo6bm8o.rs:21:25\n   |\n21 |     let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                         ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpjyo6bm8o.rs:22:24\n   |\n22 |     let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                        ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpjyo6bm8o.rs:24:35\n   |\n24 |     if (strength > best_extension.length()) {\n   |                                   ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjyo6bm8o.rs:25:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n25 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        ex",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let max_strength = 0.0;\n  let max_extension = String::from(\"\");\n  let max_class = String::from(\"\");\n  let max_class_name = String::from(\"\");\n  let max_extension_name = String::from(\"\");\n  let max_extension_name_len = 0;\n  let max_extension_name_len_len = 0;\n  let max_class_name_len = 0;\n  let max_class_name_len_len = 0;\n  let max_extension_len = 0;\n  let max_extension_len_len = 0;\n  let max_class_len = 0;\n  let max_class_len_len = 0;\n  let max_extension_name_len_len = 0;\n  let max_class_name_len_len = 0;\n  let max_extension_len_len = 0;\n  let max_class_len_len = 0;\n  let max_extension_name_len_len = 0;\n  let max_class_name_len_len = 0;\n  let max_extension_len_len = 0;\n  let max_class_len_len = 0;\n  let max_extension_name_len_len = 0;\n  let max_class_name_len_len = 0;\n  let max_extension_len_len = 0;\n  let max_class_len_len = 0;\n  let max_extension_name_len_len = 0;\n  let max_class_name_len_len = 0;\n  let max_extension_len_len = 0;\n  let max_class_len_len = 0;\n  let max_extension_name_len_len = 0;\n  let max_class_name_len_len = 0;\n  let max_extension_len_len = 0;\n  let max_class_len_len = 0;\n  let max_extension_name_len_len = 0;\n  let max_class_name_len_len = 0;\n  let max_extension_len_\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpcgede1xk.rs:54:25\n   |\n54 |   let max_extension_len_\n   |                         ^ help: add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcgede1xk.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        strength += (cap - sm) / 26.0;\n        if (strength > best_extension) {\n            best_extension = strength;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmphe475rn9.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmphe475rn9.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphe475rn9.rs:24:12\n   |\n24 |         if (strength > best_extension) {\n   |            ^                         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > best_extension) {\n24 +         if strength > best_extension {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmphe475rn9.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmphe475rn9.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0277]: can't compare `{float}` with `&str`\n  --> /tmp/tmphe475rn9.rs:24:22\n   |\n24 |         if (strength > best_extension) {\n   |                      ^ no implementation for `{float} < &str` and `{float} > &str`\n   |\n   = help: the trait `PartialOrd<&str>` is not implemented for `{float}`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphe475rn9.rs:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ko0hfav.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp4h5s6yc8.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp4h5s6yc8.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4h5s6yc8.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  let best_strength = 0.0;\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > best_strength) {\n      best_strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpepit529e.rs:21:18\n   |\n21 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpepit529e.rs:21:7\n   |\n21 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -   for (extension in extensions) {\n21 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpepit529e.rs:25:8\n   |\n25 |     if (strength > best_strength) {\n   |        ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     if (strength > best_strength) {\n25 +     if strength > best_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpepit529e.rs:22:25\n   |\n22 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpepit529e.rs:23:24\n   |\n23 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepit529e.rs:27:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n27 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let class_name_upper = class_name.to_upper();\n    let class_name_lower = class_name.to_lower();\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let ext_upper = ext.to_upper();\n        let ext_lower = ext.to_lower();\n        let ext_cap = ext_upper.count(chr => chr.is_upper());\n        let ext_sm = ext_lower.count(chr => chr.is_lower());\n        let ext_strength = (ext_cap - ext_sm) / ext_cap;\n        if ext_strength > strength {\n            strength = ext_strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name_upper + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpt2o0d8eb.rs:25:43\n   |\n25 |         let ext_cap = ext_upper.count(chr => chr.is_upper());\n   |                                           ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength_of_extension = cap - sm;\n        if (strength_of_extension > strength) {\n            strength = strength_of_extension;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpguzry6dc.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpguzry6dc.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpguzry6dc.rs:24:12\n   |\n24 |         if (strength_of_extension > strength) {\n   |            ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength_of_extension > strength) {\n24 +         if strength_of_extension > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpguzry6dc.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpguzry6dc.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpguzry6dc.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp_k1dhx3q.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp_k1dhx3q.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_k1dhx3q.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_k1dhx3q.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    let max_extension_strength = 0.0;\n    let max_extension_name_strength = 0.0;\n    let max_extension_name_index = 0;\n    let max_extension_index = 0;\n    let max_extension_name_index_index = 0;\n    let max_extension_index_index = 0;\n    let max_extension_name_index_index_index = 0;\n    let max_extension_index_index_index = 0;\n    let max_extension_name_index_index_index_index = 0;\n    let max_extension_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwcyi781l.rs:44:57\n   |\n44 |     let max_extension_name_index_index_index_index_index\n   |                                                         ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwcyi781l.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\");\n        let sm = ext.find(\"a\");\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpenp5lfso.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpenp5lfso.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength_of_ext = cap - sm;\n        if strength_of_ext > strength {\n            strength = strength_of_ext;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpc1dw9l83.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpc1dw9l83.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc1dw9l83.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmprpcab7ma.rs:21:20\n   |\n21 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmprpcab7ma.rs:21:9\n   |\n21 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for (extension in extensions) {\n21 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprpcab7ma.rs:25:12\n   |\n25 |         if (strength > max_strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -         if (strength > max_strength) {\n25 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmprpcab7ma.rs:22:29\n   |\n22 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmprpcab7ma.rs:23:28\n   |\n23 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprpcab7ma.rs:27:29\n   |\n20 |     let max_extension = \"\";\n   |                         -- expected due to this value\n...\n27 |             max_extension = extension;\n   |                             ^^^^^^^^^\n   |                             |\n   |                             expected `&str`, found struct `String`\n   |                             help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ko0hfav.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        strength += (cap - sm) / 26.0;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpqzvj2nfh.rs:21:23\n   |\n21 |         let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpqzvj2nfh.rs:22:22\n   |\n22 |         let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                      ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqzvj2nfh.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp3u3nofeu.rs:21:23\n   |\n21 |         let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp3u3nofeu.rs:22:22\n   |\n22 |         let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                      ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3u3nofeu.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    let best_strength = 0.0;\n    for(extension in extensions) {\n        let cap = extension.match(/[A-Z]/).len();\n        let sm = extension.match(/[a-z]/).len();\n        let strength = cap - sm;\n        if(strength > best_strength) {\n            best_strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpi23uvkrx.rs:21:19\n   |\n21 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpi23uvkrx.rs:21:8\n   |\n21 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for(extension in extensions) {\n21 +     forextension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmpi23uvkrx.rs:22:29\n   |\n22 |         let cap = extension.match(/[A-Z]/).len();\n   |                             ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n22 |         let cap = extension.r#match(/[A-Z]/).len();\n   |                             ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmpi23uvkrx.rs:22:35\n   |\n22 |         let cap = extension.match(/[A-Z]/).len();\n   |                                   ^ expected expression\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmplwpcpelf.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmplwpcpelf.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplwpcpelf.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmplwpcpelf.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplwpcpelf.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n    let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp2ib91zm6.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp2ib91zm6.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2ib91zm6.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2ib91zm6.rs:21:25\n   |\n21 |     let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                         ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2ib91zm6.rs:22:24\n   |\n22 |     let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                        ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ib91zm6.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\");\n        let sm = ext.find(\"a\");\n        let strength_val = cap - sm;\n        if strength_val > strength {\n            strength = strength_val;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmplxs1yatj.rs:23:32\n   |\n23 |         let strength_val = cap - sm;\n   |                            --- ^ -- Option<usize>\n   |                            |\n   |                            Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplxs1yatj.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmplwpcpelf.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmplwpcpelf.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplwpcpelf.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmplwpcpelf.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplwpcpelf.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength_of_extension = cap - sm;\n        if (strength_of_extension > strength) {\n            strength = strength_of_extension;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmper0llqb3.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmper0llqb3.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmper0llqb3.rs:24:12\n   |\n24 |         if (strength_of_extension > strength) {\n   |            ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength_of_extension > strength) {\n24 +         if strength_of_extension > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmper0llqb3.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmper0llqb3.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmper0llqb3.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors h",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp0xvvl700.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp0xvvl700.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0xvvl700.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp0xvvl700.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp0xvvl700.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0xvvl700.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --ex",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    let max_extension_strength = 0.0;\n    let max_extension_name_strength = 0.0;\n    let max_extension_name_index = 0;\n    let max_extension_index = 0;\n    let max_extension_name_index_index = 0;\n    let max_extension_index_index = 0;\n    let max_extension_name_index_index_index = 0;\n    let max_extension_index_index_index = 0;\n    let max_extension_name_index_index_index_index = 0;\n    let max_extension_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index_index_index = 0;\n    let max_extension_name_index_index_index_index_index_index_index_index_index_index = 0;\n    let max_extension_index_index_index_index_index_index_index_index_index\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpn2u714ou.rs:43:76\n   |\n43 |     let max_extension_index_index_index_index_index_index_index_index_index\n   |                                                                            ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn2u714ou.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength_val = cap - sm;\n        if(strength_val > strength) {\n            strength = strength_val;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpznh12o3t.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpznh12o3t.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpznh12o3t.rs:24:11\n   |\n24 |         if(strength_val > strength) {\n   |           ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength_val > strength) {\n24 +         if strength_val > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpznh12o3t.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpznh12o3t.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpznh12o3t.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.match(/([A-Z])/g).length;\n        let sm = extension.match(/([a-z])/g).length;\n        strength = cap - sm;\n        if(strength > strength) {\n            strength = cap - sm;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpyxmt3q86.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpyxmt3q86.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmpyxmt3q86.rs:21:29\n   |\n21 |         let cap = extension.match(/([A-Z])/g).length;\n   |                             ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n21 |         let cap = extension.r#match(/([A-Z])/g).length;\n   |                             ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmpyxmt3q86.rs:21:35\n   |\n21 |         let cap = extension.match(/([A-Z])/g).length;\n   |                                   ^ expected expression\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    let best_strength = 0.0;\n    for(extension in extensions) {\n        let cap = extension.match(/([A-Z])/).size;\n        let sm = extension.match(/([a-z])/).size;\n        let strength = cap - sm;\n        if(strength > best_strength) {\n            best_strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmplal2pfuo.rs:21:19\n   |\n21 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmplal2pfuo.rs:21:8\n   |\n21 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for(extension in extensions) {\n21 +     forextension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmplal2pfuo.rs:22:29\n   |\n22 |         let cap = extension.match(/([A-Z])/).size;\n   |                             ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n22 |         let cap = extension.r#match(/([A-Z])/).size;\n   |                             ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmplal2pfuo.rs:22:35\n   |\n22 |         let cap = extension.match(/([A-Z])/).size;\n   |                                   ^ expected expression\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpa_0s3mku.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpa_0s3mku.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa_0s3mku.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpa_0s3mku.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa_0s3mku.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let max_strength = 0.0;\n  let max_extension = String::from(\"\");\n  let max_extension_name = String::from(\"\");\n  let max_extension_strength = 0.0;\n  let max_extension_name_strength = 0.0;\n  let max_extension_name_index = 0;\n  let max_extension_index = 0;\n  let max_extension_name_index_index = 0;\n  let max_extension_index_index = 0;\n  let max_extension_name_index_index_index = 0;\n  let max_extension_index_index_index = 0;\n  let max_extension_name_index_index_index_index = 0;\n  let max_extension_index_index_index_index = 0;\n  let max_extension_name_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index = 0;\n  let max_extension_name_index_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_index = 0;\n  let max_extension_name_index_index_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_index_index = 0;\n  let max_extension_name_index_index_index_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_index_index_index = 0;\n  let max_extension_name_index_index_index_index_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_index_index_index_index = 0;\n  let max_extension_name_index_index_index_index_index_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_index_index_index_index\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpn29nsb4l.rs:43:74\n   |\n43 |   let max_extension_index_index_index_index_index_index_index_index_index\n   |                                                                          ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn29nsb4l.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  let best_extension_name = \"\";\n  let best_extension_strength = 0.0;\n  let best_extension_name_strength = 0.0;\n  let best_extension_name_strength_index = 0;\n  let best_extension_name_strength_index_index = 0;\n  let best_extension_name_strength_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index_index_index_index = 0;\n  let best_extension_name_strength_index_index_index_index_index_index_index_index_index_index =\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected expression, found `}`\n  --> /tmp/tmpym01hlp2.rs:39:1\n   |\n39 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmplwpcpelf.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmplwpcpelf.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplwpcpelf.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmplwpcpelf.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplwpcpelf.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmps5gnvcxs.rs:21:20\n   |\n21 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmps5gnvcxs.rs:21:9\n   |\n21 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for (extension in extensions) {\n21 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps5gnvcxs.rs:25:12\n   |\n25 |         if (strength > max_strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -         if (strength > max_strength) {\n25 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmps5gnvcxs.rs:22:29\n   |\n22 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmps5gnvcxs.rs:23:28\n   |\n23 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps5gnvcxs.rs:30:31\n   |\n30 |     return class_name + \".\" + max_extension;\n   |                               ^^^^^^^^^^^^^\n   |                               |\n   |                               expected `&str`, found struct `String`\n   |                               help: consider borrowing here: `&max_extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.match(/[A-Z]/).size;\n        let sm = extension.match(/[a-z]/).size;\n        strength += cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpvp0jje71.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpvp0jje71.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmpvp0jje71.rs:21:29\n   |\n21 |         let cap = extension.match(/[A-Z]/).size;\n   |                             ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n21 |         let cap = extension.r#match(/[A-Z]/).size;\n   |                             ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmpvp0jje71.rs:21:35\n   |\n21 |         let cap = extension.match(/[A-Z]/).size;\n   |                                   ^ expected expression\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp_k1dhx3q.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp_k1dhx3q.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_k1dhx3q.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_k1dhx3q.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpif5fwitu.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpif5fwitu.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpif5fwitu.rs:24:8\n   |\n24 |     if (strength > strength) {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpif5fwitu.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    for ext in extensions {\n        let cap = ext.count_uppercase_letters();\n        let sm = ext.count_lowercase_letters();\n        let strength = cap - sm;\n        if strength > max_strength {\n            max_strength = strength;\n            max_extension = ext;\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmpdbfshktv.rs:22:23\n   |\n22 |         let cap = ext.count_uppercase_letters();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmpdbfshktv.rs:23:22\n   |\n23 |         let sm = ext.count_lowercase_letters();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbfshktv.rs:30:31\n   |\n30 |     return class_name + \".\" + max_extension;\n   |                               ^^^^^^^^^^^^^\n   |                               |\n   |                               expected `&str`, found struct `String`\n   |                               help: consider borrowing here: `&max_extension`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ko0hfav.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp4h5s6yc8.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp4h5s6yc8.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4h5s6yc8.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpcl2xqz1z.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpcl2xqz1z.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcl2xqz1z.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpcl2xqz1z.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpcl2xqz1z.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcl2xqz1z.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    let max_extension_strength = 0.0;\n    let max_extension_name_strength = 0.0;\n    let max_extension_name_strength_index = 0;\n    let max_extension_name_strength_index_index = 0;\n    let max_extension_name_strength_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let max_extension_name_strength_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let max_\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpbbgsa88k.rs:39:13\n   |\n39 |     let max_\n   |             ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbbgsa88k.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp0xvvl700.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp0xvvl700.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0xvvl700.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp0xvvl700.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp0xvvl700.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0xvvl700.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --ex",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp3jz19r11.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp3jz19r11.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3jz19r11.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3jz19r11.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let strongest_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength_of_extension = cap - sm;\n    if (strength_of_extension > strength) {\n      strength = strength_of_extension;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp8bdhpmqt.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp8bdhpmqt.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8bdhpmqt.rs:24:8\n   |\n24 |     if (strength_of_extension > strength) {\n   |        ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength_of_extension > strength) {\n24 +     if strength_of_extension > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp8bdhpmqt.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp8bdhpmqt.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bdhpmqt.rs:26:29\n   |\n19 |   let strongest_extension = \"\";\n   |                             -- expected due to this value\n...\n26 |       strongest_extension = extension;\n   |                             ^^^^^^^^^\n   |                             |\n   |                             expected `&str`, found struct `String`\n   |                             help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = \"\";\n    let max_class = \"\";\n    for (extension in extensions) {\n        let cap = extension.match(/([A-Z])/g).length;\n        let sm = extension.match(/([a-z])/g).length;\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_class = class_name;\n        }\n    }\n    return max_class + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpqj6lxixx.rs:22:20\n   |\n22 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpqj6lxixx.rs:22:9\n   |\n22 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for (extension in extensions) {\n22 +     for extension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmpqj6lxixx.rs:23:29\n   |\n23 |         let cap = extension.match(/([A-Z])/g).length;\n   |                             ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n23 |         let cap = extension.r#match(/([A-Z])/g).length;\n   |                             ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmpqj6lxixx.rs:23:35\n   |\n23 |         let cap = extension.match(/([A-Z])/g).length;\n   |                                   ^ expected expression\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpqj6lxixx.rs:32:22\n   |\n32 |     return max_class + \".\" + max_extension;\n   |            --------- ^ --- &str\n   |            |         |\n   |            |         `+` cannot be used to concatenate two `&str` strings\n   |            &str\n   |\n   = note: string concatenation requires an owned `String` on the left\nhelp: create an owned `String` from a string reference\n   |\n32 |     return max_class.to_owned() + \".\" + max_extension;\n   |                     +++++++++++\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpgwz9ktli.rs:21:23\n   |\n21 |         let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpgwz9ktli.rs:22:22\n   |\n22 |         let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                      ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgwz9ktli.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if(strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpyky_md5x.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpyky_md5x.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyky_md5x.rs:24:11\n   |\n24 |         if(strength > best_extension.length()) {\n   |           ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpyky_md5x.rs:24:38\n   |\n24 |         if(strength > best_extension.length()) {\n   |                                      ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyky_md5x.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^^^^^^^^^\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp_k1dhx3q.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp_k1dhx3q.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_k1dhx3q.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_k1dhx3q.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        strength += (cap - sm) / cap;\n        if(strength > best_extension) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp8a0s53dt.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp8a0s53dt.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8a0s53dt.rs:24:11\n   |\n24 |         if(strength > best_extension) {\n   |           ^                         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > best_extension) {\n24 +         if strength > best_extension {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp8a0s53dt.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp8a0s53dt.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8a0s53dt.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror[E0277]: can't compare `{float}` with `&str`\n  --> /tmp/tmp8a0s53dt.rs:24:21\n   |\n24 |         if(strength > best_extension) {\n   |                     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength_val = cap - sm;\n        if (strength_val > strength) {\n            strength = strength_val;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp2yqv_qui.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp2yqv_qui.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2yqv_qui.rs:24:12\n   |\n24 |         if (strength_val > strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength_val > strength) {\n24 +         if strength_val > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2yqv_qui.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2yqv_qui.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2yqv_qui.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = \"\";\n    let max_extension_strength = 0.0;\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_extension_strength = strength;\n        }\n    }\n    let class_name_extension = class_name + \".\" + max_extension;\n    if (max_extension_strength == 0.0) {\n        return class_name_extension;\n    }\n    return class_name_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpvonlx635.rs:22:20\n   |\n22 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpvonlx635.rs:22:9\n   |\n22 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for (extension in extensions) {\n22 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvonlx635.rs:26:12\n   |\n26 |         if (strength > max_strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -         if (strength > max_strength) {\n26 +         if strength > max_strength {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvonlx635.rs:33:8\n   |\n33 |     if (max_extension_strength == 0.0) {\n   |        ^                             ^\n   |\nhelp: remove these parentheses\n   |\n33 -     if (max_extension_strength == 0.0) {\n33 +     if max_extension_strength == 0.0 {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpvonlx635.rs:23:29\n   |\n23 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpvonlx635.rs:24:28\n   |\n24 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvonlx635.rs:28:29\n   |\n20 |     let max_extension = \"\";\n   |                         -- expected due to this value\n...\n28 |             max_extension = extension;\n   |                      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        let strength_val = cap - sm;\n        if (strength_val > strength) {\n            strength = strength_val;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpzj78r5p5.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpzj78r5p5.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzj78r5p5.rs:24:12\n   |\n24 |         if (strength_val > strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength_val > strength) {\n24 +         if strength_val > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpzj78r5p5.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpzj78r5p5.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzj78r5p5.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpif5fwitu.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpif5fwitu.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpif5fwitu.rs:24:8\n   |\n24 |     if (strength > strength) {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpif5fwitu.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ko0hfav.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let max_strength = 0.0;\n  let max_extension = String::from(\"\");\n  let max_extension_name = String::from(\"\");\n  let max_extension_strength = 0.0;\n  let max_extension_name_strength = 0.0;\n  let max_extension_name_index = 0;\n  let max_extension_name_index_strength = 0.0;\n  let max_extension_index = 0;\n  let max_extension_index_strength = 0.0;\n  let max_extension_index_index = 0;\n  let max_extension_index_index_strength = 0.0;\n  let max_extension_index_index_index = 0;\n  let max_extension_index_index_index_strength = 0.0;\n  let max_extension_index_index_index_index = 0;\n  let max_extension_index_index_index_index_strength = 0.0;\n  let max_extension_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_strength = 0.0;\n  let max_extension_index_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_index_strength = 0.0;\n  let max_extension_index_index_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_index_index_strength = 0.0;\n  let max_extension_index_index_index_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_index_index_index_strength = 0.0;\n  let max_extension_index_index_index_index_index_index_index_index_index = 0;\n  let max_extension_index_index_index_index_index_index_index_index_index_strength = 0.0;\n  let max_extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpq1vkz3vn.rs:44:20\n   |\n44 |   let max_extension\n   |                    ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq1vkz3vn.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp3jz19r11.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp3jz19r11.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3jz19r11.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3jz19r11.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if(strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpyky_md5x.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpyky_md5x.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyky_md5x.rs:24:11\n   |\n24 |         if(strength > best_extension.length()) {\n   |           ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpyky_md5x.rs:24:38\n   |\n24 |         if(strength > best_extension.length()) {\n   |                                      ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyky_md5x.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^^^^^^^^^\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.match(/([A-Z])/g).length;\n    let sm = extension.match(/([a-z])/g).length;\n    strength += (cap - sm) / cap;\n    if (strength > best_extension.length) {\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp2150fgbr.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp2150fgbr.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmp2150fgbr.rs:21:25\n   |\n21 |     let cap = extension.match(/([A-Z])/g).length;\n   |                         ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n21 |     let cap = extension.r#match(/([A-Z])/g).length;\n   |                         ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmp2150fgbr.rs:21:31\n   |\n21 |     let cap = extension.match(/([A-Z])/g).length;\n   |                               ^ expected expression\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp5mgj24wt.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp5mgj24wt.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5mgj24wt.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp5mgj24wt.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp5mgj24wt.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5mgj24wt.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = extension;\n   |                                   ^^^^^^^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed expl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let strongest_extension = String::from(\"\");\n  for (extension in extensions) {\n    let cap = extension.count_uppercase_letters();\n    let sm = extension.count_lowercase_letters();\n    let strength = cap - sm;\n    if (strength > strength) {\n      strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpwa7sn9n1.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpwa7sn9n1.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa7sn9n1.rs:24:8\n   |\n24 |     if (strength > strength) {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmpwa7sn9n1.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase_letters();\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmpwa7sn9n1.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase_letters();\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwa7sn9n1.rs:29:29\n   |\n29 |   return class_name + \".\" + strongest_extension;\n   |                             ^^^^^^^^^^^^^^^^^^^\n   |                             |\n   |                             expected `&str`, found struct `String`\n   |                             help: consider borrowing here: `&strongest_extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpcl2xqz1z.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpcl2xqz1z.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcl2xqz1z.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpcl2xqz1z.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpcl2xqz1z.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcl2xqz1z.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpfht51j6z.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpfht51j6z.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfht51j6z.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpfht51j6z.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpfht51j6z.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfht51j6z.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp3jz19r11.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp3jz19r11.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3jz19r11.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3jz19r11.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    let best_strength = 0.0;\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > best_strength) {\n            best_strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpqugqc6fv.rs:21:19\n   |\n21 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpqugqc6fv.rs:21:8\n   |\n21 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for(extension in extensions) {\n21 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqugqc6fv.rs:25:11\n   |\n25 |         if(strength > best_strength) {\n   |           ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -         if(strength > best_strength) {\n25 +         if strength > best_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpqugqc6fv.rs:22:29\n   |\n22 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpqugqc6fv.rs:23:28\n   |\n23 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqugqc6fv.rs:27:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n27 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpcl2xqz1z.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpcl2xqz1z.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcl2xqz1z.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpcl2xqz1z.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpcl2xqz1z.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcl2xqz1z.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    for (extension in extensions) {\n        let cap = extension.count_uppercase_chars();\n        let sm = extension.count_lowercase_chars();\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_extension_name = extension;\n        }\n    }\n    let result = class_name + \".\" + max_extension_name;\n    return result;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpdyy1qmrp.rs:22:20\n   |\n22 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpdyy1qmrp.rs:22:9\n   |\n22 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for (extension in extensions) {\n22 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdyy1qmrp.rs:26:12\n   |\n26 |         if (strength > max_strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -         if (strength > max_strength) {\n26 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase_chars` found for struct `String` in the current scope\n  --> /tmp/tmpdyy1qmrp.rs:23:29\n   |\n23 |         let cap = extension.count_uppercase_chars();\n   |                             ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase_chars` found for struct `String` in the current scope\n  --> /tmp/tmpdyy1qmrp.rs:24:28\n   |\n24 |         let sm = extension.count_lowercase_chars();\n   |                            ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdyy1qmrp.rs:32:37\n   |\n32 |     let result = class_name + \".\" + max_extension_name;\n   |                                     ^^^^^^^^^^^^^^^^^^\n   |                                     |\n   |                                     expected `&str`, found struct `String`\n   |                                     help: consider borrowing here: `&max_extension_name`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let max_strength = 0.0;\n  let max_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      max_extension = extension;\n    }\n  }\n  let max_extension_name = max_extension.to_string();\n  let class_name_extension = class_name.concat(max_extension_name);\n  return class_name_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp3bb078kg.rs:21:18\n   |\n21 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp3bb078kg.rs:21:7\n   |\n21 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -   for (extension in extensions) {\n21 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3bb078kg.rs:25:8\n   |\n25 |     if (strength > max_strength) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     if (strength > max_strength) {\n25 +     if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp3bb078kg.rs:22:25\n   |\n22 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp3bb078kg.rs:23:24\n   |\n23 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3bb078kg.rs:27:23\n   |\n20 |   let max_extension = \"\";\n   |                       -- expected due to this value\n...\n27 |       max_extension = extension;\n   |                       ^^^^^^^^^\n   |                       |\n   |                       expected `&str`, found struct `String`\n   |                       help: consider borrowing here: `&extension`\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmp3bb078kg.rs:31:41\n   |\n31 |   let class_name_extension = class_name.concat(max_extension_name);\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpa_0s3mku.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpa_0s3mku.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa_0s3mku.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpa_0s3mku.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa_0s3mku.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let class_name_upper = class_name.to_upper();\n  let class_name_lower = class_name.to_lower();\n  let strength = 0.0;\n  let strongest_extension = String::from(\"\");\n  for(extension in extensions) {\n    let extension_upper = extension.to_upper();\n    let extension_lower = extension.to_lower();\n    let cap = extension_upper.count(\"A\");\n    let sm = extension_lower.count(\"a\");\n    let strength_of_extension = cap - sm;\n    if(strength_of_extension > strength) {\n      strength = strength_of_extension;\n      strongest_extension = extension;\n    }\n  }\n  return class_name_upper + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpcecopb6d.rs:22:17\n   |\n22 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpcecopb6d.rs:22:6\n   |\n22 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -   for(extension in extensions) {\n22 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcecopb6d.rs:28:7\n   |\n28 |     if(strength_of_extension > strength) {\n   |       ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n28 -     if(strength_of_extension > strength) {\n28 +     if strength_of_extension > strength {\n   | \n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpcecopb6d.rs:18:37\n   |\n18 |   let class_name_upper = class_name.to_upper();\n   |                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpcecopb6d.rs:19:37\n   |\n19 |   let class_name_lower = class_name.to_lower();\n   |                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpcecopb6d.rs:23:37\n   |\n23 |     let extension_upper = extension.to_upper();\n   |                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpcecopb6d.rs:24:37\n   |\n24 |     let extension_lower = extension.to_lower();\n   |                                     ^^^^^^^^ help: there is an associated fun",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\").is_some() ? 1 : 0;\n        let sm = ext.find(\"a\").is_some() ? 1 : 0;\n        strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n  --> /tmp/tmpt5ddkk6z.rs:21:45\n   |\n21 |         let cap = ext.find(\"A\").is_some() ? 1 : 0;\n   |                                             ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp_k1dhx3q.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp_k1dhx3q.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_k1dhx3q.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_k1dhx3q.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmplwpcpelf.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmplwpcpelf.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplwpcpelf.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmplwpcpelf.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplwpcpelf.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\");\n        let sm = ext.find(\"a\");\n        let strength_val = cap - sm;\n        if strength_val > strength {\n            strength = strength_val;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmp64a9i9sp.rs:23:32\n   |\n23 |         let strength_val = cap - sm;\n   |                            --- ^ -- Option<usize>\n   |                            |\n   |                            Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp64a9i9sp.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp3jz19r11.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp3jz19r11.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3jz19r11.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3jz19r11.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpgwz9ktli.rs:21:23\n   |\n21 |         let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpgwz9ktli.rs:22:22\n   |\n22 |         let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                      ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgwz9ktli.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if strength > best_extension.length() {\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmphon680vu.rs:21:23\n   |\n21 |         let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmphon680vu.rs:22:22\n   |\n22 |         let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                      ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmphon680vu.rs:24:38\n   |\n24 |         if strength > best_extension.length() {\n   |                                      ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphon680vu.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    for(extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if(strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_extension_name = extension.split(\".\").last();\n        }\n    }\n    let result = class_name + \".\" + max_extension_name;\n    return result;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpsbn508g8.rs:22:19\n   |\n22 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpsbn508g8.rs:22:8\n   |\n22 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for(extension in extensions) {\n22 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsbn508g8.rs:26:11\n   |\n26 |         if(strength > max_strength) {\n   |           ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -         if(strength > max_strength) {\n26 +         if strength > max_strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpsbn508g8.rs:25:28\n   |\n25 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsbn508g8.rs:29:34\n   |\n21 |     let max_extension_name = String::from(\"\");\n   |                              ---------------- expected due to this value\n...\n29 |             max_extension_name = extension.split(\".\").last();\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n                found enum `Option<&str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsbn508g8.rs:32:37\n   |\n32 |     let result = class_name + \".\" + max_extension_name;\n   |                                     ^^^^^^^^^^^^^^^^^^\n   |                                     |\n   |                                     expected `&str`, found struct `String`\n   |                                     help: consider borrowing here: `&max_extension_name`\n\nerror: aborting due to 5 previous erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\").is_some() ? 1 : 0;\n        let sm = ext.find(\"a\").is_some() ? 1 : 0;\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n  --> /tmp/tmp2_olv33z.rs:21:45\n   |\n21 |         let cap = ext.find(\"A\").is_some() ? 1 : 0;\n   |                                             ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\");\n        let sm = ext.find(\"a\");\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpiln07kf7.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiln07kf7.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_extension_name = extension.to_lower();\n        }\n    }\n    let max_extension_name_upper = max_extension_name.to_upper();\n    let class_name_upper = class_name.to_upper();\n    let class_name_plus_extension = class_name + \".\" + max_extension_name_upper;\n    return class_name_plus_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp67lm1zmb.rs:22:19\n   |\n22 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp67lm1zmb.rs:22:8\n   |\n22 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for(extension in extensions) {\n22 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp67lm1zmb.rs:26:11\n   |\n26 |         if(strength > max_strength) {\n   |           ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -         if(strength > max_strength) {\n26 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp67lm1zmb.rs:23:29\n   |\n23 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp67lm1zmb.rs:24:28\n   |\n24 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp67lm1zmb.rs:29:44\n   |\n29 |             max_extension_name = extension.to_lower();\n   |                                            ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp67lm1zmb.rs:32:55\n   |\n32 |     let max_extension_name_upper = max_extension_name.to_upper();\n   |                                             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength_of_extension = cap - sm;\n    if (strength_of_extension > strength) {\n      strength = strength_of_extension;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp2341v2do.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp2341v2do.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2341v2do.rs:24:8\n   |\n24 |     if (strength_of_extension > strength) {\n   |        ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength_of_extension > strength) {\n24 +     if strength_of_extension > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp2341v2do.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp2341v2do.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2341v2do.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength_of_extension = cap - sm;\n        if (strength_of_extension > strength) {\n            strength = strength_of_extension;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpguzry6dc.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpguzry6dc.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpguzry6dc.rs:24:12\n   |\n24 |         if (strength_of_extension > strength) {\n   |            ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength_of_extension > strength) {\n24 +         if strength_of_extension > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpguzry6dc.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpguzry6dc.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpguzry6dc.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  let best_extension_name = \"\";\n  for(extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n      best_extension_name = extension;\n    }\n  }\n  let class_name_extension = class_name + \".\" + best_extension;\n  return class_name_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpz0u5h8em.rs:21:17\n   |\n21 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpz0u5h8em.rs:21:6\n   |\n21 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -   for(extension in extensions) {\n21 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz0u5h8em.rs:25:7\n   |\n25 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     if(strength > strength) {\n25 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpz0u5h8em.rs:22:25\n   |\n22 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpz0u5h8em.rs:23:24\n   |\n23 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz0u5h8em.rs:27:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n27 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz0u5h8em.rs:28:29\n   |\n20 |   let best_extension_name = \"\";\n   |                             -- expected due to this value\n...\n28 |       best_extension_name = extension",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpgwz9ktli.rs:21:23\n   |\n21 |         let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpgwz9ktli.rs:22:22\n   |\n22 |         let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                      ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgwz9ktli.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength_of_ext = cap - sm;\n        if strength_of_ext > strength {\n            strength = strength_of_ext;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpc1dw9l83.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpc1dw9l83.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc1dw9l83.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let class_name_len = class_name.len();\n    let class_name_upper = class_name.to_upper();\n    let class_name_lower = class_name.to_lower();\n    let class_name_upper_len = class_name_upper.len();\n    let class_name_lower_len = class_name_lower.len();\n    let class_name_upper_count = 0;\n    let class_name_lower_count = 0;\n    let class_name_upper_count_sum = 0;\n    let class_name_lower_count_sum = 0;\n    let class_name_upper_count_max = 0;\n    let class_name_lower_count_max = 0;\n    let class_name_upper_count_min = 0;\n    let class_name_lower_count_min = 0;\n    let class_name_upper_count_sum_max = 0;\n    let class_name_lower_count_sum_max = 0;\n    let class_name_upper_count_sum_min = 0;\n    let class_name_lower_count_sum_min = 0;\n    let class_name_upper_count_sum_sum = 0;\n    let class_name_lower_count_sum_sum = 0;\n    let class_name_upper_count_sum_sum_max = 0;\n    let class_name_lower_count_sum_sum_max = 0;\n    let class_name_upper_count_sum_sum_min = 0;\n    let class_name_lower_count_sum_sum_min = 0;\n    let class_name_upper_count_sum_sum_sum = 0;\n    let class_name_lower_count_sum_sum_sum = 0;\n    let class_name_upper_count_sum_sum_sum_max = 0;\n    let class_name_lower_count_sum_sum_sum_max = 0;\n    let class_name_upper_count_sum_sum_sum_min = 0;\n    let class_name_lower_count_sum_sum_sum_min = 0;\n    let class_name_upper_count\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp7vaqeeq1.rs:47:31\n   |\n47 |     let class_name_upper_count\n   |                               ^ help: add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp7vaqeeq1.rs:19:39\n   |\n19 |     let class_name_upper = class_name.to_upper();\n   |                                       ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp7vaqeeq1.rs:20:39\n   |\n20 |     let class_name_lower = class_name.to_lower();\n   |                                       ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7vaqeeq1.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if (strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpf0zw67rc.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpf0zw67rc.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf0zw67rc.rs:24:12\n   |\n24 |         if (strength > best_extension.length()) {\n   |            ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:24:39\n   |\n24 |         if (strength > best_extension.length()) {\n   |                                       ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf0zw67rc.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if(strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpyky_md5x.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpyky_md5x.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyky_md5x.rs:24:11\n   |\n24 |         if(strength > best_extension.length()) {\n   |           ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpyky_md5x.rs:24:38\n   |\n24 |         if(strength > best_extension.length()) {\n   |                                      ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyky_md5x.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^^^^^^^^^\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if (strength > best_extension.len()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp1lnj2m0h.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp1lnj2m0h.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1lnj2m0h.rs:24:12\n   |\n24 |         if (strength > best_extension.len()) {\n   |            ^                               ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > best_extension.len()) {\n24 +         if strength > best_extension.len() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp1lnj2m0h.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp1lnj2m0h.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1lnj2m0h.rs:24:24\n   |\n24 |         if (strength > best_extension.len()) {\n   |                        ^^^^^^^^^^^^^^^^^^^^ expected floating-point number, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1lnj2m0h.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    let best_strength = 0.0;\n    let best_index = 0;\n    let best_extension_name = \"\";\n    let best_extension_strength = 0.0;\n    let best_extension_index = 0;\n    let extension_count = extensions.len();\n    for (i in 0..extension_count) {\n        let extension = extensions[i];\n        let extension_strength = 0.0;\n        let extension_name = \"\";\n        let extension_index = 0;\n        let extension_count = extension.len();\n        for (j in 0..extension_count) {\n            let char = extension[j];\n            if (char.is_upper()) {\n                extension_strength += 1.0;\n            } else {\n                extension_strength += 0.5;\n            }\n            extension_name += char;\n        }\n        extension_strength /= extension_count;\n        if (extension_strength > strength) {\n            strength = extension_strength;\n            best_extension = extension;\n            best_extension_name = extension_name;\n            best_extension_strength = extension_strength;\n            best_extension_index = i;\n        }\n    }\n    let class_name_length = class_name.len();\n    let class_name_upper = class_name.to_upper();\n    let class_name_lower = class_name.to_lower();\n    let best_extension_name_length = best_extension_name.len();\n    let best_extension_name_upper = best_extension_name.to_upper();\n    let best_extension_name_lower = best_extension_name.to_lower();\n    let best_extension_name_index = 0;\n    let best_extension_name_count = best_extension_name.len();\n    for (i in 0..best_extension_name_count) {\n        let char = best_extension_name[i];\n        if (char.is_upper()) {\n            best_extension_name\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp64n01ic.rs:75:3\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |                                                                               - unclosed delimiter\n...\n58 |     for (i in 0..best_extension_name_count) {\n   |                                             - unclosed delimiter\n59 |         let char = best_extension_name[i];\n60 |         if (char.is_upper()) {\n   |                              - this delimiter might not be properly closed...\n61 |             best_extension_name\n62 | }\n   | - ...as it matches this but it has different indentation\n...\n75 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpp64n01ic.rs:26:12\n   |\n26 |     for (i in 0..extension_count) {\n   |            ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpp64n01ic.rs:26:9\n   |\n26 |     for (i in 0..extension_count) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n26 -     for (i in 0..extension_count) {\n26 +     for i in 0..extension_count {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpp64n01ic.rs:32:16\n   |\n32 |         for (j in 0..extension_count) {\n   |                ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpp64n01ic.rs:32:13\n   |\n32 |         for (j in 0..extension_count) {\n   |             ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n32 -         for (j in 0..extension_count) {\n32 +         for j in 0..extension_count {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpp64n01ic.rs:58:12\n   |\n58 |     for (i in 0..best_extension_name_count) {\n   |            ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpp64n01ic.rs:58:9\n   |\n58 |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n    let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp2ib91zm6.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp2ib91zm6.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2ib91zm6.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2ib91zm6.rs:21:25\n   |\n21 |     let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                         ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2ib91zm6.rs:22:24\n   |\n22 |     let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                        ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ib91zm6.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    let best_strength = 0.0;\n    for (extension in extensions) {\n        let cap = extension.match(/([A-Z])/g).length;\n        let sm = extension.match(/([a-z])/g).length;\n        let strength = cap - sm;\n        if (strength > best_strength) {\n            best_strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp0dsed7o9.rs:21:20\n   |\n21 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp0dsed7o9.rs:21:9\n   |\n21 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for (extension in extensions) {\n21 +     for extension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmp0dsed7o9.rs:22:29\n   |\n22 |         let cap = extension.match(/([A-Z])/g).length;\n   |                             ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n22 |         let cap = extension.r#match(/([A-Z])/g).length;\n   |                             ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmp0dsed7o9.rs:22:35\n   |\n22 |         let cap = extension.match(/([A-Z])/g).length;\n   |                                   ^ expected expression\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpif5fwitu.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpif5fwitu.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpif5fwitu.rs:24:8\n   |\n24 |     if (strength > strength) {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpif5fwitu.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = \"\";\n    let max_extension_strength = 0.0;\n    for (extension in extensions) {\n        let cap = extension.count_uppercase_letters();\n        let sm = extension.count_lowercase_letters();\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_extension_strength = strength;\n        }\n    }\n    let max_extension_name = max_extension.to_s();\n    let max_extension_name_split = max_extension_name.split(\".\");\n    let max_extension_name_first = max_extension_name_split[0];\n    let max_extension_name_last = max_extension_name_split[1];\n    let max_extension_name_first_upper = max_extension_name_first.to_upper();\n    let max_extension_name_last_lower = max_extension_name_last.to_lower();\n    let max_extension_name_first_upper_last_lower = max_extension_name_first_upper + \".\" + max_extension_name_last_lower;\n    return class_name + \".\" + max_extension_name_first_upper_last_lower;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpzqgzcqgy.rs:22:20\n   |\n22 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpzqgzcqgy.rs:22:9\n   |\n22 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for (extension in extensions) {\n22 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzqgzcqgy.rs:26:12\n   |\n26 |         if (strength > max_strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -         if (strength > max_strength) {\n26 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmpzqgzcqgy.rs:23:29\n   |\n23 |         let cap = extension.count_uppercase_letters();\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmpzqgzcqgy.rs:24:28\n   |\n24 |         let sm = extension.count_lowercase_letters();\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzqgzcqgy.rs:28:29\n   |\n20 |     let max_extension = \"\";\n   |                         -- expected due to this value\n...\n28 |             max_extension = extension;\n   |                             ^^^^^^^^^\n   |                             |\n   |                             expected `&str`, found struct `String`\n   |                             help: consider borrowing here: `&extension`\n\nerror[E0599]: no method named `to_s` found for reference `&str` in th",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ko0hfav.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\");\n        let sm = ext.find(\"a\");\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpiln07kf7.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiln07kf7.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_extension_name = extension.to_lower();\n        }\n    }\n    let max_extension_name_lower = max_extension_name.to_lower();\n    let class_name_lower = class_name.to_lower();\n    let max_extension_name_class_name_lower = max_extension_name_lower + \".\" + class_name_lower;\n    if(max_extension_name_class_name_lower == class_name_lower) {\n        return class_name + \".\" + max_extension;\n    } else {\n        return class_name + \".\" + max_extension_name_lower;\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpbz38ir6b.rs:22:19\n   |\n22 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpbz38ir6b.rs:22:8\n   |\n22 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for(extension in extensions) {\n22 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz38ir6b.rs:26:11\n   |\n26 |         if(strength > max_strength) {\n   |           ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -         if(strength > max_strength) {\n26 +         if strength > max_strength {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz38ir6b.rs:35:7\n   |\n35 |     if(max_extension_name_class_name_lower == class_name_lower) {\n   |       ^                                                       ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if(max_extension_name_class_name_lower == class_name_lower) {\n35 +     if max_extension_name_class_name_lower == class_name_lower {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpbz38ir6b.rs:23:29\n   |\n23 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpbz38ir6b.rs:24:28\n   |\n24 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpbz38ir6b.rs:29:44\n   |\n29 |             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpgwz9ktli.rs:21:23\n   |\n21 |         let cap = ext.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpgwz9ktli.rs:22:22\n   |\n22 |         let sm = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                      ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgwz9ktli.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\");\n        let sm = ext.find(\"a\");\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpiln07kf7.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiln07kf7.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_strength = 0.0;\n    let max_extension_name = String::from(\"\");\n    let max_extension_name_strength = 0.0;\n    let max_extension_name_name = String::from(\"\");\n    let max_extension_name_name_strength = 0.0;\n    let max_extension_name_name_name = String::from(\"\");\n    let max_extension_name_name_name_strength = 0.0;\n    let max_extension_name_name_name_name = String::from(\"\");\n    let max_extension_name_name_name_name_strength = 0.0;\n    let max_extension_name_name_name_name_name = String::from(\"\");\n    let max_extension_name_name_name_name_name_strength = 0.0;\n    let max_extension_name_name_name_name_name_name = String::from(\"\");\n    let max_extension_name_name_name_name_name_name_strength = 0.0;\n    let max_extension_name_name_name_name_name_name_name = String::from(\"\");\n    let max_extension_name_name_name_name_name_name_name_strength = 0.0;\n    let max_extension_name_name_name_name_name_name_name_name = String::from(\"\");\n    let max_extension_name_name_name_name_name_name_name_name_strength = 0.0;\n    let max_extension_name_name_name_name_name_name_name_name_name = String::from(\"\");\n    let max_extension_name_name_name_name_name_name_name_name_name_strength = 0.0;\n    let max_extension_name_name_name_name_name_name_name_name_name_name = String::from(\"\");\n    let max_extension_name_\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpt76aidmt.rs:41:28\n   |\n41 |     let max_extension_name_\n   |                            ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt76aidmt.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp_k1dhx3q.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp_k1dhx3q.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_k1dhx3q.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_k1dhx3q.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let class_name_len = class_name.len();\n    let class_name_upper = class_name.upper();\n    let class_name_lower = class_name.lower();\n    let class_name_extensions = class_name_lower.split(\".\");\n    let class_name_extensions_len = class_name_extensions.len();\n    let class_name_extensions_upper = class_name_extensions.map(|x| x.upper());\n    let class_name_extensions_lower = class_name_extensions.map(|x| x.lower());\n    let class_name_extensions_extensions = class_name_extensions.map(|x| x.split(\".\"));\n    let class_name_extensions_extensions_len = class_name_extensions_extensions.len();\n    let class_name_extensions_extensions_upper = class_name_extensions_extensions.map(|x| x.upper());\n    let class_name_extensions_extensions_lower = class_name_extensions_extensions.map(|x| x.lower());\n    let class_name_extensions_extensions_extensions = class_name_extensions_extensions.map(|x| x.split(\".\"));\n    let class_name_extensions_extensions_extensions_len = class_name_extensions_extensions_extensions.len();\n    let class_name_extensions_extensions_extensions_upper = class_name_extensions_extensions_extensions.map(|x| x.upper());\n    let class_name_extensions_extensions_extensions_lower = class_name_extensions_extensions_extensions.map(|x| x.lower());\n    let class_name_extensions_extensions_extensions_extensions = class_name_extensions_extensions_extensions.map(|x| x.split(\".\"));\n    let class_name_extensions_extensions_extensions_extensions_len = class_name_extensions_extensions_extensions_extensions.len();\n    let class_name_extensions_extensions_\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpe5zfzobk.rs:35:42\n   |\n35 |     let class_name_extensions_extensions_\n   |                                          ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0599]: no method named `upper` found for struct `String` in the current scope\n  --> /tmp/tmpe5zfzobk.rs:19:39\n   |\n19 |     let class_name_upper = class_name.upper();\n   |                                       ^^^^^ method not found in `String`\n\nerror[E0599]: no method named `lower` found for struct `String` in the current scope\n  --> /tmp/tmpe5zfzobk.rs:20:39\n   |\n20 |     let class_name_lower = class_name.lower();\n   |                                       ^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe5zfzobk.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpa_0s3mku.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpa_0s3mku.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa_0s3mku.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpa_0s3mku.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa_0s3mku.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase_letters();\n        let sm = ext.count_lowercase_letters();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmptkl6gmmo.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase_letters();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmptkl6gmmo.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase_letters();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptkl6gmmo.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if (strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpf0zw67rc.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpf0zw67rc.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf0zw67rc.rs:24:12\n   |\n24 |         if (strength > best_extension.length()) {\n   |            ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:24:39\n   |\n24 |         if (strength > best_extension.length()) {\n   |                                       ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf0zw67rc.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength_val = cap - sm;\n        if (strength_val > strength) {\n            strength = strength_val;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp2yqv_qui.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp2yqv_qui.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2yqv_qui.rs:24:12\n   |\n24 |         if (strength_val > strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength_val > strength) {\n24 +         if strength_val > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2yqv_qui.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2yqv_qui.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2yqv_qui.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let max_strength = 0.0;\n  let max_extension = String::from(\"\");\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      max_extension = extension;\n    }\n  }\n  let max_extension_str = max_extension.to_s();\n  let class_name_str = class_name.to_s();\n  let result = class_name_str + \".\" + max_extension_str;\n  return result;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpgui3eiss.rs:21:18\n   |\n21 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpgui3eiss.rs:21:7\n   |\n21 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -   for (extension in extensions) {\n21 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgui3eiss.rs:25:8\n   |\n25 |     if (strength > max_strength) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     if (strength > max_strength) {\n25 +     if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpgui3eiss.rs:22:25\n   |\n22 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpgui3eiss.rs:23:24\n   |\n23 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_s` found for struct `String` in the current scope\n  --> /tmp/tmpgui3eiss.rs:30:41\n   |\n30 |   let max_extension_str = max_extension.to_s();\n   |                                         ^^^^ method not found in `String`\n\nerror[E0599]: no method named `to_s` found for struct `String` in the current scope\n  --> /tmp/tmpgui3eiss.rs:31:35\n   |\n31 |   let class_name_str = class_name.to_s();\n   |                                   ^^^^ method not found in `String`\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, tr",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ko0hfav.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp0xvvl700.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp0xvvl700.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0xvvl700.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp0xvvl700.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp0xvvl700.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0xvvl700.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --ex",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > max_strength {\n            max_strength = strength;\n            max_extension = ext;\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmppqznmwjf.rs:22:23\n   |\n22 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmppqznmwjf.rs:23:22\n   |\n23 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppqznmwjf.rs:30:31\n   |\n30 |     return class_name + \".\" + max_extension;\n   |                               ^^^^^^^^^^^^^\n   |                               |\n   |                               expected `&str`, found struct `String`\n   |                               help: consider borrowing here: `&max_extension`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    let max_extension_strength = 0.0;\n    let max_extension_name_strength = 0.0;\n    let extension_name_strength = 0.0;\n    let extension_name = String::from(\"\");\n    let extension_name_strength = 0.0;\n    let extension_strength = 0.0;\n    let extension = String::from(\"\");\n    let extension_strength = 0.0;\n    let class_name_strength = 0.0;\n    let class_name_strength_sum = 0.0;\n    let class_name_strength_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum_sum_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0.0;\n    let class_name_strength_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0.0;\n\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp1a51veee.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(c => c.is_upper());\n        let sm = ext.find(c => c.is_lower());\n        let strength_of_ext = cap - sm;\n        if strength_of_ext > strength {\n            strength = strength_of_ext;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpz3774x7t.rs:21:30\n   |\n21 |         let cap = ext.find(c => c.is_upper());\n   |                              ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpfht51j6z.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpfht51j6z.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfht51j6z.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpfht51j6z.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpfht51j6z.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfht51j6z.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase_letters();\n        let sm = ext.count_lowercase_letters();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmp7gtk3xno.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase_letters();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmp7gtk3xno.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase_letters();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7gtk3xno.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    let best_strength = 0.0;\n    for(extension in extensions) {\n        let cap = 0.0;\n        let sm = 0.0;\n        let cap_sm = 0.0;\n        let cap_sm_str = \"\";\n        let cap_sm_str_len = 0;\n        let cap_str = \"\";\n        let sm_str = \"\";\n        let cap_str_len = 0;\n        let sm_str_len = 0;\n        let cap_str_str = \"\";\n        let sm_str_str = \"\";\n        let cap_str_str_len = 0;\n        let sm_str_str_len = 0;\n        let cap_sm_str_len = 0;\n        let cap_sm_str_str = \"\";\n        let cap_sm_str_str_len = 0;\n        let cap_sm_str_str_cap = 0;\n        let cap_sm_str_str_sm = 0;\n        let cap_sm_str_str_cap_sm = 0;\n        let cap_sm_str_str_cap_sm_str = \"\";\n        let cap_sm_str_str_cap_sm_str_len = 0;\n        let cap_sm_str_str_cap_sm_str_cap = 0;\n        let cap_sm_str_str_cap_sm_str_sm = 0;\n        let cap_sm_str_str_cap_sm_str_cap_sm = 0;\n        let cap_sm_str_str_cap_sm_str_cap_sm_str = \"\";\n        let cap_sm_str_str_cap_sm_str_cap_sm_str_len = 0;\n        let cap_sm_str_str_cap_sm_str_cap_sm_str_cap = 0;\n        let cap_sm_str_str_cap_sm_str_cap_sm_str_sm = 0;\n        let cap_sm_str_str_cap_sm_str_cap_sm_str_cap_sm = 0;\n        let cap\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2322z4l8.rs:65:3\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |                                                                               - unclosed delimiter\n...\n21 |     for(extension in extensions) {\n   |                                  - this delimiter might not be properly closed...\n...\n52 | }\n   | - ...as it matches this but it has different indentation\n...\n65 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp2322z4l8.rs:21:19\n   |\n21 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp2322z4l8.rs:21:8\n   |\n21 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for(extension in extensions) {\n21 +     forextension in extensions {\n   | \n\nerror: expected `;`, found `}`\n  --> /tmp/tmp2322z4l8.rs:51:16\n   |\n51 |         let cap\n   |                ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2322z4l8.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n   |    -------------------                                                 ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let class_name_upper = class_name.to_upper();\n    let class_name_lower = class_name.to_lower();\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    let extension_names = extensions.map(extension => extension.to_lower());\n    for extension in extension_names {\n        let extension_upper = extension.to_upper();\n        let extension_lower = extension.to_lower();\n        let cap = extension_upper.count(c => c.is_upper());\n        let sm = extension_lower.count(c => c.is_lower());\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name_upper + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpq3lolshn.rs:22:52\n   |\n22 |     let extension_names = extensions.map(extension => extension.to_lower());\n   |                                                    ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpif5fwitu.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpif5fwitu.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpif5fwitu.rs:24:8\n   |\n24 |     if (strength > strength) {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpif5fwitu.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let class_name_upper = class_name.to_upper();\n    let class_name_lower = class_name.to_lower();\n    let strength = 0;\n    let strongest_extension = \"\";\n    for(extension in extensions) {\n        let extension_upper = extension.to_upper();\n        let extension_lower = extension.to_lower();\n        let cap = extension_upper.count(chr(65));\n        let sm = extension_lower.count(chr(97));\n        let strength_of_extension = cap - sm;\n        if(strength_of_extension > strength) {\n            strength = strength_of_extension;\n            strongest_extension = extension;\n        }\n    }\n    return class_name_upper + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpjct4_hf3.rs:22:19\n   |\n22 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpjct4_hf3.rs:22:8\n   |\n22 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for(extension in extensions) {\n22 +     forextension in extensions {\n   | \n\nerror[E0425]: cannot find function `chr` in this scope\n  --> /tmp/tmpjct4_hf3.rs:25:41\n   |\n25 |         let cap = extension_upper.count(chr(65));\n   |                                         ^^^ not found in this scope\n\nerror[E0425]: cannot find function `chr` in this scope\n  --> /tmp/tmpjct4_hf3.rs:26:40\n   |\n26 |         let sm = extension_lower.count(chr(97));\n   |                                        ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjct4_hf3.rs:28:11\n   |\n28 |         if(strength_of_extension > strength) {\n   |           ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n28 -         if(strength_of_extension > strength) {\n28 +         if strength_of_extension > strength {\n   | \n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpjct4_hf3.rs:18:39\n   |\n18 |     let class_name_upper = class_name.to_upper();\n   |                                       ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjct4_hf3.rs:19:39\n   |\n19 |     let class_name_lower = class_name.to_lower();\n   |                                       ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scop",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpa_0s3mku.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpa_0s3mku.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa_0s3mku.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpa_0s3mku.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa_0s3mku.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpa_0s3mku.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpa_0s3mku.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa_0s3mku.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpa_0s3mku.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa_0s3mku.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(c => c.is_upper());\n        let sm = ext.find(c => c.is_lower());\n        let strength_val = cap - sm;\n        if strength_val > strength {\n            strength = strength_val;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp4bcdkeco.rs:21:30\n   |\n21 |         let cap = ext.find(c => c.is_upper());\n   |                              ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmprpcab7ma.rs:21:20\n   |\n21 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmprpcab7ma.rs:21:9\n   |\n21 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for (extension in extensions) {\n21 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprpcab7ma.rs:25:12\n   |\n25 |         if (strength > max_strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -         if (strength > max_strength) {\n25 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmprpcab7ma.rs:22:29\n   |\n22 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmprpcab7ma.rs:23:28\n   |\n23 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprpcab7ma.rs:27:29\n   |\n20 |     let max_extension = \"\";\n   |                         -- expected due to this value\n...\n27 |             max_extension = extension;\n   |                             ^^^^^^^^^\n   |                             |\n   |                             expected `&str`, found struct `String`\n   |                             help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if(strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpyky_md5x.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpyky_md5x.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyky_md5x.rs:24:11\n   |\n24 |         if(strength > best_extension.length()) {\n   |           ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpyky_md5x.rs:24:38\n   |\n24 |         if(strength > best_extension.length()) {\n   |                                      ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyky_md5x.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^^^^^^^^^\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\");\n        let sm = ext.find(\"a\");\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpiln07kf7.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiln07kf7.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let class_name_upper = class_name.to_upper();\n  let class_name_lower = class_name.to_lower();\n  let strength = 0.0;\n  let strongest_extension = \"\";\n  for(extension in extensions) {\n    let ext_upper = extension.to_upper();\n    let ext_lower = extension.to_lower();\n    let ext_cap = ext_upper.count(\"A\");\n    let ext_sm = ext_lower.count(\"a\");\n    let ext_strength = (ext_cap - ext_sm) / ext_cap;\n    if(ext_strength > strength) {\n      strength = ext_strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name_upper + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp2qp6ht5d.rs:22:17\n   |\n22 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp2qp6ht5d.rs:22:6\n   |\n22 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -   for(extension in extensions) {\n22 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2qp6ht5d.rs:28:7\n   |\n28 |     if(ext_strength > strength) {\n   |       ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n28 -     if(ext_strength > strength) {\n28 +     if ext_strength > strength {\n   | \n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp2qp6ht5d.rs:18:37\n   |\n18 |   let class_name_upper = class_name.to_upper();\n   |                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp2qp6ht5d.rs:19:37\n   |\n19 |   let class_name_lower = class_name.to_lower();\n   |                                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp2qp6ht5d.rs:23:31\n   |\n23 |     let ext_upper = extension.to_upper();\n   |                               ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp2qp6ht5d.rs:24:31\n   |\n24 |     let ext_lower = extension.to_lower();\n   |                               ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mis",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.match(/([A-Z])/).size;\n        let sm = extension.match(/([a-z])/).size;\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp9czk3mgi.rs:21:20\n   |\n21 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp9czk3mgi.rs:21:9\n   |\n21 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for (extension in extensions) {\n21 +     for extension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmp9czk3mgi.rs:22:29\n   |\n22 |         let cap = extension.match(/([A-Z])/).size;\n   |                             ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n22 |         let cap = extension.r#match(/([A-Z])/).size;\n   |                             ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmp9czk3mgi.rs:22:35\n   |\n22 |         let cap = extension.match(/([A-Z])/).size;\n   |                                   ^ expected expression\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpn90uwqf9.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpn90uwqf9.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn90uwqf9.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpn90uwqf9.rs:21:25\n   |\n21 |     let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                         ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpn90uwqf9.rs:22:24\n   |\n22 |     let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                        ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn90uwqf9.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n        }\n    }\n    let class_name_extension = class_name + \".\" + max_extension;\n    return class_name_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp0y9y48b7.rs:21:20\n   |\n21 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp0y9y48b7.rs:21:9\n   |\n21 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for (extension in extensions) {\n21 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0y9y48b7.rs:25:12\n   |\n25 |         if (strength > max_strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -         if (strength > max_strength) {\n25 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp0y9y48b7.rs:22:29\n   |\n22 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp0y9y48b7.rs:23:28\n   |\n23 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0y9y48b7.rs:30:51\n   |\n30 |     let class_name_extension = class_name + \".\" + max_extension;\n   |                                                   ^^^^^^^^^^^^^\n   |                                                   |\n   |                                                   expected `&str`, found struct `String`\n   |                                                   help: consider borrowing here: `&max_extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed expl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpif5fwitu.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpif5fwitu.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpif5fwitu.rs:24:8\n   |\n24 |     if (strength > strength) {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpif5fwitu.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp_k1dhx3q.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp_k1dhx3q.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_k1dhx3q.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp_k1dhx3q.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_k1dhx3q.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if(strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpyky_md5x.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpyky_md5x.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyky_md5x.rs:24:11\n   |\n24 |         if(strength > best_extension.length()) {\n   |           ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpyky_md5x.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpyky_md5x.rs:24:38\n   |\n24 |         if(strength > best_extension.length()) {\n   |                                      ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyky_md5x.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^^^^^^^^^\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        let strength_of_extension = cap - sm;\n        if(strength_of_extension > strength) {\n            strength = strength_of_extension;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmph68i3jnf.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmph68i3jnf.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph68i3jnf.rs:24:11\n   |\n24 |         if(strength_of_extension > strength) {\n   |           ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength_of_extension > strength) {\n24 +         if strength_of_extension > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmph68i3jnf.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmph68i3jnf.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph68i3jnf.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.find(\"A\");\n    let sm = extension.find(\"a\");\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpz8fixs1g.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpz8fixs1g.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz8fixs1g.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpz8fixs1g.rs:23:24\n   |\n23 |     let strength = cap - sm;\n   |                    --- ^ -- Option<usize>\n   |                    |\n   |                    Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz8fixs1g.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.match(/([A-Z])/g).map(|m| m.to_upper()).count();\n        let sm = extension.match(/([a-z])/g).map(|m| m.to_lower()).count();\n        strength += cap - sm;\n        if (strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpw_xx1q1q.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpw_xx1q1q.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmpw_xx1q1q.rs:21:29\n   |\n21 |         let cap = extension.match(/([A-Z])/g).map(|m| m.to_upper()).count();\n   |                             ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n21 |         let cap = extension.r#match(/([A-Z])/g).map(|m| m.to_upper()).count();\n   |                             ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmpw_xx1q1q.rs:21:35\n   |\n21 |         let cap = extension.match(/([A-Z])/g).map(|m| m.to_upper()).count();\n   |                                   ^ expected expression\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\");\n        let sm = ext.find(\"a\");\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpiln07kf7.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiln07kf7.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    for (extension in extensions) {\n        let cap = extension.count_uppercase_chars();\n        let sm = extension.count_lowercase_chars();\n        let strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_extension_name = extension;\n        }\n    }\n    let max_extension_name_str = max_extension_name.to_string();\n    let max_extension_str = max_extension.to_string();\n    let max_extension_name_str_split = max_extension_name_str.split(\".\");\n    let max_extension_str_split = max_extension_str.split(\".\");\n    let max_extension_name_str_split_length = max_extension_name_str_split.length;\n    let max_extension_str_split_length = max_extension_str_split.length;\n    let max_extension_name_str_split_last = max_extension_name_str_split[max_extension_name_str_split_length - 1];\n    let max_extension_str_split_last = max_extension_str_split[max_extension_str_split_length - 1];\n    let max_extension_name_str_split_last_length = max_extension_name_str_split_last.length;\n    let max_extension_str_split_last_length = max_extension_str_split_last.length;\n    let max_extension_name_str_split_last_first = max_extension_name_str_split_last[0];\n    let max_extension_str_split_last_first = max_extension_str_split_last[0];\n    let max_extension_name_str_split_last_first_length = max_\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpt9am_6ii.rs:22:20\n   |\n22 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpt9am_6ii.rs:22:9\n   |\n22 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for (extension in extensions) {\n22 +     for extension in extensions {\n   | \n\nerror: expected `;`, found `}`\n  --> /tmp/tmpt9am_6ii.rs:44:62\n   |\n44 |     let max_extension_name_str_split_last_first_length = max_\n   |                                                              ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `max_` in this scope\n  --> /tmp/tmpt9am_6ii.rs:44:58\n   |\n44 |     let max_extension_name_str_split_last_first_length = max_\n   |                                                          ^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt9am_6ii.rs:26:12\n   |\n26 |         if (strength > max_strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -         if (strength > max_strength) {\n26 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase_chars` found for struct `String` in the current scope\n  --> /tmp/tmpt9am_6ii.rs:23:29\n   |\n23 |         let cap = extension.count_uppercase_chars();\n   |                             ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase_chars` found for struct `String` in the current scope\n  --> /tmp/tmpt9am_6ii.rs:24:28\n   |\n24 |         let sm = extension.count_lowercase_chars();\n   |                            ^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0609]: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    let max_extension_name = String::from(\"\");\n    let max_extension_strength = 0.0;\n    let max_extension_name_strength = 0.0;\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_extension_name = extension.split(\".\").last();\n            max_extension_strength = strength;\n            max_extension_name_strength = strength;\n        } else if(strength == max_strength) {\n            if(extension < max_extension) {\n                max_extension = extension;\n                max_extension_name = extension.split(\".\").last();\n                max_extension_strength = strength;\n                max_extension_name_strength = strength;\n            } else if(extension == max_extension) {\n                if(extension < max_extension_name) {\n                    max_extension = extension;\n                    max_extension_name = extension.split(\".\").last();\n                    max_extension_strength = strength;\n                    max_extension_name_strength = strength;\n                } else if(extension == max_extension_name) {\n                    if(extension < max_extension_name_strength) {\n                        max_extension = extension;\n                        max_extension_name = extension.split(\".\").last();\n                        max_extension_strength = strength;\n                        max_extension_name_strength = strength;\n                    }\n                }\n            }\n        }\n    }\n    let result = class_name.split(\".\").last() + \".\" + max_extension;\n    return result;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpflzbpamt.rs:24:19\n   |\n24 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpflzbpamt.rs:24:8\n   |\n24 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n24 -     for(extension in extensions) {\n24 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpflzbpamt.rs:28:11\n   |\n28 |         if(strength > max_strength) {\n   |           ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n28 -         if(strength > max_strength) {\n28 +         if strength > max_strength {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpflzbpamt.rs:34:18\n   |\n34 |         } else if(strength == max_strength) {\n   |                  ^                        ^\n   |\nhelp: remove these parentheses\n   |\n34 -         } else if(strength == max_strength) {\n34 +         } else if strength == max_strength {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpflzbpamt.rs:35:15\n   |\n35 |             if(extension < max_extension) {\n   |               ^                         ^\n   |\nhelp: remove these parentheses\n   |\n35 -             if(extension < max_extension) {\n35 +             if extension < max_extension {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpflzbpamt.rs:40:22\n   |\n40 |             } else if(extension == max_extension) {\n   |                      ^                          ^\n   |\nhelp: remove these parentheses\n   |\n40 -             } else if(extension == max_extension) {\n40 +             } else if extension == max_extension {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpflzbpamt.rs:41:19\n   |\n41 |                 if(extension < max_exten",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let class_name_lower = class_name.to_lower();\n  let class_name_upper = class_name.to_upper();\n  let strength = 0.0;\n  let strongest_extension = \"\";\n  let extension_count = 0;\n  for(extension in extensions) {\n    let extension_lower = extension.to_lower();\n    let extension_upper = extension.to_upper();\n    let extension_count_upper = extension_count.to_upper();\n    let extension_count_lower = extension_count.to_lower();\n    let strength_upper = strength.to_upper();\n    let strength_lower = strength.to_lower();\n    let strength_diff = 0.0;\n    if(extension_count_upper > extension_count_lower) {\n      strength_diff = 1.0;\n    } else if(extension_count_lower > extension_count_upper) {\n      strength_diff = -1.0;\n    }\n    if(extension_count_upper > 0 && extension_count_lower > 0) {\n      strength_diff = strength_diff + (extension_count_upper - extension_count_lower);\n    }\n    if(extension_count_upper > 0 && strength_diff > strength) {\n      strength = strength_diff;\n      strongest_extension = extension;\n    } else if(extension_count_lower > 0 && strength_diff < strength) {\n      strength = strength_diff;\n      strongest_extension = extension;\n    }\n    extension_count = extension_count + 1;\n  }\n  let extension_count_upper = extension_count.to_upper();\n  let extension_count_lower = extension_count.to_lower();\n  if(extension_count_upper > 0 && extension_count_lower > 0) {\n    strength = strength + (extension_count_upper - extension_count_lower);\n  }\n  if(strength > 0) {\n    return class_name_lower + \".\" + strongest_extension;\n  } else {\n    return class_name_lower;\n  }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp0sqht4ah.rs:23:17\n   |\n23 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp0sqht4ah.rs:23:6\n   |\n23 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n23 -   for(extension in extensions) {\n23 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0sqht4ah.rs:31:7\n   |\n31 |     if(extension_count_upper > extension_count_lower) {\n   |       ^                                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n31 -     if(extension_count_upper > extension_count_lower) {\n31 +     if extension_count_upper > extension_count_lower {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0sqht4ah.rs:33:14\n   |\n33 |     } else if(extension_count_lower > extension_count_upper) {\n   |              ^                                             ^\n   |\nhelp: remove these parentheses\n   |\n33 -     } else if(extension_count_lower > extension_count_upper) {\n33 +     } else if extension_count_lower > extension_count_upper {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0sqht4ah.rs:36:7\n   |\n36 |     if(extension_count_upper > 0 && extension_count_lower > 0) {\n   |       ^                                                      ^\n   |\nhelp: remove these parentheses\n   |\n36 -     if(extension_count_upper > 0 && extension_count_lower > 0) {\n36 +     if extension_count_upper > 0 && extension_count_lower > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0sqht4ah.rs:39:7\n   |\n39 |     if(extension_count_upper > 0 && strength_diff > strength) {\n   |       ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n39 -     if(extension_co",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if (strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpf0zw67rc.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpf0zw67rc.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf0zw67rc.rs:24:12\n   |\n24 |         if (strength > best_extension.length()) {\n   |            ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:24:39\n   |\n24 |         if (strength > best_extension.length()) {\n   |                                       ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf0zw67rc.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp3jz19r11.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp3jz19r11.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3jz19r11.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp3jz19r11.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3jz19r11.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let strongest_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > strength) {\n      strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpkypytito.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpkypytito.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkypytito.rs:24:8\n   |\n24 |     if (strength > strength) {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpkypytito.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpkypytito.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkypytito.rs:26:29\n   |\n19 |   let strongest_extension = \"\";\n   |                             -- expected due to this value\n...\n26 |       strongest_extension = extension;\n   |                             ^^^^^^^^^\n   |                             |\n   |                             expected `&str`, found struct `String`\n   |                             help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --expla",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let max_strength = 0.0;\n  let max_extension = \"\";\n  let max_extension_name = \"\";\n  let max_extension_strength = 0.0;\n  let max_extension_name_strength = 0.0;\n  for (extension in extensions) {\n    let cap = extension.count_uppercase_letters();\n    let sm = extension.count_lowercase_letters();\n    let strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      max_extension = extension;\n      max_extension_name = extension.to_lower();\n      max_extension_strength = strength;\n      max_extension_name_strength = strength;\n    } else if (strength == max_strength) {\n      if (extension < max_extension) {\n        max_extension = extension;\n        max_extension_name = extension.to_lower();\n        max_extension_strength = strength;\n        max_extension_name_strength = strength;\n      } else if (extension == max_extension) {\n        if (extension < max_extension_name) {\n          max_extension = extension;\n          max_extension_name = extension.to_lower();\n          max_extension_strength = strength;\n          max_extension_name_strength = strength;\n        } else if (extension == max_extension_name) {\n          if (extension < max_extension_name_strength) {\n            max_extension = extension;\n            max_extension_name = extension.to_lower();\n            max_extension_strength = strength;\n            max_extension_name_strength = strength;\n          }\n        }\n      }\n    }\n  }\n  let result = class_name + \".\" + max_extension_name;\n  if (max_extension_strength != max_extension_name_strength) {\n    result += \".\" + max_extension_name;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpo6oq197k.rs:24:18\n   |\n24 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpo6oq197k.rs:24:7\n   |\n24 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n24 -   for (extension in extensions) {\n24 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo6oq197k.rs:28:8\n   |\n28 |     if (strength > max_strength) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n28 -     if (strength > max_strength) {\n28 +     if strength > max_strength {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo6oq197k.rs:34:15\n   |\n34 |     } else if (strength == max_strength) {\n   |               ^                        ^\n   |\nhelp: remove these parentheses\n   |\n34 -     } else if (strength == max_strength) {\n34 +     } else if strength == max_strength {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo6oq197k.rs:35:10\n   |\n35 |       if (extension < max_extension) {\n   |          ^                         ^\n   |\nhelp: remove these parentheses\n   |\n35 -       if (extension < max_extension) {\n35 +       if extension < max_extension {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo6oq197k.rs:40:17\n   |\n40 |       } else if (extension == max_extension) {\n   |                 ^                          ^\n   |\nhelp: remove these parentheses\n   |\n40 -       } else if (extension == max_extension) {\n40 +       } else if extension == max_extension {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo6oq197k.rs:41:12\n   |\n41 |         if (extension < max_extension_name) {\n   |            ^                              ^\n   |\nhelp: remove th",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpl4emznkw.rs:20:19\n   |\n20 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpl4emznkw.rs:20:8\n   |\n20 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for(extension in extensions) {\n20 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl4emznkw.rs:24:11\n   |\n24 |         if(strength > strength) {\n   |           ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if(strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpl4emznkw.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4emznkw.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmphjyiv8by.rs:21:19\n   |\n21 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmphjyiv8by.rs:21:8\n   |\n21 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for(extension in extensions) {\n21 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphjyiv8by.rs:25:11\n   |\n25 |         if(strength > max_strength) {\n   |           ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -         if(strength > max_strength) {\n25 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmphjyiv8by.rs:22:29\n   |\n22 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmphjyiv8by.rs:23:28\n   |\n23 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphjyiv8by.rs:30:31\n   |\n30 |     return class_name + \".\" + max_extension;\n   |                               ^^^^^^^^^^^^^\n   |                               |\n   |                               expected `&str`, found struct `String`\n   |                               help: consider borrowing here: `&max_extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.find(\"A\");\n    let sm = extension.find(\"a\");\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpz8fixs1g.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpz8fixs1g.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz8fixs1g.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpz8fixs1g.rs:23:24\n   |\n23 |     let strength = cap - sm;\n   |                    --- ^ -- Option<usize>\n   |                    |\n   |                    Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz8fixs1g.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpn90uwqf9.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpn90uwqf9.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn90uwqf9.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpn90uwqf9.rs:21:25\n   |\n21 |     let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                         ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpn90uwqf9.rs:22:24\n   |\n22 |     let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                        ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn90uwqf9.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        strength += cap - sm;\n        if (strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpdz6_g21t.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpdz6_g21t.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdz6_g21t.rs:24:12\n   |\n24 |         if (strength > best_extension.length()) {\n   |            ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpdz6_g21t.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpdz6_g21t.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpdz6_g21t.rs:24:39\n   |\n24 |         if (strength > best_extension.length()) {\n   |                                       ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdz6_g21t.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   | ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n        strength += cap - sm;\n        if (strength > best_extension.length()) {\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpf0zw67rc.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpf0zw67rc.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf0zw67rc.rs:24:12\n   |\n24 |         if (strength > best_extension.length()) {\n   |            ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > best_extension.length()) {\n24 +         if strength > best_extension.length() {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `length` found for reference `&str` in the current scope\n  --> /tmp/tmpf0zw67rc.rs:24:39\n   |\n24 |         if (strength > best_extension.length()) {\n   |                                       ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf0zw67rc.rs:25:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n25 |             best_extension = extension;\n   |                              ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for(extension in extensions) {\n    let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n    let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n    let strength = cap - sm;\n    if(strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp2ib91zm6.rs:20:17\n   |\n20 |   for(extension in extensions) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp2ib91zm6.rs:20:6\n   |\n20 |   for(extension in extensions) {\n   |      ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for(extension in extensions) {\n20 +   forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2ib91zm6.rs:24:7\n   |\n24 |     if(strength > strength) {\n   |       ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if(strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2ib91zm6.rs:21:25\n   |\n21 |     let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").to_i();\n   |                         ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmp2ib91zm6.rs:22:24\n   |\n22 |     let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\").to_i();\n   |                        ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ib91zm6.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpfht51j6z.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpfht51j6z.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfht51j6z.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpfht51j6z.rs:21:29\n   |\n21 |         let cap = extension.find_first_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n   |                             ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `find_first_of` found for struct `String` in the current scope\n  --> /tmp/tmpfht51j6z.rs:22:28\n   |\n22 |         let sm = extension.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n   |                            ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfht51j6z.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength_val = cap - sm;\n        if (strength_val > strength) {\n            strength = strength_val;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmppug7yfg1.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmppug7yfg1.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppug7yfg1.rs:24:12\n   |\n24 |         if (strength_val > strength) {\n   |            ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength_val > strength) {\n24 +         if strength_val > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmppug7yfg1.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmppug7yfg1.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppug7yfg1.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpif5fwitu.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpif5fwitu.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpif5fwitu.rs:24:8\n   |\n24 |     if (strength > strength) {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpif5fwitu.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    let best_strength = 0.0;\n    for(extension in extensions) {\n        let cap = extension.match(/[A-Z]/).size;\n        let sm = extension.match(/[a-z]/).size;\n        let strength = cap - sm;\n        if(strength > best_strength) {\n            best_strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpt3jqjtap.rs:21:19\n   |\n21 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpt3jqjtap.rs:21:8\n   |\n21 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for(extension in extensions) {\n21 +     forextension in extensions {\n   | \n\nerror: expected identifier, found keyword `match`\n  --> /tmp/tmpt3jqjtap.rs:22:29\n   |\n22 |         let cap = extension.match(/[A-Z]/).size;\n   |                             ^^^^^ expected identifier, found keyword\n   |\nhelp: escape `match` to use it as an identifier\n   |\n22 |         let cap = extension.r#match(/[A-Z]/).size;\n   |                             ++\n\nerror: expected expression, found `/`\n  --> /tmp/tmpt3jqjtap.rs:22:35\n   |\n22 |         let cap = extension.match(/[A-Z]/).size;\n   |                                   ^ expected expression\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ko0hfav.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            best_extension = ext;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmp7ko0hfav.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ko0hfav.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = ext;\n   |                              ^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let strength = 0.0;\n  let best_extension = \"\";\n  for (extension in extensions) {\n    let cap = extension.count_uppercase();\n    let sm = extension.count_lowercase();\n    let strength = cap - sm;\n    if (strength > strength) {\n      strength = strength;\n      best_extension = extension;\n    }\n  }\n  return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpif5fwitu.rs:20:18\n   |\n20 |   for (extension in extensions) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpif5fwitu.rs:20:7\n   |\n20 |   for (extension in extensions) {\n   |       ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -   for (extension in extensions) {\n20 +   for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpif5fwitu.rs:24:8\n   |\n24 |     if (strength > strength) {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -     if (strength > strength) {\n24 +     if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:21:25\n   |\n21 |     let cap = extension.count_uppercase();\n   |                         ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpif5fwitu.rs:22:24\n   |\n22 |     let sm = extension.count_lowercase();\n   |                        ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpif5fwitu.rs:26:24\n   |\n19 |   let best_extension = \"\";\n   |                        -- expected due to this value\n...\n26 |       best_extension = extension;\n   |                        ^^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmof5ha70.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmof5ha70.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmof5ha70.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:21:29\n   |\n21 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpmof5ha70.rs:22:28\n   |\n22 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmof5ha70.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.count_uppercase_letters();\n        let sm = ext.count_lowercase_letters();\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmptkl6gmmo.rs:21:23\n   |\n21 |         let cap = ext.count_uppercase_letters();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase_letters` found for struct `String` in the current scope\n  --> /tmp/tmptkl6gmmo.rs:22:22\n   |\n22 |         let sm = ext.count_lowercase_letters();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptkl6gmmo.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = String::from(\"\");\n    for ext in extensions {\n        let cap = ext.count_uppercase();\n        let sm = ext.count_lowercase();\n        let strength = cap - sm;\n        if strength > max_strength {\n            max_strength = strength;\n            max_extension = ext;\n        }\n    }\n    return class_name + \".\" + max_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmppqznmwjf.rs:22:23\n   |\n22 |         let cap = ext.count_uppercase();\n   |                       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmppqznmwjf.rs:23:22\n   |\n23 |         let sm = ext.count_lowercase();\n   |                      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppqznmwjf.rs:30:31\n   |\n30 |     return class_name + \".\" + max_extension;\n   |                               ^^^^^^^^^^^^^\n   |                               |\n   |                               expected `&str`, found struct `String`\n   |                               help: consider borrowing here: `&max_extension`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let strongest_extension = \"\";\n    for ext in extensions {\n        let cap = ext.find(\"A\");\n        let sm = ext.find(\"a\");\n        let strength = cap - sm;\n        if strength > strength {\n            strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpenp5lfso.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpenp5lfso.rs:26:35\n   |\n19 |     let strongest_extension = \"\";\n   |                               -- expected due to this value\n...\n26 |             strongest_extension = ext;\n   |                                   ^^^\n   |                                   |\n   |                                   expected `&str`, found struct `String`\n   |                                   help: consider borrowing here: `&ext`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let best_extension = \"\";\n    for (extension in extensions) {\n        let cap = extension.find(\"A\");\n        let sm = extension.find(\"a\");\n        let strength = cap - sm;\n        if (strength > strength) {\n            strength = strength;\n            best_extension = extension;\n        }\n    }\n    return class_name + \".\" + best_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpa_0s3mku.rs:20:20\n   |\n20 |     for (extension in extensions) {\n   |                    ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpa_0s3mku.rs:20:9\n   |\n20 |     for (extension in extensions) {\n   |         ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n20 -     for (extension in extensions) {\n20 +     for extension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa_0s3mku.rs:24:12\n   |\n24 |         if (strength > strength) {\n   |            ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -         if (strength > strength) {\n24 +         if strength > strength {\n   | \n\nerror[E0369]: cannot subtract `Option<usize>` from `Option<usize>`\n  --> /tmp/tmpa_0s3mku.rs:23:28\n   |\n23 |         let strength = cap - sm;\n   |                        --- ^ -- Option<usize>\n   |                        |\n   |                        Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa_0s3mku.rs:26:30\n   |\n19 |     let best_extension = \"\";\n   |                          -- expected due to this value\n...\n26 |             best_extension = extension;\n   |                              ^^^^^^^^^\n   |                              |\n   |                              expected `&str`, found struct `String`\n   |                              help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n  let class_name_lower = class_name.to_lower();\n  let extensions_lower = extensions.map(extension => extension.to_lower());\n  let strength = 0;\n  let strongest_extension = \"\";\n  let strongest_extension_name = \"\";\n  for (extension of extensions_lower) {\n    let extension_name_lower = extension.to_lower();\n    let cap_count = extension_name_lower.count(\"\");\n    let sm_count = extension_name_lower.count(\"\");\n    let strength = cap_count - sm_count;\n    if (strength > strength) {\n      strength = strength;\n      strongest_extension = extension;\n      strongest_extension_name = extension_name_lower;\n    }\n  }\n  let class_name_extension = class_name_lower + \".\" + strongest_extension_name;\n  return class_name_extension;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp6v55y_0r.rs:19:51\n   |\n19 |   let extensions_lower = extensions.map(extension => extension.to_lower());\n   |                                                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let strength = 0.0;\n    let max_strength = 0.0;\n    let max_extension = \"\";\n    let max_extension_name = \"\";\n    for(extension in extensions) {\n        let cap = extension.count_uppercase();\n        let sm = extension.count_lowercase();\n        let strength = cap - sm;\n        if(strength > max_strength) {\n            max_strength = strength;\n            max_extension = extension;\n            max_extension_name = extension;\n        }\n    }\n    return class_name + \".\" + max_extension_name;\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n",
      "timestamp": 1664292516,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpq8qfigz2.rs:22:19\n   |\n22 |     for(extension in extensions) {\n   |                   ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpq8qfigz2.rs:22:8\n   |\n22 |     for(extension in extensions) {\n   |        ^                       ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n22 -     for(extension in extensions) {\n22 +     forextension in extensions {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpq8qfigz2.rs:26:11\n   |\n26 |         if(strength > max_strength) {\n   |           ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -         if(strength > max_strength) {\n26 +         if strength > max_strength {\n   | \n\nerror[E0599]: no method named `count_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpq8qfigz2.rs:23:29\n   |\n23 |         let cap = extension.count_uppercase();\n   |                             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `count_lowercase` found for struct `String` in the current scope\n  --> /tmp/tmpq8qfigz2.rs:24:28\n   |\n24 |         let sm = extension.count_lowercase();\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq8qfigz2.rs:28:29\n   |\n20 |     let max_extension = \"\";\n   |                         -- expected due to this value\n...\n28 |             max_extension = extension;\n   |                             ^^^^^^^^^\n   |                             |\n   |                             expected `&str`, found struct `String`\n   |                             help: consider borrowing here: `&extension`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq8qfigz2.rs:29:34\n   |\n21 |     let max_extension_name = \"\";\n   |                ",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}