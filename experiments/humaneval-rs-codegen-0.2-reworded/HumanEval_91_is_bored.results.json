{
  "name": "HumanEval_91_is_bored",
  "language": "rs",
  "prompt": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n",
  "tests": "}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut last = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    } else {\n      last = i.index();\n    }\n  }\n  if last == 0 {\n    return count;\n  }\n  return count + 1;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp2fd7u8a7.rs:12:14\n   |\n12 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n12 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut last_char = ' ';\n  for c in S {\n    if c == '.' || c == '?' || c == '!' {\n      if last_char == 'I' {\n        count += 1;\n      }\n      last_char = c;\n    } else {\n      last_char = c;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpjnntg9fa.rs:12:12\n   |\n12 |   for c in S {\n   |            ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !(S.starts_with(\"I\") && S.ends_with(\".\")) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpyr4emi9b.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmp2h4w68i6.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.chars().next().is_some() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpskcq8thx.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpr57ck2lf.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for s in S.split(\".\") {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp0s67y269.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S.get(i) == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpopkpejs3.rs:11:12\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpopkpejs3.rs:11:18\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split(\".\").map(|s| {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  })\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `return`\n  --> /tmp/tmpdbldcnk6.rs:16:3\n   |\n16 |   return count;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n16 |   { return count; }\n   |   +               +\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpr57ck2lf.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmp2h4w68i6.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut is_bored = false;\n  for isize i = 0; i < S.len(); i += 1 {\n    let c = S.get(i);\n    if c == '.' || c == '?' || c == '!' {\n      count += 1;\n      if count == 2 {\n        is_bored = true;\n        break;\n      }\n    } else {\n      count = 0;\n    }\n  }\n  return is_bored;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp0huyllcj.rs:12:12\n   |\n12 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp0huyllcj.rs:12:18\n   |\n12 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !is_bored_word(S.get(i)) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_bored_word` in this scope\n  --> /tmp/tmp708acn69.rs:12:9\n   |\n12 |     if !is_bored_word(S.get(i)) {\n   |         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp708acn69.rs:12:29\n   |\n12 |     if !is_bored_word(S.get(i)) {\n   |                             ^ help: a local variable with a similar name exists: `S`\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp708acn69.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split(\".\") {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp49e4pmr2.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  let last_char = ' ';\n  for c in S {\n    if c == '.' || c == '?' || c == '!' {\n      if last_char == 'I' {\n        count += 1;\n      }\n    }\n    last_char = c;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmps4f529r4.rs:12:12\n   |\n12 |   for c in S {\n   |            ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.chars().next().is_some(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpy9__q1ew.rs:12:25\n    |\n12  |     if S.chars().next().is_some(\"I\") {\n    |                         ^^^^^^^ --- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpdv05e957.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if S.at(count).is_lower() {\n      count += 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpavg9sw4f.rs:94:3\n   |\n9  | fn is_bored(S: String) -> isize {\n   |                                 - unclosed delimiter\n10 |   let count = 0;\n11 |   for _ in S.chars() {\n   |                      - unclosed delimiter\n...\n82 |     if S.at(count).is_lower() {\n   |                               - this delimiter might not be properly closed...\n83 |       count += 1\n84 | }\n   | - ...as it matches this but it has different indentation\n...\n94 | }\n   |   ^\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpavg9sw4f.rs:12:10\n   |\n12 |     if S.at(count).is_lower() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpavg9sw4f.rs:17:10\n   |\n17 |     if S.at(count).is_lower() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpavg9sw4f.rs:22:10\n   |\n22 |     if S.at(count).is_lower() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpavg9sw4f.rs:27:10\n   |\n27 |     if S.at(count).is_lower() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpavg9sw4f.rs:32:10\n   |\n32 |     if S.at(count).is_lower() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpavg9sw4f.rs:37:10\n   |\n37 |     if S.at(count).is_lower() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpavg9sw4f.rs:42:10\n   |\n42 |     if S.at(count).is_lower() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpavg9sw4f.rs:47:1",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.find(c => c == \"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpjcrrjf34.rs:12:17\n   |\n12 |     if S.find(c => c == \"I\") {\n   |                 ^^ expected one of 8 possible tokens\n\nerror: expected `{`, found `=>`\n  --> /tmp/tmpjcrrjf34.rs:12:17\n   |\n12 |     if S.find(c => c == \"I\") {\n   |     --          ^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpr57ck2lf.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.get(count) == \"I\" {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if count == 3 {\n      return count;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmp_kmoetu3.rs:12:14\n    |\n12  |     if S.get(count) == \"I\" {\n    |          --- ^^^^^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_kmoetu3.rs:12:24\n   |\n12 |     if S.get(count) == \"I\" {\n   |                        ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(count) == Some(\"I\") {\n   |                        +++++   +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S[i] == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp1uujp0vb.rs:11:12\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp1uujp0vb.rs:11:18\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !S.is_char_at(count) {\n      count += 1;\n    }\n    if S.is_char_at(count) && S.is_char_at(count + 1) && S.is_char_at(count + 2) && S.is_char_at(count + 3) && S.is_char_at(count + 4) && S.is_char_at(count + 5) && S.is_char_at(count + 6) && S.is_char_at(count + 7) && S.is_char_at(count + 8) && S.is_char_at(count + 9) && S.is_char_at(count + 10) && S.is_char_at(count + 11) && S.is_char_at(count + 12) && S.is_char_at(count + 13) && S.is_char_at(count + 14) && S.is_char_at(count + 15) && S.is_char_at(count + 16) && S.is_char_at(count + 17) && S.is_char_at(count + 18) && S.is_char_at(count + 19) && S.is_char_at(count + 20) && S.is_char_at(count + 21) && S.is_char_at(count + 22) && S.is_char_at(count + 23) && S.is_char_at(count + 24) && S.is_char_at(count + 25) && S.is_char_at(count + 26) && S.is_char_at(count + 27) && S.is_char_at(count + 28) && S.is_char_at(count + 29) && S.is_char_at(count + 30) && S.is_char_at(count + 31) && S.is_char_at(count + 32) && S.is_char_at(count + 33) && S.is_char_at(count + 34) && S.is_char_at(count + 35) && S.\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmplpgbua62.rs:26:3\n   |\n9  | fn is_bored(S: String) -> isize {\n   |                                 - unclosed delimiter\n10 |   let mut count = 0;\n11 |   for _ in S.iter() {\n   |                     - this delimiter might not be properly closed...\n...\n16 | }\n   | - ...as it matches this but it has different indentation\n...\n26 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmplpgbua62.rs:16:1\n   |\n16 | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmplpgbua62.rs:16:1\n   |\n15 |     if S.is_char_at(count) && S.is_char_at(count + 1) && S.is_char_at(count + 2) && S.is_char_at(count + 3) && S.is_char_at(count + 4) &&...\n   |     -- this `if` expression has a condition, but no block\n16 | }\n   | ^ expected `{`\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmplpgbua62.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0599]: no method named `is_char_at` found for struct `String` in the current scope\n  --> /tmp/tmplpgbua62.rs:12:11\n   |\n12 |     if !S.is_char_at(count) {\n   |           ^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n --> /tmp/tmplpgbua62.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S[i] == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp1uujp0vb.rs:11:12\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp1uujp0vb.rs:11:18\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n      i += 1;\n      while i < S.len() && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n        i += 1;\n      }\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw0t44xol.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw0t44xol.rs:16:28\n   |\n16 |       while i < S.len() && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n   |                            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw0t44xol.rs:16:43\n   |\n16 |       while i < S.len() && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n   |                                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut last = 0;\n  for i in S.iter() {\n    if i.is_char('.') {\n      last = 0;\n    } else if i.is_char('?') {\n      last = 0;\n    } else if i.is_char('!') {\n      last = 0;\n    } else if i.is_char('I') {\n      if last == 0 {\n        count += 1;\n      }\n      last = 1;\n    } else {\n      last = 0;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpt4uowsu7.rs:12:14\n   |\n12 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n12 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.at(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmp4itjdfw0.rs:12:10\n   |\n12 |     if S.at(0) == \"I\" {\n   |          ^^ method not found in `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let n = 0;\n  for _ in S.chars() {\n    if S.find(c => c == 'I') {\n      n += 1;\n    }\n  }\n  return n;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpdilize2q.rs:12:17\n   |\n12 |     if S.find(c => c == 'I') {\n   |                 ^^ expected one of 8 possible tokens\n\nerror: expected `{`, found `=>`\n  --> /tmp/tmpdilize2q.rs:12:17\n   |\n12 |     if S.find(c => c == 'I') {\n   |     --          ^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmp2h4w68i6.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while i < S.len {\n    if S[i] == 'I' {\n      count += 1;\n      i += 1;\n    } else if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n      i += 1;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwfhon6uk.rs:12:15\n   |\n12 |   while i < S.len {\n   |               ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while i < S.len() {\n   |                  ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwfhon6uk.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwfhon6uk.rs:16:15\n   |\n16 |     } else if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |               ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwfhon6uk.rs:16:30\n   |\n16 |     } else if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |                              ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut is_bored = false;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S.get(i) == \"I\" {\n      count += 1;\n      if count == 2 {\n        is_bored = true;\n        break;\n      }\n    } else if count == 1 {\n      count = 0;\n    }\n  }\n  return is_bored;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpoem6rc9v.rs:12:12\n   |\n12 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpoem6rc9v.rs:12:18\n   |\n12 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !(S.starts_with(\"I\")) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp87y9_o9r.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n      i += 1;\n      while i < S.len() && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n        i += 1;\n      }\n      i += 1;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm_hh4343.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm_hh4343.rs:16:28\n   |\n16 |       while i < S.len() && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n   |                            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm_hh4343.rs:16:43\n   |\n16 |       while i < S.len() && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n   |                                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmp2h4w68i6.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !(S.starts_with(\"I\") && S.ends_with(\".\")) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpyr4emi9b.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.get(count) == \"I\" {\n      count += 1;\n    } else {\n      count = 0;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpir9vn80j.rs:12:14\n    |\n12  |     if S.get(count) == \"I\" {\n    |          --- ^^^^^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpir9vn80j.rs:12:24\n   |\n12 |     if S.get(count) == \"I\" {\n   |                        ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(count) == Some(\"I\") {\n   |                        +++++   +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut is_bored = false;\n  for s in S.split(\".\") {\n    if s.starts_with(\"I\") {\n      count += 1;\n    } else {\n      count = 0;\n    }\n    if count >= 2 {\n      is_bored = true;\n      break;\n    }\n  }\n  return is_bored;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp89g619tt.rs:23:10\n   |\n9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected `isize` because of return type\n...\n23 |   return is_bored;\n   |          ^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut pos = 0;\n  let mut last_pos = 0;\n  for pos in S.iter() {\n    if S[pos] == 'I' {\n      count += 1;\n      last_pos = pos;\n    }\n  }\n  if count == 0 {\n    return 0;\n  }\n  if count == 1 {\n    return 1;\n  }\n  if count == 2 {\n    return 2;\n  }\n  if count == 3 {\n    return 3;\n  }\n  if count == 4 {\n    return 4;\n  }\n  if count == 5 {\n    return 5;\n  }\n  if count == 6 {\n    return 6;\n  }\n  if count == 7 {\n    return 7;\n  }\n  if count == 8 {\n    return 8;\n  }\n  if count == 9 {\n    return 9;\n  }\n  if count == 10 {\n    return 10;\n  }\n  if count == 11 {\n    return 11;\n  }\n  if count == 12 {\n    return 12;\n  }\n  if count == 13 {\n    return 13;\n  }\n  if count == 14 {\n    return 14;\n  }\n  if count == 15 {\n    return 15;\n  }\n  if count == 16 {\n    return 16;\n  }\n  if count == 17 {\n    return 17;\n  }\n  if count == 18 {\n    return 18;\n  }\n  if count == 19 {\n    return 19;\n  }\n  if count == 20 {\n    return 20;\n  }\n  if count == 21 {\n    return 21;\n  }\n  if count == 22 {\n    return 22;\n  }\n  if count == 23 {\n    return 23;\n  }\n  if count == 24 {\n    return 24;\n  }\n  if count == 25 {\n    return 25;\n  }\n  if count == 26 {\n    return 26;\n  }\n  if count == 27 {\n    return 27;\n  }\n  if count == 28 {\n    return 28;\n  }\n  if count == 29 {\n    return\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5v3wkw43.rs:118:3\n    |\n9   | fn is_bored(S: String) -> isize {\n    |                                 - unclosed delimiter\n...\n106 |   if count == 29 {\n    |                  - this delimiter might not be properly closed...\n107 |     return\n108 | }\n    | - ...as it matches this but it has different indentation\n...\n118 | }\n    |   ^\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp5v3wkw43.rs:13:16\n   |\n13 |   for pos in S.iter() {\n   |                ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n13 |   for pos in S.chars() {\n   |                ~~~~~\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp5v3wkw43.rs:14:8\n   |\n14 |     if S[pos] == 'I' {\n   |        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0069]: `return;` in a function whose return type is not `()`\n   --> /tmp/tmp5v3wkw43.rs:107:5\n    |\n9   | fn is_bored(S: String) -> isize {\n    |                           ----- expected `isize` because of this return type\n...\n107 |     return\n    |     ^^^^^^ return type is not `()`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5v3wkw43.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 5 previous ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut last = 0;\n  for i in S.iter() {\n    if i.is_char('.') || i.is_char('?') || i.is_char('!') {\n      if i.is_char('I') {\n        if last == 0 {\n          count += 1;\n        }\n        last = 0;\n      } else {\n        last = 1;\n      }\n    } else {\n      last = 0;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmppwkcbx69.rs:12:14\n   |\n12 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n12 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut last_char = ' ';\n  for c in S.iter() {\n    if c == '.' || c == '?' || c == '!' {\n      if last_char == 'I' {\n        count += 1;\n      }\n    }\n    last_char = c;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpn0c3avsd.rs:12:14\n   |\n12 |   for c in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n12 |   for c in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < S.len) {\n    if (S[i] == 'I') {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2n5g6su0.rs:12:9\n   |\n12 |   while (i < S.len) {\n   |         ^         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < S.len) {\n12 +   while i < S.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2n5g6su0.rs:13:8\n   |\n13 |     if (S[i] == 'I') {\n   |        ^           ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (S[i] == 'I') {\n13 +     if S[i] == 'I' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp2n5g6su0.rs:12:16\n   |\n12 |   while (i < S.len) {\n   |                ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < S.len()) {\n   |                   ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp2n5g6su0.rs:13:9\n   |\n13 |     if (S[i] == 'I') {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split(\".\").map(|s| {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  })\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `return`\n  --> /tmp/tmpdbldcnk6.rs:16:3\n   |\n16 |   return count;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n16 |   { return count; }\n   |   +               +\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split(\".\") {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp49e4pmr2.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpzcfw93bf.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  let start = 0;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S[i] == 'I' {\n      count += 1;\n      start = i;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmptm0yymfk.rs:12:12\n   |\n12 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmptm0yymfk.rs:12:18\n   |\n12 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.chars().next().is_some() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpskcq8thx.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpr57ck2lf.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !(S.starts_with(\"I\")) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp87y9_o9r.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpr57ck2lf.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.chars().next().is_some() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpskcq8thx.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut pos = 0;\n  let mut last_pos = 0;\n  let mut last_word = String::from(\"\");\n  while (pos < S.len) {\n    if (S[pos] == '.' || S[pos] == '?' || S[pos] == '!') {\n      last_pos = pos;\n      last_word = S.slice(last_pos, pos);\n      pos += 1;\n      continue;\n    }\n    if (S[pos] == 'I') {\n      count += 1;\n      pos += 1;\n      continue;\n    }\n    if (last_word == String::from(\"I\")) {\n      pos = last_pos;\n      last_pos = 0;\n      last_word = String::from(\"\");\n      continue;\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp7yft6kti.rs:14:9\n   |\n14 |   while (pos < S.len) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (pos < S.len) {\n14 +   while pos < S.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7yft6kti.rs:15:8\n   |\n15 |     if (S[pos] == '.' || S[pos] == '?' || S[pos] == '!') {\n   |        ^                                               ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (S[pos] == '.' || S[pos] == '?' || S[pos] == '!') {\n15 +     if S[pos] == '.' || S[pos] == '?' || S[pos] == '!' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7yft6kti.rs:21:8\n   |\n21 |     if (S[pos] == 'I') {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (S[pos] == 'I') {\n21 +     if S[pos] == 'I' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7yft6kti.rs:26:8\n   |\n26 |     if (last_word == String::from(\"I\")) {\n   |        ^                              ^\n   |\nhelp: remove these parentheses\n   |\n26 -     if (last_word == String::from(\"I\")) {\n26 +     if last_word == String::from(\"I\") {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp7yft6kti.rs:14:18\n   |\n14 |   while (pos < S.len) {\n   |                  ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |   while (pos < S.len()) {\n   |                     ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp7yft6kti.rs:15:9\n   |\n15 |     if (S[pos] == '.' || S[pos] == '?' || S[pos] == '!') {\n   |         ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split(\".\").map(|s| {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  })\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `return`\n  --> /tmp/tmpdbldcnk6.rs:16:3\n   |\n16 |   return count;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n16 |   { return count; }\n   |   +               +\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for s in S.split(\".\") {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp0s67y269.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.chars().next().is_some() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpskcq8thx.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split(\".\").map(|s| {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  })\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `return`\n  --> /tmp/tmpdbldcnk6.rs:16:3\n   |\n16 |   return count;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n16 |   { return count; }\n   |   +               +\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.chars().next().is_some('I') {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmprdjysyuh.rs:12:25\n    |\n12  |     if S.chars().next().is_some('I') {\n    |                         ^^^^^^^ --- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < S.len) {\n    let c = S[pos];\n    if (c == '.' || c == '?' || c == '!') {\n      pos += 1;\n      continue;\n    }\n    if (S.starts_with(\"I\")) {\n      count += 1;\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppj98lh1e.rs:12:9\n   |\n12 |   while (pos < S.len) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < S.len) {\n12 +   while pos < S.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppj98lh1e.rs:14:8\n   |\n14 |     if (c == '.' || c == '?' || c == '!') {\n   |        ^                                ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (c == '.' || c == '?' || c == '!') {\n14 +     if c == '.' || c == '?' || c == '!' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppj98lh1e.rs:18:8\n   |\n18 |     if (S.starts_with(\"I\")) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n18 -     if (S.starts_with(\"I\")) {\n18 +     if S.starts_with(\"I\") {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmppj98lh1e.rs:12:18\n   |\n12 |   while (pos < S.len) {\n   |                  ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (pos < S.len()) {\n   |                     ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmppj98lh1e.rs:13:13\n   |\n13 |     let c = S[pos];\n   |             ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try `rustc --explai",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !is_bored_word(S.get(i)) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_bored_word` in this scope\n  --> /tmp/tmp708acn69.rs:12:9\n   |\n12 |     if !is_bored_word(S.get(i)) {\n   |         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp708acn69.rs:12:29\n   |\n12 |     if !is_bored_word(S.get(i)) {\n   |                             ^ help: a local variable with a similar name exists: `S`\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp708acn69.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S[i] == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp1uujp0vb.rs:11:12\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp1uujp0vb.rs:11:18\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.char() == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `char` found for struct `String` in the current scope\n  --> /tmp/tmpgje00jjc.rs:12:10\n   |\n12 |     if S.char() == \"I\" {\n   |          ^^^^ help: there is an associated function with a similar name: `chars`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpdv05e957.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmp2h4w68i6.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for s in S.split(\".\") {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293039,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmp5qo7tygl.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpzcfw93bf.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut last_char = ' ';\n  for c in S {\n    if c == '.' || c == '?' || c == '!' {\n      last_char = c;\n      continue;\n    }\n    if last_char == 'I' {\n      count += 1;\n    }\n    last_char = c;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpr3776d4t.rs:12:12\n   |\n12 |   for c in S {\n   |            ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for s in S.split(\".\") {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp0s67y269.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let n = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      n += 1;\n    }\n  }\n  return n;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmp8_wjo_ay.rs:13:7\n   |\n10 |   let n = 0;\n   |       -\n   |       |\n   |       first assignment to `n`\n   |       help: consider making this binding mutable: `mut n`\n...\n13 |       n += 1;\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for s in S.split(\".\") {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp0s67y269.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut last = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n      last = i.index();\n    }\n  }\n  if count > 0 {\n    return last;\n  }\n  return 0;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpx83ttz7m.rs:12:14\n   |\n12 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n12 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut is_bored = false;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S[i] == 'I' {\n      count += 1;\n      if count == 2 {\n        is_bored = true;\n        break;\n      }\n    } else {\n      count = 0;\n    }\n  }\n  return is_bored;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpe1q33ued.rs:12:12\n   |\n12 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpe1q33ued.rs:12:18\n   |\n12 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.find(c => c == \"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpjcrrjf34.rs:12:17\n   |\n12 |     if S.find(c => c == \"I\") {\n   |                 ^^ expected one of 8 possible tokens\n\nerror: expected `{`, found `=>`\n  --> /tmp/tmpjcrrjf34.rs:12:17\n   |\n12 |     if S.find(c => c == \"I\") {\n   |     --          ^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp8la2rae6.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpzcfw93bf.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmp2h4w68i6.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.get(count) == \"I\" {\n      count += 1;\n    } else {\n      count = 0;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpir9vn80j.rs:12:14\n    |\n12  |     if S.get(count) == \"I\" {\n    |          --- ^^^^^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpir9vn80j.rs:12:24\n   |\n12 |     if S.get(count) == \"I\" {\n   |                        ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(count) == Some(\"I\") {\n   |                        +++++   +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !S.is_char_at(count).is_some() {\n      count += 1;\n    }\n    if S.is_char_at(count).unwrap() == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmplmlcpnq1.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0599]: no method named `is_char_at` found for struct `String` in the current scope\n  --> /tmp/tmplmlcpnq1.rs:12:11\n   |\n12 |     if !S.is_char_at(count).is_some() {\n   |           ^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `is_char_at` found for struct `String` in the current scope\n  --> /tmp/tmplmlcpnq1.rs:15:10\n   |\n15 |     if S.is_char_at(count).unwrap() == \"I\" {\n   |          ^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.at(0).is_upper() {\n      count += 1;\n    }\n    if S.at(0).is_lower() {\n      count += 1;\n    }\n    if S.at(0).is_digit() {\n      count += 1;\n    }\n    if S.at(0).is_punct() {\n      count += 1;\n    }\n    if S.at(0).is_space() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_alpha() {\n      count += 1;\n    }\n    if S.at(0).is_\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnqvrt9q_.rs:86:3\n   |\n9  | fn is_bored(S: String) -> isize {\n   |                                 - unclosed delimiter\n10 |   let count = 0;\n11 |   for _ in S.chars() {\n   |                      - this delimiter might not be properly closed...\n...\n76 | }\n   | - ...as it matches this but it has different indentation\n...\n86 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpnqvrt9q_.rs:76:1\n   |\n75 |     if S.at(0).is_\n   |     -- this `if` expression has a condition, but no block\n76 | }\n   | ^ expected `{`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpnqvrt9q_.rs:12:10\n   |\n12 |     if S.at(0).is_upper() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpnqvrt9q_.rs:15:10\n   |\n15 |     if S.at(0).is_lower() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpnqvrt9q_.rs:18:10\n   |\n18 |     if S.at(0).is_digit() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpnqvrt9q_.rs:21:10\n   |\n21 |     if S.at(0).is_punct() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpnqvrt9q_.rs:24:10\n   |\n24 |     if S.at(0).is_space() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpnqvrt9q_.rs:27:10\n   |\n27 |     if S.at(0).is_alpha() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmpnqvrt9q_.rs:30:10\n   |\n30 |     if S.at(0).is_alpha() {\n   |          ^^ method not found in `String`\n\nerror[E0599]: no method named `at` found for struct `String` in the curre",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split(\".\") {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp49e4pmr2.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for s in S.split(\".\") {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp0s67y269.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < S.len) {\n    if (S[pos] == 'I') {\n      count += 1;\n      pos += 1;\n      while (pos < S.len && S[pos] != '.' && S[pos] != '?' && S[pos] != '!') {\n        pos += 1;\n      }\n    } else {\n      pos += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcwx97u_0.rs:12:9\n   |\n12 |   while (pos < S.len) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < S.len) {\n12 +   while pos < S.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcwx97u_0.rs:13:8\n   |\n13 |     if (S[pos] == 'I') {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (S[pos] == 'I') {\n13 +     if S[pos] == 'I' {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcwx97u_0.rs:16:13\n   |\n16 |       while (pos < S.len && S[pos] != '.' && S[pos] != '?' && S[pos] != '!') {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n16 -       while (pos < S.len && S[pos] != '.' && S[pos] != '?' && S[pos] != '!') {\n16 +       while pos < S.len && S[pos] != '.' && S[pos] != '?' && S[pos] != '!' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpcwx97u_0.rs:12:18\n   |\n12 |   while (pos < S.len) {\n   |                  ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (pos < S.len()) {\n   |                     ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpcwx97u_0.rs:13:9\n   |\n13 |     if (S[pos] == 'I') {\n   |         ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0615]: attempted to take value of method ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut is_bored = false;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    }\n  }\n  if count == 0 {\n    is_bored = true;\n  }\n  return is_bored;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp6sfa287w.rs:12:14\n   |\n12 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n12 |   for i in S.chars() {\n   |              ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6sfa287w.rs:20:10\n   |\n9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected `isize` because of return type\n...\n20 |   return is_bored;\n   |          ^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut pos = 0;\n  let mut last = 0;\n  let mut last_pos = 0;\n  let mut last_pos_end = 0;\n  let mut last_pos_end_end = 0;\n  let mut last_pos_end_end_end = 0;\n  let mut last_pos_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut last_pos_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmpqfipuauy.rs:32:1\n   |\n32 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp13ceu5ju.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmp13ceu5ju.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp13ceu5ju.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut pos = 0;\n  while (pos < S.len()) {\n    if (S[pos] == 'I') {\n      count += 1;\n      pos += 1;\n    } else if (S[pos] == '.' || S[pos] == '?' || S[pos] == '!') {\n      pos += 1;\n    } else {\n      break;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpm5xlhxjw.rs:12:9\n   |\n12 |   while (pos < S.len()) {\n   |         ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < S.len()) {\n12 +   while pos < S.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm5xlhxjw.rs:13:8\n   |\n13 |     if (S[pos] == 'I') {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (S[pos] == 'I') {\n13 +     if S[pos] == 'I' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm5xlhxjw.rs:16:15\n   |\n16 |     } else if (S[pos] == '.' || S[pos] == '?' || S[pos] == '!') {\n   |               ^                                               ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (S[pos] == '.' || S[pos] == '?' || S[pos] == '!') {\n16 +     } else if S[pos] == '.' || S[pos] == '?' || S[pos] == '!' {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm5xlhxjw.rs:13:9\n   |\n13 |     if (S[pos] == 'I') {\n   |         ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm5xlhxjw.rs:16:16\n   |\n16 |     } else if (S[pos] == '.' || S[pos] == '?' || S[pos] == '!') {\n   |                ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpr57ck2lf.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp_1v4jtub.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S[i] == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp1uujp0vb.rs:11:12\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp1uujp0vb.rs:11:18\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmp2h4w68i6.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.iter().drop(1) {\n    if i == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmps4crzmt7.rs:11:14\n   |\n11 |   for i in S.iter().drop(1) {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars().drop(1) {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.at(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `at` found for struct `String` in the current scope\n  --> /tmp/tmp4itjdfw0.rs:12:10\n   |\n12 |     if S.at(0) == \"I\" {\n   |          ^^ method not found in `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S[i] == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp1uujp0vb.rs:11:12\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp1uujp0vb.rs:11:18\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.is_bored() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpr57ck2lf.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut last_char = ' ';\n  let mut last_char_index = 0;\n  for i in S.iter() {\n    if i == '.' || i == '?' || i == '!' {\n      last_char = i;\n      last_char_index = i.len();\n      continue;\n    }\n    if last_char == 'I' {\n      count += 1;\n    }\n    last_char = ' ';\n    last_char_index = 0;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp0kopnaqg.rs:13:14\n   |\n13 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n13 |   for i in S.chars() {\n   |              ~~~~~\n\nerror[E0599]: no method named `len` found for type `char` in the current scope\n  --> /tmp/tmp0kopnaqg.rs:16:27\n   |\n16 |       last_char_index = i.len();\n   |                           ^^^ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  let last_char = ' ';\n  for (c in S) {\n    if (c == '.' || c == '?' || c == '!') {\n      if (last_char == 'I') {\n        count += 1;\n      }\n    }\n    last_char = c;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpkyph4g1c.rs:12:10\n   |\n12 |   for (c in S) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpkyph4g1c.rs:12:7\n   |\n12 |   for (c in S) {\n   |       ^      ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n12 -   for (c in S) {\n12 +   for c in S {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkyph4g1c.rs:13:8\n   |\n13 |     if (c == '.' || c == '?' || c == '!') {\n   |        ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (c == '.' || c == '?' || c == '!') {\n13 +     if c == '.' || c == '?' || c == '!' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkyph4g1c.rs:14:10\n   |\n14 |       if (last_char == 'I') {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n14 -       if (last_char == 'I') {\n14 +       if last_char == 'I' {\n   | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpkyph4g1c.rs:12:13\n   |\n12 |   for (c in S) {\n   |             ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n      i += 1;\n      while i < S.len() && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n        i += 1;\n      }\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw0t44xol.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw0t44xol.rs:16:28\n   |\n16 |       while i < S.len() && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n   |                            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw0t44xol.rs:16:43\n   |\n16 |       while i < S.len() && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n   |                                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !(S.starts_with(\"I\")) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp87y9_o9r.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for isize i = 0; i < S.len(); i += 1 {\n    if S[i] == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp1uujp0vb.rs:11:12\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp1uujp0vb.rs:11:18\n   |\n11 |   for isize i = 0; i < S.len(); i += 1 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpqa2otr6s.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpqa2otr6s.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa2otr6s.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.chars() {\n    if S.find(c => c == \"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpjcrrjf34.rs:12:17\n   |\n12 |     if S.find(c => c == \"I\") {\n   |                 ^^ expected one of 8 possible tokens\n\nerror: expected `{`, found `=>`\n  --> /tmp/tmpjcrrjf34.rs:12:17\n   |\n12 |     if S.find(c => c == \"I\") {\n   |     --          ^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut is_bored = false;\n  for _ in S.iter() {\n    if is_bored {\n      count += 1;\n    } else if is_bored = starts_with(S.iter(), \"I\"); {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error: expected `{`, found `;`\n  --> /tmp/tmp56wgons7.rs:15:52\n   |\n15 |     } else if is_bored = starts_with(S.iter(), \"I\"); {\n   |            --                                      ^ expected `{`\n   |            |\n   |            this `if` expression has a condition, but no block\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp56wgons7.rs:12:14\n   |\n12 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n12 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for _ in S.iter() {\n    if !S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpzcfw93bf.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for s in S.split(\".\") {\n    if s.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp0s67y269.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.iter() {\n    if S.get(0) == \"I\" {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp13ceu5ju.rs:11:14\n   |\n11 |   for _ in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for _ in S.chars() {\n   |              ~~~~~\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmp13ceu5ju.rs:12:14\n    |\n12  |     if S.get(0) == \"I\" {\n    |          --- ^ string indices are ranges of `usize`\n    |          |\n    |          required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp13ceu5ju.rs:12:20\n   |\n12 |     if S.get(0) == \"I\" {\n   |                    ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&_>`\n           found reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n12 |     if S.get(0) == Some(\"I\") {\n   |                    +++++   +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpdy6npcy9.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.iter() {\n    if i.is_char('I') {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpxskl9oqs.rs:11:14\n   |\n11 |   for i in S.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in S.chars() {\n   |              ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  for i in S.chars() {\n    if i == 'I' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293039,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmpp1hg_wnm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let count = 0;\n  for _ in S.split('.') {\n    if S.starts_with(\"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpradlz4bl.rs:13:7\n   |\n10 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n13 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < S.len() {\n    if S[i] == 'I' {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8kswi2bz.rs:13:8\n   |\n13 |     if S[i] == 'I' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}